picotron cartridge // www.picotron.net
version 2

:: bios/
:: bios/apps/
:: bios/demos/
:: bios/fonts/
:: bios/lib/
:: bios/misc/
:: bios/pm/
:: bios/screensavers/
:: bios/themes/
:: bios/util/
:: bios/wallpapers/
:: bios/widgets/
:: bios/wm/
:: gfx/
:: map/
:: sfx/
:: bios.lua
--[[pod_format="raw",created="2025-12-13 23:20:57",modified="2025-12-13 23:55:52",revision=3]]
store("/distributions/bootinto.txt","bios")
send_message(2,{event="reboot"})
:: bios/apps/terminal.lua
--[[pod_format="raw",author="zep",created="2023-10-07 14:33:59",icon=userdata("u8",16,16,"0000000000000000000000000000000000000001010101010101010100000000000001070707070707070707010000000001070101010101010101010701000001070101010101010101010101070100010701010101070101010101010701000107010101010107010101010107010001070101010101010701010101070100010701010101010701010101010701000107010101010701010101010107010001070101010101010101010101070100011d07010101010101010101071d0100011d1d0707070707070707071d1d010000011d1d1d1d1d1d1d1d1d1d1d0100000000011d1d1d1d1d1d1d1d1d0100000000000001010101010101010100000000"),modified="2025-07-09 22:28:11",notes="",revision=154,stored="2024-03-09 10:31:21",title="Terminal",version=""]]
--[[

	terminal.lua
	(c) Lexaloffle Games LLP

	-- ** terminal is also an application launcher. manages cproj / decides permissions **

	-- to consider: line entry in terminal can be a bitmap
		// can already use p8scii! works but need to improve workflow for encoding characters (and maybe use P8-style unicode replacements)
		// alternative: could support pod_type="image" style lines using same rule a text editor widget

]]


local _envdat = env()

-- set preferred window size unless about to corun a program (which should be the one to create the window w/ size, icon)
-- this window size might be overwritten by env().window_attribs
if (not _envdat.corun_program) then
	window{
		width=260, -- 0.1.0e: changed to 240 (was 320). be more boxy. 5*52, 4*65
		height=160,
		icon = userdata"[gfx]0907000707000000070000777777777770000077770000077770000077777777777[/gfx]"
	}
end

-- 0.2.1c: by providing a history file, multiple instances of terminal can share the same merged command history
-- pwc_output windows (the default fullscreen window, and windows created with ctrl+r) automatically share /ram/system/history.pod
local history_file = _envdat.history
if (not history_file and _envdat.window_attribs and _envdat.window_attribs.pwc_output) then
	history_file = "/ram/system/history.pod"
end
--printh("terminal history file: "..tostring(history_file))


if (pwd() == "/system/apps") cd("/") -- start in root instead of location of terminal.lua


-- 0.1.1e: set starting path via commandline
if fullpath(_envdat.argv[1]) then
	cd(fullpath(_envdat.argv[1]))
end

-- 0.2.0e: set starting path via env().path
if _envdat.path then
	cd(_envdat.path)
end

--- *** NO GLOBALS ***   --   don't want to collide with co-running program

local cmd=""

local line={}
local lineh={}
local lines_at_corun_resume = 0
local add_line = function() end
local history={}
local history_pos = 1
local scroll_y = 0
local char_h = peek(0x4002)
local char_w = peek(0x4000)
local cursor_pos = 0
local disp_w, disp_h = 480, 270 -- assume full size (needed for ctrl-r terminal program)
local back_page = userdata("u8", 480, 270)
local last_total_text_h = 0
local max_lines = 256 -- to do: increase w/ more efficient rendering (cache variable line offsets)
local left_margin = 2

local terminal_draw 
local terminal_update

local corun_draw, corun_update

local input_prompt
local blocking_proc_id

local terminal_cor
local corun_cor

local running_corun = false
local corun_windowed_bit = 0x0
local pwd_on_suspend = nil

-- to do: nice way to get a local copy of needed api
-- co-running program should be free to redefine any of these

local env = env
local blit = blit
local cls = cls
local set_draw_target = set_draw_target
local send_message = send_message
local window = window
local note = note
local on_event = on_event
local cocreate = cocreate
local coresume = coresume
local costatus = costatus
local readtext = readtext
local peektext = peektext
local fstat = fstat
local fullpath = fullpath
local fetch = fetch
local store = store
local add = add
local type = type
local mid = mid
local min = min
local max = max
local del = del
local deli = deli
local load = load
local rectfill = rectfill
local rect = rect
local env = env
local cd = cd
local time = time
local print = print
local printh = printh
local exit = exit
local split = split
local set_clipboard = set_clipboard
local get_clipboard = get_clipboard
local tostring = tostring


local _has_focus = true
on_event("gained_focus", function() _has_focus = true end)
on_event("lost_focus", function() _has_focus = false end)


--corunning coroutines

local coco = {}


function _init()

	-- don't pause fullscreen terminal when not corunning pwc
	if (not _envdat.corun_program) then
		window{
			pauseable = false,
			title = "Terminal"
		}
	end

	-- add_line("picotron terminal // "..flr(stat(0)).." bytes used")

end


-- scroll just enough to make sure command prompt is visible
local function show_last_line()

	local hh = 0
	for i=1,#lineh do
		hh += lineh[i]
	end
	last_total_text_h = hh

	local old_scroll_y = scroll_y
	
	scroll_y = mid(scroll_y, 
		last_total_text_h - disp_h + 18, -- puts prompt at bottom of screen 
		last_total_text_h + char_h -  5  -- puts prompt at top of screen (same as ctrl-l)
	)

	--[[
	if (old_scroll_y ~= scroll_y) then
		printh("old_scroll_y -> scroll_y  (disp_h, last_total_text_h, btm, top): "..
			pod{old_scroll_y, scroll_y, disp_h, last_total_text_h, last_total_text_h - disp_h + 18, last_total_text_h + char_h -  5})
	end
	]]
	
end


-- to do: string format for custom prompts?
-- for now, create a return value so that can use sedit
local function get_prompt()
	if (input_prompt) return input_prompt.str -- reading some user text
	local result 
	result = "\f6"..(_envdat.sandbox and "[sandboxed] " or "")..pwd().."\f7> "

	return result -- custom prompt goes here
end


local function resume_corun_program()
	lines_at_corun_resume = #line
	running_corun = true

	send_message(3, {event="set_haltable_proc_id", haltable_proc_id = pid()})

	-- window manager remebers if that window was ever pauseable
	send_message(3, {event="resume_pwc", haltable_proc_id = pid()})

	if (corun_update or corun_draw) then
		if (corun_draw)   _draw = corun_draw
		if (corun_update) _update = corun_update
	end

	poke(0x547f, peek(0x547f) | corun_windowed_bit)

	if (pwd_on_suspend) cd(pwd_on_suspend)
end


--[[

	return control to terminal

]]
local function suspend_corun_program()

--	if (corun_cor) printh("@@ suspend_corun_program // corun_cor "..tostring(costatus(corun_cor)))

	-- 0.2.0i: copy whatever is on the screen after corun (unless was using print / input to add lines -- don't want to copy that)
	--> can run a program like: vid() circfill(200,100,50,12) and be left with the graphical output in back page
	if (#line == lines_at_corun_resume) blit(get_display(), back_page)
--	if (#line == 0) blit(get_display(), back_page)

	-- stop resuming corun_cor
	running_corun = false

	-- kill all audio channels
	note()


	-- consume keypresses
	readtext(true)
	send_message(pid(), {event = "reset_kbd"})

	-- tidy up mess of state
	input_prompt = nil
	pressed_enter_while_blocking = false
	cmd = ""

	-- 0.2.0i: can return to nil when _draw / _update not defined
	corun_draw = _draw ~= terminal_draw and _draw or nil
	corun_update = _update ~= terminal_update and _update or nil

	_draw = terminal_draw
	_update = terminal_update
	corun_windowed_bit = peek(0x547f) & 0x8 -- restore this bit on resume

	blocking_proc_id = nil

	window{pauseable = false}

	-- back to last directory that user chose
	pwd_on_suspend = pwd()
	local pwd1 = fetch("/ram/system/pwd.pod")
	if (pwd1) then cd(pwd1) end

	set_draw_target()

	show_last_line()

end



local function get_file_extension(s)

	if (type(s) ~= "string") return nil
	return s:ext()

end


local function try_multiple_extensions(prog_name)
	--printh(" - - - - trying multiple entensions for: "..tostr(prog_name))

	if (type(prog_name) ~= "string") return nil

	local res =
		--(fstat(prog_name) and prog_name and get_file_extension(prog_name)) or  --  needs extension because don't want regular folder to match
		(fstat(prog_name) and prog_name:ext() and prog_name) or  --  needs extension because don't want regular folder to match
		(fstat(prog_name..".lua") and prog_name..".lua") or
		-- only .p64 carts can be run without specifying extension (would be overkill; reduce ambiguity)
		-- also: don't automatically append .p64 when checking a bbs:// or anywhen:// address -- causes e.g. checking server for cd.p64
		(not (fullpath(prog_name) and fullpath(prog_name):prot()) and fstat(prog_name..".p64") and prog_name..".p64") or 
		nil
	--printh(" - - - - - - - - -")
	return res

end


--[[
	find a program 

	look in /system/util, /system/apps, /appdata/system/util and finally current path

	to do: some kind of customisable $PATH? would be nice to avoid the need for that
]]
local function resolve_program_path(prog_name)

	if (type(prog_name) ~= "string") return nil

	-- check for illegal filename chars -> probably a lua command
	if (string.find(prog_name, "\"", 1, true)) return nil 

	-- need explicit exension when running protocol path
	-- (anywhen paths can't rely on try_multiple_extensions failing because doesn't test actual existence. to do: fix ~ is dangerous!)
	if (prog_name:prot()) then
		local ext = prog_name:ext()
		return (ext and ext:is_cart() or ext=="lua") and prog_name or nil
	end

	 -- shorthand; too complex to make #foo a first-class alternative to bbs://foo.p64  //  consider: ext(), fullpath()
	if (prog_name[1] == "#") prog_name = "bbs://"..prog_name:sub(2)..".p64"

	-- /appdata/system/util/ can be used to extend built-in apps (same pattern as other collections)
	-- update: not true, other collections (wallpapers) are replaced rather than extended by /appdata

	if (prog_name[1] == "." or prog_name[1] == "/") then
		-- 0.1.1:  ./foo.lua, ../foo.lua, absolute path -> don't search other paths
		return try_multiple_extensions(prog_name) 
	end


	return
		try_multiple_extensions("/system/util/"..prog_name) or
		try_multiple_extensions("/system/apps/"..prog_name) or
		try_multiple_extensions("/appdata/system/util/"..prog_name) or
		try_multiple_extensions(prog_name) -- 0.1.0c: moved last 

end

-- 0.2.0e: use meandering center of execution (including the mainloop in lib/foot.lua)
-- -> no longer need to rely on update / draw callbacks, so reduce the need for special flow logic & disjointed callstacks 
local function corun_program_inside_terminal(prog_name)
	if (not prog_name) return

	local prog_str = fetch(prog_name)
	if (not prog_str) then
		add_line("could not fetch "..prog_name)
		return
	end

	-- inject a foot that runs _init if the program defines one
	-- let terminal draw,update persist until redefined (might be an interactive terminal program which uses them)
	-- also: automatic fullscreen window creation is disabled in foot when corunning -- let the corun program define window
	-- note: don't need a mainloop -- will use the one already provided by terminal's foot
	-- "if (_draw == d0) poke(0x547f, peek(0x547f) & ~0x20)" --need to ctrl+r tests/background_work (because terminal sets that bit at first)

	prog_str = 
			"_init = nil local _draw0 = _draw ; "..
			prog_str.." \n "..
[[
			if (_init) then _init() end
			if (_draw == _draw0) poke(0x547f, peek(0x547f) & ~0x20) -- no _draw defined -> clear bit (see foot)
			if (_draw and not get_display()) then
				-- create fullscreen window
				window()
			end
]]

	local f, err = load(prog_str, "@"..prog_name, "t", _ENV)

	
	if (f) then
		-- kick off execution -- will resume from _update
		corun_cor = cocreate(f)
		running_corun = true

		-- tricky: need to always run terminal update in background so can bootstrap the corun update
		-- this bit cleared in head.lua set_window_1, so background updates don't remain set when ctrl+r
		poke(0x547f, peek(0x547f) | 0x40);
		poke(0x547f, peek(0x547f) & ~0x8) -- print to terminal until a window is created
	else
		-- syntax error  //  to do: other possible errors?
		send_message(3, {event="report_error", content = "*syntax error"})
		send_message(3, {event="report_error", content = tostr(err)})

		-- don't get stuck in a fullscreen pauseable state
		show_last_line()
		window{pauseable = false}
	end

	scroll_y = 0

end




--[[

	run_program_in_new_process()

	initial pwd is always program path (even for stand-alone .lua scripts), so if planning to run
	from a different directory (e.g. /system/util), program needs to start with cd(env().path)

]]
local function run_program_in_new_process(prog_name, argv)

	local fileview = nil

	-- 0.2.0h: terminal is allowed to grant sandboxed access to argv[1] when it is a resolvable filename
	if fullpath(argv[1]) then
		fileview = {{location=fullpath(argv[1]), mode="RW"}}
	end

	local proc_id, err = create_process(
		prog_name,
		{
			argv = argv,
			path = pwd(), -- used by commandline programs -- cd(env().path)
			window_attribs = {show_in_workspace = true},
			fileview = fileview,

			-- tell new process where to print to  (0.1.1e unless new terminal!)
			print_to_proc_id = prog_name ~= _envdat.argv[0] and pid() or nil,
		}
	)

	if (err) add_line(err)

	-- 0.2.0e: blocking -- until either dead or that process has a window
	-- (via child_completed, child_created_window messages)
	if (proc_id) then
		blocking_proc_id = proc_id
	end

end


--[[

	run_terminal_command

	try in order:

		1. built-in commands (cd / exit etc) that can not be replaced by lua or program names
		2. programs          // can't have spaces in them
		3. lua command

	note: running a program might be in the form of a legal lua statement, but if the program
		doesn't exist, then the lua statement is never executed. e.g.

		ls = 3 -- runs list with args {"=","3"}
		xx = 3 -- assigns 3 to xx (assuming there is no program called xx)

]]

local function run_terminal_command(cmd)

	local prog_name = resolve_program_path(split(cmd," ",false)[1])

--	printh("run_terminal_command program: "..tostr(prog_name))

	local argv = {}
	local argv0 = split(cmd," ",false) -- to do: quoted strings! wildcard expansion!

	local index = 0 -- 0-based so that 1 is first argument
	for i=1,#argv0 do
		if (argv0[i] ~= "") then -- 0.1.1e: don't pass "" arguments (e.g. trailing space). dangerous!
			argv[index] = argv0[i]
			index += 1
		end
	end

	-----

	if (argv[0] ~= "." and cmd ~= "") frame_by_frame_mode = false
	
	if (argv[0] == "." or (cmd == "" and frame_by_frame_mode)) then

		if (not corun_update and not corun_update) then
			-- to do: support this if can unify coresume_until_flipped
			add_line("no draw / update callbacks found")
			return
		end

		frame_by_frame_mode = true
		if (corun_update) corun_update()
		if (corun_draw) corun_draw()
		flip()
		blit(get_display(), back_page) -- copy whatever is on screen
	
	elseif (argv[0] == "cd") then

		local result = cd(argv[1])
		if (result) then add_line(result) end -- result is an error message

	elseif (cmd == "exit") then

		exit(0)
		
	elseif (cmd == "cls") then

		set_draw_target(back_page)
		cls()
		set_draw_target()
		line={} lineh={} -- 0.2.1c: clear text
		scroll_y = last_total_text_h

	elseif (cmd == "reset") then

		reset()
		window{pauseable=false}
		vid(0)

	elseif (cmd == "resume") then

		if (corun_cor) then
			resume_corun_program()
		else
			print("nothing to resume")
		end

	elseif (prog_name) then

		run_program_in_new_process(prog_name, argv) -- could do filename expansion etc. for arguments

	else
		-- last: try lua

		local f, err = load(cmd, nil, "t", _ENV)

		if (f) then
		
			-- run loaded lua as a coroutine
			terminal_cor = cocreate(f)

		else

			-- try to differenciate between syntax error /command not found

			local near_msg = "syntax error near"
			if (near_msg == sub(err, 5, 5 + #near_msg - 1)) then
				-- caused by e.g.: "foo" or "foo -a" or "foo a.png" when foo doesn't resolve to a program
				add_line "command not found"
			else
				add_line(err)
			end

		end

	end

end



add_line = function(s)
	s = tostr(s)
	if (not s) then return end

	if (#line > max_lines) then
		deli(line, 1)		
		deli(lineh, 1)
	end

	if (#line >= 1 and sub(line[#line],-1) == "\000") then
		-- append to previous line; roughly match behaviour of cursor when printing to display
		-- kinda inefficient if do many appends, but simplifies height calculation.
		line[#line] = sub(line[#line], 1, -2)..s
		-- update height
		local xx,yy = print(line[#line], 0, 10000)
		lineh[#lineh] = max(4, yy and yy-10000)
	elseif #line >= 1 and (s[1] == "\r" or (s[1] == "\f" and s[3] == "\r")) then -- and (line[#line-1][1] == "\r" or line[#line-1][3] == "\r") then
		-- \r has a special meaning in this context -- "replace previous line"
		-- replace previous line; roughly match behaviour of cursor when printing to display
		-- kinda inefficient if do many appends, but simplifies height calculation.
		line[#line] = s
		-- update height
		local xx,yy = print(line[#line], 0, 10000)
		lineh[#lineh] = max(4, yy and yy-10000)
	else
		local xx,yy = print(s, 0, 10000)
		add(line,  s)
		add(lineh, max(4, yy and yy-10000))
	end

	show_last_line()

	

--	printh(pod{line=#line, num_lineh=#lineh, added_lineh=lineh[#lineh], last_total_text_h=last_total_text_h})

end


-- ** incredibly inefficient! to do: need to replace with string matching
local function find_common_prefix(s0, s1)

	if (type(s0) ~= "string") then return nil end
	if (type(s1) ~= "string") then return nil end

	if (s0 == s1) then return s0 end

	local len = 0
	while(sub(s0,1,len+1) == sub(s1,1,len+1)) do
		len = len + 1
		--printh(len)
	end

	return sub(s0,1,len)
end

--[[
	
	tab_complete_filename

	0.1.1e: can handle protocol locations
	
]]
local function tab_complete_filename()

	if (cmd == "") then return end

	-- get string
	local args = split(cmd, " \"", false)  -- also split on " to allow tab-completing filenames inside strings
	local prefix = args[#args] or ""

	-- construct path prefix  -- everything (canonical path) except the filename
	local prefix = fullpath(prefix)
	if (not prefix) return -- bad path

	local prot = prefix:prot(true) -- true to only check string prefix
	local prot_str = prot and (prot.."://") or ""
	if (prot) then
		prefix = prefix:sub(#prot+3)
	end


	local pathseg = split(prefix,"/",false)
	local path_part = ""
	for i=1,#pathseg-1 do
		path_part = path_part .. "/" .. pathseg[i]
	end
	if (path_part == "") then path_part = "/" end -- canonical filename special case

	prefix = (pathseg and pathseg[#pathseg]) or "/"


	-- printh("@@@ listing: "..prot_str..path_part)
	local files = ls(prot_str..path_part)

	if (not files) return

	-- find matches

	local segment = nil
	local matches = 0
	local single_filename = nil

	for i=1,#files do
		-- printh(prefix.." :: "..files[i])
		if (sub(files[i], 1, #prefix) == prefix) then
			matches = matches + 1
			local candidate = sub(files[i], #prefix + 1) -- remainder

			-- set segment to starting sequence common to candidate and segment
			segment = segment and find_common_prefix(candidate, segment) or candidate
			single_filename = path_part.."/"..files[i] -- used when single match is found
		end
	end

	if (segment) then
		cmd = cmd .. segment
		cursor_pos = cursor_pos + #segment
	end

	-- show files if >= 2
	if (matches > 1) then
		add_line("-- "..matches.." matching files --")
		for i=1,#files do
			if (sub(files[i], 1, #prefix) == prefix) then
				add_line(files[i])
			end
		end
	elseif single_filename and fstat(single_filename) == "folder" then
		-- trailing slash when a single match is a folder
		-- for folders with an extension, need to already match the full name;
		--> press tab once for foo.p64 and once more for foo.p64/)
		-- the vast majority of the time, user wants to refer to the cart itself
		if not single_filename:ext() or prefix == sub(cmd,-#prefix) 
		then
			cmd ..= "/"
			cursor_pos += 1
		end
	end

end


local tv_frames = 
{	[0] =
	userdata"[gfx]0907000707000000070000777777777770000077770070077770000077777777777[/gfx]",
	userdata"[gfx]0907000707000000070000777777777770070077770707077770070077777777777[/gfx]",
	userdata"[gfx]0907000707000000070000777777777770707077770000077770707077777777777[/gfx]",
}

function coresume_until_flipped(c)

	if corun_draw then

		-- corunning a program that has a _draw function defined
		-->  should be allowed to yield() at top level more than once per frame (e.g. used by print / input / fetch)

		while true do
			local res,err = coresume(c)
			if costatus(c) == "suspended" and stat(984) == 0 then
				-- yielded but didn't flip yet; go around again
			else
				-- finished
				return res,err
			end
		end

	else
		-- corunning without a draw function 
		--> run until halted or finished [to do: or _draw function defined?]
		-- to do: would be nice to use same pattern as above; but custom mainloop from terminal vs separate process is quite different
		while true do
			local res,err = coresume(c)
			--printh("costatus: "..pod{costatus(c), running_corun})
			if costatus(c) == "suspended" and running_corun then
				-- yielded but still running; go through terminal update/draw to allow input / print
				return
			else
				-- finished
				return res,err
			end
		end

	end
end


function _update()


	-- something corunning 

	if (corun_cor and running_corun)
	then
		if (costatus(corun_cor) == "suspended") then

			local res,err = coresume_until_flipped(corun_cor)

			if (err) then
				-- errors that occur when running at top level (including _init)  are caught here;
				-- can't access callstack (?) so just report single line error
				send_message(3, {event="report_error", content = "*runtime error"})
				send_message(3, {event="report_error", content = tostring(err)}) 
				send_message(3, {event="report_error", content = debug.traceback(corun_cor)}) 

				--printh("@@ "..err)
			end
		end

		-- finished running corun program

		if (costatus(corun_cor) ~= "running" and costatus(corun_cor) ~= "suspended") then

			-- let it keep "running" when _draw or _update was defined
			-- the /coroutine/ has finished running, but the program is running using terminal's mainloop
			-- and the newly defined _update and/or _draw callbacks
			if (_draw ~= terminal_draw or _update ~= terminal_update) then
				-- ditch callback that was not defined by the corun program
				-- dummy callbacks so that foot doesn't need to care about callbacks disappearing
				if (_draw == terminal_draw) _draw = function() end
				if (_update == terminal_update) _update = function() end
			else
				-- otherwise immediately stop (e.g. custom mainloop or a terminal script)
				suspend_corun_program()
				corun_cor = nil
			end
			
		end

		if (not input_prompt) return
	end

	-- something running in terminal (ALMOST DUPE)

	if (terminal_cor) then

		--printh("running terminal_cor")
		if (not input_prompt) set_draw_target(back_page)
		poke(0x547f, peek(0x547f) & ~0x8) -- print to terminal until a window is created  --  pset(100,100,8)?pget(100,100)
		local res,err = coresume(terminal_cor)
		set_draw_target()

		if (err) then
			add_line("\feRUNTIME ERROR")
			add_line(err)
			printh("## "..err)
		end

		-- finished running terminal command
		if (costatus(terminal_cor) ~= "running" and costatus(terminal_cor) ~= "suspended") then
			terminal_cor = nil
			input_prompt = nil
			readtext(true)
			send_message(pid(), {event = "reset_kbd"})
			cmd = ""
			
		end

	end


	if (key("ctrl")) then

		if keyp("l") then
			set_draw_target(back_page)
			cls()
			set_draw_target()
			scroll_y = last_total_text_h + 5
		end

		if keyp("v") then

			local str = get_clipboard()
			cmd = sub(cmd, 1, cursor_pos) .. str .. sub(cmd, cursor_pos+1)
			cursor_pos = cursor_pos + #str

		end

		if keyp("c") then

			set_clipboard(cmd)
			
		end

		if keyp("x") then

			set_clipboard(cmd)
			cmd = ""
			cursor_pos = 0
			
		end

		if (keyp("e")) cursor_pos = #cmd

		-- clear text intput queue; don't let anything else pass through
		-- readtext(true) -- 0.1.0f: wrong! ctrl sometimes used for text entry (altgr), and anyway ctrl-* shouldn't ever produce textinput event
	end

	-- single character response to blocking input
	if (input_prompt and input_prompt.single_char and peektext()) then
		local k = readtext()
		send_message(input_prompt.pid, {event = "input_response", response = k})
		if (not input_prompt.hide) add_line(get_prompt()..k) -- show what was entered
		input_prompt = nil
		cmd = ""
		return
	end

	-- can read chars for command unless already pressed enter while blocking
	-- (want to buffer next typed command, but only up until pressed enter -- give up and discard after that)
	while (peektext() and not (pressed_enter_while_blocking and not input_prompt)) do
		local k = readtext()

		-- insert at cursor
		if (not halted_t or time() > halted_t + 0.25) -- ignore input right after stop() -- annoying
		then 
			cmd = sub(cmd, 1, cursor_pos) .. k .. sub(cmd, cursor_pos+1)
			cursor_pos = cursor_pos + 1
			show_last_line()
		end
	end

	-- tab completion and histroy navigation: not available for input() or otherwise running a blocking program
	if (not blocking_proc_id) then

		if (keyp("tab")) then
			tab_complete_filename();
		end

		if (keyp("up")) then
			history[history_pos] = cmd
			history_pos = mid(1, history_pos-1, #history	)
			cmd = history[history_pos]
			cursor_pos = #cmd
		end

		if (keyp("down")) then
			history[history_pos] = cmd
			history_pos = mid(1, history_pos+1, #history)
			cmd = history[history_pos]
			cursor_pos = #cmd
		end

	end

	if (keyp("left")) then
		cursor_pos = mid(0, cursor_pos - 1, #cmd)
	end

	if (keyp("right")) then
		cursor_pos = mid(0, cursor_pos + 1, #cmd)
	end

	if (keyp("home") or (key("ctrl") and keyp("a"))) cursor_pos = 0
	if (keyp("end")) cursor_pos = #cmd

	if (keyp("backspace") and #cmd > 0) then
		cmd = sub(cmd, 1, max(0,cursor_pos-1))..sub(cmd, cursor_pos+1)
		cursor_pos = mid(0, cursor_pos - 1, #cmd)
	end

	if (keyp("delete") or (key("ctrl") and keyp("d"))) then
		cmd = sub(cmd, 1, max(0,cursor_pos))..sub(cmd, cursor_pos+2)
	end


	--if (input_prompt) printh(t()) -- check framerate for debugging keyp("enter") responsivity

	if (keyp("enter")) then

		-- not waiting for input and there is a blocking process running -- don't process command
		-- (and note that enter was pressed, to stop reading further additions to cmd)
		if (blocking_proc_id and not input_prompt) then
			pressed_enter_while_blocking = true
			return
		end

		if (input_prompt) then
			-- send back to calling program
			send_message(input_prompt.pid, {event = "input_response", response = cmd})
			if (not input_prompt.hide) add_line(get_prompt()..cmd) -- show what was entered
			input_prompt = nil
			cmd = ""
			return
		end


		if (cmd ~= "" or not frame_by_frame_mode) then
			add_line(get_prompt()..cmd)
		end

		
		-- execute the command

		run_terminal_command(cmd)
		show_last_line()

		-- add to history

		if (history[#history] == "") then 
			history[#history] = cmd
		elseif cmd ~= "" then
			add(history, cmd)
		end

		-- store history if there is one

		if (history_file and cmd ~= "") then
			store(history_file, {pid(), history, pwd()}) 
			store("/ram/system/pwd.pod", pwd())
		end

		history_pos = #history+1

		-- reset the prompt

		cmd = ""
		cursor_pos = #cmd -- cursor at end of command

	end

	


end
terminal_update = _update


function _draw()

	local disp = get_display()
	if (disp) disp_w, disp_h = disp:width(), disp:height()
	
	--if (running_corun) printh("_draw running_corun")
--	printh("terminal draw "..time())

--	local show_terminal_layer = input_prompt or not running_corun
	local show_terminal_layer = true -- 0.2.0e: always draw -- center of execution doesn't reach here when when terminal layer isn't wanted

	if show_terminal_layer then

		camera()
		clip()
		cls()
		blit(back_page, nil, 0, 0, 0, 0, 480, 270)
	

	-- experiment: run painto / dots3d in terminal
--[[
	if (running_proc_id) then
		_blit_process_video(running_proc_id, 0, 0)
	end
]]

	--scroll_y = mid(0, scroll_y, #line * char_h - disp_h)

	--printh("disp_h: "..disp_h.." scroll_y: "..scroll_y.." max: "..(#line * char_h - disp_h))


		local x = left_margin
		local y = 7 - scroll_y

		local y0 = y

		-- to do: could cache wrapped strings
		-- and/or add a picotron-specific p8scii address for rhs wrap
		--local wrap_prefix = "\006r"..chr(ord("a") + max(6, disp_w \ 4 - 10))
		local wrap_prefix = ""
		
		poke(0x5f36, (@0x5f36) | 0x80) -- turn on wrap

		for i=1,#line do
			--printh(i..": "..scroll_y)
			_, y = print(line[i], x, y, 7)
			--_, y = print("\^ow5a"..line[i], x, y, 7) -- kinda messy (and too expensive?)
		end

		y = y or 0

		last_total_text_h = y - y0


		-- poke(0x5f36, (@0x5f36) | 0x80) -- turn on wrap

		camera()

		-- show prompt when not waiting for a program to complete
		if (not blocking_proc_id or input_prompt) then

			local prefix = "\^owff"..wrap_prefix..get_prompt() -- show outline only when entering text
			print(prefix..cmd.."\0", x, y, 7)
			print(prefix..sub(cmd,1,cursor_pos).."\0", x, y, 7)

			local cx, cy = peek4(0x54f0, 2)
			if (cx > disp_w - peek(0x4000)) cx,cy = peek4(0x54f8), cy + peek(0x4002) -- where next character is (probably) going to be after warpping

			-- show cursor when window is active (no cursor for input prompt when reading single char)
			if (_has_focus and (not input_prompt or not (input_prompt.single_char and input_prompt.str == ""))) then
				if (time()%1 < .5) then
					rectfill(cx, cy, cx+char_w-1, cy+char_h-4, 14)
				end
			end

		end

	end

end
terminal_draw = _draw


-- can stop blocking when child completed
on_event("child_completed", function(msg)
	if (msg.proc_id == blocking_proc_id) then
		blocking_proc_id = nil
		suspend_corun_program()
	end
end)
-- .. or created a window
on_event("child_created_window", function(msg)
	if (msg.proc_id == blocking_proc_id) then
		blocking_proc_id = nil
		suspend_corun_program()
	end
end)

on_event("print", function(msg)
	add_line(msg.content)	
end)

on_event("input", function(msg)
	
	input_prompt = {
		str = msg.prompt,
		pid = msg._from,
		hide = msg.hide,
		single_char = msg.single_char
	}
end)


-- window manager can tell guest program to halt
-- (usually by pressing escape)
on_event("halt", function(msg)
	if (corun_cor) then
		suspend_corun_program() -- can resume later
	end
	if (msg.description) print(msg.description)
	halted_t = time()
end)



--scroll_y = 0

-- run e.g. pwc output
if (_envdat.corun_program) then
	corun_program_inside_terminal(_envdat.corun_program)
end


function load_history(do_cd)
	if (not history_file) return
	local hdat = fetch(history_file)

	if type(hdat) == "table" and hdat[1] ~= pid()  -- don't reload if this process wrote the file
	then
		-- printh(" > loading history // pwd: "..hdat[3])
		history = hdat[2]
		--if (do_cd) cd(hdat[3]) -- only on startup
		history_pos = #history + 1
		scroll_y = 0
	end
end

-- pwc_output: always load history_f if it exists
-- used to be env().reload_history, but covaries and means the same thing
if history_file then
	load_history(true)
	on_event("modified:"..history_file, load_history)
end


on_event("mousewheel", function(msg)
	scroll_y = scroll_y - msg.wheel_y * char_h * 2
end)

--[[
	ctrl-shift-r (wm) to live-reload lua files or gfx files
]]
on_event("reload_src", function(msg)

	-- security: only accept from window manager
	if (msg._from ~= 3) then
		return
	end

	local src_file = msg.location

	if (src_file:ext() == "lua") then

		local prog_str = fetch(src_file)
		if (not prog_str) return
		local f = load(prog_str, "@"..src_file, "t", _ENV)

		if (f) then
			f()
			notify("reloaded src file: "..src_file:basename())
		else
			-- to do: how to return error?
			notify("could not compile")
		end
	end

	if (src_file:ext() == "gfx") then
		-- 0.2.0i: reload  spritebank

		local num = tonum(src_file:basename():sub(1,2)) or tonum(src_file:basename():sub(1,1))
		if (num and num >= 0 and num < 32) then
			local g = fetch(src_file)
			if g and type(g) == "table" then
				for i=0,255 do
					if type(g[i]) == "table" and type(g[i].bmp) == "userdata" then
						set_spr(num*256 + i, g[i].bmp)
					end
				end
			end
		end
	end


end)


on_event("resize", function(msg)
	show_last_line()
end)

:: bios/custom_boot.lua
--[[pod_format="raw",created="2025-12-13 21:44:55",modified="2025-12-13 21:44:55",revision=0]]
--[[
	Picotron Kernel
	Handle process creation and slice allocation
	-- should be small so that can configure to just run a single cart (update: why?)
]]




-- allowed to assume / and /ram is mounted before boot.lua is run
-- and that there is already /system

cp("/system/misc/ram_info.pod", "/ram/.info.pod")

mkdir("/ram/cart")
mkdir("/ram/system") -- system state (userland)
mkdir("/ram/shared") -- system state visible to sandboxed carts
mkdir("/ram/drop")   -- host files dropped into picotron -- can just leave them kicking around until reboot
--mkdir("/ram/log")    -- logs for this session -- to do

mkdir("/desktop")
-- mkdir("/apps")       -- later; could be optional!

mkdir("/appdata")
mkdir("/appdata/system")
mkdir("/appdata/system/desktop2") -- for the tooltray
mkdir("/appdata/bbs")
mkdir("/appdata/shared") -- anyone can write (bbs carts can communicate with each other)


-- 0.2.0c: quit early (yielding causes kernal runtime error) if can not read /desktop or /appdata
-- --> means can not write there either
if fstat("/desktop") ~= "folder" or fstat("/appdata") ~= "folder" then
	if (fstat("/desktop") ~= "folder") _printh("can not access /desktop")
	if (fstat("/appdata") ~= "folder") _printh("can not access /appdata")
	_printh("picotron home path or is read-only? or / is mounted to a path that is not writeable?")
	yield()
end



-- need to fetch settings early to determine fullscreen or windowed
local sdat = fetch"/appdata/system/settings.pod"
if (type(sdat) ~= "table") sdat = {} -- will be created / mended in startup.lua if needed
_apply_system_settings(sdat)




--mkdir("/ram/dev") -- experimental; devices are an extraneous concept if have messages and ram file publishing


-- load head manually -- used by startup.lua to create processes
-- (other userland functions in /system/lib/* are not used by startup)

function env() return {} end -- empty environment for boot process
local head_func, err = load(fetch("/system/lib/head.lua"))
if (not head_func) _printh("** could not load head ** "..err)
head_func()

-- user can extend this with /appdata/system/startup.lua (is daisy-chained)


local startup_src  = fetch("/system/startup.lua")
if (type(startup_src) ~= "string") then
	_printh("** could not read startup.lua")
else
	local startup_func = load(startup_src)
	if (type(startup_func) ~= "function") then
		_printh("** could not load startup.lua")
	else
		startup_func()
	end
end

-- better: run as a process; want userland processes to run during startup
-- 0.2.0e: load_workspaces.lua is wrapped in create_process(); 
--         -> to do: review role of boot.lua vs startup.lua; separation is not clear
-- create_process("/system/startup.lua")


local last_processes_list_publish = 0

function run_userland_processes(allotment)

	local pl = _get_process_list()
	local wm_proc_id = 3

	-- publish! 4 times a second so at least some spikes show up
	if (time() > last_processes_list_publish + 0.25) then
		store("/ram/system/processes.pod", pl)
		last_processes_list_publish = time()
	end


	while(pl[1] and pl[1].id <= wm_proc_id) do
		deli(pl, 1)
	end

	--printh("---")

	local keep_going = true
	local remaining = allotment -- - stat(301) -- 0.2.0e: already subtracted stat(301) (total system frame cycles) from allotment!
	local slices = 0


	-- assign cpu share
	local total_cpu_share = 0
	for i=1,#pl do
		-- to do: observe signal 43? proably don't need that mechanism (temporary high priority)
		local pri = pl[i].priority
		pl[i].cpu_share  = pri
		total_cpu_share += pri
	end

	-- round: might not make any progress towards zero -- e.g. if still a tiny bit of cpu left
	-- that rounds down to 0 cycles; or for some other anomolous reason a process keeps returning
	-- 0.1.1e: also happens because of atomic disk op locking -- reduced max round from 4096 to 512 for speed
	-- 0.2.0h: atomic locking given high priority so very rarely need anything higher than ~4. -> 16 is safe
	local round = 0
	while (keep_going and remaining > 0 and round < 16) do

		keep_going = false

		local total_cpu_share_this_round = total_cpu_share
		
		-- tiny slices for debugging -- find issues caused due to process switching
		-- cpu = 0.0001 -- 30 insts/slice. need high round max (4096) to prevent flickering on desktop

--		printh("  "..stat(301))
		for i = 1,#pl do -- need to iterate forwards to get consistent tab order on load! (means del() sometimes cause iteration to skip a process)
			local p = pl[i]
			if (p) then

				local cpu_to_spend = remaining * p.cpu_share / total_cpu_share_this_round

	--				if (p.name == "ps") then
	--					printh(string.format("  running %2d  cpu: %3.3f  share %3.3f  round %d", p.id, cpu_to_spend, p.cpu_share / total_cpu_share_this_round, round))
	--				end

				--local completed, cpu_spent, err = _run_process_slice(p.id, p.id < 10 and 0.2 or cpu) -- debug: only microslice cproj output
				local completed, cpu_spent, err = _run_process_slice(p.id, cpu_to_spend)

				if (cpu_spent) remaining -= cpu_spent

	--				if (cpu_spent > cpu_to_spend * 1.01) printh("* "..pod{p.name, cpu_spent / cpu_to_spend})


	--			printh(string.format("  running %2d  cpu: %3.3f/%3.3f  share %3.3f  comp: %s round %d remaining: %3.3f", 
	--				p.id, cpu_spent, cpu_to_spend, p.cpu_share / total_cpu_share_this_round, completed and "*" or " ", round, remaining))


				if (completed) then
					--if (p.name == "ps") printh("    completed "..p.name.." cpu:"..string.format("%3.3f",cpu_spent).."  // round "..round)
					total_cpu_share -= p.cpu_share
					del(pl, p) -- means sometimes skip a process for a round
					keep_going = true -- in case there was a skipped process that still has cpu to spend
				elseif cpu_spent and cpu_spent > 0 then
					-- at least one process made progress
					-- (note: when atomic file op in progress, should really give that process more cpu because
					--  others are all going to be 0 until it is finished. could transfer allocation from blocked process!)
					keep_going = true
					
				end



				slices += 1
			
				
			end
		end
		
		round += 1
--		if (keep_going) printh("------")

	end

--	printh("@@rounds "..round)
--	printh("slices: "..slices.."   stat(301): "..stat(301))

end


-- boot sound
sfx_index = 0
sfx_delay = 1000 --1200
r = fetch"/system/misc/boot.sfx"


for i=0,0x2ff do
	poke(0x30000+i*0x100, get(r,i*0x100,0x100))
end


local total_frames = 0
local max_wm_cpu = 0.02

local wm_cpu = {}
local max_cpu_samples = 64
for i=0,max_cpu_samples-1 do wm_cpu[i] = 0 end
local wm_cpu_index = 0
local played_boot_sound = false

while (true) do -- \m/

--	printh("------------ mainloop "..total_frames.." ----------------")
	total_frames += 1

	-- play boot sound when not running a headless script
	-- to do: use time() for better sync
	if not played_boot_sound and stat(987) >= sfx_delay and stat(315) == 0 then
		played_boot_sound = true
		sfx(sfx_index)
	end


	-- maybe don't need procman
	-- to do: just let any (local security context) process kill any other process
	-- can assume completes within 0.1 cpu
	_run_process_slice(2, 0.1)



	-- allocate longest time spent in wm within the last 8 frames
	local wm_cpu_max = 0.01 -- at least 1%
	for i=0,max_cpu_samples-1 do
		if (wm_cpu[i] > wm_cpu_max) wm_cpu_max = wm_cpu[i]
	end


--	printh("[boot.lua] wm_cpu_max:"..wm_cpu_max)

--[[	printh(string.format("%3.3f %3.3f %3.3f %3.3f %3.3f %3.3f %3.3f %3.3f ",
		wm_cpu[0],wm_cpu[1],wm_cpu[2],wm_cpu[3],wm_cpu[4],wm_cpu[5],wm_cpu[6],wm_cpu[7]))
]]

	-- 0.98 to give 2% margin
	-- problem is: run_userland_processes can't guarantee to run under allotment; e.g. finish on expensive operation
	-- also allows wm to spike by 1% without causing frame overrun (e.g. when desktop apps are maxing out userland cpu)
	-- to do: perhaps could be less when desktop workspaces / more for fullscreen workspace

	local userland_cpu = 0.98 - wm_cpu_max - stat(301)
	local cpu0 = stat(301)

	run_userland_processes(userland_cpu)

	local cpu1 = stat(301)

--	printh("  ul -> "..pod{stat(303), stat(301)\0.001, stat(304)\0.001})


	-- run window manager last: want to see most recent state of every program; otherwise a frame behind?
	
	-- make sure wm process completes
	local wm_slice_completed = false 
	local total_wm_cpu = 0
	while not wm_slice_completed do

		local completed, cpu_spent, err = _run_process_slice(3, 0.5)

		--printh(" wm slice cpu: "..pod{completed, cpu_spent, err})

		if (cpu_spent) total_wm_cpu += cpu_spent

		if (err) then

			poke(0x0, 1) -- low level error code
			--printh("*** wm error: "..err)

			wm_slice_completed = true -- give up
		elseif completed then
			--printh("completed: "..cpu_spent)
			wm_cpu[wm_cpu_index] = total_wm_cpu
			wm_cpu_index = (wm_cpu_index + 1) % max_cpu_samples
			wm_slice_completed = true
			-- if (total_wm_cpu > wm_cpu_max) printh("wm cpu spike: "..total_wm_cpu.." / "..wm_cpu_max) 
		else
			-- printh("** wm slice did not complete; running again **")
			-- to do: when does this happen? genuine large spike in wm usage?
				-- or because of unexpected yields / superyields? (run_process_slice does not currently run subslices)
		end

	end

	local cpu2 = stat(301)

--	printh("  wm -> "..pod{stat(303), stat(301)\0.001, stat(304)\0.001})

	-- to do: allow it to complete (assuming 1 whole frame of cpu is enough) -- don't want to discard (or show!) half-rendered frames 

--[[
	 printh(string.format("cpu0: %3.3f [userland: %3.3f/%3.3f] -> cpu1: %3.3f [wm:%3.3f/%3.3f] -> %3.3f",
			cpu0, cpu1-cpu0, userland_cpu, cpu1, cpu2-cpu1, wm_cpu_max, cpu2))
--]]

	-- return control to c program 
	-- (let emscripten mainloop function end to return control to the browser)

--	coroutine.yield()

	

	flip() -- reset cpu_cycles for next frame? doesn't matter now that using stat(301) though.

end

:: bios/lib/api.lua
--[[pod_format="raw",created="2024-03-24 14:56:58",modified="2024-03-24 14:56:58",revision=0]]


-- iterators need to be in lua to avoid c boundary yielding

function all(c) if (c == nil or #c == 0) then return function() end end
 	local i=1
 	local li=nil
 	return function()
 		if (c[i] == li) then i=i+1 end
 		while(c[i]==nil and i <= #c) do i=i+1 end
 		li=c[i]
 		return li
 	end
end

function foreach(c,_f)
	for i in all(c) do _f(i) end 
end

-- pico-8 style sub // to do: move to c

function sub(str, p0, p1)
	if (type(str) ~= "string") then return end
	if (p1 ~= nil and type(p1) != "number") p1 = p0 -- get character at pos
	return string.sub(str, p0, p1)
end


-- pico-8 compatibility (but as_hex works differently; no fractional part)
-- weird to have 2 slightly different ways to write the same thing, but tostr(foo,1) is too handy for getting hex numbers

local _tostring = tostring
function tostr(val, as_hex)
	if (as_hex) then
		if (type(val) != "number") return -- same as pico-8
		return string.format("0x%x", tonumber(val) or 0)
	else
		return _tostring(val)
	end
end

-- pack, unpack globals at top level

unpack = table.unpack
pack = table.pack



:: bios/lib/app_menu.lua
--[[

	menuitem{
		id = 3,                   -- unique identifier. integer ids are used to sort items (otherwise in order added)
		label = "Foo",            -- user-facing label
		shortcut = "CTRL-O",      -- drawn right justified in menu
		greyed = false,           -- greyed out item (use for ---)
		action = function(b) end  -- callback on select -- b is the button pressed (left / right)
	}

]]

local _menu = {}
local _send_message = _send_message
local _pid = pid
local _signal = _signal

local function eval_menuitem(item)
	local item1 = {}
	for k,v in pairs(item) do
		if (k == "label" and type(v) == "function") v = v() -- label can be a function
		item1[k] = v
	end
	return item1
end

function menuitem(m, a, b)

	_menu = _menu or {}

	-- clear
	if (not m) then
		_menu = {}
		_send_message(3, {event = "app_menu_item", clear = true})
		return
	end

	-- legacy pico-8 calling format
	if (a) then
		m = {
			id = m, -- integer position
			label = a,
			action = b
		}
	end

	-- add divider
	if (m == "---") m = {divider = true}
	if m.divider then
		_send_message(3, {event = "app_menu_item", attribs = m})
		return
	end

	if (not _menu[m.id]) then
		_menu[m.id] = m
	elseif not m.label then
		-- remove
		_menu[m.id] = nil
	else
		-- update items
		for k,v in pairs(m) do
			_menu[m.id][k] = v
		end
	end

	-- resend whole menu item state (wm doesn't need to handle partial changes)
	-- also handles deletion

--	_send_message(3, {event = "app_menu_item", attribs = _menu[m.id] or m})
	_send_message(3, {event = "app_menu_item", attribs = eval_menuitem(_menu[m.id] or m)})

end


-- default hooks
on_event("menu_action", function(msg)
	local item = _menu[msg.id]
	if (item and item.action) then
		local res = item.action(msg.b)
		-- to do: clear keys / buttons here. could be a signal

		-- resend incase label changed
		_send_message(3, {event = "app_menu_item", attribs = eval_menuitem(item)})
		

		if (not res) then
			-- close the menu
			--send_message(_pid(), {event = "unpause"})
			_signal(23) -- block all buttons until released
			send_message(3, {event = "close_pause_menu"}) -- only applies to fullscreen apps
		end
	end
end)

-- wm asks for labels to be updated each time bringing up the pause menu
-- i.e. re-evaluate the ones that are functions
on_event("update_menu_labels", function(msg)
	for i=1,#_menu do
		if _menu[i] and type(_menu[i].label) == "function" then
			_send_message(3, {event = "app_menu_item", attribs = eval_menuitem(_menu[i])})
		end
	end
end)





:: bios/lib/coroutine.lua

--------------------------------------------------------------------------------------------------------------------------------
--    Coroutines
--------------------------------------------------------------------------------------------------------------------------------

-- aliases
yield = coroutine.yield
cocreate = coroutine.create
costatus = coroutine.status

local _coresume = coroutine.resume -- used internally
local _costatus = coroutine.status
local _yielded_to_escape_slice = _yielded_to_escape_slice

--[[

	coresume wrapper needed to preserve and restore call stack
	when interrupting program due to cpu / memory limits

]]

function coresume(c,...)
	
	_yielded_to_escape_slice(0)
	local ret = {_coresume(c,...)}
	--printh("coresume() -> _yielded_to_escape_slice():"..tostring(_yielded_to_escape_slice()))
	while (_yielded_to_escape_slice() and _costatus(c) == "suspended") do
		_yielded_to_escape_slice(0)
		ret = {_coresume(c,...)}
	end
	_yielded_to_escape_slice(0)

	return unpack(ret)
end

-- 0.1.1e library version should do the same
coroutine.resume = coresume



:: bios/lib/events.lua
--[[pod_format="raw",created="2024-05-28 08:10:08",modified="2024-05-28 08:13:55",revision=5]]
--[[

	events.lua
	part of head.lua

]]

do

	local _envdat = env()
	local _send_message = _send_message
	local _read_message = _read_message
	local _update_buttons = _update_buttons
	local _signal = _signal
	local _flip = _flip

	local _warp_mouse = _warp_mouse
	
	local _window_has_focus = false

	local _pidval = pid()
	local _window_can_read_kbd = _pidval <= 3

	local message_hooks = {}
	local message_subscriber = {}
	local mouse_x = 0
	local mouse_y = 0
	local mouse_b = 0
	local wheel_x = 0
	local wheel_y = 0
	local locked_dx = 0
	local locked_dy = 0

--	local _req_host_clipboard_text = _req_host_clipboard_text -- old approach; deleteme
--	local _get_host_clipboard_text = _get_host_clipboard_text

	local _set_host_clipboard_text = _set_host_clipboard_text
	local _set_userland_clipboard_text = _set_userland_clipboard_text
	local _get_userland_clipboard_text = _get_userland_clipboard_text
	local sandbox_clipboard_text = nil


	local ident = math.random()

	local key_state={}
	local last_key_state={}
	local repeat_key_press_t={}

	local frame_keypressed_result={}
	local scancode_blocked = {} -- deleteme -- not used or needed   //  update: maybe do? ancient sticky keys problem

	local input_response = nil -- used by input()

	local any_key0 = false
	local any_key1 = false

	local halt_corun_program = nil

	local pressed_ctrl_v = false


	function mouse(new_mx, new_my)
		if (new_mx or new_my) then
			new_mx = new_mx or mouse_x
			new_my = new_my or mouse_y
			_warp_mouse(new_mx, new_my);
		end
		return mouse_x, mouse_y, mouse_b, wheel_x, wheel_y -- wheel
	end

	--[[
		do_lock bits
			0x1 enable mouse (P8)       //  ignored; always enabled!
			0x2 mouse_btn    (P8)       //  mouse buttons trigger player buttons (not implemented)
			0x4 mouse lock   (P8)       //  lock cursor to picotron host window when set
			0x8 auto-unlock on mouseup  //  common pattern for dials (observed by gui.lua)
	]]
	function mouselock(do_lock, event_sensitivity, move_sensitivity)
		if (event_sensitivity) poke(0x5f28, mid(0,event_sensitivity*64, 255)) -- controls scale of deltas (64 == 1 per picotron pixel)
		if (move_sensitivity)  poke(0x5f29, mid(0,move_sensitivity *64, 255)) -- controls speed of cursor while locked (64 == 1 per host pixel)
		if (type(do_lock) == "number") poke(0x5f2d, do_lock)    -- set all flags
		if (do_lock == true)  poke(0x5f2d, peek(0x5f2d) | 0x4)  -- don't alter flags, just set the lock bit
		if (do_lock == false) poke(0x5f2d, peek(0x5f2d) & ~0x4) -- likewise
		if ((peek(0x5f2d) & 0x4) == 0) return 0, 0               -- when not locked, always return 0,0
		return locked_dx, locked_dy -- wheel, locked is since last frame
	end



	--[[

		// 3 levels of keyboard mapping:

		1. raw key names  //  key("a", true)
	
			"a" means "the key to the right of capslock"
			defaults to US layout, patched by /appdata/system/scancodes.pod
			example: tracker music input -- layout should physically match a piano

		2. mapped key names  // key("a")

			"a" means the key with "a" written on it
			e.g. the key to the right of tab on a typical azerty keyboard
			defaults to OS mapping, patched by /appdata/system/keycodes.pod
			example: key"f" to flip sprite horiontally should respond to the key with "f" written on it

		3. text entry  // readtext()

			"a" is a unicode string triggered by pressing a when shift is not held (-> SDL_TEXTINPUT event)
			ctrl-a or enter does not trigger a textinput event; need to read with mapped key names using key() + keyp()
			defaults to host OS keyboard layout and text entry method; not configurable inside Picotron [yet?]
	]]
	

	-- physical key names
	-- include everything from sdl -- might want to make a POS terminal; but later could define a "commonly supported" subset
	local scancode_name = {
	"", "", "", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", 
	"m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "1", "2", 
	"3", "4", "5", "6", "7", "8", "9", "0", "enter", "escape", "backspace", "tab", "space", "-", "=", "[", 
	"]", "\\", "#", ";", "'", "`", ",", ".", "/", "capslock", "f1", "f2", "f3", "f4", "f5", "f6", 
	"f7", "f8", "f9", "f10", "f11", "f12", "printscreen", "scrolllock", "pause", "insert", "home", "pageup", "delete", "end", "pagedown", "right", 
	"left", "down", "up", "numlock", "kp /", "kp *", "kp -", "kp +", "kp enter", "kp 1", "kp 2", "kp 3", "kp 4", "kp 5", "kp 6", "kp 7", 
	"kp 8", "kp 9", "kp 0", "kp .", "<", "menu0", "", "kp =", "", "", "", "", "", "", "", "f20", 
	"f21", "f22", "f23", "f24", "execute", "help", "menu1", "select", "stop0", "again", "undo", "", "", "", "find", "", 
	"", "", "", "", "", "kp ,", "kp = (as400)", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "alterase", "right alt", "stop1", "clear", "prior", "return", "separator", 
	"out", "oper", "clear / again", "crsel", "exsel", "", "", "", "", "", "", "", "", "", "", "", 
	"kp 00", "kp 000", "thousandsseparator", "decimalseparator", "currencyunit", "currencysubunit", "kp (", "kp )", "kp {", "kp }", "kp tab", 
		"kp backspace", "kp a", "kp b", "kp c", "kp d", 
	"kp e", "kp f", "kp xor", "kp ^", "kp %", "kp <", "kp >", "kp &", "kp &&", "kp |", "kp ||", "kp :", "kp #", "kp space", "kp @", "kp !", 
	"kp memstore", "kp memrecall", "kp memclear", "kp memadd", "kp memsubtract", "kp memmultiply", "kp memdivide", "kp +/-", "kp clear", 
		"kp clearentry", "kp binary", "kp octal", "kp decimal", "kp hexadecimal", "", "", 
	"lctrl", "lshift", "lalt", "lcommand", "rctrl", "rshift", "ralt", "rcommand"
	}



	local raw_name_to_scancode = {}

	for i=1,#scancode_name do
		local name = scancode_name[i]
		if (name ~= "") raw_name_to_scancode[name] = i
	end

	-- patch with /settings/scancodes
	-- e.g. store("/appdata/system/scancodes.pod", {lctrl=57}) to use capslock as lctrl

	local patch_scancodes = fetch"/appdata/system/scancodes.pod"
	if type(patch_scancodes) == "table" then
		for k,v in pairs(patch_scancodes) do
			raw_name_to_scancode[k] = v
		end
	end

	-------------------------------------------------------------------------
	--	name_to_scancodes:  default host OS default mapping
	--  each entry is a table of one or more scancodes that trigger it
	-------------------------------------------------------------------------

	local name_to_scancodes = {}

	for i=1,255 do
		local mapped_name = stat(302, i)
		if (mapped_name and mapped_name ~= "") then
			-- temporary hack -- convert from SDL names (should happen at lower level)
			mapped_name = mapped_name:lower()
			if (mapped_name:sub(1,7) == "keypad ") mapped_name = "kp "..mapped_name:sub(8)
			if (mapped_name:sub(1,5) == "left ") mapped_name = "l"..mapped_name:sub(6)
			if (mapped_name:sub(1,6) == "right ") mapped_name = "r"..mapped_name:sub(7)
			if (mapped_name == "return") mapped_name = "enter"
			if (mapped_name == "lgui") mapped_name = "lcommand"
			if (mapped_name == "rgui") mapped_name = "rcommand"
			if (mapped_name == "loption") mapped_name = "lalt"
			if (mapped_name == "roption") mapped_name = "ralt"

--			printh("mapping "..mapped_name.." to "..i.."    // ".._get_key_from_scancode(i))

			if (not name_to_scancodes[mapped_name]) name_to_scancodes[mapped_name] = {}

			add(name_to_scancodes[mapped_name], i)

		end
	end


	-- raw  scancode names that are not mapped to anything -> dummy scancode (simplify logic)
	for i=1,#scancode_name do
		if (scancode_name[i] ~= "") then
			if (raw_name_to_scancode[scancode_name[i]] == nil) raw_name_to_scancode[scancode_name[i]] = -i
		end
	end

	
	-- patch keycodes (can also overwrite multi-keys like ctrl)

	local patch_keycodes = fetch"/appdata/system/keycodes.pod"
	if type(patch_keycodes) == "table" then
		for k,v in pairs(patch_keycodes) do
			-- /replace/ existing table; can use keycodes.pod to turn off mappings
			if (type(v) == "table") then
				name_to_scancodes[k] = v
			else
				name_to_scancodes[k] = {raw_name_to_scancode[v] or v} -- can use raw name or scancode directly.
			end
			--printh("mapping keycode "..k.." to "..pod(name_to_scancodes[k]))
		end
	end

	-- scancodes map to themselves unless explicitly remapped
	-- (avoids an extra "or scancode" in get_scancode)

	for i=0,511 do
		name_to_scancodes[i]    = name_to_scancodes[i] or {i}
		raw_name_to_scancode[i] = raw_name_to_scancode[i] or i
	end

	-- faster lookup for lctrl, rctrl, lalt, ralt wm filtering combinations
	local lctrl = (name_to_scancodes.lctrl and name_to_scancodes.lctrl[1]) or -1
	local rctrl = (name_to_scancodes.rctrl and name_to_scancodes.rctrl[1]) or -1
	local lalt =  (name_to_scancodes.lalt  and name_to_scancodes.lalt[1])  or -1
	local ralt =  (name_to_scancodes.ralt  and name_to_scancodes.ralt[1])  or -1


	-- alternative names
	-- (if the name being aliased is unmapped, then inherit its dummy mapping)

	name_to_scancodes["del"]      = name_to_scancodes["delete"] -- 0.1.0b used del
	name_to_scancodes["return"]   = name_to_scancodes["enter"]   
	name_to_scancodes["+"]        = name_to_scancodes["="]
	name_to_scancodes["~"]        = name_to_scancodes["`"]
	name_to_scancodes["<"]        = name_to_scancodes[","]
	name_to_scancodes[">"]        = name_to_scancodes["."]


	-- super-keys that are triggered by a bunch of other keys
	-- common to want to test for "any ctrl" (+ picotron includes apple command keys as ctrl)

	local function create_meta_key(k)
		local result = {}
		for i=1,#k do	
			local t2 = name_to_scancodes[k[i]]
			if (t2) then -- key might not be mapped to anything (ref: rctrl on robot)
				for j=1,#t2 do
					add(result, t2[j])
				end
			end
		end
		--printh("@@@ "..pod(k).."  -->  "..pod(result))
		return result
	end

	name_to_scancodes["ctrl"]  = create_meta_key{"lctrl",  "rctrl",  "lcommand", "rcommand"}
	name_to_scancodes["alt"]   = create_meta_key{"lalt",   "ralt"}
	name_to_scancodes["shift"] = create_meta_key{"lshift", "rshift"}
	name_to_scancodes["menu"]  = create_meta_key{"menu0",  "menu1"}
	name_to_scancodes["stop"]  = create_meta_key{"stop0",  "stop1"}


	-- is allowed to return a table of scancodes that a key is mapped to
	local function get_scancode(scancode, raw)
		local scancode = (raw and raw_name_to_scancode or name_to_scancodes)[scancode]
		--[[
		if (scancode_blocked[scancode]) then
			-- unblock when not down. to do: could do this proactively and not just when queried 
			if (key_state[scancode] != 1) scancode_blocked[scancode] = nil 
			return 0 
		end
		]]
		return scancode
	end

	--[[

		keyp(scancode, raw)

			raw means: use US layout; same physical layout regardless of locale.
			use for things like music keyboard layout in tracker

			otherwise: map via appdata/system/scancodes.pod (should be "kbd_layout.pod"?)

		-- frame_keypressed_result is determined before each call to _update()
		--  (e.g. ctrl-r shouldn't leave a keypress of 'r' to be picked up by tracker. consumed by window manager)

	]]

	function keyp(scancode, raw, depth)

--		if (scancode == "escape") printh("get_scancode(\"escape\"): "..get_scancode(escape))

--		if (not _window_can_read_kbd) return nil

		if (not(scancode)) return any_key1 and not any_key0

		scancode = get_scancode(scancode, raw)

		if (type(scancode) == "table") then			
			
			if (#scancode == 1) then
				-- common case: just process that single scancode
				scancode = scancode[1]
			else
				if (depth == 1) return false -- eh?
				local res = false
				for i=1,#scancode do res = res or keyp(scancode[i], raw, 1) end
				return res
			end
		end

		-- keep returning same result until end of frame
		if (frame_keypressed_result[scancode]) return frame_keypressed_result[scancode]

		-- first press
		if (key_state[scancode] and not last_key_state[scancode]) then
			repeat_key_press_t[scancode] = time() + 0.5 -- to do: configurable
			frame_keypressed_result[scancode] = true

			-- experimental: block all buttons! means can process keypresses first in _update so that they won't interfere with buttons mapped to keyboard
			-- update: nah -- too much magic and not that useful. better to do explicitly in _update() (e.g. ignore button presses while ctrl held)
			-- _signal(23)

			return true
		end

		-- repeat
		if (key_state[scancode] and repeat_key_press_t[scancode] and time() > repeat_key_press_t[scancode]) then
			repeat_key_press_t[scancode] = time() + 0.04
			frame_keypressed_result[scancode] = true
			return true
		end

		return false
	end
	
	
	function key(scancode, raw)

--		if (not _window_can_read_kbd) return nil
		if (not(scancode)) return any_key1

		scancode = get_scancode(scancode, raw)

		if (type(scancode) == "table") then
			local res = false
			for i=1,#scancode do 
				if (key_state[scancode[i]]) return true
			end
			return false
		end

		return key_state[scancode]
	end



	-- clear state until end of frame (update: or until pressed again?)
	-- (mapped keys only -- can't be used with raw scancodes)
	function clear_key(scancode)

		scancode = get_scancode(scancode)

		if (type(scancode) == "table") then
			for i=1,#scancode do 
				frame_keypressed_result[scancode[i]] = nil
				key_state[scancode[i]] = nil
			end
			return
		end

		frame_keypressed_result[scancode] = nil
		key_state[scancode] = nil
	end

	
	local text_queue={}

	function readtext(clear_remaining)
		local ret=text_queue[1]

		for i=1,#text_queue do -- to do: use table operation
			text_queue[i] = text_queue[i+1] -- includes last nil
		end

		if (clear_remaining) text_queue = {}
		return ret
	end

	function peektext(i)
		return text_queue[i or 1]
	end

	-- when window gains or loses focus
	local function reset_kbd_state()
		--printh("resetting kbd")
		text_queue={}
		key_state={}
		last_key_state={}

		-- block buttons
		_signal(23)

		-- block all keys
		--[[
			scancode_blocked = {}
			for k,v in pairs(name_to_scancode) do
				scancode_blocked[v] = true
			end
		]]

	end

	-- 
	function get_clipboard()

		if (_envdat.sandbox) then
			return sandbox_clipboard_text
		end

		return _get_userland_clipboard_text()
		
	end

	function set_clipboard(str)
		if (type(str) == "number") str = tostring(str)
		if (type(str) ~= "string") return

		-- set at all 3 levels regardless of context: sandbox, userland, host
		sandbox_clipboard_text = str
		_set_userland_clipboard_text(str)
		_set_host_clipboard_text(str)
	end


	local function _update_keybd()

		-- 0.1.0g: disable control keys when alt is held
		-- don't want ALTgr + 7 to count as ctrl + 7 (some hosts consider ctrl + alt to be held when ALTgr is held)
		if (key_state[lalt] or key_state[ralt]) then
			key_state[lctrl] = nil
			key_state[rctrl] = nil
		end


		if (_pidval > 3 and key"alt") then
			-- wm workspace flipping shouldn't produce keyp("left") / keyp("right")
			clear_key("left") 
			clear_key("right")
			-- host alt+enter / tab shouldn't produce keyp("enter") / keyp("tab")
			clear_key("enter")
			clear_key("tab")
		end

		-- 0.1.1e: handle ctrl-v (message only sent by wm when window has focus)
		if (pressed_ctrl_v) then

--			printh("@@ event:pressed_ctrl_v ~ simulate ctrl-v keyress")
			key_state[name_to_scancodes["lctrl"][1]] = 1    -- can set any of the physicals keys named "lctrl"
			key_state[name_to_scancodes["v"][1]] = 1        -- ditto
			last_key_state[name_to_scancodes["v"][1]] = nil -- so that keyp("v") == true
			
			-- pretend all keys are released after 0.1 seconds (artifical keypresses have no keyup message; will be sticky)
			--send_message(_pidval, {event="reset_kbd", _delay = 0.1})

			send_message(_pidval, {event="keyup", scancode = name_to_scancodes["lctrl"][1], _delay = 0.1})
			send_message(_pidval, {event="keyup", scancode = name_to_scancodes["v"][1], _delay = 0.1})

			pressed_ctrl_v = false

		elseif stat(318) == 1 then
			-- web: when ctrl-v, pretend the v didn't happen. 
			-- the only way to get ctrl-v is via the "pressed_ctrl_v" message
			if (key("ctrl") and keyp("v")) then
				clear_key("v") 
			end
		end

		-- transfer sandbox clipboard (whether triggered by virtual or regular host)

		if (key("ctrl") and keyp("v")) then
			sandbox_clipboard_text = _get_userland_clipboard_text() -- ctrl-v taken as permission to transfer from userland clipboard to sandbox
			_signal(23) -- also: block buttons. Don't want the "v" press to pass through as a button press
		end

		any_key0 = any_key1 -- last frame
		any_key1 = stat(305) -- this frame

	end




	local future_messages = {}

	--[[
		called in foot exactly once before each _update
		(and once per frame if no _update defined)
	]]
	
	function __process_event_messages()

		frame_keypressed_result = {}

		wheel_x, wheel_y, locked_dx, locked_dy = 0, 0, 0, 0

		last_key_state = unpod(pod(key_state))

		-- send an update message every update if anyone is listening (used by fs.lua fetch job polling and wrangle for watching state changes)
		-- same test as foot in foot
		if (message_hooks["update"] and ((peek(0x547f) ^^ 0x20) & 0x61) > 0) send_message(_pidval, {event="update"})

		local future_index = 1

		repeat
			
			local msg = _read_message()

			if (msg and msg._delay) msg._open_t = time() + msg._delay

			-- future messages: when _open_t is specified, open message at that time

			if (not msg and future_index <= #future_messages) then
				-- look for next future message that is ready to be received
				while (future_index <= #future_messages and future_messages[future_index]._open_t >= time()) do
					future_index += 1
				end
				msg = deli(future_messages, future_index)
			elseif (msg and msg._open_t and time() < msg._open_t) then
				-- don't process yet! put in queue of future messages
				add(future_messages, msg)
				msg = nil
			end

			
			if (msg) then

			--	printh(ser(msg))

				if (message_hooks[msg.event]) then
					for i = 1, #message_hooks[msg.event] do
						responce = message_hooks[msg.event][i](msg)
						-- 0.2.0i: when a _reply_id is present, send a responce back to ._from
						-- at this point, ._from normally has an event handler for that responce_id (installed during initial send_message) 
						if msg._reply_id then -- means sender is expecting a reply
							responce = responce or {}
							responce.event = msg._reply_id
							send_message(msg._from, responce)
						end
					end
				end

				--send to each firehose subscriber (used by wm)

				for i=1,#message_subscriber do
					message_subscriber[i](msg) -- ignore return value in this context
				end

			end -- msg ~= nil

		until not msg

		--------------------------------------------------------------------------------------------------------------------------------

		_update_keybd()

		--------------------------------------------------------------------------------------------------------------------------------

		-- when window does not have focus, ignore controller
		-- window manager can always read controller (need for pause menu control)
		-- to do: app can request background buttons in window()
		_update_buttons(_window_has_focus or _pidval <= 3)

		--------------------------------------------------------------------------------------------------------------------------------

	end

	-- flip()
	-- allow custom mainloop / #putaflipinit / jelpi style fadeout
	-- Farbs on "Meandering Thread of Execution": https://mastodon.social/@Farbs/112691223223669609

	function flip(flags)
		flags = flags or 0x4

		if (not _draw and not _update) flags |= 0x4 -- always pump messages when no mainloop [yet]

		if (flags & 0x4) > 0 and _pidval > 3 then  

			-- e.g. #putaflipinit; need to handle events

			__process_event_messages() 

			if halt_corun_program then
				halt_corun_program = false
				yield() -- to interrupt when corun in terminal
			end

			_flip(flags) -- need to flip before check pause bit

			-- hold program while paused
			while (peek(0x547f) & 0x4) > 0 do
				__process_event_messages() 
				_flip(0x1) -- superyield (don't advance time or end frame)
			end

		else
			-- vanilla flip
			_flip(flags)
		end
	end



	-----------------------------------------------------------------------------------------------------------------------------
	
	function on_event(event, f)

		-- when f is nil (or not a function) remove all hooks for that event
		if (type(f) != "function") then
			if (event and message_hooks) message_hooks[event] = nil
			return
		end

		if (not message_hooks[event]) message_hooks[event] = {}

		-- for file modification events: let pm know this process is listening for that file
		if (sub(event, 1, 9) == "modified:") then
			local filename_userland = sub(event, 10)
			local filename_kernal = filename_userland

			-- for simplicity, sandboxed processes can't subscribe to anything except /ram/shared/* 
			-- (otherwise need to handle location rewrites) in message contents
			-- if (_envdat._sandbox and filename:sub(1,12) ~= "/ram/shared/") return
			-- allow /appdata -- pm.lua can handle it
			if (_envdat._sandbox and filename_userland:sub(1,12) ~= "/ram/shared/" and filename_userland:sub(1,9) ~= "/appdata/") return

			-- sandboxed process: map 
			-- to do: should us _userland_to_kernal_path here but how to safety expost to events.lua?
			-- this is a temporary solution for bbs://trashman
			if (_envdat.sandbox and _envdat.bbs_id) then
				if (filename_userland:sub(1,9) == "/appdata/" and filename_userland:sub(1,16) ~= "/appdata/shared/") then
					filename_kernal = "/appdata/bbs/".._envdat.bbs_id.."/"..filename_userland:sub(10)
				end
			end

			_send_message(2, {
				event = "_subscribe_to_file",
				filename_userland = filename_userland, -- the file as it appears in the modified:foo -- could be relative
				filename_kernal = fullpath(filename_kernal) -- full path of unmapped file on disk / in ram
			})
		end

		add(message_hooks[event], f)
	end

	-- kernel space for now -- used by wm (jettisoned)
	function _subscribe_to_events(f)
		add(message_subscriber, f)
	end


	--[[
		input()
		send "input" event to terminal and then wait for a response 

		flags:
			0x1 hide result
			0x2 return when any key is pressed
			0x4 non-blocking
	]]
	function input(prompt, flags)
		
		flags = flags or 0
		local hide = (flags & 0x1) > 0
		local single_char = (flags & 0x2) > 0
		local non_blocking = (flags & 0x4) > 0

		prompt = prompt or "? "

		local corunning = _envdat.corun_program

--		printh("input() from process: ".._pidval)


		if (corunning) then
			-- when corunning via ctrl+r, should not pause on enter
			-- also creates fullscreen window if one does not already exist (print does this explicitly)
			window{pauseable = false}
			poke(0x547f, peek(0x547f) & ~0x8) -- not a graphical program though; print to terminal
		end

		-- when print_to_proc_id is not specified, print to self (e.g. ctrl-r running in terminal)
		_send_message(_envdat.print_to_proc_id or _pidval, {event="input",prompt=prompt,hide=hide,single_char=single_char})

		-- wandering center of execution
		-- for a terminal script, shouldn't run anything after call to input() until control returns
		repeat

--			if ((t()*8)\1 == t()*8) printh(t()) -- debug: show heartbeat
			if (input_response) then
				local res = input_response
				input_response = nil
				reset_kbd_state()
				return res
			end

			if (corunning) then -- or (peek(0x547f) & 0x8) == 0) then
				-- just yield -- let terminal foot handle the flip (otherwise get double flip and btnp / kepy logic fails) 
				yield()
			else
				-- flip needed for running program from terminal
				flip(0x5) -- 0x1 hold frame (and don't end frame) to avoid flicker; 0x4 process messages (so that input_response can arrive)
			end

		until non_blocking

		return -- non-blocking and no input: return nothing at all
	end


	--------------------------------------------------------------------------------------------------------------------------------
	-- standard events
	--------------------------------------------------------------------------------------------------------------------------------

	on_event("input_response", function(msg)
		input_response = msg.response
	end)

	on_event("mouse", function(msg)
		mouse_x = msg.mx
		mouse_y = msg.my
		mouse_b = msg.mb	
	end)

	on_event("mousewheel", function(msg)
		wheel_x += msg.wheel_x or 0
		wheel_y += msg.wheel_y or 0
	end)

	on_event("mouselockedmove", function(msg)
		locked_dx += msg.locked_dx or 0
		locked_dy += msg.locked_dy or 0
	end)

	on_event("keydown", function(msg)
		key_state[msg.scancode] = 1
	end)

	on_event("keyup", function(msg)
		key_state[msg.scancode] = nil
	end)

	-- needed for web hacks; defer keypress message until after received clipboard contents
	on_event("pressed_ctrl_v", function(msg)
		pressed_ctrl_v = true
	end)

	-- used by wm to stop keypresses getting through
	on_event("clear_key", function(msg)
		-- printh("[".._pidval.."] clear_key: "..tostring(msg.scancode))
		clear_key(msg.scancode)
	end)

	on_event("reset_kbd", function(msg)
		reset_kbd_state()
	end)

	on_event("reset_kbd_for_paste", function(msg)
		clear_key("v")
	end)

	on_event("textinput", function(msg)
		if not(key"ctrl") and #text_queue < 1024 then -- ignore textinput when ctrl is held // do here in (rather than in os_sdlem.c) to respect ctrl mapping
			text_queue[#text_queue+1] = msg.text;
		end
	end)

	on_event("gained_focus", function(msg)
		_signal(15) -- give audio priority to this process; can steal PFX6416 control on note() / sfx() / music()
		_window_has_focus = true
		_window_can_read_kbd = true
		reset_kbd_state()
		poke(0x547f, peek(0x547f) | 0x10)
	end)

	on_event("lost_focus", function(msg)
		_window_has_focus = false
		if (_pidval > 3) _window_can_read_kbd = false
		reset_kbd_state()
		poke(0x547f, peek(0x547f) & ~0x10)
	end)

	on_event("gained_visibility", function(msg)
		poke(0x547f, peek(0x547f) | 0x1)
	end)

	on_event("lost_visibility", function(msg)
		if (_pidval > 3) poke(0x547f, peek(0x547f) & ~0x1) -- safety: only userland processes can lose visibility
	end)

	on_event("resize", function(msg)
		--printh("resize: "..pod(msg))
		-- throw out old display and create new one. can adjust a single dimension
		if (get_display()) then
			-- set x,y because sometimes want to use resize message to also adjust window position so that
			-- e.g. width and x visibly change at the same frame to avoid jitter (ref: window resizing widget)
			window{width = msg.width, height = msg.height, width0 = msg.width0, height0 = msg.height0, x = msg.x, y = msg.y}
		end
	end)

	on_event("squash", function(msg)
		
		window{
			width  = msg.width,
			height = msg.height,
			x = msg.x, y = msg.y, squash_event = true
		}
	end)

	-- placeholder event used when confirming window close from confirm.p64
	-- to do: general solution for allowing programs to do something just before they are closed
	on_event("exit", function(msg)
		if (_pidval > 3 and msg._flags and (msg._flags & 0x1) > 1) exit()
	end)

	-- events used by userland programs

	if (_pidval > 3) then
		on_event("pause",       function() poke(0x547f, peek(0x547f) |  0x4) reset_kbd_state() end)
		on_event("unpause",     function() poke(0x547f, peek(0x547f) & ~0x4) reset_kbd_state() end)
		on_event("exit", exit)
	end

	if _envdat.corun_program then
		on_event("halt", function(msg)
			halt_corun_program = true -- halt in next flip();
		end)
	end


	_export_functions_to_head{
		flip = flip,
		on_event = on_event
	}


end



:: bios/lib/foot.lua
--[[pod_format="raw",created="2024-03-11 18:02:01",modified="2024-04-23 11:47:10",revision=5]]
--[[
	foot.lua
]]

local pidval = pid()
local envdat = env()

-- init first; might set window inside _init
-- to do: no visual feedback while _init does a lot of work. maybe need to spin the picotron button gfx!
if (_init) _init() 

-- create a fullscreen window if _draw exists at this point, but program didn't explicitly call window() yet
if (_draw and not get_display() and not envdat.corun_program) then
	window()
end

-- 0x20: has draw function (used for automatic priority adjustment in get_process_list)
--       when not set, implies background_updates
if (_draw) poke(0x547f, peek(0x547f) | 0x20)

-- mainloop: when _draw or _update exists // this mainloop used by /everything/ including wm
while (_draw or _update) do

	--local t0 = stat(1) -- debug

	-- __process_event_messages called once before every _update -- assumed by keyp() and btnp
	-- when only _draw exists (and not _update), still called once per frame
	__process_event_messages()

	-- debug: look for spikes in wm message processing (> 1%)
	-- if (pidval==3 ((stat(1) - t0)\0.001) > 10) printh("[foot] wm messages cpu spike: "..((stat(1) - t0)\0.001))


	if (peek(0x547f) & 0x4) > 0 and pidval > 3 then

		-- paused: nothing left to do this frame; just superyield
		flip(0x1)

	else

		-- set a hold_frame flag here and unset after mainloop completes (in flip) 
		-- window manager can decide to discard half-drawn frame. --> PICO-8 semantics
		-- moved to start of mainloop so that _update() can also be halfway through
		-- drawing something (perhaps to a different target) without it being exposed

		poke(0x547f, peek(0x547f) | 0x2)

		-- 0.2.0h: only run _update when visible (0x01) or app opted in with bit 0x40 // window{ background_updates = true }
		-- OR: if doesn't have a _draw function (^^ 0x20) --> don't need to opt in if program never creates a window (e.g. some kind of daemon)
		if (_update and ((peek(0x547f) ^^ 0x20) & 0x61) > 0) then

			_update()

			local fps = stat(7)
			if (fps < 60) __process_event_messages() _update()
			if (fps < 30) __process_event_messages() _update()

			-- below 20fps, just start running slower. It might be that _update is slow, not _draw.
		end

		if (_draw and (peek(0x547f) & 0x81) > 0) -- window is visible (0x1) or has background draws (0x80)
		then
			_draw()
		elseif (pid() <= 3) then
			-- safety for wm: draw next frame. // to do: why is this ever 0 for kernel processes? didn't received gained_visibility message?
			-- printh("[foot] ** forcing draw of wm (visibility bit not set) **")  -- to do: why is this happening?
			poke(0x547f, peek(0x547f) | 0x1)
		end

		flip(0x0) -- vanilla flip: no more computation this frame, and show whatever is in video memory

	end

end

:: bios/lib/fs.lua
--[[

	fs.lua

	filesystem / pod

]]


do


	local _env = env
	local _sandbox = _env().sandbox
	local _signal = _signal
	local _send_message = _send_message

	local _fetch_local = _fetch_local
	local _fetch_remote = _fetch_remote
	local _fetch_anywhen = _fetch_anywhen
	local _list_anywhen_by_day = _list_anywhen_by_day
	local _list_anywhen_by_loc = _list_anywhen_by_loc
	local _list_anywhen_folder_moment = _list_anywhen_folder_moment
	local _fetch_remote_result = _fetch_remote_result
	local _store_local = _store_local
	local _cache_store = _cache_store
	local _cache_fetch = _cache_fetch

	local _fetch_userland
	local _store_userland
	local _fstat_userland

	local _fetch_metadata_from_file = _fetch_metadata_from_file
	local _store_metadata_str_to_file = _store_metadata_str_to_file
	local _pod = _pod
	local _fstat = _fstat
	local _pwd = _pwd
	local _mount = mount
	local _cd = _cd
	local _rm = _rm
	local _cp = _cp
	local _mv = _mv
	local _ls = _ls
	local _normalise_userland_path = _normalise_userland_path
	local _is_well_formed_bbs_path = _is_well_formed_bbs_path
	local _get_process_list = _get_process_list
	local _pid = pid

	local _fcopy = _fcopy
	local _fdelete = _fdelete
	local _fullpath = _fullpath
	local _mkdir = _mkdir

	local _split = split
	local _printh = _printh

	local _yield = yield

	-- fileview can be extended via request_file_access messages
	local fileview = unpod(pod(_env().fileview))


	--[[--------------------------------------------------------------------------------------------------------------------------------

		extra protocols:  bbs // later: anywhen, podnet

		moving protocol handling into userspace means that some functionality normally handled by _fullpath needs 
		to be duplicated: path collapsing (_normalise_userland_path), auto mounting, pwd prefixing

	----------------------------------------------------------------------------------------------------------------------------------]]
	
	-- per-process record of prot://file cached as ram files
	-- later: lower-level mounting? need for writeable protocols (podnet)

	local prot_to_ram_path={}
	local ram_to_prot_path={}

	local prot_driver = {}
	
	-- test protocol
-- [==[
	prot_driver["echo"] = {
--[===[
		store_path_in_ram = function(path)
			mkdir("/ram/echo")					
			local fn=("/ram/echo/"..#prot_to_ram_path)
			if (path:ext()) fn ..= "."..path:ext()
			_store_local(fn, "["..path.."]", "--[[pod]]") -- no metadata; for bbs:// carts could inject bbs_id, bbs_author? too much magic
			return fn
		end,
]===]
		-- can provide instead of store_path_in_ram 
		get_file_contents = function(path)
			return "["..path.."]", "--[[pod]]"
		end,
		get_listing = function(path)
			return{"[listing: "..path.."]"}
		end,
		get_attr = function(path)
			return "file", #path
		end
	}
-- ]==]
	
	local function get_bbs_host()
		-- bbs web player
		if ((stat(317) & 0x3) == 0x1) then
			if (stat(152) == "localhost") return "http://localhost" -- dev
			return "https://www.lexaloffle.com"
		end

		-- any other exports: bbs:// is not supported (to do: explicit error codepath -- just disable bbs:// ? )		
		if ((stat(317) & 0x1) > 0) return ""

		-- binaries: main server
		return "https://www.lexaloffle.com"
	end

	local function get_versioned_cart_url(bbs_id)
		-- bbs web player: just use get_cart for now -- later: use cdn
		if ((stat(317) & 0x3) == 0x1) return get_bbs_host().."/bbs/get_cart.php?cat=8&lid="..bbs_id
		-- exports: bbs:// otherwise not supported 
		if (stat(317) > 0) return ""
		-- binaries: use cdn
		return "https://carts.lexaloffle.com/"..bbs_id..".p64.png"
	end

	--[[
		normalise_anywhen_path()

		want the /@/m/d part to be as far to right as possible, and should immediately follow file

		/desktop/@/2025-08-01/00:00:00/foo.txt -> /desktop/foo.txt/@/2025-08-01/00:00:00.txt

		-- to do: when multiple  /@/m/d groups exist, perhaps remove all but the last?
		--> allows things like: /desktop/@/2025-08-01/00:00:00/foo.txt/@
			~ only really useful for navigation though; perhaps filenav can handle that
			e.g. filenav > anywhen opens a new window showing /desktop/foo.txt/@
			// seems nicer
	]]
	local function normalise_anywhen_path(path)

		if (type(path) ~= "string") return nil
		local lloc, when = unpack(split(path, "@", false)) 
		lloc = lloc:sub(1,-2)

		-- the moment is inside a folder (simple test: no extension. see get_attr
		local is_folder_moment = not lloc:ext()

		if (is_folder_moment) then

			-- move everything on the right to the left hand side location
			-- /desktop/@/2025-08-01/00:00:00/temp -> /desktop/temp/@/2025-08-01/00:00:00
			lloc ..= when:sub(21)
			when = when:sub(1,20) -- /m/d
			if (lloc:ext()) when ..= "."..lloc:ext() -- /desktop/@/2025-08-01/00:00:00/foo.txt -> /desktop/foo.txt/@/2025-08-01/00:00:00.txt
		end

		return lloc.."/@"..when
	end


	-- anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00.p64/foo.txt
	-- ?pod{fstat"anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00"}
	-- ?pod{ls"anywhen://promo/pap/pap_2025.p64/@/2025-07-28"}
	
	--[[
		strip_anywhen()
		0.2.0i: canonical userland paths never have anywhen:// in them
		(they are unambiguously identified by containing an @ character)
		--> add anywhen:// when converting from userland -> kernal path, and then strip to get back to userland
	]]
	local function strip_anywhen(s)
		if (type(s) ~= "string") return s
		if (s:prot(true) == "anywhen") return s:sub(10) -- strip "anywhen:/" keep last /
		return s
	end


	local anywhen_id = 1
	local anywhen_to_ram = {}
	prot_driver["anywhen"] = {

		--[[
			figure out where to split (where subpath starts) 
			and also convert timestamp format so that can drag and drop as a local file (can't have : in filename)
			
			anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00.p64/foo.txt
				anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00.p64
				/foo.txt
		]]
		extract_cart_path = function(path)

			if (_sandbox) return nil -- never mount anywhen paths from sandboxed process

			path = normalise_anywhen_path(path)

			local c_path, when = unpack(split(path, "@", false))

			if (not c_path or not when or #when < 20 or when[1] ~= "/") return nil -- no path or no time specified or bad format
			
			c_path = c_path:sub(1,-2)  -- anywhen://promo/pap/pap_2025.p64  (trim just to check extension)
			local c_path_ext = c_path:ext() or ""

			if (not c_path_ext:is_cart()) return nil -- not inside a cart

			-- 3. timestamp part /2025-08-02/00:00:00.p64 -> 2025-08-02/00_00_00

			local ts = when:sub(2,14).."_"..when:sub(16,17).."_"..when:sub(19,20)
			c_path = c_path.."/@/"..ts

			-- 2. subpath // everything after date  (/foo.txt)
--
			local subpath = when:sub(21)

			-- remove extension part of when (and move back to c_path
			if (subpath:sub(1,4) == ".p64") then subpath=subpath:sub(5) c_path..=".p64"
				elseif (subpath:sub(1,8) == ".p64.rom") then subpath=subpath:sub(9) c_path..=".p64.rom"
				elseif (subpath:sub(1,8) == ".p64.png") then subpath=subpath:sub(9) c_path..=".p64.png"
			end

--			printh("[extract_cart_path] "..path.." ->\n   ["..c_path.."]\n   ["..subpath.."]")

			return c_path, subpath
			
		end,


		store_path_in_ram = function(path)

			if (path:ext() == "p64") then
				mkdir("/ram/anywhen") -- to do: do once on startup, like /ram/bbs
				
				if (anywhen_to_ram[path]) then
					return anywhen_to_ram[path]
				end

				-- try to grab cart
				--printh("[store_path_in_ram] trying to fetch for storing: "..path:sub(10))
				local ret, meta = _fetch_anywhen(path:sub(10)) -- strip "anywhen:/" (keep one slash)

				if (ret) then
					local fn = "/ram/anywhen/".._pid().."_"..anywhen_id..".p64"
					--printh("\\o/ could fetch to store: "..path:sub(10).."  as  "..fn) 
					anywhen_id += 1
					_store_local(fn, ret, meta) -- no metadata; for bbs:// carts could inject bbs_id, bbs_author? too much magic
					anywhen_to_ram[path] = fn
					return fn
				end

			end
			return nil -- doesn't exist or not a cart
		end,

		-- for files outside of cart
		get_file_contents = function(path)
			path = normalise_anywhen_path(path)
			path = strip_anywhen(path)
			return _fetch_anywhen(path)
		end,

		get_listing = function(path)
			if (type(path) ~= "string") return nil

			path = normalise_anywhen_path(path)

			local filename, when = unpack(split(path, "@", false))
			local local_loc = path:sub(10)

			----------------------------------------------------------------------------------------

			if (not filename:sub(1,-2):ext()) -- inside a folder when left part has no extension (see get_attr)
			then

				if (when and #when == 11) then
					return _list_anywhen_by_day(local_loc) -- /ld/@/2025-08-27
				end

				if (when == "") then
					return _list_anywhen_by_loc(local_loc:sub(1,-2)) -- /desktop/
				end

				-- listing inside a folder
				if (#when >= 20) return _list_anywhen_folder_moment(local_loc)
				return nil
			end

			----------------------------------------------------------------------------------------

			--printh("[anywhen] get_listing "..pod{path, filename, when})
			if (when and #when == 11) then -- e.g. "/2024-07-01"
				--> show days
				return _list_anywhen_by_day(local_loc) -- /foo.p64/@/2025-08-27
			end

			if (when == "") then -- requesting temporal listing at top level (days by location)
				--> show months
				return _list_anywhen_by_loc(local_loc:sub(1,-3)) -- cut off "/@" at end
			end

			if (not when) then

				-- local file -- update: never happens because not handled by anywhen in that case
				if (fstat(local_loc) == "file" or (local_loc:ext() and local_loc:ext():is_cart())) then
					return {"@"}
				end

				-- location is a folder on host --> same listing as local filesystem
				return _ls(local_loc)

			end
			
			return nil
		end,

		-- is a file only when date-time is fully specified
		get_attr = function(path)
			path = normalise_anywhen_path(path)

			local filename, when = unpack(split(path, "@", false))
			local ext = path:ext()

			if (when) then

				-- don't actually search for existence, but at least reject whens that are not well-formed
				-- important in some sitations; e.g. for distinguishing commands from lua statements in terminal!
				-- to do: more thorough form checking
				if (when[1] and when[1] ~= "/" and tonum(when:sub(1,2) ~= nil)) return false

				local when_ext = when:ext()
				local when_ext_len = when_ext and #when_ext+1 or 0
--				printh("when, when_ext, when_ext:is_cart(), len: "..pod{when, when_ext, when_ext:is_cart(), #when - #when_ext})

				if (#when - when_ext_len == 20) then -- "/2025-08-04/00:00:00.p64" with ".p64" removed
					if (when_ext and when_ext:is_cart()) return "folder", 0
					if (not when_ext) then
						-- not looking at something inside the when --> if filename part doesn't have an exention, is a folder
						if (not filename:sub(1,-2):ext()) return "folder", 0 -- e.g. /desktop/@
					end
					return "file", 0 -- points to a particular version of a single file
				end

				if (when_ext_len > 0) return "file", 0
			end			

--[[
			if (when) then
				local ext = path:ext()
				if (not ext or ext:is_cart()) return "folder", 0
				return "file", 0
			end
]]
			-- don't 
			return "folder", 0 -- no when --> folder at top level
		end
	}


	-- per session cache for listings 
	-- to do: review: cache to disk? maybe should be up to the calling app? (ref: splore list)
	local bbs_listing_cache = {}

	prot_driver["bbs"] = {

		extract_cart_path = function(path)
			local cart_path_pos = string.find(path,".p64",1,true) -- true to turn off pattern matching
			if (cart_path_pos) then
				return
					path:sub(1, cart_path_pos+3),  --  bbs://foo.p64
					path:sub(cart_path_pos+4)      --  /main.lua
			end
		end,

		store_path_in_ram = function(path)

			-- can assume /ram/bbs exists; see create_process()

			--printh("bbs store_path_in_ram: "..tostring(path))

			-- bbs://cart/foo.p64  (or bbs://foo.p64!)
			if (path:ext() == "p64") then
				local bbs_id = path:basename():sub(1,-5)
				local fn = "/ram/bbs/"..path:basename()..".png"

				-- already downloaded to ram by another process
				if (fstat(fn)) return fn

				local is_versioned = bbs_id:sub(-2,-2) == "-" or bbs_id:sub(-3,-3) == "-"

				
				--if (is_versioned) then
				if (true) then -- 0.2.0e: prefer used cached version if available (see notes in next block comments)
					-- when versioned, never changes on server so can always use this if it exists
					-- when not versioned, use here if don't want to do agressive automatic updates per-fetch 
					local cached_cart_png = _cache_fetch("carts", bbs_id..".p64.png")
					if (cached_cart_png and #cached_cart_png >= 512) then
						--printh("copying cached cart to ram: "..fn)
						if (not _store_local(fn, cached_cart_png, "format=\"raw\"")) then
							-- found in cache. if unversioned, initiate download of most recent version (non-blocking)
							-- will be cached on successful download
							cart_png, meta, err = _fetch_remote(get_bbs_host().."/bbs/get_cart.php?cat=8&lid="..bbs_id)
							return fn
						else
							--printh("** store_local failed from fs.lua")
						end
					end
				end

				--[[
					0.2.0e: use whatever can be found on disk
					would rather use an older version immedaitely; important when bbs cart is used as a default editor
					but fetch most recent version to cache (will be used on next mount; probably during next session)
					for now happens every time a non-versioned bbs cart is mounted, but in future can:
						- publish a bloom filter of /published/ cart existence (don't want to expose unlisted cart ids in filter)
						- download all-time (512k), hourly (16k) version of filter proactively
						-> only need to fetch here when higher id is found in filters (false positives ok).  // need to store .nfo files to look up local revision
						// store a byte per hash position: val_n = MAX(version, val_n) --> version lower bound on read is MIN{val0, val1 ..} // 255 means unknown
						// if false positives rare enough, can go back to use blocking fetch (and get immediate updates when new cart has been up for > 1h)
				]]
				if (not is_versioned) then
					local cached_cart_png = _cache_fetch("carts", bbs_id.."-%d.p64.png", true)
					if (cached_cart_png and #cached_cart_png >= 512) then
						--printh("copying cached cart to ram: "..fn)
						_store_local(fn, cached_cart_png, "format=\"raw\"")
						return fn
					end
				end

				-- download (blocking)
	
				-- printh("[bbs://] fetching cart from carts.lexaloffle.com/"..bbs_id..".p64.png -> "..fn)

				local cart_png, meta, err 

				if (is_versioned) then
					cart_png, meta, err = fetch(get_versioned_cart_url(bbs_id))
				end

				-- 0.1.1f "< 512": when response is an error message / too short; no legit cart png is < 512 bytes
				-- (happens in several nearyy locations)
				if (type(cart_png) ~= "string" or #cart_png < 512) then 
					-- fall back to origin; might not be on cdn yet?, or cdn is down? or cloudflare rate-limiting requests?
					--printh("get_cart fallback: "..bbs_id)
					cart_png, meta, err = fetch(get_bbs_host().."/bbs/get_cart.php?cat=8&lid="..bbs_id)
				end

				--if(err)printh("bbs prot error on fetch: "..err)
				if (type(cart_png) == "string" and #cart_png >= 512) then
					-- printh("[bbs://] fetched and cache: "..#cart_png.." bytes")
					-- store(fn, cart_png, meta) -- wrong! can't access when sandboxed
					_store_local(fn, cart_png, "format=\"raw\"")
					_cache_store("carts", bbs_id..".p64.png", cart_png)
					return fn
				end

				-- for ids with no version, check in cache *after* trying download
				-- (always want the latest version if it exists)
				-- to do: could also scan for highest versioned copy in cache
				-- to do: remove this section; now checking cache up front, same as versioned carts
				if (not is_versioned) then
					-- printh("[bbs://] attempting to use non-versioned cart from cache")
					local cached_cart_png = _cache_fetch("carts", bbs_id..".p64.png")
					if (cached_cart_png and #cached_cart_png >= 512) then
						store(fn, cached_cart_png, {format="raw"})
						return fn
					end
				end

				return nil, "cart download failed"
				
			end

			-- test
			if (path == "bbs://news.txt") then
				local text_file, meta, err = fetch(get_bbs_host().."/dl/docs/picotron_bbs_news.txt")
				-- printh("@@ downloading: "..get_bbs_host().."/dl/docs/picotron_bbs_news.txt")

				if (type(text_file) == "string" and #text_file > 0) then
					mkdir("/ram/bbs")
					store("/ram/bbs/news.txt", text_file)
					return "/ram/bbs/news.txt"
				else
					return nil, "cart download failed"
				end
			end

			return nil -- couldn't resolve
		end,
	
		get_listing = function(path)

			--printh("bbs:// listing: "..tostring(path))
			
			-- ** not meant as a public endpoint, please use bbs:// instead! **
			local endpoint = get_bbs_host().."/bbs/pod.php?"
			local req

			local p_page = nil
			local q_str = nil

			-- show page 0 instead of pages

			if (sub(path,1,10) == "bbs://new/")       p_page=sub(path,11)  q_str="sub=2"
			if (sub(path,1,10) == "bbs://wip/")       p_page=sub(path,11)  q_str="sub=3"
			if (sub(path,1,15) == "bbs://featured/")  p_page=sub(path,16)  q_str="sub=2&orderby=featured"

			p_page=tonumber(p_page)
			if (type(p_page) == "number" and q_str) req = endpoint.."cat=8&max=32&start_index="..(p_page*32).."&"..q_str


			if (req) then

				-- printh("req:"..pod{path, req})

				local res = nil
				if (bbs_listing_cache[req] and time() < bbs_listing_cache[req].response_t + 10) then
					-- use session cache
					res = bbs_listing_cache[req].response
				else
					--printh("req:"..pod{path, req})
					res = fetch(req)
					if (res) then
						-- store session cache
						bbs_listing_cache[req] = {
							response = res,
							response_t = time()
						}

						-- also start downloading everything!
						for i=1, #res do
							-- start download if doesn't already exist in cache
							if (not _cache_fetch("carts", res[i].id..".p64.png")) then
								--printh("starting background download: "..res[i].id..".p64.png")
								local job_id, err = _fetch_remote(get_versioned_cart_url(res[i].id))
							end
						end


					elseif bbs_listing_cache[req] then
						-- fallback to session cache (e.g. went offline after getting listing a long time ago)
						res = bbs_listing_cache[req].response
					end
				end

				if (res) then
					local list = {}
					for i=1,#res do
						add(list, res[i].id..".p64")
					end
					return list
				end
			end

			if (path == "bbs://") then 
				return{
--[[
					-- visual test: with icons. maybe should be allowed to view by .label / .title when it exists
					-- or specify an icon to replace folder icon when available -- looks nice in list mode
					"\^:0000637736080800 new",
					"\^:00081c7f3e362200 featured",
					"\^:001c14363e777f00 wip",
]]
					"new",
					"featured",
					"wip",
--[[
					-- to do: browse these from settings
					-- use tags; one cart could be a screensaver or a live desktop (and possibly adapt itself!)
					"screensavers",
					"desktops",
					"widgets",
					"themes", -- a cart that demos theme? bundle multiple themes? separate podnet files?
]]
					"news.txt", -- test; probably want news.pod or news.p64 if do something like this
				}
			end

			-- page navigation
			if (path == "bbs://new" or path == "bbs://featured" or path == "bbs://wip") then
				local ret = {}
				for i=0,31 do
					add(ret, tostring(i))
				end
				return ret
			end
		
			return {}
		end,
		get_attr = function(path)
			-- to do: check for existence of top-level folder / file
			if not _is_well_formed_bbs_path(path) then 
				-- e.g. lua command from terminal tried as util command first
				return nil 
			end
--[[
			-- experimental: probe for file existence?
			local l = ls(prot_driver["bbs"].get_listing(path:dirname()))
			local found = false
			for i=1,#l do
				if (fullpath(l[i]) == fullpath(path)) found = true
			end
--			if (not found) return nil
]]
			local ext = path:ext()
			if (ext == "p64") return "folder", 0 -- cart subfolder is ignored
			if (not ext)      return "folder", 0 -- bbs://new
			if (ext == "txt") return "file", 0   -- news.txt
			return nil -- file doesn't exist
		end,
		get_file_contents = function(path)
			-- 0.2.1e // don't store in ram
			if (path == "bbs://news.txt") return fetch(get_bbs_host().."/dl/docs/picotron_bbs_news.txt")
		end
	}

	----------------------------------------------------------------------------------------------------------------------------------
	-- path remapping
	--
	-- rule: local functions (_mkdir) take raw paths ("/appdata/bbs/bbs_id/foo") 
	--       global functions (mkdir) take userland paths ("/appdata/foo")
	----------------------------------------------------------------------------------------------------------------------------------

	local function path_is_inside(path, container_path)
		local len = #container_path -- the shorter string
		if (container_path == "*") return true
		if (type(path) ~= "string") return false
		path = path:path() -- strip hash part 
		return path:sub(1,len) == container_path and (#path == len or path[len + 1] == "/")
	end

	
	--[[
		_kernal_to_userland_path  (was "_un_sandbox_path")
		
		convert from proc->pwd to pwd():

			/appdata/bbs/bbs_id/foo         -->   /appdata/foo     (when sandboxed)
			podnet://1/appdata/bbs_id/foo   -->   podnet://1/foo   (when sandboxed ~ to do)
			bbs://new                        -->   bbs://new        (because not mounted by bbs:// driver)
			/ram/bbs/blah.p64.png            -->   bbs://blah.p64   (because mounted by bbs:// driver)

		** uses protocol driver to mount carts on demand
	]]


	local function _kernal_to_userland_path(path)
		if (type(path) ~= "string") return nil

		-- /ram/bbs/foo-0.p64.png/gfx/foo.gfx   -->   bbs://new/3/foo-0.p64/gfx/foo.gfx

		if (path:sub(1,9) == "/ram/bbs/") then -- optimisation; most of the time this is not true
			local sub_path = ""
			local ram_cart_path = path
			local ram_cart_path_pos = string.find(path,".p64.png",1,true)  -- 0.2.0h: need ,1,true to turn off pattern matching. "." is a wildcard.

			if (ram_cart_path_pos) then
				ram_cart_path = path:sub(1, ram_cart_path_pos+7)  --  /ram/bbs/foo.p64.png
				sub_path = path:sub(ram_cart_path_pos+8)      --  /main.lua
				--printh("sub_path: "..tostring(sub_path))
				--printh("_kernal_to_userland_path // path, ram_cart_path_pos, ram_cart_path, sub_path: "..pod{path, ram_cart_path_pos, ram_cart_path, sub_path})
				if (ram_to_prot_path[ram_cart_path]) then
					return strip_anywhen(ram_to_prot_path[ram_cart_path]..sub_path)
				end
			end
		end

		-- needed so that e.g. fullpath("anywhen://...") doesn't resolve back to /bbs/anywhen/...
		-- to do: build into protocol definition?
		if (path:sub(1,13) == "/ram/anywhen/") then
			local sub_path = ""
			local ram_cart_path = path
			local ram_cart_path_pos = string.find(path,".p64",1,true)
			if (ram_cart_path_pos) then
				ram_cart_path = path:sub(1, ram_cart_path_pos+3)  --  /ram/bbs/foo.p64
				sub_path = path:sub(ram_cart_path_pos+4)      --  /main.lua
				
				--printh("_kernal_to_userland_path // path, ram_cart_path_pos, ram_cart_path, sub_path: "..pod{path, ram_cart_path_pos, ram_cart_path, sub_path})
				if (ram_to_prot_path[ram_cart_path]) then
					-- printh("anywhen sub_path: "..tostring(sub_path).." -> "..ram_to_prot_path[ram_cart_path]..sub_path)
					return strip_anywhen(ram_to_prot_path[ram_cart_path]..sub_path)
				end
			end
		end

		-- no local mapping for a protocol path -> return as-is
		if (path:prot(true)) return strip_anywhen(path)

		-- is local filesystem path
		if (not _sandbox) return path
		
		--[[
			-- /appdata mapping only when bbs_id is set
			-- commented; handled by backwards rewrite rules below
			if (path:sub(1,9) == "/appdata/bbs/" and _env().bbs_id)
			then  
				local bbs_id_base = split(_env().bbs_id, "-", false)[1] -- don't include the version
				local cart_dir = "/appdata/bbs/"..bbs_id_base..path:sub(9)
				local cart_dir_len0 = #cart_dir
				local cart_dir_len1 = #cart_dir + 1
				if path:sub(1, cart_dir_len0) == cart_dir and (#path == cart_dir_len0 or path[cart_dir_len1] == "/") then
					return "/appdata"..path:sub(cart_dir_len1)
				end
			end
		]]

		-- un-rewrite :: /appdata/bbs/bbs_id/foo/a.txt -> /appdata/foo/a.txt
		-- target is:    /appdata/bbs/bbs_id
		-- location is:  /appdata

		if (fileview) then
			for i=1,#fileview do
				if fileview[i].target and path_is_inside(path, fileview[i].target) then
					-- printh("reversed rule: "..path.."  -->  "..fileview[i].location..path:sub(#fileview[i].target + 1))
					return fileview[i].location..path:sub(#fileview[i].target + 1)
				end
			end
		end

		-- no rule applies; return as-is
		return path
	end


	--[[
		_userland_to_kernal_path
		
		convert from pwd() to proc->pwd:

			/appdata/foo     -->   /appdata/bbs/bbs_id/foo         (when sandboxed)
			podnet://1/foo   -->   podnet://1/appdata/bbs_id/foo   (when sandboxed ~ to do)
			bbs://new        -->   bbs://new                        (because not mounted by bbs:// driver)
			bbs://blah.p64   -->   /ram/bbs/blah.p64                (because mounted by bbs:// driver)

		** uses protocol driver to mount carts to /ram/mountp/[prot_name]/ on demand

	]]
	local prot_lookups = 0

	local function _userland_to_kernal_path(path_p, mode_p)

		if (type(path_p) ~= "string") return nil
		if (path_p == "") return nil -- don't accept fetch("") etc -- is dangerous

		mode_p = mode_p or "R"

		local path

		if (path_p:prot(true) or path_p[1] == "/") then
			-- absolute path: use as-is
			path = path_p
		else
			-- relative path: prepend (userland) pwd() first and normalise first 
			-- e.g. bbs://new/foo.p64/gfx/.. -> /ram/bbs://new/foo.p64/gfx
			local userland_pwd = _kernal_to_userland_path(_pwd())
			if (userland_pwd[#userland_pwd] == "/") then
				path = userland_pwd..path_p -- at start e.g. "bbs://", don't want extra /
			else
				path = userland_pwd.."/"..path_p
			end
		end

		-- normalise (e.g. collapse /foo/./a/../b ->  /foo/b)
		path = _normalise_userland_path(path)

		-- 0.2.0i: userland paths never need to specify anywhen:// !
		-- just: if they contain a @, then prepend anywhen:// for kernal -- kernal form is always prot://..

		if (string.find(path, "@")) then
			if (not path:prot(true)) path = "anywhen:/"..path
		end

		-- resolved path has protocol when explicitly starts with protocol or is relative to _pwd() that has a protocol
		-- (both cases handled above -- path already has protocol prefix at this point)
		local prot = path:prot(true) -- true for efficiency because kernal path form always prot:// (not anywhen's path@/m/d)

		-- undefined protocol should never resolve to anything
		if (prot and not prot_driver[prot]) return nil

		-- if writin to protol, fail (before resolving to ram path)
		if (mode_p == "W" and prot) return nil

		-------------------------------------------------------------------------------------------------------------
		-- protocol driver can opt to map carts to ram by implementing extract_cart_path() and store_path_in_ram() --
		-------------------------------------------------------------------------------------------------------------

		if prot and prot_driver[prot].extract_cart_path then

			-- 0.2.0i safety: block mount pruning until end of frame (46)
			-- because don't want to e.g. prune /ram/anywhen after call to _userland_to_kernal_path while still using those 
			-- ram files. before blocking, yield with pruning enabled to give a chance to prune (in case many repeated calls
			-- that are generating many ram files).

			prot_lookups += 1
			if (prot_lookups % 64 == 0) then
				_signal(47) -- enable mount pruning
				_yield() -- prune mounts if need every 64 file lookups
			end
			_signal(46) -- block mount pruning; expires at end of frame or after 100ms

			-- 1. driver.extract_cart_path() is used to determined where the cart maps to
			local cart_path, sub_path = prot_driver[prot].extract_cart_path(path)

			if (cart_path) then
				
				-- 2. driver.store_path_in_ram() is used to populate that ram path (e.g. by downloading a cart)
				-- store_path_in_ram() can return nil when shouldn't store (e.g. bbs://new)
				if (not prot_to_ram_path[cart_path]) then
					local fn = prot_driver[prot].store_path_in_ram(cart_path)
					if (fn) then
						--printh("@@ stored prot_to_ram_path["..cart_path.."] = "..fn.."  // path: "..path)
						prot_to_ram_path[cart_path] = fn
						ram_to_prot_path[fn] = cart_path
					else
						-- printh("@@ failed to store "..cart_path.."  // src: "..path)
					end
				end
			
				-- 3. kernel path resolves to that ram location, so can use fetch / fstat / ls transparently from userland 
				if prot_to_ram_path[cart_path] then
					local ram_path = prot_to_ram_path[cart_path]..sub_path
					--printh("@ resolved "..path.." to "..ram_path)
					return ram_path
				end
			end

			return path -- could not resolve; return as-is (and let the protocol driver deal with it)
			
		end

		-------------------------------------------------------------------------------------------------------------

		-- no protocol

		path = _fullpath(path) -- raw fullpath; handles relative paths + pwd
		if (type(path) ~= "string") return nil -- couldn't resolve, or nil to start with

		-------------------------------------------------------------------------------------------------------------
		-- apply access rules

		-- no protocol: return path as-is when not sandboxed
		-- (implicit rule: * RW)
		if (not _sandbox) return path

		----> sandboxed <----

		-- sandboxed processes can not read anywhen:// (or write ~ already blocked above)
		if (prot == "anywhen") return nil

		-- otherwise can only access certain locations
		-- to do: could pregenerate lists according to matching mode, but perf shouldn't be an issue here

		if (fileview) then -- safety; should always exist
			for i=1,#fileview do
				local rule = fileview[i]
				if (rule.mode == "RW" or (mode_p == "R" and rule.mode == "R") or (mode_p == "X" and rule.mode == "X")) then
					if path_is_inside(path, rule.location) then
						if (rule.target) then
							-- allow but rewrite
							--printh("allowing: "..path.."   -->   "..rule.target..path:sub(#rule.location+1))

							-- create target on demand; most bbs carts don't ever write anything, and don't want folderjunk 
							--printh("creating bbs appdata folder; path: "..path)
							_mkdir(rule.target)

							return rule.target..path:sub(#rule.location+1) -- "/appdata/bbs/bbs_id".."/foo.txt"
						else
							--printh("allowing: "..path)
							return path -- allow
						end
					end
				end
			end
		end

		-- anything else not allowed

		-- printh("no access from sandbox: "..path.." // mode: "..mode_p)

		return nil
	end


	-- sandboxed versions of some files
	-- to do: /ram/system/process/n.pod for a particular process
	local function _fetch_partial(path)

		if (path == "/ram/system/processes.pod") then

			local p = _get_process_list()
			local out = {}
			for i=1,#p do
				-- sandboxed cart can see: system processes, instances of self, direct children
				if (p[i].id <= 3 or 
					p[i].prog:sub(1,8) == "/system/" or
					p[i].prog == env().argv[0] or p[i].parent_id == _pid()) then
					add(out, p[i])
				else
					add(out, {
						id = 0,
						name = "[hidden]",
						prog = "[hidden]",
						cpu = 0,
						memory = 0,
						priority = 0,
						pwd = ""
					})
				end
			end
			
			return out
		end

		return nil
	end



	--------------------------------------------------------------------------------------------------------------------------------

		-- generate metadata string in plain text pod format
	local function _generate_meta_str(meta_p)

		-- use a copy so that can remove pod_format without sideffect
		local meta = unpod(pod(meta_p)) or {}

		local meta_str = "--[["

		if (meta.pod_format and type(meta.pod_format) == "string") then
			meta_str ..= "pod_format=\""..meta.pod_format.."\""
			meta.pod_format = nil -- don't write twice
		elseif (meta.pod_type and type(meta.pod_type) == "string") then
			meta_str ..= "pod_type=\""..meta.pod_type.."\""
			meta.pod_type = nil -- don't write twice
		else
			meta_str ..= "pod"
		end

		local meta_str1 = _pod(meta, 0x0) -- 0x0: metadata always plain text. want to read it!

		if (meta_str1 and #meta_str1 > 2) then
			meta_str1 = sub(meta_str1, 2, #meta_str1-1) -- remove {}
			meta_str ..= ","
			meta_str ..= meta_str1
		end

		meta_str..="]]"

		return meta_str

	end


	function pod(obj, flags, meta)

		-- safety: fail if there are multiple references to the same table
		-- to do: allow this but write a reference marker in C code? maybe don't need to support that!
		local encountered = {}
		local function check(n)
			local res = false
			if (encountered[n]) return true
			encountered[n] = true
			for k,v in pairs(n) do
				if (type(v) == "table") res = res or check(v)
			end
			return res
		end
		if (type(obj) == "table" and check(obj)) then
			-- table is not a tree
			return nil, "error: multiple references to same table"
		end

		if (meta) then
			local meta_str = _generate_meta_str(meta)
			return _pod(obj, flags, meta_str) -- new meaning of 3rd parameter!
		end

		return _pod(obj, flags)
	end

	

	local function _fix_metadata_dates(meta)
		
		-- time string generation bug that happened 2023-10! (to do: fix files in /system)
		if (type(meta.modified) == "string" and tonumber(meta.modified:sub(6,7)) > 12) then
			meta.modified = meta.modified:sub(1,5).."10"..meta.modified:sub(8)
		end
		if (type(meta.created) == "string" and tonumber(meta.created:sub(6,7)) > 12) then
			meta.created = meta.created:sub(1,5).."10"..meta.created:sub(8)
		end

		-- use legacy value .stored if .modified was not set
		if (not meta.modified) meta.modified = meta.stored

	end

	local function _fix_legacy_metadata(meta)
		if (not meta) return

		_fix_metadata_dates(meta)
		
		-- cartridge icons before 0.2.0c that don't have any colourful pixels set should be treaded as low-colour
		-- same for non-cartridges (no .runtime) when modified before 0.2.0c came out
		-- i.e. always apply theme even when not settings.lowcol_icons
		if (type(meta.icon) == "userdata") then
			if (meta.runtime and meta.runtime < 17) or (not meta.runtime and meta.modified and meta.modified:sub(1, 10) < "2025-03-26")then
				meta.lowcol_icon = true
				local themecols = {[0]=true,[1]=true,[13]=true,[6]=true,[7]=true}
				for i=0,255 do
					if (not themecols[meta.icon[i]]) meta.lowcol_icon = nil -- has a colourful colour
				end
			end
		end
	end

	local function _fetch_metadata(filename)
		local result = _fetch_metadata_from_file(_fstat(filename) == "folder" and filename.."/.info.pod" or filename)
		_fix_legacy_metadata(result)
		return result
	end

	function fetch_metadata(filename_p)
		if (type(filename_p) ~= "string") return nil
		local filename = _userland_to_kernal_path(filename_p)

		if (not filename) then
			-- try directly from .info.pod (perhaps /desktop is not allowed in sandbox, but /desktop/.info.pod is)
			filename = _userland_to_kernal_path(filename_p.."/.info.pod", "X")
			if (filename) then
				local res  = _fetch_metadata_from_file(filename)
				if (not _sandbox) return res -- not sandboxed; return 
				-- otherwise: censor! only return positions, no file names (used by e.g. bbs://desktop_pet.p64)
				local res2 = {file_item={}}
				if (res.file_item) then
					local index = 0
					for k,v in pairs(res.file_item) do
						res2.file_item["file_"..index] = { x = v.x, y = v.y }
						index += 1
					end
				end
				return res2
			end
			return nil
		end

		--printh("fetch_metadata kernal_path: "..filename)
		return _fetch_metadata(filename)
	end



	-- fetch and store can be passed locations instead of filenames
	-- return obj, metadata, err_str
	local fetch_job = nil
	function fetch(location, options)

		if (type(location) != "string") return nil, nil, "location is not a string"

		if (type(options) ~= "table") options = {}

		local filename, hash_part = table.unpack(_split(location, "#", false))
		local prot = location:prot(true)

		-- to do: move http handling into drive (same pattern as anywhen)
		if (prot == "https" or prot == "http") then
			--[[
				remote fetches are logically the same as local ones -- they block the thread
				but.. can be put into a coroutine and polled
			]]

			-- _printh("[fetch] calling _fetch_remote: "..filename)
			local job_id, err = _fetch_remote(filename)
			-- _printh("[fetch] job id: "..job_id)

			if (err) return nil, nil, err

			if type(options.on_complete) == "function" then

				if (not fetch_job) then
					fetch_job = {}
					on_event("update", function(msg)
						for i=#fetch_job,1,-1 do
							local result, meta, err = _fetch_remote_result(fetch_job[i].job_id)
							if (result or err) then
								fetch_job[i].on_complete(result, meta, err)
								fetch_job[i] = nil
							end
						end
					end)
				end

				options.job_id = job_id
				options.location = location
				add(fetch_job, options)
				return nil, nil, "in progress"
			end

			local tt = time()

			while time() < tt + 10 do -- to do: configurable timeout.

				-- _printh("[fetch] about to fetch result for job id "..job_id)

				local result, meta, err = _fetch_remote_result(job_id)

				-- _printh("[fetch] result: "..type(result))

				if (result or err) then
					-- _printh("[fetch remote] err: "..pod(err))
					return result, meta, err
				end

--				flip(0x1)
--				_yield()  -- 0.2.0e: yield is sufficient
				-- 0.2.0i: superyield; want to behave the same when called from inside coroutine
				-- can now use fetch("https://example.com", on_complete = function(obj, metadata, err_str) ... end)
				flip(0x1)

			end
			return nil, nil, "timeout"

		else
			-- local file (update: or generic protocol)
			kpath = _userland_to_kernal_path(filename)

			-- if kpath resolves to a protocol path, use get_file_contents when defined by driver
			-- to do: http should implement get_file_contents callback
			if (kpath and kpath:prot()) then
				prot = kpath:prot()
				if (prot_driver[prot].get_file_contents) then
					return prot_driver[prot].get_file_contents(kpath)
				end
				return nil, nil, "could not access"
			end

			if (not kpath) then
				-- try again with partial view of file (processes.pod)
				kpath = _userland_to_kernal_path(filename, "X")
				if (kpath) return _fetch_partial(kpath)
			end

			if (not kpath) return nil, nil, "could not access path"

			local flags = 0
			if (options.argb) flags |= 0x1
			if (options.raw_str) flags |= 0x2
			local ret, meta = _fetch_local(kpath, flags)
			_fix_legacy_metadata(meta)

			return ret, meta -- no error
		end
	end

	_fetch_userland = fetch

	
	--[[
		mkdir()
		returns string on error
	]]
	function mkdir(p)
		p = _userland_to_kernal_path(p, "W")
		if (not p) return "could not access path"

		if (p:prot()) return -- protocols don't support mkdir / writes yet

		if (_fstat(p)) return -- is already a file or directory

		-- create new folder
		local ret = _mkdir(p)

		-- couldn't create
		if (ret) return ret

		-- can store starting metadata to file directly because no existing fields to preserve
		-- // 0.1.0f: replaced "stored" with modified; not useful as a separate concept
		_store_metadata_str_to_file(p.."/.info.pod", _generate_meta_str{created = date(), modified = date()})
	end


	-- to do: errors
	function store(location, obj, meta)

		if (type(location) != "string") return nil

		-- currently no writeable protocols
		if (location:prot()) then
			return "can not write "..location
		end

		location = _userland_to_kernal_path(location, "W")

		if (not location) return "could not store to path"

		-- special case: can write raw .p64 / .p64.rom / .p64.png binary data out to host file without mounting it
		local ext = location:ext()

		if (type(obj) == "string" and ext and ext:is_cart()) then
			_signal(40)
				_rm(location:path()) -- unmount existing cartridge // to do: be more efficient
			_signal(41)
			return _store_local(location, obj)
		end

		-- ignore location string
		local filename = _split(location, "#", false)[1]
		
		-- grab old metadata
		local old_meta = _fetch_metadata(filename)
		
		if (type(old_meta) == "table") then
			if (type(meta) == "table") then			
				-- merge with existing metadata.   // to do: how to remove an item?			
				for k,v in pairs(meta) do
					old_meta[k] = v
				end
			end
			meta = old_meta
		end

		if (type(meta) != "table") meta = {}
		if (not meta.created) meta.created = date()
		if (not meta.revision or type(meta.revision) ~= "number") meta.revision = -1
		meta.revision += 1   -- starts at 0
		meta.modified = date()


		-- 0.1.1e: store "prog" when is bbs:// -- the program that was used to create the file can be used to open it again
		if (_env().argv[0]:prot(true) == "bbs") then
			meta.prog = _env().argv[0]
		end

		-- use pod_format=="raw" if is just a string
		-- (_store_local()  will see this and use the host-friendly file format)

		if (type(obj) == "string") then
			meta.pod_format = "raw"
		else
			-- default pod format otherwise
			-- (remove pod_format="raw", otherwise the pod data will be read in as a string!)
			meta.pod_format = nil 
		end


		local err_str = _store_local(filename, obj, _generate_meta_str(meta))

		-- notify program manager (handles subscribers to file changes)
		if (not err_str) then
			_send_message(2, {
				event = "_file_stored",
				filename = _fullpath(filename), -- pm expects raw path
				proc_id = pid()
			})
		end

		-- nil if no error
		return err_str

	end
	_store_userland = store


	local function _store_metadata(filename, meta)

		local old_meta = _fetch_metadata(filename)
		
		if (type(old_meta) == "table") then
			if (type(meta) == "table") then			
				-- merge with existing metadata.   // to do: how to remove an item? maybe can't! just recreate from scratch if really needed.
				for k,v in pairs(meta) do
					old_meta[k] = v
				end
			end
			meta = old_meta
		end

		if (type(meta) != "table") meta = {}
		meta.modified = date() -- 0.1.0f: was ".stored", but nicer just to have a single, more general "file was modified" value.


		local meta_str = _generate_meta_str(meta)

		if (_fstat(filename) == "folder") then
			-- directory: write the .info.pod
			_store_metadata_str_to_file(filename.."/.info.pod", meta_str)
		else
			-- file: modify the metadata fork
			_store_metadata_str_to_file(filename, meta_str)
		end
	end

	function store_metadata(filename, meta)
		return _store_metadata(_userland_to_kernal_path(filename, "W"), meta)
	end


	_rm = function(f0, flags, depth)

		flags = flags or 0x0
		depth = depth or 0

		local attribs, size, origin = _fstat(f0)

		if (not attribs) then
			-- does not exist
			return
		end

		if (attribs == "folder") then

			-- folder: first delete each entry using this function
			-- dont recurse into origin! (0.1.0h: unless it is cartridge contents)
			-- e.g. rm /desktop/host will just unmount that host folder, not delete its contents
			if (not origin or (origin:sub(1,11) == "/ram/mount/")) then 
				local l = ls(f0)
				if (type(l) == "table") then
					for k,fn in pairs(l) do
						_rm(f0.."/"..fn, flags, depth+1)
					end
				end
			end
			-- remove metadata (not listed)
			_rm(f0.."/.info.pod", flags, depth+1)

			-- flag 0x1: remove everything except the folder itself (used by cp when copying folder -> folder)
			-- for two reasons:

			-- leave top level folder empty but stripped of metadata; used by cp to preserve .p64 that are folders on host
			if (flags & 0x1 > 0 and depth == 0) then
				return
			end

		end


		-- delete single file / now-empty folder
		
		-- _printh("_fdelete: "..f0)
		return _fdelete(f0)
	end

	function rm(f0)
		local f1 = _userland_to_kernal_path(f0, "W")
		if (not f1) return "could not resolve"
		if (f1:prot()) return "can not modify "..f1:prot() -- protocols don't support writing yet 

		-- 0.2.1e: deleting /ram/mount* is dangerous -- contents of mounted carts deleted and flushed to origin
		if (f1 == "/ram") return "can not delete ram"
		if (f1 == "/ram/mount") return "can not modify ram/mount"
		if (f1:sub(1,11) == "/ram/mount/") return "can not modify ram/mount"

		_signal(40)
			local ret = _rm(f1, 0, 0) -- atomic operation
		_signal(41)
		return ret
	end


	--[[	
		internal; f0, f1 are raw (kernal) paths 

		handles anywhen:// and bbs:// by using userland functions
		(when kernal path has protocol, always same as canonical userland path)

		if dest (f1) exists, is deleted!  (cp util / filenav copy operations can do safety)
	]]
	function _cp(f0, f1, moving, depth, bbs_id)

		depth = depth or 0
		f0 = _fullpath(f0)
		f1 = _fullpath(f1)

		if (not f0)   return "could not resolve source path"
		if (not f1)   return "could not resolve destination path"
		if (f0 == f1) return "can not copy over self"

		local f0_prot = f0:prot()

		local f0_type = f0_prot and fstat(f0) or _fstat(f0) -- need to use userland function for protocol source path (e.g. copy from anywhen)
		local f1_type = _fstat(f1)

		if (not f0_type) then
			--print(tostring(f0).." does not exist") 
			return "could not read source location"
		end

		-- explicitly delete in case is a folder -- want to make sure contents are removed
		-- to do: should be an internal detail of delete_path()?
		-- 0.1.0e: 0x1 to keep dest as a folder when copying a folder over a folder
		-- (e.g. dest.p64/ is a folder on host; preferable to keep it that way for some workflows)
		if (f1_type == "folder" and depth == 0) _rm(f1, f0_type == "folder" and 0x1 or 0x0) 

		-- folder: recurse
		if (f0_type == "folder") then

			-- 0.1.0c: can not copy inside itself   "cp /ram/cart /ram/cart/foo" or "cp /ram/cart/foo /ram/cart" 
			-- 0.1.1:  but cp foo foo2/ is ok (or cp foo2 foo/)
			local minlen = min(#f0, #f1)
			if (sub(f1, 1, minlen) == sub(f0, 1, minlen) and (f0[minlen+1] == "/" or f1[minlen+1] == "/")) then
				return "can not copy inside self" -- 2 different meanings!
			end
			-- 0.1.1e: special case for /  --  is technically also "can not copy inside self", but might as well be more specific
			if (f0 == "/" or f1 == "/") then
				return "can not copy /"
			end

			-- get a cleared out root folder with empty metadata
			-- (this allows host folders to stay as folders even when named with .p64 extension -- some people use that workflow)
			_mkdir(f1)

			-- copy each item (could also be a folder)

			local l = (f0_prot and ls or _ls)(f0)
			for k,fn in pairs(l) do
				local res = _cp(f0.."/"..fn, f1.."/"..fn, moving, depth+1)
				if (res) return res
			end

			-- copy metadata over if it exists (ls does not return dotfiles)
			-- 0.1.0f: also set initial modified / created values 

			local meta = (f0_prot and fetch_metadata or _fetch_metadata)(f0) or {}

			-- also set date [and created when not being used by mv())
			meta.modified = date()
			if (not moving) meta.created = meta.created or meta.modified -- don't want to clobber .created when moving

			-- when copying / moving from bbs:// -> local, carry over bbs_id and sandbox. copy over existing values! (in particular, dev bbs_id)
			if (bbs_id) then
				-- printh("@@ carrying over bbs_id as metadata"..bbs_id)
				meta.bbs_id = bbs_id
				meta.sandbox = "bbs"
			end

			-- store it back at target location. can just store file directly because no existing fields to preserve
			_store_metadata_str_to_file(f1.."/.info.pod", _generate_meta_str(meta))

			return
		end

		-- copy a single file

		if (f0_prot) then
			-- from a protocol: need to do a userland fetch and store
			local obj, meta = _fetch_userland(f0)
			_store_userland(f1, obj, meta)
		else
			-- local -> local: can do a raw binary copy
			_fcopy(f0, f1)
		end

		-- 0.2.1c notify program manager (handles subscribers to file changes)
		if (true) then -- to do: check file could actually be stored
			_send_message(2, {
				event = "_file_stored",
				filename = f1, -- is already kernal fullpath like pm expects
				proc_id = pid()
			})
		end

	end

	--[[
		mv(src, dest)

		to do: rename / relocate using host operations if possible

		to do: currently moving a mount copies it into a regular file and removes the mount;
			-> should be possible to rename/move mounts around?
	]]
	function mv(src_p, dest_p)

		-- special case: moving a file from (read-only) protocol; treat as a copy (e.g. drag and drop from bbs)
		-- cp() handles that case
		if (src_p:prot()) return cp(src_p, dest_p)

		local src  = _userland_to_kernal_path(src_p, "W") 
		local dest = _userland_to_kernal_path(dest_p, "W")
		if (not src) return "could not resolve source path"
		if (not dest) return "could not resolve destination path"
		if (dest:prot()) return "can not write to "..dest:prot().."://" -- protocols don't support writing yet 

		-- skip mv if src and dest are the same (is a NOP but not an error. to do: should it be?)
		if (_fullpath(src) == _fullpath(dest)) return

		-- special case: when copying from bbs://, retain .bbs_id .sandbox as metadata
		local bbs_id = (src_p:prot(true) == "bbs" and src_p:ext() == "p64") and src_p:basename():sub(1,-5) or nil

		_signal(40) -- 0.1.1e compound op lock (prevent flushing cart halfway through moving)
			local res = _cp(src, dest, true, nil, bbs_id) -- atomic operation
		_signal(41)
		if (res) return res -- copy failed

		-- copy completed -- safe to delete src
		_signal(40)
			_rm(src)
		_signal(41)
	end

	function cp(src_p, dest_p)
		local src  = _userland_to_kernal_path(src_p)
		local dest = _userland_to_kernal_path(dest_p, "W")
		if (not src) return "could not resolve source path"
		if (not dest) return "could not resolve destination path"
		if (dest:prot()) return "can not write to "..dest:prot().."://" -- protocols don't support writing yet 

		-- special case: copying a file from protocol; read file via userdata fetch / store (avoid duplicated logic)
		-- happens when source is an anywhen file (so not mounted inside /ram/anywhen) // cp("anywhen://...","1.txt")
		if (src_p:prot() and fstat(src_p) == "file") then
			local dat,meta = _fetch_userland(src_p)
			_store_userland(dest_p, dat, meta)
		end

		-- special case: when copying from bbs://, retain .bbs_id .sandbox as metadata
		local bbs_id = (src_p:prot(true) == "bbs" and src_p:ext() == "p64") and src_p:basename():sub(1,-5) or nil

		_signal(40) -- 0.1.1e: lock flushing for compound operation; don't want to e.g. store a cart on host that is halfway through being copied
			local ret0, ret1 = _cp(src, dest, nil, nil, bbs_id) -- atomic operation   (to do: remove ret1; never used?)
		_signal(41) -- unlock 
		return ret0, ret1
	end

	-- 

	--[[
		ls
		note: ls("not_in_sandbox") returns nil, even if there subdirectories accessible to the sandbox
		--> ls("/") does not list ("/appdata")
	]]
	function ls(p)
		p = p or _pwd()

		kernal_path = _userland_to_kernal_path(p)
		if (not kernal_path) return nil -- not allowed to list if couldn't sandbox / resolve

		-- protocol listing
		local prot = kernal_path:prot()
		if (prot) return prot_driver[prot].get_listing(kernal_path) or {}

		-- local listing
		return _ls(kernal_path)
	end

	function cd(p)
		if (type(p) ~= "string") return nil
		kernal_path = _userland_to_kernal_path(p)

		if (not kernal_path) return nil -- means local path doesn't exist

		-- protocol path
		local prot = kernal_path:prot()
		if (prot) return _cd(kernal_path, true) -- to do: use protocol get_attr first to check it is a folder

		-- local
		return _cd(kernal_path)
	end

	function pwd()
		return _kernal_to_userland_path(_pwd())
	end

	function fullpath(p)
		local kernal_path = _userland_to_kernal_path(p)
		if (not kernal_path) return nil

		-- resolve to protocol location -> no further indirection
		if (kernal_path:prot(true)) then
			return strip_anywhen(kernal_path)
		end

		-- otherwise now have a path on local filesystem or /ram; can convert back after applying _fullpath	
--[[
		if (p:prot()) then
			printh("_fullpath(kernal_path): ".._fullpath(kernal_path))
		end
]]
		return _kernal_to_userland_path(_fullpath(kernal_path))
	end

	function mount(a, b)
		if (_sandbox) return nil -- can't mount anything when sandboxed (or read mount descriptions) 
		if (a:prot() or b:prot()) return nil -- can't mount protocols [yet]
		return _mount(a, b)
	end

	function fstat(p)

		local kernal_path = _userland_to_kernal_path(p)

		if (not kernal_path) return nil
		
		-- protocol path attributes
		local prot = kernal_path:prot(true)
		if (prot) then -- mean protocol exists because otherwise _userland_to_kernal_path returns nil
			-- printh("reading protocol path attributes: "..kernal_path)
			local kind, size = prot_driver[prot].get_attr(kernal_path)
			return kind, size
		end
		
		-- otherwise now have a path on local filesystem (including /ram), can use _fstat
		
		if (_sandbox) then	
			local kind, size = _fstat(kernal_path)
			return kind, size -- don't expose mount description when sandboxed
		end

		return _fstat(kernal_path) -- includes mount description
	end
	_fstat_userland = fstat

	-- system apps (filenav) can request access to particular files
	on_event("extend_fileview", function(msg)
		-- printh("requesting file access via extend_fileview: "..pod(msg))
		if (msg._flags and (msg._flags & 0x1) > 0) then  --  requesting process is a trusted system app (filenav)
			if type(msg.filename) == "string" then
				add(fileview, {
					location = msg.filename:path(), -- 0.2.0e: only want path part for applying rules
					mode = "RW"
				})
			end
		end
	end)

	-- grant access to dropped files

	on_event("drop_items", function(msg)
		if (msg._flags and (msg._flags & 0x1) > 0) then  --  requesting process is a trusted system app (window manager)
			for i=1,#msg.items do
				-- printh("granting file access via dropped item: "..msg.items[i].fullpath)
				if type(msg.items[i].fullpath) == "string" then
					add(fileview, {
						location = msg.items[i].fullpath:path(), -- 0.2.0e: only want path part for applying rules
						mode = "RW"
					}, 1) -- insert at start so that mapping don't interfere. e.g. drop from /appdata/anotherapp
				end
			end
		end
	end)

	_export_functions_to_head{
		fetch = fetch,
		fullpath = fullpath,

		-- the following are not used by head; deleteme
		fetch_metadata = fetch_metadata,		
		store_metadata = store_metadata,
		store = store,
		pwd = pwd,
		fstat = fstat
	}

end

:: bios/lib/gui.lua
--[[pod_format="raw",created="2025-03-28 22:10:21",modified="2025-03-28 22:10:21",revision=0]]
--[[

	gui.lua

	standard gui library
	// "standard" means included by head.lua

	super-minimal -- similar to codo gui.  ** well-defined and freeze early

	goal: scrollbox full of buttons and input boxes
	-> need attributes like clip_to_parent clip_to_self
		// or perhaps: stack of draw states? push_draw_state(). and/or push_clip()
		// needs to also apply when determining pointer element though. overcomplicated.
		// update: not that complicated! implemented in playground 10

	events:
		click, doubleclick, drag, release
		tap // on release when mouse hasn't moved
		mousewheel

]]


do
	local GuiElement={} -- helper class; never used externally

	local next_id = 0

	-- 0.1.1e: moved here so can be used by helper class
	-- 0.1.1f: only used for constructing msg tbl in helper
	-- grabbed once per frame at start of update_all (once for each gui, but is harmless)
	local global_mx, global_my, global_mb = 0,0,0
	
	-- 0.1.1e a dummy draw function always exists; simplifies clipping / hiding logic
	function GuiElement:draw() end


	function GuiElement:new(el)
		el = el or {}
		setmetatable(el, self)
		self.__index = self

		-- test: deleteme
		--if (not el.draw) el.draw = function() end

		-- el.debug_id = next_id -- for debugging
		next_id = next_id + 1

		-- time of creation
		-- sometimes don't want to interact with newly created elements
		el.t0 = time()

		-- commented: too confusing to have a default position / size when accidentally not specified on creation 
		-- to do: only useful if make crashes inside gui.lua more readable though!
--[[
		el.x = el.x or 43
		el.y = el.y or 43
		el.width = el.width or 43
		el.height = el.height or 43
]]

		el.z  = el.z or 0
		el.sx = el.x or 0 -- will be calculated on update
		el.sy = el.y or 0

		if (el.clip_to_parent == nil) then
			el.clip_to_parent = true
		end

		-- to do: update when used with relative sizes
		el.width0  = el.width
		el.height0 = el.height

		el.child = el.child or {}

		return el
	end

	-- child can be null to create new element
	function GuiElement:attach(child)
		child = child or {}		
		child = GuiElement:new(child)
		child.parent = self
		child.head = self.head or self -- also updated in update_absolute_position (ref: wm manually reattaches subtrees, messing up head)

		-- calculate relative size immediately -- might be used while calculating other elements
		if (child.width_rel)  child.width  = self.width  * child.width_rel  + (child.width_add  and child.width_add  or 0) 
		if (child.height_rel) child.height = self.height * child.height_rel + (child.height_add and child.height_add or 0)

		return add(self.child, child)

	end

	function GuiElement:has_keyboard_focus()
		return self.head.keyboard_focus_el == self and (peek(0x547f) & 0x10) > 0 -- 0.2.0h: process window needs to also have focus
	end

	function GuiElement:set_keyboard_focus(val)
		-- to do: assert(typeof(this)=="table");   might accidentally self.set_keyboard_focus() instead of self:set_keyboard_focus()
		if (val == true) then
			self.head.keyboard_focus_el = self
		elseif (self.head.keyboard_focus_el == self) then
			-- only set to nil if was this element (don't clobber a different element's focus)
			self.head.keyboard_focus_el = nil
		end

	end


	--[[

		g = create_gui()
		p = g:attach_pulldown({x = ..})
		p:attach_pulldown_item("Hey", func)

	]]
	function GuiElement:attach_pulldown(el)

		local p = self:attach(el)

		function p:draw(ev)

			local flat_top = false -- when false, can generalise to dismissable dialogue. probably too leaky though.
			local x0 = 1
			local y0 = flat_top and -1 or 1
			local x1 = self.width-2
			local y1 = self.height-2
			
			rectfill(x0,y0, x1,y1, 7)

			local border_col = 1
			
			line(x0+1, y1+1, x1-1, y1+1, border_col)
			line(x0-1, y0+1, x0-1, y1-1, border_col)
			line(x1+1, y0+1, x1+1, y1-1, border_col)
			if (not flat_top) then
				-- top border and corners
				line(x0+1, y0-1, x1-1, y0-1, border_col)
				pset(x0,y0,border_col)
				pset(x1,y0,border_col)
			end
			-- bottom corners
			pset(x0,y1,border_col)
			pset(x1,y1,border_col)

		end

		-- no items yet
		p.item_y = 4
		p.item_h = 12
		p.height = 10 -- extra 2px at the bottom feels better

		return p
	end

	function GuiElement:attach_pulldown_item(el)

		-- deleteme
		-- 0.1.1e: commented; (see https://www.lexaloffle.com/bbs/?tid=145205 "attach_pulldown_item's loss of event handlers")
		-- was there a reason to make a copy rather than reuse el (like the rest of the gui library)? seems not.
		-- local item = unpod(pod(el)) -- copy attributes

		local item = el or {}
		
		-- need to copy function separately
		item.action     = el.action

		-- default attrib values
		item.label      = item.label or "???"
		item.x          = item.x or 1
		item.y          = item.y or self.item_y
		item.width      = item.width or self.width-2  -- (-2 to fit inside 1px black border)
		item.height     = item.height or self.item_h


		item.draw = function(self, ev)
			if (ev.has_pointer and not self.divider) rectfill(0,0,self.width-1, self.height-1, 13)
			if (self.divider) then
				line(4,4, self.width-5, 4, 6)
			else
				local xx = 6
				local yy = 3
				if (self.icon) then
					pal(7,1)
					spr(self.icon, xx, 3)
					pal(7,7) -- hrrrm
					xx += 14
				end

				print(self.label, xx, yy, 1)

				if (self.shortcut) then
					local ww = print(self.shortcut, 0,-1000)
					-- to do: adapt greyed out colour (make pulldown themeable)
					print("\f6"..self.shortcut, self.width - ww - 6, yy)
				end
			end
		end
		
		-- run and close
		item.tap = function(self)
			if (self.action) then
				self.action()
				if not self.stay_open then
					if (self.onclose) then self.onclose() end -- to do: deleteme (not needed?)
					if (self.parent.onclose) then self.parent.onclose() end
					del(self.parent.parent.child, self.parent) -- close pulldown
				end
			end
			return true
		end

		-- don't propagate clicks -- will e.g. cause app menu modal to always be dismissed
		item.click = function(self)
			return true		
		end

		local item_h = self.item_h
		if (el.divider) item_h -= 4 -- line break is shorter
		self.item_y += item_h
		self.height += item_h
		self.height0 = self.height

		return self:attach(item)
	end

	--[[
		attach_field  //  ** placeholder

		needs a get() and set() callback

		** maybe fields are always too specialised; leave up to client
		   but nice to have a drop-in starting point if can make it general enough
	]]
	function GuiElement:attach_field(el)
		local el = self:attach(el)

		function el:draw()
			local str = type(self.get == "function") and self:get() or "---"
			if (self:has_keyboard_focus()) str = self.str
			if (self.print_prefix) str = self.print_prefix..str
			local ww,hh = print(str,0,-1000)
			rectfill(0,0,self.width-1,self.height-1, self:has_keyboard_focus() and 8 or 0)			
			print(str,self.width-ww-1,1,6)
			if (self.label) then
				clip()
				local ww = print(self.label,0,-1000)
				print(self.label, -ww, 1, 13)
			end
		end

		function el:click()
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = "" -- starting editing new string
		end


		function el:update()
			if (self:has_keyboard_focus()) then

				while (peektext()) do
					self.str = self.str .. readtext()
				end

				if (keyp("backspace")) self.str = sub(self.str,1,-2)

				if (keyp("enter")) then
					if (type(self.set) == "function") self:set(self.str)
					self:set_keyboard_focus(false)
				end

			end
		end


		return el
	end


	--[[
		attach_scrollbars() // to do: horizontal bar (or generalise to 2d)

		assume that self is a container element, where 
			child[1] is the element to be scrolled
			child[2] is the scrollbar

		example:

		g = create_gui()
		my_container = g:attach(my_container_attribs)
		my_container:attach(my_contents)
		my_container:attach_scrollbars()

		to allow mousewheel scrolling, still need to process messages from contents:

			function contents:mousewheel(msg)
				self.y += msg.wheel_y * 32 -- scroll speed is arbitrary
			end

			** to do: mousewheel event should propagate up to parent though (if not defined)
	]]

	function GuiElement:attach_scrollbars(attribs)

		--if no children, attach to parent! to do: standardise
		local container = self

		local bar_w = 8

		local attribs = attribs or {} 

		-- pick out only attributes relevant to scrollbar (autohide)
		-- caller could adjust them after though -- to do: perhaps should just spill everything in attribs as starting values
		local scrollbar = {
			x = 0, justify = "right",
			y = 0,
			width = bar_w,
			height = container.height,
			height_rel = 1.0,
			autohide = attribs.autohide,
			bar_y = 0,
			bar_h = 0,
			cursor = "grab",

			update = function(self, msg)
				local container = self.parent
				local contents  = container.child[1]
				local h0 = self.height
				local h1 = contents.height
				local bar_h = max(9, h0 / h1 * h0)\1  -- bar height; minimum 9 pixels
				local emp_h = h0 - bar_h - 1          -- empty height (-1 for 1px boundary at bottom)
				local max_y = max(0, contents.height - container.height)

				self.scroll_spd = max_y / emp_h
				if (max_y > 0) then
					self.bar_y = flr(- emp_h * contents.y / max_y)
					self.bar_h = bar_h
				else
					self.bar_y = 0
					self.bar_h = 0
				end

				if (self.autohide) then
					self.hidden = contents.height <= container.height
				end

				-- hack: match update height same frame 
				-- otherwise /almost/ works because gets squashed by virtue of height being relative to container, but a frame behind
				-- (doesn't work in some cases! to do: nicer way to solve this?)
				-- self.squash_to_clip = container.squash_to_clip 

				-- 0.1.1e: always clamp
				contents.x = mid(0, contents.x, container.width  - contents.width)
				contents.y = mid(0, contents.y, container.height - contents.height)

			end,
			
			draw = function(self, msg)
				local bgcol = 13
				local fgcol = 6

				rectfill(0, 0, self.width-1, self.height-1, bgcol | (fgcol << 8))
				if (self.bar_h > 0) rrectfill(1, self.bar_y+1, self.width-2, self.bar_h-1, 1, fgcol)

				-- lil grip thing; same colour as background
				local yy = self.bar_y + self.bar_h/2
				line(2, yy-1, self.width-3, yy-1, bgcol)
				line(2, yy+1, self.width-3, yy+1, bgcol)

			end,
			drag = function(self, msg)
				local content = self.parent.child[1]
				content.y -= msg.dy * self.scroll_spd
				-- clamp
				content.y = mid(0, content.y, -max(0, content.height - container.height))

			end,
			click = function(self, msg)
				local content = self.parent.child[1]
				
				-- click above / below to pageup / pagedown
				if (msg.my < self.bar_y) content.y += self.parent.height
				if (msg.my > self.bar_y + self.bar_h) content.y -= self.parent.height
			end
		}

		-- standard mousewheel support when attach scroll bar
		-- speed: 32 pixels // to do: maybe should be a system setting?
		function container:mousewheel(msg)
			local content = self.child[1]
			if (not content) return

			local old_x = content.x
			local old_y = content.y

			if (key("ctrl")) then
				content.x += msg.wheel_y * 32 
			else
				content.y += msg.wheel_y * 32 
			end

			-- clamp
			content.y = mid(0, content.y, -max(0, content.height - container.height))


			-- 0.1.1e: consume event (e.g. for nested scrollables)
			return true

			-- experimental: consume only if scrolled
			--if (old_x ~= content.x or old_y ~= content.y) return true 
			
		end

		return container:attach(scrollbar)

	end


	function GuiElement:attach_button(el)
		el.label = el.label or "[label]"
		el.width = el.width or #el.label * 5 + 10 -- to do: calculate width with current font
		el.height = el.height or 14
		el.cursor = el.cursor or "pointer"

		-- 0.2.1c: set default attributes on creation
		-- later: can define a "class" or "style" at system-wide level or gui level that has these default values
		el.bgcol  = el.bgcol  or (el.highlight and 0x0606 or 0x0706)
		el.fgcol  = el.fgcol  or (el.highlight and 0x0201 or 0x0e01)
		el.border = el.border or (el.highlight and 0x0d0d or el.bgcol)

		local b = self:attach(el)

		function b:draw(msg)
			local bgcol  = el.bgcol or 0x0706
			local fgcol  = el.fgcol or 0x0e01
			local border = el.border or bgcol
			if (msg.has_pointer) then
				bgcol  >>= 8
				fgcol  >>= 8
				border >>= 8
			end

			local yy = 0
			if (msg.mb > 0 and msg.has_pointer) yy = yy + 1

			local x0,y0,x1,y1 = 0,yy,self.width-1,yy+self.height-2

			if (el.border) then
				-- border: default corner radius 2 
				rrectfill(x0,y0,self.width,self.height-1,2,bgcol)
				rrect    (x0,y0,self.width,self.height-1,2,border)
				--[[ test: skeuomorphic button  //  result: ._.
				if (el.highlight) then
					local a,b,c,d
					if (msg.mb > 0 and msg.has_pointer) then
						a,b,c,d = clip(self.sx - 2, self.sy+3,self.width,self.height,true)
					else
						a,b,c,d = clip(self.sx + 2, self.sy-3,self.width,self.height,true)
					end
					rrect(x0,y0,self.width,self.height-1,2,el.highlight)
					clip(a,b,c,d)
				end
				]]
			else
				-- no border; default corner radius 1
				rrectfill(0,0,self.width,self.height,1,bgcol)
			end

			print(self.label, self.width/2 - #self.label * 2.5, 3 + yy, fgcol)
		end

		return b

	end

	local attach_text_editor = nil 
	function GuiElement:attach_text_editor(...)
		-- lazily load the text editor
		if (not attach_text_editor) attach_text_editor = include("/system/lib/gui_ed.lua")
		return attach_text_editor(self, ...)
	end


	function GuiElement:detach(el)
		if (not el) then
			-- can just detach()
			return del(self.parent.child, self)
		end
		return del(self.child, el)
	end

	-- bring as far foward as will go before find an element with higher z
	function GuiElement:bring_to_front()
		p = self.parent
		if (not p) then return end

		for i=1,#p.child-1 do
			if (p.child[i] == self and p.child[i].z >= p.child[i+1].z) then
				p.child[i],p.child[i+1] = p.child[i+1],p.child[i]
			end
		end
	end

	-- push as far back as will go before find an element with lower z
	function GuiElement:push_to_back()
		p = self.parent
		if (not p) then return end

		for i=#p.child,2,-1 do
			
			if (p.child[i] == self and p.child[i].z <= p.child[i-1].z) then
				p.child[i],p.child[i-1] = p.child[i-1],p.child[i]
			end
		end
	end

	-- event propagates to children only when specified with msg.propagate_to_children (used for draw, update)
	-- normally don't want to propagate -- e.g. just click on pointer element

	function GuiElement:event(msg)

		if (not msg) then return end

		-- this helper is not scoped to a particular Gui -- need to pass in pointer_element via head
	
		if (self.head.pointer_element == self) then
			local mx, my = mouse()
			msg.has_pointer = (mx >= self.sx and my >= self.sy and mx < self.sx + self.width and my < self.sy + self.height)
		else
			msg.has_pointer = nil
		end

		local fin = false
		local cl,ct,cw,ch,cc

		-- call event handler if it exists
		if (type(self[msg.event]) == "function") then

			if (self.hidden) then

				-- no callbacks, no propagation to children
				fin = true

				-- exception: update callback is called on hidden elements but does not propagate to children
				-- means element can update own hidden state. ref: scrollbars autohide
				if (msg.event == "update") then
					self[msg.event](self, msg)
				end
			else

				-- 0.1.1e: always set mx,my,mb in message // was confused when tried to use if from an update callback
				-- to do: settle on which events get which state values
				-- local mx, my, mb = mouse() 
				msg.mx, msg.my = global_mx - self.sx, global_my - self.sy
				msg.mb = global_mb

				if (msg.event == "draw") then
					-- draw is special: optionally clip children and set camera position
					-- [experimental: also, can skip if outside]

					cl,ct,cw,ch,cc = clip(self.sx, self.sy, self.width, self.height, self.clip_to_parent)

					camera(-self.sx, -self.sy)

					--[[
						-- commented. works, but is too complex and spooky if it goes wrong
						-- when efficiency is needed, implement custom layer that handles longs lists etc (ref:filenav)
						if (self.clip_to_parent and cc) then
							-- clipped out -- can skip. and don't bother drawing children (implied clip_to_parent)
							fin = true
						else
							fin = self[msg.event](self, msg)
						end
					]]


					-- 0.1.1c: only bother drawing when state that this element depends on has changed
					-- to do: perhaps could draw (or blit to) own userdata if requested
					-- ** EXPERIMENTAL **
					if (self.draw_dependency) then

						local state_str = self:draw_dependency()
						if (state_str ~= self.last_state_str) then
							fin = self.draw(self, msg)
							self.last_state_str = state_str
						else
							-- -> can skip drawing this entire branch
							fin = true
						end
					else
						fin = self.draw(self, msg)
					end
				else

					-- generic callback (not "draw")

					fin = self[msg.event](self, msg)

				end
			end

		end

		if (not fin) then

			if (msg.propagate_to_children) then

				-- propagate to children (have to explicitly set in message)
				-- used for draw, update

				for i=1,#self.child do
					local c = self.child[i]
					if (c and c.event) then 
						c:event(msg)
					end
				end
			else

				-- default: propagate to parents   //   e.g. can mousewheel anywhere in scrollbox to scroll 
				-- block this by returning true from callback

				if (self.parent) self.parent:event(msg)

			end
		end

		

		-- restore clipping, camera state if needed
		if (cl) then
			clip(cl,ct,cw,ch)
			camera() -- to do: backup and restore
		end

	end


	-- Gui: class factory, extends GuiElement
	-- was Gui, now create_gui (consistent with create_undo_stack)

	function create_gui(head_el)

		head_el = head_el or {}

		head_el.head = head_el
		
		head_el.x = head_el.x or 0
		head_el.y = head_el.y or 0
		head_el.z = head_el.z or 0

		-- by default, occupy entire display adaptively
		if (not head_el.width)  head_el.width_rel  = 1.0
		if (not head_el.height) head_el.height_rel = 1.0

		head_el.width = head_el.width or 480
		head_el.height = head_el.height or 270

		local gui = GuiElement:new(head_el)

		local mx, my, mb, wheel_x, wheel_y = 0,0,0,0,0 -- 0.1.1f: made local again; sometimes want to clobber this state per-gui
		local last_mx, last_my, last_mb = 0,0,0
		local dx, dy = 0
		local start_mx, start_my,start_el,tap0_mx,tap0_my = 0,0,nil,0,0
		local drag_t = 0
		local dragging_el = nil

		-- don't pay attention to mouse button until it is first recorded as not pressed
		-- avoids complications when e.g. button is held on creation (generating click event)
		local block_mb = true

		-- to do: shouldn't need this? can use has_pointer()?
		function gui:get_pointer_element()
			return gui.pointer_element
		end

		function gui:get_keyboard_focus_element()
			return gui.keyboard_focus_el
		end

--[[
		-- commented; don't really want to have brittle iterator code in the window manager during dev
		-- breaks easily while experimenting with cpu model -> can't debug from inside
		-- (and turns out, don't really need this)
		function iter(tree)

			local function traverse(node)
				coroutine.yield(node)
				for i=1,#node.child do
				    traverse(node.child[i])
				end
			end

			local c = coroutine.create(function() traverse(tree) end)
		 
			return function()
				local _, value  = coresume(c) -- wrapped version needed in order to reconstruct call tree
--				local _, value  = coroutine.resume(c)
				return value
			end
		end
]]

		-- to do: rename: "evaluate_element"?
		local function update_absolute_position(el, px0, py0, px1, py1)
				
				-- hack: update head so that tree structure can change (should that be allowed? wm does it!)
				el.head = el.parent.head or el

				-- optimisation: shouldn't need to calculate for hidden elements
				if (el.hidden) return

				local px = el.parent.sx or 0
				local py = el.parent.sy or 0
				local elx = el.x or 0 -- necessary! to do: review .x .y existence
				local ely = el.y or 0
				
				-- set clipping rectangle to union of self and parent clipping // dupe from el_at_xy_recursive
				local sx0, sy0 = el.sx, el.sy
				local sx1 = sx0 + el.width
				local sy1 = sy0 + el.height
				if (el.clip_to_parent) then
					sx0 = mid(px0, sx0, px1)
					sy0 = mid(py0, sy0, py1)
					sx1 = mid(px0, sx1, px1)
					sy1 = mid(py0, sy1, py1)
				end

				-- relative size (might get squashed)
				if (el.width_rel)  el.width  = el.parent.width  * el.width_rel  + (el.width_add or 0)   el.width0 = el.width
				if (el.height_rel) el.height = el.parent.height * el.height_rel + (el.height_add or 0)  el.height0 = el.height


				-- confining and squashing
				if (el.confine_to_clip or el.squash_to_clip or el.confine_to_parent or el.squash_to_parent) then
					-- similar to confine_to_parent, but use px0, py0, px1, py1 relative to parent sx, sy
					local x0 = px0 - el.parent.sx
					local y0 = py0 - el.parent.sy
					local x1 = px1 - el.parent.sx
					local y1 = py1 - el.parent.sy

					-- when confine_*() or squash_*() is used on an element, the width and height attrs change meaning to "evaluated size".
					-- to change the size of such elements, modify width0, height0 instead  //  wm does this
					el.width  = el.width0
					el.height = el.height0

					-- squash first because might still want to confine afterwards due to minimum width, height

					if (el.squash_to_parent) then
						-- adjust size to fit 
						if (elx < 0) then
							el.width += elx
							elx = 0
						end
						if (ely < 0) then
							el.height += ely
							ely = 0
						end
						el.width = max(el.min_width,   min(el.width, el.parent.width - elx))
						el.height = max(el.min_height, min(el.height, el.parent.height - ely))
						
					end

					-- ditto

					if (el.squash_to_clip) then
						-- adjust size to fit 
						--printh("squash_to_clip: "..pod{x0,y0,x1,y1})
						if (elx < x0) then
							el.width = max(el.min_width, el.width - (x0 - elx))
							--printh("squash left: adjust elx "..elx.." to x0:"..x0)
							elx = x0
						end
						if (ely < y0) then
							el.height = max(el.min_height, el.height - (y0 - ely))
							ely = y0
						end
						el.width  = max(el.min_width,  min(el.width,  x1 - elx))
						el.height = max(el.min_height, min(el.height, y1 - ely))
					end

					-- confine_to_parent: reposition so that element remains inside parent
					-- (when oversized, set x / y to 0 -- can use with squash_to_parent)

					if (el.confine_to_parent) then
						-- bump left, up
						elx = min(elx, el.parent.width - el.width)
						ely = min(ely, el.parent.height - el.height)
						-- bump right, down 
						elx = max(0, elx)
						ely = max(0, ely)
					end
					
					if (el.confine_to_clip) then
						-- bump left, up
						elx = min(elx, x1 - el.width)
						ely = min(ely, y1 - el.height)
						-- bump right, down 
						elx = max(x0, elx)
						ely = max(y0, ely)
					end

					
				end

				
				if (el.justify == "right") then
--					printh("justify right  el.x,width,parent.width: "..pod{el.x, el.width, el.parent.width})
				end

				-- apply justification by modifying parent position
				if (el.justify or el.vjustify) -- faster test: unusually false
				then
					if (el.justify == "right")  then px = px + el.parent.width - el.width end
					if (el.justify == "center") then px = px + el.parent.width/2 - el.width/2 end
					if (el.vjustify == "bottom") then py = py + el.parent.height - el.height end
					if (el.vjustify == "center") then py = py + el.parent.height/2 - el.height/2 end
				end

				-- add parent position
				el.sx = (px + elx) \ 1
				el.sy = (py + ely) \ 1

				for i=1, #el.child do
					update_absolute_position(el.child[i], sx0, sy0, sx1, sy1)
				end

		end


		local function update_absolute_positions()

			-- dummy parent to reduce logic in update_absolute_position()

			gui.parent = {
				x=0, y=0,
				width = get_display():width(),
				height = get_display():height()
			}

--			update_absolute_position(head_el) -- head_el /is/ the gui

			-- in case squash_*() or confine_*() is used, need to calculate clipping rectangle -- same pattern as el_at_xy()
			-- using sfx.p64 instrument editor to measure: ~15% cpu increase
			-- to do: flatten gui tree once and iterate over that? do later when gui has settled down
			if (head_el.sx) then -- safety; should always be set already
				update_absolute_position(head_el, head_el.sx, head_el.sy, head_el.sx + head_el.width, head_el.sy + head_el.height)
			end

			gui.parent = nil

		end


		local function el_at_xy_recursive(el, px0, py0, px1, py1, x, y) --, depth)

			-- was needed due to superyield L->top borking bug -- can guarantee now?
			--[[
			if (not el or not el.sx or not el.sy) then printh("*** bad el in el_at_xy_recursive") return end
			if (depth > 64) then printh("*** max depth el_at_xy_recursive") return end
			]]

			-- ghost is drawn but can't interact
			if (el.hidden or el.ghost) return nil

			local best_el = nil

			local sx0, sy0 = el.sx, el.sy
			local sx1 = sx0 + el.width
			local sy1 = sy0 + el.height

			-- clip by parent -- events should also be clipped when not visibly interacting

			if (el.clip_to_parent) then
				sx0 = mid(px0, sx0, px1)
				sy0 = mid(py0, sy0, py1)
				sx1 = mid(px0, sx1, px1)
				sy1 = mid(py0, sy1, py1)
			end

			--printh("el_at_xy_recursive "..pod{tostring(el), {x, y}, {sx0, sy0, sx1, sy1}})

			local is_inside = (x >= sx0 and x < sx1 and y >= sy0 and y < sy1)
	
			-- last element in tree (so prefers leaf nodes). matches visual order

			if (is_inside and (not el.test_point or el:test_point(x - el.sx, y - el.sy))) then
				best_el = el
			end
			
			-- only search children when inside
			-- (unless clip_to_parent is false, in which case children could be anywhere)
			-- 0.1.1e: fixed; was "if (true or is_inside.." -- thx Eiyeron!
			-- need to test for every child; is the /child/ that might not be clipped and should be clickable
			-- https://www.lexaloffle.com/bbs/?tid=145205 // "Scrollbar content are clickable past their parents"
			for i=1, #el.child do
				if (is_inside or not el.child[i].clip_to_parent) then
					--best_el = el_at_xy_recursive(el.child[i], sx0, sy0, sx1, sy1, x, y, depth + 1) or best_el -- debug
					best_el = el_at_xy_recursive(el.child[i], sx0, sy0, sx1, sy1, x, y) or best_el
				end
			end
			
			return best_el
		
		end

		-- x, y are relative to TLC of gui
		function gui:el_at_xy(x, y)
			local el = nil

			--[[
				don't interact with gui a moment after it was created; avoid complex edge cases
				e.g. dragging while regenerate gui -> don't want to immediately pick up whatever
				is under the cursor. (confusing)
			]]
			-- 0.1.0c: commented; pushes complexity to other places! e.g. drop file into newly opened window
			--if (time() < gui.t0 + 0.2) return false

			-- no element when outside of gui itself (head element)
			el = el_at_xy_recursive(gui, gui.x, gui.y, gui.x + gui.width, gui.y + gui.height, x, y, 0)
			--el = el_at_xy_recursive(gui, 0, 0, 480, 270, x, y ,0)
			
			--printh("--> el_at_xy: "..tostring(el).."  //  "..pod{el.sx,el.sy,el.width,el.height})
			return el

		end

		-- deleteme
		function gui:el_at_pointer(x,y)
			printh("** FIXME: el_at_pointer -> el_at_xy")
			return gui:el_at_xy(x,y)
		end

		-- sometimes want to make an element that isn't attached [yet]
		-- e.g. scroll box contents
		function gui:new(el)
			return GuiElement:new(el)
		end

		

		--[[
					0x5480 ~ 0x5bff     (64) indexed display palette
					0x54c0 ~ 0x553f     (128) picotron misc draw state
		]]
		local draw_state = userdata("i64", 24) -- 192 bytes

		function gui:draw_all()

			update_absolute_positions()

			local el=self
			local msg = el and { mx = mx - el.sx, my = my - el.sy, mb = mb} or {}

			msg.event = "draw"
			msg.propagate_to_children = true

			-- should gui be responsible for preserving draw state?
			draw_state:peek(0x5480, 0, 24) -- back up 192 bytes of draw state
			clip() camera()
			self:event(msg)
			draw_state:poke(0x5480) -- restore

		end


		-- update_all mean update the whole gui tree -- is typically called onced from _update
		function gui:update_all()

			last_mx, last_my, last_mb = mx, my, mb
			mx, my, mb, wheel_x, wheel_y = mouse() -- screen space
			global_mx, global_my, global_mb = mouse() -- optimisation: only fetch once per frame; for constructing msg

			dx = mx - last_mx
			dy = my - last_my

			if (block_mb and mb == 0) block_mb = false
			if (block_mb) then
				-- consider mouse state to be junk when mb hasn't been 0 yet
				mx,my,mb = 0,0,0
			end

			update_absolute_positions()

			-- if dragging something, always pay attention only to that
			-- (even if drag outside of that element)

			local el = dragging_el or gui:el_at_xy(mx, my)

			-- can be nil
			gui.pointer_element = el 


			-- check for hidden parent
			
			local el2 = el
			while (el2) do
				if (el2.hidden) el = nil -- found; don't send any messages
				el2 = el2.parent
			end



			----------------- update cursor --------------------------------------------------------------


			gui.mouse_cursor_gfx = (el and el.cursor) or false -- use false so that can send in a message

			if (pid() > 3) then
				if (gui.last_mouse_cursor_gfx != gui.mouse_cursor_gfx) then
					window{cursor = gui.mouse_cursor_gfx}
				end
				gui.last_mouse_cursor_gfx = gui.mouse_cursor_gfx
			end


			----------------- standard messages: only send to element at pointer -----------------------

			-- construct generic message with state information
			local msg = el and {
				mx = mx - el.sx, 
				my = my - el.sy, 
				mb=mb, dx=dx, dy=dy
			} or {}


			

			
			local do_double_click = false
			local do_double_tap = false

			local dx = start_mx - mx
			local dy = start_my - my

			-- mouse down: could be click or click + double-click
			if el and last_mb == 0 and mb > 0 then


				-- mouse buttons needs to match: clicking left and then right quickly should not trigger double click/tap
				if ((el.last_click_t and time() - el.last_click_t < 0.4) and 
					mb == el.last_click_mb and
					dx*dx + dy*dy < 4*4
				) then
					do_double_click = true
					-- (send message later -- would click message to be sent first)
				end


				-- click
				-- two click messages for every double click -- because might only care about rapid clicks and not double clicks
				
				-- mousedown (and not second click in a double click): send click and start drag
				
				start_mx = mx
				start_my = my
				start_el = el -- to do: use this to discard some interactions that should start and end on the same element (no gui refresh midway)
				drag_t = time()
				dragging_el = el	
				-- commented: need to explicitly set, so that it is possible to know if there 	
				-- is an element that is actively consuming keyboard input via gui:get_keyboard_focus_element
				--gui.keyboard_focus_el = el 
				el.last_click_t = time()
				el.last_click_mb = mb

				-- 0.1.0h clicking anywhere removes keyboard focus [but can be immediately regained by the element being clicked on]
				-- this allows any textfield to be clicked outside of to remove focus. ref: renaming instrument / map layer
				-- to do: is that behaviour ever unwanted? should be optional?
				el.head.keyboard_focus_el = nil

				msg.event="click" el:event(msg)
				

			end

			-- mouseup: send release and possibly tap
			if (el and last_mb > 0 and mb == 0) then

				-- tap if mouse position hasn't moved more than 4 pixels
				--local dx = start_mx - mx
				--local dy = start_my - my

				-- only tap when close to position-at-mousedown within one second, and element existed for 200ms or more
				-- 0.1.1e: tap must be within 0.3 seconds (was 1.0 -- too slow; could be meant as a drag)
				-- ref: filenav doubleclick to enter folder -> don't want tap on newly created interface
				if (dx*dx + dy*dy < 4*4 and time() < drag_t + 0.3 and t() > el.t0 + 0.2) then

					msg.event="tap" msg.last_mb = last_mb el:event(msg)

					-- also send a doubletap if second tap (using same mouse button)
					if (el.last_tap_t and time() - el.last_tap_t < 0.4 and last_mb == el.last_tap_mb and
							(tap0_mx-mx)^2 + (tap0_my-my)^2 < 4*4 -- close to original tap position
						) then
						do_double_tap = true
					else
						el.last_tap_t = time()
						el.last_tap_mb = last_mb
					end

					tap0_mx = mx
					tap0_my = my

				end

				-- common to want to know where drag started from
				msg.mx0 = start_mx - el.sx
				msg.my0 = start_my - el.sy

				-- release
				msg.event="release" el:event(msg)
			end

			-- hover. maybe don't need?
			if (el and mb == 0) then
				msg.event="hover" el:event(msg)
			end

			-- drag
			if (dragging_el) then

				-- if (last_mb > 0 and mb > 0) then -- only start dragging the frame after mouse button becomes active
				if (mb > 0) then  -- what's wrong with dragging from first frame? need that interactivity! e.g. pick up colour in sprite editor
					msg.event="drag" 
					-- common to want to know where drag started from
					msg.mx0 = start_mx - dragging_el.sx -- 0.1.1f: was el.sx, el.sy
					msg.my0 = start_my - dragging_el.sy

					-- locked pointer? use that for dx, dy. ref: instrument designer envelope knob
					if (peek(0x5f2d) & 0x4) > 0 then
						local locked_dx, locked_dy = mouselock()
						msg.dx = locked_dx
						msg.dy = locked_dy
					end

					dragging_el:event(msg)
					--printh("dragging_el: "..tostring(dragging_el))
				elseif (mb == 0) then            -- .. but stop dragging immediately when mouse button released

					dragging_el = nil

					-- auto unlock mouse on release
					if ((peek(0x5f2d) & 0x8) > 0) poke(0x5f2d, peek(0x5f2d) & ~0x4)
				end
			end

			-- doubleclick sent after click / drag (e.g. in text editor, don't want to deselect what the double click selected)
			if (do_double_click) then
				msg.event="doubleclick" el:event(msg)
				el.last_click_t = 0
			end

			-- doubletap message comes after second tap message
			if (do_double_tap) then
				msg.event="doubletap" el:event(msg)
			end

			-- mousewheel event
			
			if (el and (wheel_x ~= 0 or wheel_y ~= 0)) then
				msg.wheel_x = wheel_x
				msg.wheel_y = wheel_y
				msg.event="mousewheel" el:event(msg)
			end
	
			----------------- send update message to gui tree -----------------------

			msg.event="update" msg.propagate_to_children = true self:event(msg)


		end


		return gui
	end

end

:: bios/lib/gui_ed.lua
--[[pod_format="raw",created="2024-03-13 18:17:04",modified="2024-06-30 01:20:27",revision=10]]
--[[

	/dev/ed/gui_ed.lua

	text editor widget

	good for ~128k

]]

local function apply_markup(l)

	--[[

		** markup is still experimental! will likely change (or disappear) in future
		if it becomes standard, will be an extremely thin set of rules; motivation is
		to provide a simple format for writing notes and per-cart documentation.
		ideally would support slugs in locations: manual.txt#configuration

	]]

	-- require space; better to be strict
	if (sub(l,1,2) == "# ") then
		--return "\14\06t\06w"..sub(l,3)
		-- return "\^t\^w"..sub(l,3).."\^g\-h"..sub(l,3) -- haha
		--return "------------------------------------\n  "..sub(l, 3).."\n------------------------------------\n"
		--return "\^od60\^t\^w\f6"..sub(l,3) -- placeholder headings (later: switch to large font)
		--return "\^t\^w"..sub(l,3) -- placeholder headings (later: switch to large font)
		--return "\^o5ff\f7\^x7"..sub(l,3).."\n\^x4\*p-" -- placeholder headings (later: switch to large font)
		return "\^x4\*\150-\n\|c\^x5".."\128 "..sub(l,3).."\n\|a\^x4\*\150-"  -- \143 for diamond  \152 for horizontal stripes  \132 for dither


	end

	if (sub(l,1,3) == "## ") then
		return "\128 "..sub(l,4).."\|k"
	end

	if (sub(l,1,4) == "### ") then
		return "\129 "..sub(l,5).."\|k"
	end

	-- test for indented sections (should be optional / automatic though)
	if (sub(l,1,5) == "\t### ") then
		return "\t\129 "..sub(l,6).."\|k"
	end

	-- colour comments differently even with no highlighting? nice for note-taking
	if (sub(l,1,3) == "// ") then
		return "\fd"..l
	end

	if (sub(l,1,3) == "```") then
		-- hrrrm. need state
	end

	-- no markup; need to let "]]" pass through!
	return l
end


local search_box_height = 18
local search_box_width  = 240

function close_search_pane(container)
	
	if (not container.search_box) return

	window{capture_escapes = false}
	container.search_box:detach()

	container.search_box = false

end



function open_search_pane(container, search_func, prompt_str)

	-- already open
	if (container.search_box) return

	prompt_str = prompt_str or "Find:"

--	printh("opening search pane from container: "..tostring(container))

	local search_box = container.parent:attach({
		x = container.x + container.width - search_box_width - 8, y = container.y, 
		width = search_box_width, height = search_box_height
	})

	function search_box:draw()
		rectfill(0,0,self.width,self.height,6)
		line(0,self.height-1,self.width,self.height-1,13)
		print(prompt_str,8,6, 5)
	end

	local search_field = search_box:attach_text_editor({
		x=34, y=3, width=search_box_width - 48, height=12, block_scrolling = true, max_lines = 1,
		key_callback = {enter = function () search_func(1) close_search_pane(container) end }
	})

	if (prompt_str == "Find:") then
		search_field:set_text({container.last_search_str or ""})
		search_field:select_all()
	end

	search_field:set_keyboard_focus(true) -- to do: perhaps should allow search_field:set_keyboard_focus()
	
	container.search_box = search_box
	container.search_field = search_field

	window{capture_escapes = true}

end

-- attach_text_editor
-- returns the content -- all exposed methods (incl :attach_scrollbars!) and attributes can be stored there  
local function attach_text_editor(g, parent)

	local container = g:attach(parent)

	local content                -- referenced by container:draw
	local undo_stack



	local char_w = peek(0x4000) -- only used for cursor
	local char_h = peek(0x4002)

	
	local cursor_y0 = -1
	local cursor_y1 = 7

	local cur_x, cur_y = 1, 1
	local cur_xp = 0 -- cursor x in pixels (preserve original position when moving across a shorter line that clamps cur_x)
	local highlight_y = nil  --  e.g. jump to error and want to highlight the line

	local hydrated = {}
	local hydrate_y = 1

	local sel = {{line=0, char=0}, {line=0, char=-1}, {line=0, char=0}}



	-- note: need a draw function so that parent clipping is set!

	function container:draw()
		-- default container draw: clear to blue
		-- perhaps could be optional though if caller wants to manage background (e.g. live coding w/ code shown on top of output)
		rectfill(0,0,self.width-1, self.height-1, content.bgcol)

		-- print("\^w\^t ***"..tostring(cur_y), 10,10,8)

		-- show keyboard focus state (debug, but maybe useful in future)
		-- have blinking cursor!
		--[[
		if (content:has_keyboard_focus() and self.max_lines == 1) then
			rect(0, 0, self.width-1, self.height-1, 10)
		end
		]]

	end
	
	-- returns true when call back exists AND callback doesn't opt to pass-through
	local function key_pressed_callback(self, k)
		if (type(content.key_callback[k]) == "function") then
			return not content.key_callback[k](self, text)
		end
		return false
	end


	
	-- make the scrollable thing
	-- start same height as container

	content = container:attach({x=0,y=0,width=container.width, height=container.height})

	-- copy attributes passed to container
	-- stored in content so that caller can deal only with return value of attach_code_editor (content, not container) 
	-- don't do an pairs() copy because don't want to copy over internal values
	
	content.show_line_numbers   = container.show_line_numbers
	content.embed_pods          = container.embed_pods
	content.syntax_highlighting = container.syntax_highlighting
	content.show_tabs           = container.show_tabs
	content.markup              = container.markup
	content.max_lines           = container.max_lines
	content.has_search          = container.has_search
	content.bgcol               = container.bgcol or 1
	content.fgcol               = container.fgcol or 6
	content.curcol              = container.curcol or 14
	content.selcol              = container.selcol or 10
	content.lncol               = container.lncol or 16
	content.block_scrolling     = container.block_scrolling
	content.key_callback        = container.key_callback or {}

	content.margin_top          = container.margin_top or 3
	content.margin_left         = container.margin_left or 4
	content.margin_left1        = content.margin_left + (content.show_line_numbers and 28 or 0) -- updated every frame


	---
	local text = {""}

	local num = rnd(20)
	local x = container.x or 0
	local y = container.y or 0
	local width = container.width or 200
	local height = container.height or 100

	local last_show_tabs -- can be changed live

	

-- colour when editing a line
	local editing_line_col = content.bgcol == 1 and 9 or 5


	------------------------------------------------------------------------------------

	local function set_selection(tbl)
		sel = tbl
		-- starting point (for adjusting with shift+click / shift+navigate)
		if (not sel[3]) then
			sel[3] = unpod(pod(sel[1]))
		end
	end


	local function get_sx_for_cur_x(str, pos)
		if (pos < 1) then return 0 end
		local s = sub(str, 1, pos)
		return print(s, 0, -100)
	end

	-- don't care about x for now
	local function find_cur_y_for_click(my)

		local yy = content.margin_top

		my += 1  -- slight fudge to match cursor / because space below characters visually part of next row

		for i = 1, #text do			
			yy += (hydrated[i] and hydrated[i].draw_h) or char_h
			if (my < yy) return i
		end

		return #text

	end

	
	local function find_x_for_cur_x(cur_x, str)
		if (not str) return 0
		return print(sub(str, 1, cur_x - 1), 0, -1000)
	end

	-- assumes tabs rendered relative to home_x ------
	local function find_cur_x_for_click(cx, str)
		if (not str) return 0

		if (#str == 0) then return 1 end

		-- printh("find_cur_x_for_click: "..cx)
		
		for i=1,#str do
			local xx = print(sub(str, 1, i), 0, -1000)
			if (xx and xx >= cx) then return i end
		end
		return #str+1
	end

	------------------------------------------------------------------------------------

	function content:set_text(t)
		if (type(t) == "string") t = split(t,"\n",false)

		text = t 

		-- behave as if editing a new file
		-- (can't undo across set_texts)
		cur_y = 1
		hydrated = {}
		undo_stack:reset()
	end

	function content:get_text() return text end

	-- when this return value varies, there are (usually) unsaved changes
	-- used by code.p64, notebook.p64 wrangler callbacks
	-- use + #text[cur_y] because checkpoints are only made at the end of each word
	function content:get_state_hint()
		return (undo_stack and #undo_stack.undo_stack or -1) + ((text[cur_y] and #text[cur_y] or 0) << 16)
	end

	function content:get_undo_stack() return undo_stack end

	function content:select_all()
		set_selection{{line=1, char=1}, {line=#text, char=#text[#text]}}
	end

	function content:search_box_is_open()
		return container.search_box
	end

	

	local identcol = {}
	local reserved = {"and", "break", "do", "else", "elseif", "end", "for", "function", "if", "in", "local", "not", "or", "repeat", "return", "then", "until", "while"}
	local reserved_val = {"true", "false", "nil"}
	local api_name = {
-- /tools/list_api.lua
"flr","pset","select","set_spr","vec","set","map","reset","palt","userdata","poke8","get_spr",
"get","cp","socket","foreach","t","create_process","pal","sspr","tokenoid","fillp",
"memset","norm","btn","assert","type","oval","create_undo_stack","error","poke2",
"theme","add","env","fetch_metadata","clear_key","pwf","menuitem","load","create_gui",
"on_event","sfx","mv","store","tonum","mouselock","pwd","music","print","memmap","store_metadata",
"tostring","time","pod","include","rect","date","stat","get_clipboard","peektext","split",
"pairs","unpod","readtext","key","getmetatable","camera","keyp","sgn","fset","mouse","tostr",
"notify","all","sub","rawlen","ord","mset","yield","pack","costatus","cocreate","min","ceil",
"rawequal","unmap","coresume","stop","peek2","unpack","printh","exit","memcpy","note","window",
"line","get_display","cursor","get_draw_target","open","pget","del","mid","spr","ipairs",
"vid","rawset","peek4","poke","deli","peek","btnp","pid","tonumber","circfill","rrectfill",
"max","set_draw_target","cd","mget","cls","mount","poke4","color","blit","fstat","atan2",
"collectgarbage","ls","setmetatable","rm","send_message","count","mkdir","create_delta",
"cos","rawget","circ","clip","flip","next","peek8","fetch","wrangle_working_file","tline3d",
"rectfill","srand","set_clipboard","fget","sqrt","warn","pcall","fullpath","chr","apply_delta",
"rnd","ovalfill","abs","sin","rrect"
	}
	for i=1,#reserved do
		identcol[reserved[i]] = "e"
	end
	for i=1,#api_name do
		identcol[api_name[i]] = "b"
	end
	for i=1,#reserved_val do
		identcol[reserved_val[i]] = "c"
	end

	local multi_catcol ={[3] = "d", [4] = "c"} -- multiline categories take priority
	local catcol={[0]="7","6","c","d", "c", "7"}

	local function highlight_line(line, token_state)

		if (not line) return

		if (not content.syntax_highlighting) return line

		local pos = 1
		local out = ""
		
		while (pos <= #line) do
			local str, pos1, cat
			str, pos1, cat, token_state = tokenoid(line, pos, token_state)

			if (not str) then return out end

			if (str == "\t" and content.show_tabs) then
				-- str = "\f2|\-c\t" -- don't want the | to advance cursor position
				str = "\^h\f2\-f|\^g\|f\-f|\^g\t" -- better: set home and go back to original cursor position before tabbing. also draw | twice to fill gap! (ha!)
			end
			

			local colstr = multi_catcol[cat] or identcol[str] or catcol[cat] or ""
			out = out .. "\f" .. colstr .. str
			pos = pos1
		end

		return out,token_state
	end

	------------------------------------------------------------------------------------

	-- hydrate can invalidate total height
	local total_height = nil

	--[[
		hydrate()
		applies syntax hydrateing, pod embedding, pn markup 
		to do: handle markup. need 2 standard banks of fonts

		renderable   -- the thing to render (could be a userdata)
		draw_h       -- height of the item
		text_src     -- invalid when no longer matches (need to recalcuate)
		token_state0 -- state of tokenoidizer ad start of line (should match previous line when valid)
		token_state  -- state of tokenoidizer (optional) after line

	]]
--	local function hydrate(line, token_state)

	local function hydrate(i, from)

		if (i > #text) return -- safety

		-- no need
		if (
			hydrated[i] and 
			hydrated[i].text_src == text[i] and
			(i == 1 or (hydrated[i-1] and hydrated[i-1].token_state == hydrated[i].token_state0))
		) 
		then
			return
		end

		-- always invalidate total height when something is hydrated
		total_height = nil

		-- make sure previous line is hydrated
		if (i > 1) then
			hydrate(i-1, i)
			-- safety
			if (not hydrated[i-1]) return
		end


		--[[
			-- debug: show reason hydration is happening

			local reason = "unknown reason"
			if (not hydrated[i]) then reason = "not hydrated yet"
			elseif (hydrated[i].text_src != text[i]) then reason = "text_src changed"
			elseif (not hydrated[i-1]) then reason = "previous lie not hydrated"
			elseif (hydrated[i-1].token_state != hydrated[i].token_state0) then reason = "previous token_state doesn't match"
			end

			printh("hydrating: "..i.."   (from: "..(from or "")..") because "..reason)
		]]

		local token_state = i > 1 and hydrated[i-1].token_state or 0
		local line = text[i]

		local item = {
			text_src = line,
			token_state = token_state,
			token_state0 = (i == 1 or not hydrated[i-1]) and 0 or hydrated[i-1].token_state,
			-- draw_y includes the top margin
			draw_y = i > 1 and (hydrated[i-1].draw_y + hydrated[i-1].draw_h) or content.margin_top
		}

		hydrated[i] = item

		-- pod
		if (content.embed_pods and sub(line,1,7) == "--[[pod") then
			item.renderable = unpod(line)
			if (type(item.renderable) == "userdata") then
				item.draw_h = item.renderable:height() + 4 -- give 4 pixels margin below image
				return
			else
				item.renderable = line
			end
		end
		
		-- marked up line
		if (content.markup and (not content.syntax_highlighting or (token_state >> 8) == 3)) then

			-- when syntax highlight is on, only apply markup when inside a comment!
			-- for multiline string: (token_state >> 8) == 3
			
			local marked_up_line = apply_markup(line)
			local x1, y1 = print(marked_up_line, 0, -1000)

			if (token_state >= 256) marked_up_line = "\fd"..marked_up_line -- commented markup should still be commented colour

			-- still need to do highlighting to close comment block. consider: "# foo ]]"
			-- (alternative strategy: apply_markup() can return nil)
			if (content.syntax_highlighting) _, item.token_state = highlight_line(line, token_state)

			item.has_markup = true
			item.renderable = marked_up_line
			item.draw_h = y1 and (y1 + 1000) or 10 -- to do: when is marked_up_line nil? (causing y1 to be nil)
			return
		
		end

		-- syntax highlighted line

		item.renderable, item.token_state = highlight_line(line, token_state)
		item.token_state = item.token_state or 0


		local x1, y1 = print(item.renderable, 0, -1000)
		if (y1) item.draw_h = y1 + 1000
	end
	

		
	
	local function set_cur_xp()
		-- -2 (~ half character width) so that can move between characters that are <= 2px apart without getting rounded down
		cur_xp = find_x_for_cur_x(cur_x, text[cur_y]) - 2 
		--printh("set cur_xp: "..cur_xp)
	end


	-- visible_x / visible_y: minimum distance from cusor to edge
	-- e.g. when searching, want to see above and below
	-- with 12px minimum edge disance, means can also drag-scroll-select more easily
	local function show_cursor(visible_x, visible_y)

		visible_x = visible_x or 12 -- double as the click to scroll area
		visible_y = visible_y or 12 -- ditto

		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines

		if (not hydrated[cur_y]) return -- to do: how/when does this happen?

		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y

		if (not xx or not yy) return

		content.y = mid (-(yy - visible_y), content.y, -(yy - (container.height - content.margin_top) + char_h + 4 + visible_y))
		content.x = mid (-(xx - visible_x), content.x, -(xx - (container.width - content.margin_left1) + char_w + 8 + visible_x))

		--printh(xx)

		content.clamp_scrolling()

	end

	-- similar to set_cursor, but scrolls so that line is not near edge
	-- (to do: generalise based on textfield height -- is currently used by code.p64)
	function content:jump_to_line(y, do_highlight)
		if (not y) return
		if (do_highlight) highlight_y = y

		if (cur_y == y) then
			-- already on this line --> just make sure cursor is visible
			-- (prevents scrolling on save, because it triggers a "jump_to_hloc" message -- to do: shouldn't in the first place?)
			return 
		end
		cur_y = y
		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines
		if (not hydrated[cur_y]) return -- to do: how/when does this happen?
		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y
		if (not yy) return

		local visible_x = 12
		content.y = mid (-(yy - 100), content.y, -(yy - (container.height - content.margin_top) + char_h + 4 + 160))
		content.x = mid (-(xx - visible_x), content.x, -(xx - (container.width - content.margin_left1) + char_w + 8 + visible_x))

		set_cur_xp()

	end


	local function center_cursor(q)

		visible_x = 12
		visible_y = 12

		-- dupe
		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines
		if (not hydrated[cur_y]) printh("couldn't center 1") return -- to do: how/when does this happen?
		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y
		if (not xx or not yy) printh("couldn't center 2") return

		content.y = -yy + container.height * (1-q)
		content.x = 0 ---yy + container.height/2

		content.clamp_scrolling()

	end



	-- safety; shouldn't happen
	local function contain_cursor()
		if (not text or #text == 0) text = {""}
		cur_y = mid(1, cur_y, #text)
		cur_x = mid(1, cur_x, #text[cur_y] + 1)
	end

	local function is_something_selected()
		return sel[2].line > sel[1].line or (sel[2].line == sel[1].line and sel[2].char >= sel[1].char)
	end
	
	-- scrollbars calls this if it exists  -- UPDATE: nope; scrollbars not resposible for clamping at all
	-- just always clamp internally. (so clamp_scrolling is not a special name here)
	function content:clamp_scrolling()
		local max_y = max(0, content.height - container.height)
		content.y = mid(0, content.y, -max_y)
		content.x = min(0, content.x)

		if (content.block_scrolling) then
			content.x = 0
			content.y = 0
		end
	end

	function content:draw()

		-- rhs: clip at container (hack so that don't need to calculate content width)
		poke2(0x552c, container.sx + container.width)

		-- draw tabs relative to home
		poke(0x4005, (@0x4005) | 0x2)

		-- line number background
		if (self.show_line_numbers) then
			rectfill(0, 0, 26, self.height, content.lncol)
		end
		
		local x = content.margin_left1
		local y = content.margin_top 
		local inside_comment = false
		local something_selected = is_something_selected()

		local start_i = mid(1, find_cur_y_for_click(0 - content.y),       #text)
		local end_i   = mid(1, find_cur_y_for_click(container.height - content.y),  #text)

		-- draw_y includes the top margin
		y = (hydrated[start_i] and hydrated[start_i].draw_y or content.margin_top)

		for i= start_i, end_i do

			

			-- =====================================================
			-- print line
			-- =====================================================

			local y0 = y

			-- print line number on left
		
			--clip()
			if (self.parent.show_line_numbers) then
				print(string.format("%4d",i), 3, y, content.bgcol)
			end

			-- validate line to print; might propagate backwards
			hydrate(i)

			-- safety
			if (not hydrated[i]) return -- nothing much can do

			local y1 = 0

			-- record where it was drawn (used for cursor_y -> line_index lookup)
			hydrated[i].draw_x = x
			hydrated[i].draw_y = y

--			if (cur_y == i) then -- ha
			if (highlight_y == i) then
				rectfill(content.margin_left1-4, y+cursor_y0-1, 100000, y+cursor_y0+(hydrated[i].draw_h or 8)-2,18)
			end

			-- draw selection
			if (sel and i >= sel[1].line and i <= sel[2].line) then
				
				local c0 = i > sel[1].line and 1 or sel[1].char
				local c1 = i < sel[2].line and #text[i]+1 or sel[2].char -- +1 for implied \n
				if (c1 >= c0) then -- c1==c0 means single character selected
					local sx0 = content.margin_left1 + get_sx_for_cur_x(text[i], c0-1)
					local sx1 = content.margin_left1 + get_sx_for_cur_x(text[i].." ", c1)-1 -- extra char on right so that newline selection is visible
					rectfill(sx0, y + cursor_y0, sx1, y + cursor_y1, content.selcol)
				end
			end



			if (cur_y == i or (sel[1].line <= i and sel[2].line >= i)) then

				-- cursor is over, or selection covers that line
				--> show raw text (but still with syntax highlighting when enabled)

				local token_state = hydrated[i-1] and hydrated[i-1].token_state or 0

				-- highlight text outside of a comment (when it doesn't have any markup)
				-- i.e. regular code should still be highlighted as usual when the cursor is over it
--[[
				local highlighted_line = 
					(content.syntax_highlighting and type(hydrated[i].renderable) == "string" and not hydrated[i].has_markup) and
					highlight_line(text[i], token_state) or text[i]
				_,y1 = print(highlighted_line, x, y, editing_line_col)
]]

				if (type(hydrated[i].renderable) == "userdata" or hydrated[i].has_markup) then
					-- show true form
					_,y1 = print(text[i], x, y, editing_line_col)
				else
					-- show as usual (just highlighting)
					_,y1 = print(hydrated[i].renderable, x, y, content.fgcol)
				end

			else

				if (type(hydrated[i].renderable) == "userdata") then
					-- embedded pod; only happens when content.embed_pods is true					
					spr(hydrated[i].renderable, x, y)
				else
					-- text [with markup]
					_,y1 = print(hydrated[i].renderable, x, y, content.fgcol)
				end

			end

			-- move cursor down
			-- if hydrated height is greater, use that -- so that page doesn't jump around when cursor goes on/off
			y = max(y1, hydrated[i].draw_h and (y + hydrated[i].draw_h) or 0)

			-- cursor: when no selection and has focus
			if (content:has_keyboard_focus() and i == cur_y and not something_selected and t()%0.5 < 0.25) then
				local sx = x
				local sy = y0
				if (cur_x > 1) then
					local substr = sub(text[i], 1, cur_x-1)
					sx = print(substr,x,-100)
				end
				
				-- 0.2.0h cursor: find the width that printing the character would occupy
				-- (need to print whole line to get tabs right)
				local char_w1 = print(sub(text[i], 1, cur_x), x, -100)
				if (char_w1) char_w1 -= sx
				char_w1 = char_w1 and max(char_w1, char_w) or char_w
				--local rectfunc = (text[i][cur_x] == "\t") and rect or rectfill -- use rect for tabs? too heavy otherwise?
				local rectfunc = rectfill -- nah, just big chunky rectangle to be consistent
				rectfunc(sx, sy + cursor_y0, sx+char_w1-1, sy+cursor_y1, content.curcol)
				print(text[i][cur_x], sx, sy, content.bgcol) -- inverted; can always see what is under the cursor

			end
			
		end

	end



	local function insert_string(orig, pos, str)
		if (not orig or not pos or not str) return
		str = tostring(str)
		return sub(orig, 1, pos-1) .. str .. sub(orig, pos)
	end

	local function insert_multiline_string(str, y, x)

		if (type(str) ~= "string") return

		local lines = split(str, "\n", false) -- false for no mixed types (numbers also returned as strings)

		if (#lines == 1) then
			-- printh("just one line")
			text[y] = insert_string(text[y], x, str)
			cur_x += #str
			set_cur_xp()
			return
		end

		-- 1. split -- same as pressing enter

		local nl = #lines - 1

		-- printh("inserting "..nl.." lines")

		for i=#text + nl, cur_y + 1, -1 do
			text[i] = text[i - nl]
		end

		
		text[cur_y + nl] = lines[#lines] .. sub(text[cur_y], cur_x)
		text[cur_y] = sub(text[cur_y], 1, cur_x-1) .. lines[1]

		for i=2, #lines-1 do
			text[cur_y + i - 1] = lines[i]
		end

		cur_y += nl
		cur_x = #lines[#lines] + 1
		set_cur_xp()

		hydrate_y = y

		-- safety: re-hydrate from scratch
		hydrate_y = 1
		hydrated = {}

	end

	local function delete_string(orig, pos0, pos1)
		return sub(orig, 1, pos0-1) .. sub(orig, pos1+1)
	end
	local function insert_line(pos, str)
		for i=#text+1, pos+1, -1 do
			text[i] = text[i-1]
		end
		text[pos] =  str or ""
	end
	local function delete_line(pos)
		local n = #text
		for i=pos,n do
			text[i] = text[i+1] -- last one will be nil
		end
	end
	local function delete_char()
		if (cur_x == 1) then
			-- join w/ previous line
			if (cur_y > 1) then
				cur_x = #text[cur_y-1] + 1
				text[cur_y-1] = text[cur_y-1] .. text[cur_y]
				delete_line(cur_y)
				cur_y = cur_y - 1
			end
		else
			text[cur_y] = delete_string(text[cur_y], cur_x-1, cur_x-1)
			cur_x = cur_x - 1
		end
		set_cur_xp()
	end

	

	local function deselect()
		set_selection{{line=0, char=0}, {line=0, char=-1}}
	end

	local function get_selected_text()

		local str = ""

		if (not is_something_selected()) return ""

		if (sel[1].line == sel[2].line) then
			-- select within single line
			str = sub(text[sel[1].line], sel[1].char, sel[2].char)
		else
			-- select across multiple lines
			str ..= (sub(text[sel[1].line], sel[1].char) or "") .. "\n"
			for i = sel[1].line + 1, sel[2].line - 1 do
				str ..= text[i] .. "\n"
			end
			str ..= (sub(text[sel[2].line], 1, sel[2].char) or "")
		end

		if (sel[2].char > #text[sel[2].line]) str ..= "\n" -- trailing \n
		return str
	end



	local function delete_selected()

		if (not is_something_selected()) then return end

		local l0 = sel[1].line + 1
		local l1 = sel[2].line

		cur_x = sel[1].char
		cur_y = sel[1].line

		-- perfectly delete from start of line0 to end of line1 --> don't keep first line
		if (sel[1].char == 1 and sel[2].char > #text[sel[2].line]) then  -- "sel[2].char >" means newline is selected
			l0 = sel[1].line
		end

		-- 1. join start of line0 and end of line1
		text[sel[1].line] = (sub(text[sel[1].line], 1, sel[1].char - 1) or "") .. (sub(text[sel[2].line], sel[2].char + 1) or "")
		
		-- 2. remove anything inbetween

		local n = l1 - l0 + 1 -- number of lines to delete


		if (n > 0) then
			for i = l0, #text do
				text[i] = text[i + n]
			end
		end
		
		deselect()

		if (#text == 0) then
			text = {""}
		end

		set_cur_xp()

	end




	local function extend_selection_to_cursor()

		sel[2] = {line = cur_y, char = cur_x}
		
		-- copy initalial position (might swap)
		sel[1].line, sel[1].char = sel[3].line, sel[3].char
		
		-- swap so that start is always first
		if (sel[2].line < sel[1].line or
			(sel[2].line == sel[1].line and sel[2].char < sel[1].char))
		then
			sel[1].line, sel[2].line = sel[2].line, sel[1].line
			sel[1].char, sel[2].char = sel[2].char, sel[1].char
		end

		-- half open
		sel[2].char = sel[2].char - 1
		if (sel[2].char < 1 and sel[2].line > 1) then
			sel[2].line -= 1
			sel[2].char = #text[sel[2].line] + 1 -- +1 for implicit \n
		end

	end

	function content:get_cursor()
		return cur_x, cur_y
	end


	function content:set_cursor(x,y)
		if (not x and not y) then
			-- set based on mouse
			local mx, my = mouse()
			-- printh(string.format("mx %d my %d", mx, my))
			mx -= container.sx
			my -= container.sy
			-- printh(string.format(" --> mx %d my %d", mx, my))
			local cy = find_cur_y_for_click(my)
			cur_y = mid(1, cy, #text)
			cur_x = find_cur_x_for_click(mx - content.margin_left1, text[cur_y])
			deselect()
			show_cursor()
			return
		end

		if (x) cur_x = x
		if (y) cur_y = y

		set_cur_xp()
		show_cursor() -- always show
		
	end

	function content:center_cursor(...)
		-- experimental; disable for now
		--center_cursor(...)
	end


	------------------------------------------------------------------------------------------------
	-- update
	------------------------------------------------------------------------------------------------

	
	local function get_total_height()

		-- current total is valid
		if (total_height) return total_height

		-- re-calculate (only happens after something was hydrated)
		total_height = 0
		for i=1,#text do
			total_height += (hydrated[i] and hydrated[i].draw_h) or char_h
		end

		return total_height
	end

	-- deleteme -- hydration should be 100% lazy
	local function hydrate_all()
		for i=1,#text do
			hydrate(i)
		end
	end


	----------------------------------------------------------------------------------------------------------------

	local function checkpoint()
		--printh("@ checkpoint")
		undo_stack:checkpoint()
	end

	local last_line_y = -1
	local function backup_line_edit()
		-- to do: should be whitespace check
		if (cur_y ~= last_line_y or ((sub(text[cur_y],cur_x-1,cur_x-1) == " ") != (sub(text[cur_y],cur_x,cur_x) == " "))) then
			checkpoint()
		end
		last_line_y = cur_y
	end



	local function strchr(s, c)
		return string.find (s, c, 1, true)
	end

	local function get_char_cat(c)
		if (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", c)) return 1
		if (ord(c) >= 128 or ord(c) < 0) return 1

		-- pico-8 0.2.4d: added some operators for pico-8 help system
		if (strchr("@%$", c)) return 3
		if (strchr("#^?", c)) return 4
		if (strchr("(){}[]<>", c)) return 5
		
		if (strchr("!@#$%^&*:;.,~=+-/\\`'\"", c)) return 2;

		return 6 -- something else. whitespace
	end

	local function select_from_double_tap(line, pos, sel)

		checkpoint()

		local cat = get_char_cat(sub(line,pos,pos))
		
		local sel0 = pos;
		local sel1 = pos;
		
		
		while (sel0 > 1 and get_char_cat(sub(line,sel0-1,sel0-1)) == cat) do
			sel0 -= 1
		end

		while (sel1 < #line and get_char_cat(sub(line,sel1+1,sel1+1)) == cat) do
			sel1 +=1
		end

		set_selection{{line=cur_y, char=sel0}, {line=cur_y, char=sel1}}

	end


	local function calculate_skip_steps(dir)
		
		local line = text[cur_y]
		
		-- normal cursor movement: one character at a time
		if not key("ctrl") then
			if (dir < 0 and (cur_y > 1 or cur_x > 1)) return -1
			if (dir > 0 and (cur_y < #text or cur_x <= #line)) return 1
			return 0;
		end

		

		local pos = cur_x
		local cat0 = 0 -- unknown starting category
		
		while ((dir < 0 and pos > 1) or (dir > 0 and pos <= #line + 1)) do -- #line + 1 for \n

			if (dir < 0) pos += dir
			
			-- category of current char
			cat = get_char_cat(sub(line,pos,pos));
			
			-- found a character that disagrees with starting category -> end of span
			if ((cat0 > 0) and (cat != cat0)) then
				if (dir > 0 and pos > 0) pos -= 1

				if (cat0 == 6 and cat ~= 6) then
					-- skip whitespace and search for end of non-whitespace
					-- going left: jump to start of word; going right: jump to end of word
					cat0 = cat
				else
					return (pos - cur_x) + 1
				end
			end

			if (cat0 == 0 and cat != 0) then		
				cat0 = cat
			end

			if (dir > 0) pos += dir
		end

		if (dir > 0 and pos > 1) pos -= 1

		return pos - cur_x
	end


	local function comment_selection()
		local found_uncommented = false
		
		local something_selected = is_something_selected()
		local line1 = something_selected and sel[1].line or cur_y
		local line2 = something_selected and sel[2].line or cur_y

		for i=line1,line2 do
			if (text[i] and text[i]:sub(1,2) ~= "--") found_uncommented = true
		end		
			
		if found_uncommented then
			for i=line1,line2 do
				text[i] = "--"..text[i]
			end
		else
			-- uncomment all
			for i=line1,line2 do
				if (text[i]) text[i] = text[i]:sub(3)
			end
		end
	end


	local function indent_selection()

		checkpoint()

		line1, line2 = sel[1].line, sel[2].line
	
		if (key("shift")) then
			for i=line1, line2 do
				if text[i] and (ord(text[i],1) == 9 or sub(text[i],1,1) == " ") then
					text[i] = sub(text[i],2)
					if (i == sel[1].line) sel[1].char -= 1
					if (i == sel[2].line) sel[2].char -= 1
				end
			end
		else
			for i=line1,line2 do
				if (text[i]) text[i] = "\009"..text[i]
			end
			sel[1].char += 1
			sel[2].char += 1
		end


	end

	----------------------------------------------------------------------------------------------------------------

	local function search_text(dir, needle)
		local x = cur_x
		local y = cur_y

		if (is_something_selected()) then
			x = sel[2].char
			y = sel[2].line
			-- printh("starting at "..pod(sel[2]))
		end

		local start_x = x
		local start_y = y

		local first = true
		while (first or y != start_y) do

			local x0, x1 = string.find(text[y], needle, x, true)

			if x0 then
				sel[1].line, cur_y = y,  y
				sel[1].char, cur_x = x0, x0
				sel[2] = {line = y, char = x1}
				show_cursor(50, 80)
				set_cur_xp()
				return
			end
			y += 1 x = 1
			if (y > #text) y = 1
			first = false
		end

		notify("could not find: "..needle)

	end

	-- dupe for functions / markers
	-- search for "function ", strawberry src bookmark, or level 1~3 markup header (experimental)
	local function search_for_function(dir)
		local x = 1
		local y = cur_y + dir
		local start_x = x
		local start_y = y

		local first = true
		while (first or y != start_y) do
			
			if (text[y]) then
				local found = string.find(text[y], "function ", 1, true)
				if (not found) found = text[y]:sub(1,12) == "--[[BOOKMARK" and 1
				if (not found and text[y][1] == "#") then
					if (not found) found = text[y]:sub(1,2) == "# " and 1
					if (not found) found = text[y]:sub(1,3) == "## " and 1
					if (not found) found = text[y]:sub(1,4) == "### " and 1
				end
				if found then
					cur_x, cur_y = found, y
					show_cursor(50, 128) -- 128 to get subtle change in relative scroll y when wrap in code editor -- to do: generalise
					set_cur_xp()
					highlight_y = cur_y
					return
				end
			end
			y += dir 
			if (y > #text) y = 1
			if (y < 1) y = #text
			first = false
		end

	end

	local function block_closer(line)

		-- find first and last non-whitespace tokenoid
		local str, pos, cat, tok0, tok1
		pos = 1
		while (pos <= #line) do
			str, pos, cat = tokenoid(line, pos)
			if ((not tok0 or tok0 == "local") and cat==1) tok0 = str -- first identifier tokenoid (ignore "local")
			if (cat ~= 0) tok1 = str                                 -- last non-whitespace tokenoid
		end

		if (tok1 == "do" or tok1 == "then" or tok1 == "else") return "end"
		if (tok1 == "repeat") return "until"

		-- function definition
		if (tok0 == "function") return "end"

		return nil
	end

	function content:update()

		if (cur_y ~= highlight_y) highlight_y = nil

		self.width = 10000 -- hack; don't need to know width [yet]. but need to catch mouse events when scrolled to the right

		-- update content.margin_left1 -- adjusted dynamically when line numbers turned on/off
		content.margin_left1 = content.margin_left + (content.show_line_numbers and 28 or 0)

		-- discard hydrated lines when settings change (only show_tabs can be changed live for now)
		if (self.show_tabs ~= last_show_tabs) then
			hydrated = {}
			hydrate_y = 1
		end
		last_show_tabs = self.show_tabs

		-- rolling hydration (semi-lazy layout evaluation; spread out computation before e.g. jump to end of file)

		for i=1,20 do -- 0.2.0i: changed to 20 (was 5) -> 1200 lines per second
			if (hydrate_y > #text) hydrate_y = 1
			hydrate(hydrate_y)
			hydrate_y = hydrate_y + 1
		end

		local new_height = max(get_total_height() + 32, container.height) -- 32 px space at the bottom

		if (self.height != new_height) then
			self.height = new_height
			show_cursor()
		end


		content.clamp_scrolling()


		-- don't need to have focus -- can close from anywhere
		if (keyp("escape")) then
			if (container.search_box) then
				close_search_pane(container)
			else
				key_pressed_callback(self, "escape")
			end
		end
		

		if (self:has_keyboard_focus()) then

			-- clear text input buffer when gaining focus (assumes: no reason to every want existing buffer text)
			if (not self.last_keyboard_focus) then
				readtext(true)
			end

			while peektext() do
				backup_line_edit()
				local k = readtext()

				if (type(content.key_callback[k]) == "function") then
					content.key_callback(k)
				else
				
					delete_selected()
					text[cur_y] = insert_string(text[cur_y], cur_x, k)
					cur_x = cur_x + 1
					set_cur_xp()
					show_cursor()
				end
			end


			-- tab
			if (keyp("tab")) then

				if key_pressed_callback(self, "tab") then
					-- skip
				elseif (is_something_selected()) then
					indent_selection()
				else
					backup_line_edit()
					local k = "\009"
					delete_selected()
					text[cur_y] = insert_string(text[cur_y], cur_x, k)
					cur_x = cur_x + 1
					set_cur_xp()
					show_cursor()
				end
			end

			-- enter
			if (keyp("enter")) then

				if key_pressed_callback(self, "enter") then
					-- skip
				else

					checkpoint()

					-- find tabs & spaces at start to match indentation
					local whitespace=""
					local pos = 1
					while (pos <= #text[cur_y] and (sub(text[cur_y], pos, pos) == "\t" or sub(text[cur_y], pos, pos) == " ")) do
						whitespace ..= sub(text[cur_y], pos, pos)
						pos += 1
					end

					--split current line
					insert_line(cur_y + 1, whitespace .. sub(text[cur_y], cur_x))
					text[cur_y] = sub(text[cur_y], 1, cur_x-1)
					cur_x = 1 + #whitespace
					cur_y = cur_y + 1
					show_cursor()

					-- block
					if (key"shift") then
						local blc = block_closer(text[cur_y-1])
						if (blc) then
							insert_line(cur_y+1, whitespace..blc)
							text[cur_y] ..= "\t" -- indent
							cur_x += 1
						end
					end

				end
				set_cur_xp()
			end

			-- backspace
			if (keyp("backspace")) then
				backup_line_edit()
				if (is_something_selected()) then
					delete_selected()
				else
					delete_char()
				end
				show_cursor()
			end

			-- delete
			if (not key("shift") and keyp("delete")) then

				backup_line_edit()
				if (is_something_selected()) then
					delete_selected()
				elseif (cur_y < #text or cur_x <= #text[#text]) then
					-- dupe: same as pressing right and then backspace
					if (cur_x > #text[cur_y]) then
						if (cur_y < #text) then
							cur_x = 1
							cur_y = cur_y + 1				
						end
					else
						cur_x = cur_x + 1
					end
		 
					delete_char()
				end
				show_cursor()
			end


			-----------------------------------------------------
			-- cursor navigation
			-----------------------------------------------------
			local pressed_cursor_nav_key = false

			local nav_keys = {"left","right","up","down", "home","end", "pageup","pagedown"}

			for i=1,#nav_keys do
				local k = nav_keys[i]
				if keyp(k) then
					if key_pressed_callback(self, k) then
						-- callback called for this navigation key: ignore following logic
						clear_key(k)
					else
						pressed_cursor_nav_key = true
					end
				end
			end


			if pressed_cursor_nav_key then

				if (not is_something_selected()) then
					set_selection{{line=cur_y, char=cur_x}, {line=cur_y, char=cur_x-1}}
				end

				show_cursor()
			end


			if (keyp("left")) then
				if (cur_x < 2) then
					if (cur_y > 1) then
						cur_y = cur_y - 1				
						cur_x = #text[cur_y] + 1
					end
				else
					--cur_x = cur_x - 1
					cur_x += calculate_skip_steps(-1)
				end
				set_cur_xp()
			end
			if (keyp("right")) then
				if (cur_x > #text[cur_y]) then
					if (cur_y < #text) then
						cur_x = 1
						cur_y = cur_y + 1				
					end
				else
					cur_x += calculate_skip_steps(1)
				end
				set_cur_xp()
			end
			if (key("alt") and keyp("up")) then
				search_for_function(-1)
			elseif (key("alt") and keyp("down")) then
				search_for_function(1)
			elseif (keyp("up") or keyp("pageup")) then
				local n = keyp("pageup") and 20 or 1
				for i=1,n do
					if (cur_y < 2) then
						cur_x = 1
					else
						local xx = cur_xp and cur_xp or find_x_for_cur_x(cur_x, text[cur_y])
						cur_y = cur_y - 1
						cur_x = xx > 0 and 1 + find_cur_x_for_click(xx, text[cur_y]) or 1
						cur_x = mid(1, cur_x, #text[cur_y] + 1)
					end
				end
				contain_cursor()
			elseif (keyp("down") or keyp("pagedown")) then
				local n = keyp("pagedown") and 20 or 1
				for i=1,n do
					if (cur_y >= #text) then
						cur_x = #text[cur_y]+1
					else
						local xx = cur_xp and cur_xp or find_x_for_cur_x(cur_x, text[cur_y])
						cur_y = cur_y + 1
						cur_x = xx > 0 and 1 + find_cur_x_for_click(xx, text[cur_y]) or 1
						cur_x = mid(1, cur_x, #text[cur_y] + 1)
					end
				end
				contain_cursor()
			end

			if (keyp("home") or (key"ctrl" and keyp"up")) then
				if (key"ctrl") cur_y = 1
				cur_x = 1
				show_cursor()
				set_cur_xp()
			end

			if (keyp("end") or (key"ctrl" and keyp"down")) then
				if (key"ctrl") cur_y = #text
				cur_x = #text[cur_y]+1
				show_cursor()
				set_cur_xp()
			end

			
			if (pressed_cursor_nav_key) then

				-- hold shift to extend
				if (key("shift")) then
					extend_selection_to_cursor()
				else
					deselect()
				end

				-- keep cursor visible
				show_cursor()
			end

			-- alternative to ctrl-x: shift+delete (in same group as ctrl-insert for copy)

			if key("shift") and keyp("delete") then
				-- dupe from ctrl-x below
				checkpoint()
				set_clipboard(get_selected_text())
				delete_selected()
			end

			-- alternative to ctrl-v: shift+insert (in same group as ctrl-insert for copy)

			if key("shift") and keyp("insert") then
				-- dupe from ctrl-v below
				checkpoint()
				delete_selected()
				insert_multiline_string(get_clipboard(), cur_y, cur_x)
				show_cursor()
			end

			-- ctrl-* presses

			if (key("ctrl")) then

				if keyp("x") and is_something_selected() then
					checkpoint()
					set_clipboard(get_selected_text())
					delete_selected()
				end

				if (keyp("c") or keyp("insert")) and is_something_selected() then
					set_clipboard(get_selected_text())
				end

				if keyp("v") then
					checkpoint()
					delete_selected()
					insert_multiline_string(get_clipboard(), cur_y, cur_x)
					show_cursor()
				end

				if keyp("z") then
					undo_stack:undo()
				end

				if keyp("y") then
					undo_stack:redo()
				end

				if keyp("a") then
					set_selection{{line=1, char=1}, {line=#text, char=#text[#text]}}
				end
				
				if keyp("f") and content.has_search then
					open_search_pane(container, function ()
						local needle = container.search_field:get_text()[1]
						container.last_search_str = needle
						search_text(1, needle)	
					end)
				end

				if keyp("l") and content.has_search then
					open_search_pane(container, function ()
						local line_num = tostring(container.search_field:get_text()[1])
						if (line_num) then
							cur_y = mid(1, flr(line_num), #text)
							content.jump_to_line(cur_y)
--							show_cursor()
							set_cur_xp()
						end
					end, "Line:")
				end

				if keyp("g") and container.last_search_str then
					search_text(1, container.last_search_str)
				end

				if keyp("e") then  -- End
					cur_x = #text[cur_y]+1
					show_cursor()
					set_cur_xp()
				end

				if keyp("w") then  -- staWt
					cur_x = 1
					show_cursor()
					set_cur_xp()
				end

				-- ctrl+b: block comment
				if keyp("b") then
					checkpoint()
					comment_selection()
				end

				-- ctrl+d: duplicate line
				if keyp("d") then
					checkpoint()
					deselect()
					insert_line(cur_y, text[cur_y])
					cur_y += 1
					show_cursor()
				end

			end


		end -- keyboard focus

		self.last_keyboard_focus = self:has_keyboard_focus()

		contain_cursor()

--		printh(string.format("cpu %.3f",stat(1)),440,2,7)

	end



	-- ======================================================================================================================

	----------------------------------------------------------------------------------------
	-- undo
	----------------------------------------------------------------------------------------


	-- don't want to unpod(pod(text)) because only need separate copy of string references

	local function duplicate_text_table(text)
		local t2={}
		for i=1,#text do
			t2[i] = text[i]	
		end
		return t2
	end

	undo_stack = create_undo_stack(
		function() return {
			duplicate_text_table(text),
			cur_x,
			cur_y,
			content.x,
			content.y,
			pod(sel) -- to do: store as flat integer-indexed table for determinism (works fine in practice though)
		} end,

		function(s)
			text = s[1] 
			cur_x = s[2]
			cur_y = s[3]
			content.x = s[4]
			content.y = s[5]
			sel = unpod(s[6])

			show_cursor()
		end
	)

	

	-------------------------------------------------------------------------------------------------------------------------


	-- to do: how to manage scroll speed?
--[[
	function content:mousewheel(msg)
		if (key("ctrl")) then
			self.x += msg.wheel_y * 32 
		else
			self.y += msg.wheel_y * 32 
		end

	end
]]
	


	function content:click(msg)
		self:set_keyboard_focus(true)
		local cy = find_cur_y_for_click(msg.my)
		if (cy ~= cur_y) checkpoint()
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - content.margin_left1, text[cur_y])
		set_cur_xp()
		if (key("shift")) then
			-- add to selection
			sel[2] = {line=cur_y, char=cur_x-1}
		else
			-- no selection: start new one
			set_selection{{line=cur_y, char=cur_x}, {line=cur_y, char=cur_x-1}}
		end
		show_cursor()
		return true
	end

	-- stop tap messages inside editor from rising to parent
	function content:tap(msg)
		return true
	end

	function content:doubletap(msg)
		-- dupe from click
		local cy = find_cur_y_for_click(msg.my)
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - content.margin_left1, text[cur_y])
		select_from_double_tap(text[cur_y], cur_x, sel)
		return true
	end


	function content:drag(msg)
		-- dupe from click
		local cy = find_cur_y_for_click(msg.my)
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - content.margin_left1, text[cur_y])
		extend_selection_to_cursor()
		show_cursor()
		return true
	end

	
	-------------------------------------------------------------------------------------------------------------------------


	--[[
		allow caller to operate only only content
		ce = gui:attach_text_editor()
		ce:attach_scrollbars()  -- instead of ce.parent:attach_scrollbars()
	]]
	function content:attach_scrollbars(...)
		self.parent:attach_scrollbars(...)
	end

	
	-- container:attach_scrollbars()
	-- return container

	return content
end


return attach_text_editor


:: bios/lib/jettison.lua
--[[

	jettison kernal runtime functions so that they are not visible from userland
	rule: starts with single underscore followed by a..z

	-> not jettisoned:
		_VERSION
		__process_event_messages
]]

if (pid() > 3) then
	for k,v in pairs(_G) do
		if (sub(k,1,1) == "_" and ord(k,2,2) >= ord("a") and ord(k,2,2) <= ord("z")) then
			_G[k] = nil
		end
	end
end

-- sandboxed programs can not use the Debug library for now
-- (needs security review -- probably can be partially available at least)
if (env().sandbox) then
	Debug = nil
end


--[[
if (pid() > 3) then
	printh("----- candidates for jettison ------")
	local str = ""
	for k,v in pairs(_G) do
		if (sub(k,1,1) == "_" and #k > 3) then
			str..= k.." = nil\n"
		end
	end
	printh(str)
end
]]


:: bios/lib/legacy.lua
--[[

	deprecated

]]

if (false) then

	function notify_user(...)
		printh("*** DELETEME (LEGACY): notify_user")
		return notify(...)
	end

	function log(...)
		printh("*** DELETEME (LEGACY): log")
		return notify(...)
	end


	function print_p8scii(...)
		printh("*** DELETEME (LEGACY): print_p8scii")
		return print(...)
	end

	function set_window_title(title, description, location)
		printh("*** DELETEME (LEGACY): set_window_title")
		window{title = title, description = description, location = location}
	end

	function set_window_icon(icon)
		printh("*** DELETEME (LEGACY): set_window_icon")
		window{icon = icon}
	end


	function set_window(...)
		printh("*** DELETEME (LEGACY): set_window")
		return window(...)
	end

	function create_window(...)
		printh("*** DELETEME (LEGACY): create_window")
		return window(...)
	end

	function create_tab(location)
		printh("*** DELETEME (LEGACY): create_tab")
		window{tabbed   = true}
	end

	function Gui(...)
		printh("*** DELETEME (LEGACY): Gui")
		return create_gui(...)
	end


	--[[
	get_key_pressed = keyp
	get_key_state = key
	]]

end


:: bios/lib/mem.lua

local _map_ram = _map_ram
local _ppeek = _ppeek
local _ppeek4 = _ppeek4
local _set_spr = _set_spr
local _draw_map = _draw_map
local _unmap_ram = _unmap_ram

local _fetch_metadata_from_file = _fetch_metadata_from_file
local _load = load

--------------------------------------------------------------------------------------------------------------------------------
--   Memory
--------------------------------------------------------------------------------------------------------------------------------

local userdata_ref = {} -- hold mapped userdata references
local _current_map = nil -- defaults to 32x32 at end of this file
local _unmap -- defined below

function memmap(ud, addr, offset, len)
	if (type(addr) == "userdata") addr,ud = ud,addr -- legacy >_<
	if (_map_ram(ud, addr, offset, len)) then
		
		if (addr == 0x100000) then
			_unmap(_current_map, 0x100000) -- kick out old map
			_current_map = ud
		end
		userdata_ref[ud] = ud -- need to include a as a value on rhs to keep it held

		return ud -- 0.1.0h: allows things like pfxdat = fetch("tune.sfx"):memmap(0x30000)
	end
end

-- unmap by userdata
-- ** this is the only way to release mapped userdata for collection **
-- ** e.g. memmapping a userdata over an old one is not sufficient to free it for collection **
function unmap(ud, addr, len)
	if _unmap_ram(ud, addr, len) -- len defaults to full userdata length
	then
		-- nothing left pointing into Lua object -> can release reference and be garbage collected 	
		userdata_ref[ud] = nil
	end
end
_unmap = unmap

--------------------------------------------------------------------------------------------------------------------------------
--    Sprite Registry
--------------------------------------------------------------------------------------------------------------------------------

local _spr = {} 

-- add or remove a sprite at index
-- flags stored at 0xc000 (16k)
function set_spr(index, s, flags_val)
	index &= 0x3fff
	_spr[index] = s    -- reference held by head
	_set_spr(index, s) -- notify process
	if (flags_val) poke(0xc000 + index, flags_val)
end

-- 0.1.1e: only 32 banks (was &0x3fff). bits 0xe000 reserved for orientation (flip x,y,diagonal)
function get_spr(index)
	return _spr[flr(index) & 0x1fff]
end



function map(ud, b, ...)
	
	if (type(ud) == "userdata") then
		-- userdata is first parameter -- use that and set current map
		_draw_map(ud, b, ...)
	else
		-- pico-8 syntax
		_draw_map(_current_map, ud, b, ...)
	end
end




:: bios/lib/print.lua
--[[

	print.lua

]]

local _envdat = env()
local _pid = pid
local _print_p8scii = _print_p8scii
local _printh = _printh
local _tostring  = tostring
local _send_message  = _send_message

function printh(str)
	_printh(string.format("[%03d] %s", _pid(), _tostring(str)))
end

--	function print(str, x, y, col)
function print(...)

	local temp={...}
	if (#temp == 0) return $0x54f0, $0x54f4 -- NOP; return unmodified cursor position

	local str, x, y, col = ...

	-- print to back page if y is set or has a window (0x8) (if only x is set taken to be a colour command for printing to terminal)
	if y or ((peek(0x547f) & 0x8) > 0)
	then
		return _print_p8scii(str, x, y, col)
	end

	if (stat(315) > 0) then
		-- running headless; print to host terminal
		-- doen't happen after creating a window because will likely end up spamming console
		_printh(_tostring(str)) 
	else
		-- 0.2.0d: can set colour with print("blue",12")
		local colpref = ""
		if type(x) == "number" then
			if (x >= 0 and x <= 9) colpref = "\f"..chr(ord("0")+x)
			if (x >= 10) colpref = "\f"..chr(ord("a") + x-10)
		end
		-- when print_to_proc_id is not set, send to self (e.g. printing to terminal)
		_send_message(_envdat.print_to_proc_id or _pid(), {event="print",content=colpref .. _tostring(str)})

		-- lazily create terminal window to print to (!)
		-- allows ctrl+r to test commandline programs. input() does something similar
		if (_envdat.corun_program and not get_display()) then
			window()
			poke(0x547f, peek(0x547f) & ~0x8) -- not a graphical program though; print to terminal
		end

		-- allow message to be dispatched / received
		yield() -- depends how many slices end up being issued within a system frame (see boot)
		--flip(0x5) -- ditto; but works from inside coroutine
		--flip() -- quite slow, but consistent speed

	end

end

:: bios/lib/resources.lua
--[[pod_format="raw",created="2024-03-21 06:13:04",modified="2024-03-21 06:13:04",revision=0]]
--[[

	resources.lua

	on program boot, load everything in gfx/[0..9].gfx

	also: 0.map, 0.sfx

]]

local completed = false

local function _autoload_resources()

	-- save all open files to /ram/cart when running pwc (same pattern as util/save.lua)
	-- 0.2.1c: also look for external changes on host ~ PICO-8 style workflow when editing the .p64 file directly
	if (env().corun_program == "/ram/cart/main.lua") then
		on_event("save_working_cart_files_completed",function(msg)
			completed = true
		end)

		-- wait for all save messages to come back via wm, for up to 120 frames
		send_message(3, {event="save_working_cart_files", notify_on_complete=pid()})
		for i=1,120 do if (not completed) then flip() end end
		
		-- look for external changes (dupe from util/info.lua)
		found_external_changes = false
		local pwc = fetch("/ram/system/pwc.pod")
		cp(pwc, "/ram/system/pwcv1") -- ** subtle: doesn't read from the already modifed mount, because save_working_cart_files re-mounts for this purpose **

		function compare_path(path)
			local fn0 = "/ram/system/pwcv0"..path
			local fn1 = "/ram/system/pwcv1"..path
			if fstat(fn0) == "folder" then
				local l = ls(fn1) -- list fn1 so that can manually add files to .p64 in a text editor on host 
				if (l) then
					for i=1,#l do compare_path(path.."/"..l[i]) end
				end
			elseif path == "label.qoi" then
				-- ignore
			else
				local s0 = fetch(fn0, {raw_str=true})
				local s1 = fetch(fn1, {raw_str=true})
				if (s0 and s0 ~= s1) cp(fn1, "/ram/cart/"..path) found_external_changes = true 
			end
		end

		compare_path("")

		if (found_external_changes) then 
			notify("\^:007f41417f613f00 loaded external changes") 
			cp("/ram/system/pwcv1", "/ram/system/pwcv0")
		end

	end
	
	local gfx_files = ls("gfx") or {}

	for i=1,#gfx_files do
		local fn=gfx_files[i]
		local num = tonum(string.sub(fn,1,2)) or tonum(string.sub(fn,1,1))
		fn = "gfx/"..fn
		if (num and num >= 0 and num <= 31) then

			local gfx_dat = fetch(fn)
			if (type(gfx_dat) == "userdata") then

				-- item is a single spritesheet assumed to be 16x16 even tiles
				-- to do: make loading pngs easier? (currently always load as raw i32 userdata)
				
				local w,h = gfx_dat:width(), gfx_dat:height()
				w = w // 16
				h = h // 16

				-- load sprite bank from gfx_dat
				for y=0,15 do
					for x=0,15 do
						local sprite = userdata("u8",w,h)
						blit(gfx_dat, sprite, x*w, y*h, 0, 0, w, h)
						set_spr(x + y * 16 + num * 256, sprite, 0); -- no flags
					end
				end


			elseif (type(gfx_dat) == "table" and gfx_dat[0] and gfx_dat[0].bmp) then

--				printh("autoloading "..fn)

				-- format saved by sprite editor
				-- sprite flags are written to 0xc000 + index

				for i=0,#gfx_dat do
					set_spr(num * 256 + i, gfx_dat[i].bmp, gfx_dat[i].flags or 0)
				end
			end

		end
	end


	-- load default map layer if there is one (for PICO-8 style map())
	-- map0.map for dev legacy -- should use 0.map
	local mm = fetch("map/0.map") or fetch("map/map0.map")

	if (mm) then
		-- dev legacy: layers are stored in a sub-table. to do: can delete this later
		if (mm.layer and mm.layer[0] and mm.layer[0].bmp) memmap(mm.layer[0].bmp, 0x100000)
		
		-- set current working map
		if (mm[1] and mm[1].bmp) memmap(mm[1].bmp, 0x100000)
	end

	-- set starting tile size to size of sprite 0 (has authority; observed by map editor too)
	if (get_spr(0)) then
		local w, h = get_spr():attribs()
		poke(0x550e, w, h)
	else
		poke(0x550e, 16, 16)
	end

	-- load default sound bank (256k at 0x30000)
	local ss = fetch("sfx/0.sfx")
	if (type(ss) == "userdata") ss:poke(0x30000)
	

end


-- always autoload resources (even for a .lua file -- might be running main.lua from commandline)

_autoload_resources()
	


:: bios/lib/socket.lua
--[[

	socket.lua

	sock = socket("tcp://X.Y.Z.W:1234")
	?sock:status() 
	len = sock:write("hey")
	str = sock:read()          -- non-blocking
	sock:close()

]]

local Socket = {}

local _create_tcp_socket = _create_tcp_socket
local _create_udp_socket = _create_udp_socket
local _close_socket = _close_socket
local _read_socket = _read_socket
local _write_socket = _write_socket
local _sock_status = _sock_status
local _accept_socket = _accept_socket

-- to do: should [also] happen when garbage collected 
-- (or just time out; don't usually want long idle connections on backend anyway)
function Socket:close()
	if (not self.id) return
	_close_socket(self.id)
	self.id = 0 -- no longer associated with a PSOCKET
end


function Socket:new(attribs)

	if (type(attribs) == "string") attribs = {addr = attribs}

	-- need an address. "*" for server?
	if (not attribs.addr) return nil, "no address specified"

	-- split protocol from address
	local prot = attribs.addr:prot(true)
	if (prot) then
		attribs.addr = sub(attribs.addr, #prot + 4)
		attribs.prot = prot
	end

	-- convenience: tcp and udp addresses can contain port number
	-- ipv4 tcp://1.2.3.4:80
	-- ipv6 tcp://[1:2:3:4:5:6]:80
	if (attribs.prot == "tcp" or attribs.prot == "udp") then

		-- try ipv4
		local res = split(attribs.addr, ":", true)
		if (#res <= 2) then
			-- ipv4 or *
			if (type(res[2]) == "number") then 
				attribs.addr = res[1] -- could be "*"
				attribs.port = res[2]
			end
			-- test: convert to IPv4-mapped IPv6 address
			--[[
			if (attribs.addr ~= "*") then
				attribs.addr = "::ffff:"..attribs.addr
			end
			]]
		else
			-- ipv6: remove enclosing square brackets (if there are any) to extract port number
			local res1 = split(attribs.addr, "[", false)
			if res1 and res1[2] then
				res1 = split(res1[2], "]", false)
				if res1 then
					attribs.addr = res1[1]
					res1 = split(res1[2],":",true)
					if (res1 and type(res1[2]) == "number") then
						attribs.port = res1[2]
					end
				end
			end
		end

--		printh("new socket: "..pod{attribs})
	end

	local sock = attribs

	setmetatable(sock, self)
	self.__index = self

	-- printh(":new // attribs arg: "..pod(attribs))

	if sock.prot == "tcp" then
		if (not _create_tcp_socket) return nil, "socket implementation not available"
		sock.id, err = _create_tcp_socket(attribs.port, attribs.addr)		
		if (not sock.id) return nil, err or "_create_tcp_socket failed"
		return sock
	end

	if sock.prot == "udp" then
		if (not _create_udp_socket) return nil, "socket implementation not available"
		sock.id, err = _create_udp_socket(attribs.port, attribs.addr)		
		if (not sock.id) return nil, err or "_create_udp_socket failed"
		return sock
	end
	
	return nil, "socket protocol not found"
end

function Socket:read()
	return _read_socket(self.id)
end

function Socket:write(dat)
	return _write_socket(self.id, dat)
end

function Socket:status(dat)
	
	local ret = _sock_status(self.id) 

	if (ret) return ret

	-- socket either called :close() or remote host closed connection (fd no longer valid)
	return  self.id == 0 and "closed" or "disconnected"

end

function Socket:accept()
	local id = _accept_socket(self.id)
	if (id) then
		-- new socket accepted
		local sock = {
			id = id,
			port = self.port,
			addr = "[client_addr]" -- 
		}
		setmetatable(sock, self)
		self.__index = self
		return sock
	end
end


function socket(...)
	return Socket:new(...)
end

-- legacy; deleteme

function create_socket(...)
	printh("** FIXME: create_socket should be socket")
	return Socket:new(...)
end

:: bios/lib/theme.lua


local theme_dat = nil

function theme(which)

	-- fetch lazily
	if (not theme_dat) then
		theme_dat = fetch"/ram/shared/theme.pod"
		if (not theme_dat) then
			local sdat = fetch"/appdata/system/settings.pod"
			if (not sdat) sdat = fetch"/system/misc/default_settings.pod"
			if (sdat and sdat.theme) theme_dat = fetch(sdat.theme) -- if there is a theme file set in settings, use that
			if (not theme_dat) theme_dat = fetch"/appdata/system/theme.pod" or fetch"/system/themes/classic.theme"
			store("/ram/shared/theme.pod", theme_dat)
		end
	end

	return theme_dat[which]
end

on_event("modified:/ram/shared/theme.pod", function()
	-- replace only if this process is using theme data
	if (theme_dat) theme_dat = fetch"/ram/shared/theme.pod"
end)


:: bios/lib/undo.lua
--[[

	undo.lua

	my_stack = create_undo_stack(mysave, myload, pod_flags, item)
	
		function mysave()   -- return program state
		function myload(s)  -- load s into program state
		pod_flags           -- pod format for pod() -- (default to 0x81: simple rle has best patch_size/cpu/mem results in almost all cases)
		item                -- extra info that the caller can use (usually to identify which item)

]]


local Undo = {}

local create_delta = create_delta
local apply_delta = apply_delta

function Undo:reset()

	self.head_state_str = ""
	self.undo_stack = {}
	self.redo_stack = {}

	-- store initial state; first item in .undo_stack is treated as a dummy (live_state -> "")
	self:checkpoint()
end

function Undo:undo()

	if (#self.undo_stack < 2) return false -- nothing to undo ~ first item goes back to nil state

	if (#self.redo_stack == 0) self:checkpoint() -- might have made changes after head state

	-- return to checkpoint before head
	local prev_state_str = apply_delta(self.head_state_str, deli(self.undo_stack))
	add(self.redo_stack, create_delta(prev_state_str, self.head_state_str))
	self.load_state(unpod(prev_state_str), self.item)
	self.head_state_str = prev_state_str -- new head

	return true
end


function Undo:redo()

	if (#self.redo_stack < 1) return false -- nothing to redo

	local next_state_str = apply_delta(self.head_state_str, deli(self.redo_stack))
	add(self.undo_stack, create_delta(next_state_str, self.head_state_str))
	self.load_state(unpod(next_state_str), self.item)
	self.head_state_str = next_state_str -- new head

	return true
end



function Undo:checkpoint()

	-- from current to previously recorded checkpoint
	local live_state_str = pod(self.save_state(self.item), self.pod_flags)

	-- printh("live_state_str: "..#live_state_str)

	-- skip when no changes
	--> if save_state() returns two differen strings for the same state, will produce a nop checkpoint
		-- pod() is not deterministic because integer-indexed array length can vary unexpectedly:
		-- consider: a={[2]=2} ?pod(a)   (produces "{[2]=2}")   vs.  a={1,2}a[1]=nil ?pod(a) (produces "{nil,2}")
	if (live_state_str == self.head_state_str and #self.undo_stack > 0) then
		return false -- no change
	end

	local delta = create_delta(live_state_str, self.head_state_str)

	add(self.undo_stack, delta)
	self.head_state_str = live_state_str
	self.redo_stack = {}
	return true
end


function Undo:new(save_state, load_state, pod_flags, item)

	local u = {
		save_state = save_state,
		load_state = load_state,
		pod_flags  = pod_flags or 0x81, -- 0.2.0i: 0x81 is almost always optimal (was 0x0)
		item = item
	}

	setmetatable(u, self)
	self.__index = self

	u:reset()
	
	return u
end

--------------------------------------------------------------------------------------------------------------------------------
--    Undo
--------------------------------------------------------------------------------------------------------------------------------

function create_undo_stack(...)
	return Undo:new(...)
end





:: bios/lib/window.lua

local _envdat = env() -- keep a local copy for speed
local _pid = pid
local _set_draw_target = _set_draw_target
local _send_message  = _send_message
local _unmap = unmap

-- manage process-level data: dispay, env

-- reference to display and draw target owned by window.lua
local _disp = nil
local _target = nil

-- default to display
function set_draw_target(d)

	-- 0.1.0h: unmap existing target (garbage collection)
	_unmap(_target, 0x10000)
	
	d = d or _disp

	local ret = _target
	_target = d
	_set_draw_target(d)

	-- map to 0x10000 -- want to poke(0x10000) in terminal, or use specialised poke-based routines as usual
	-- draw target (and display data source) is reset to display after each _draw() in foot
	memmap(d, 0x10000)
	
	return ret

end

function get_draw_target()
	return _target
end

-- used to have a set_display to match, but only need get_display(). (keep name though; display() feels too ambiguous)
function get_display()
	return _disp
end

---------------------------------------------------------------------------------------------------

local first_set_window_call = true

local function set_window_1(attribs)

	-- to do: shouldn't be needed by window manager itself (?)
	-- to what extent should the wm be considered a visual application that happens to be running in kernel?
	-- if (_pid() <= 3) return

	attribs = attribs or {}


	-- on first call, observe attributes from env().window_attribs
	-- they **overwrite** any same key attributes passed to set_window
	-- (includes pwc_output set by window manager)

	if (first_set_window_call) then

		first_set_window_call = false

		poke(0x547f, peek(0x547f) | 0x8) -- window created; changes behaviour of print()
	
		if type(_envdat.window_attribs) == "table" then
			for k,v in pairs(_envdat.window_attribs) do
				attribs[k] = v
			end
		end

		-- set the program this window was created with (for workspace matching)

		attribs.prog = _envdat.argv[0]


		-- special case: when corunning a program under terminal, program name is /ram/cart/main.lua
		-- (search /ram/cart/main.lua in wrangle.lua -- works with workspace matching for tabs)

		if (attribs.prog == "/system/apps/terminal.lua") then
			attribs.prog = "/ram/cart/main.lua"
		end

		
		-- first call: decide on an initial window size so that can immediately create display

		-- default size: fullscreen (dimensions set below)
		if not attribs.tabbed and (not attribs.width or not attribs.height) then
			attribs.fullscreen = true
		end

		-- not fullscreen, tabbed or desktop, and (explicitly or implicitly) moveable -> assume regular moveable desktop window
		if (not attribs.fullscreen and not attribs.tabbed and not attribs.wallpaper and
			(attribs.moveable == nil or attribs.moveable == true)) 
		then
			if (attribs.has_frame  == nil) attribs.has_frame  = true
			if (attribs.moveable   == nil) attribs.moveable   = true
			if (attribs.resizeable == nil) attribs.resizeable = true
		end


		-- wallpaper has a default z of -1000
		if (attribs.wallpaper) then
			attribs.z = attribs.z or -1000 -- filenav is -999
		end

		-- clear background processing bits on first window() call; 
		-- need to set with window{background_updates=true} (0x40) and/or window{background_draws=true} (0x80)
		-- there might be a bit set by terminal for bootstrapping to get to this point
		poke(0x547f, peek(0x547f) & 0x3f)

	end

	-- video mode implies fullscreen

	if (attribs.video_mode) then
		attribs.fullscreen = true
	end


	-- setting fullscreen implies a size and position

	if attribs.fullscreen then
		attribs.width = 480
		attribs.height = 270
		attribs.x = 0
		attribs.y = 0
	end

	-- setting tabbed implies a size and position  // but might be altered by wm

	if attribs.tabbed then
		attribs.fullscreen = nil
		attribs.width = 480
		attribs.height = 248+11
		attribs.x = 0
		attribs.y = 11
	end

	-- setting new display size
	if attribs.width and attribs.height then

		local scale = 1
		if (attribs.video_mode == 3) scale = 2 -- 240x135
		if (attribs.video_mode == 4) scale = 3 -- 160x90
		local new_display_w = attribs.width  / scale
		local new_display_h = attribs.height / scale


		local w,h = -1,-1
		if (get_display()) then
			w = get_display():width()
			h = get_display():height()
		end

		-- create new bitmap when display size changes
		if (w != new_display_w or h != new_display_h) then
			-- this used to call set_display(); moved inline as it should only ever happen here

			-- 0.1.0h: unmap existing display (garbage collcetion)
			_unmap(_disp, 0x10000)

			_disp = userdata("u8", new_display_w, new_display_h)
			memmap(_disp, 0x10000)
			set_draw_target() -- reset target to display

			-- set display attributes in ram
			poke2(0x5478, new_display_w)
			poke2(0x547a, new_display_h)

			poke (0x547c, attribs.video_mode or 0)

			poke(0x547f, peek(0x547f) & ~0x2) -- safety: clear hold_frame bit
			-- 0x547d is blitting mask; keep previous value
		end
	end

	if (attribs.background_updates) poke(0x547f, peek(0x547f) | 0x40)
	if (attribs.background_draws)   poke(0x547f, peek(0x547f) | 0x80)

--		printh("set_window_1: "..pod(attribs))

	_send_message(3, {event="set_window", attribs = attribs})

end

-- set preferred size; wm can still override
function window(w, h, attribs)

	-- this function wrangles parameters;
	-- set_window_1 doesn't do any further transformation / validation on parameters

	if (type(w) == "table") then
		attribs = w
		w,h = nil,nil

		-- special case: adjust position by dx, dy
		-- discard other 
		if (attribs.dx or attribs.dy) then
			_send_message(3, {event="move_window", dx=attribs.dx, dy=attribs.dy})
			return
		end

	end

	attribs = attribs or {}
	attribs.width = attribs.width or w
	attribs.height = attribs.height or h
	attribs.parent_pid = _envdat.parent_pid

	return set_window_1(attribs)
end


-- fullscreen videomode with no cursor
function vid(mode)
	window{
		video_mode = mode,
		cursor = 0
	}
end

:: bios/lib/wrangle.lua
--[[pod_format="raw",created="2024-03-12 18:17:15",modified="2025-07-07 05:32:30",revision=4]]
--[[

	wrangle.lua

	// not designed to be customisible; aim to take care of 90% of cases with a minimal replacement for boilerplate.
	to customise: copy and modify (internals will not change [much] after 0.1) -- update: ha!

	// 0.2.1e note: should try to support old / minimal versions of wrangler from wm so that this implementation can be
	copied and modified even while still in development. e.g. okpal has own wrangler.

	wrangle_working_file(save_state, load_state, untitled_filename, get_hlocation, set_hlocation, state_hint)

	user supplies two callbacks, similar to create_undo_stack():

		save_state()          -- should return data (and optionally metadata)
		load_state(dat, meta) -- takes data and restores program state

	and 3 optional callbacks: 

		get_hlocation         -- return the string that goes after "#" in the location (e.g. foo.lua#33 -> "33")
		set_hlocation,        -- given the sub-location string (33), apply to editor state (jump to line 33)
		state_hint            -- used for efficient unsaved changes detection; return value can be anything,
		                         but should change when state of file /might/ have changed. more info: notebook.p64/main.lua

]]


local current_filename -- should be "current_location"

local last_synced_state = nil -- state at time of load / save (i.e. when known to be in sync with disk)
local last_synced_state_md5 = nil

local last_synced_hint_value = nil
local last_hint_value = nil
local unsaved_changes = false

-- deleteme; don't need the concept of staleness at the wrangler / wm level (can do everything with unsaved_changes())
local is_stale = false

local _env = env
local _send_message = _send_message
local split = split
local create_process = create_process
local _signal = _signal
local pid = pid
local fetch = fetch
local store = store

local save_state_callback_exists = nil -- used when generating menu items

function pwf()
	return current_filename
end

-- used by infobar to highlight line of code when opened from error messages
local highlight_from_env = env().highlight


local function update_menu_items()
	
	-- don't need -- can do file open, CTRL-I to get file info
	-- also: can hover over tab to see filename
	-- ** maybe: right click on tab gives a different tab-specific menu
	--    at the moment it is only really useful for "close tab", and maybe confusing that there is the same menu twice
--[[
	menuitem{
		id = "file_info",
		label = "\^:1f3171414141417f About "..current_filename:basename(),
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
	-- \^:1c367f7777361c00  -- i in circle
]]


	--** fundamental problem (maybe wrangler could tackle):
	--** when edit metadata, doesn't feel like anything changes on disk until save it
	--** But then Save As, what happens? Should wrangler store current metadata and pass it on?
--[[
	menuitem{
		id = "file_info",
		label = "\^:1c367f7777361c00 File Metadata",
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
]]
--	menuitem()

	menuitem{
		id = "open_file",
		label = "\^:7f4141417f616500 Open File",
		shortcut = "CTRL-O",
		action = function()
			local path = current_filename:dirname() -- same folder as current file (or "/")
			
			-- printh("ctrl-o path from wrangler: "..pod{current_filename, current_filename:dirname()})

			--create_process("/system/apps/filenav.p64", {path = path, window_attribs= {workspace = "current", autoclose=true}})

			local open_with = _env().argv[0]

			-- can assume when program is terminal, co-running /ram/cart and should use that to open the file (useful for developing tools that use file wrangler)
			--> use /ram/cart to run it.   //  allows wrangling files from load'ed cartridge; useful for tool dev
			if (open_with == "/system/apps/terminal.lua") then
				open_with = "/ram/cart/main.lua"
			end

			-- printh("open_with: "..open_with)

			create_process("/system/apps/filenav.p64", {path = path, open_with = open_with, window_attribs= {workspace = "current", autoclose=true}})
		end
	}

	-- open include save items when a save_state callback is provided
	if (save_state_callback_exists) then

		-- save file doesn't go through filenav -- can send straight to even handler installed by wrangle.lua
		if (current_filename:sub(1,10) == "/ram/cart/") then
			menuitem{
				id = "save_file",
				label = "\f6\^:7f4141417f616500 Save File (auto)",
				shortcut = "CTRL-S", -- ctrl-s is handled by window manager
				action = function() _send_message(pid(), {event = "save_file"}) return true end -- can still save just in case!
			}
		else
			menuitem{
				id = "save_file",
				label = "\^:7f4141417f616500 Save File",
				shortcut = "CTRL-S", -- ctrl-s is handled by window manager
				action = function() _send_message(pid(), {event = "save_file"}) end
			}
		end

		menuitem{
			id = "save_file_as",
			label = "\^:7f4141417f616500 Save File As",

			action = function() 
				local segs = split(current_filename,"/",false)
				local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
				create_process("/system/apps/filenav.p64", 
					{path=path, intention="save_file_as", use_ext = current_filename:ext(), window_attribs={workspace = "current", autoclose=true}})
			end
		}

	end

	menuitem("---")

end




local function set_current_filename(fn)
	fn = fullpath(fn) -- nil for bad filenames
	if (not fn) return false
	current_filename = fn
	window{
		title = current_filename:basename(),
		location = current_filename
	}
	update_menu_items() -- (auto) shown on /ram/cart files
	return true -- could set
end

function set_last_synced_state(content, hint_val)
	last_synced_state = pod(content, 0x3) -- to do: (efficiency) extract from caller store() / fetch() process which also uses format 0x3 by default
	last_synced_state_md5 = nil
	if (#last_synced_state > 0x40000) then
		-- when state string is > 256k (unusual), use md5 instead to save memory
		-- if dealing with a large file, preferable to conserve memory
		-- introduces tiny risk of collisions, but not very dangerous (skip a single version change every 3.4e+38 autosaves)
		last_synced_state_md5 = last_synced_state:md5()
		last_synced_state = nil -- allow to be garbage collected
	end

	-- reset 
	last_hint_value = nil
	unsaved_changes = false
	last_synced_hint_value = hint_val
	send_message(3, {event = "set_unsaved_changes", val = false, filename = fullpath(current_filename)})

	-- to do: maybe also maintain an unsaved_changes bit somewhere so that app can check status 
	-- (+ 2 other locations in this file where unsaved_changes is set)
	-- 

end


--[[
	wrangle_working_file() // the user-facing api

	untitled_filename is also used to specifiy default extension (foo.pal -> auto appends .pal on save)

	state_hint:
		should complete quickly and return value should change when there /might/ be unsaved changes
		always confirmed by last_synced_state comparison

	to do: move to table parameters if gets too unweildy
]]
function wrangle_working_file(save_state, load_state, untitled_filename, get_hlocation, set_hlocation, state_hint)

--[[
	-- to do: move to table parameters; review names
	local opt = {}

	if (type(save_state) == "table") then
		opt = save_state
		save_state = opt.save_state
		load_state = opt.load_state
		untitled_filename = opt.untitled_filename
		get_hlocation = opt.get_hlocation
		set_hlocation = opt.set_hlocation
	else
		opt = {
			save_state = save_state,
			load_state = load_state,
			untitled_filename = untitled_filename,
			get_hlocation = get_hlocation,
			set_hlocation = set_hlocation
		}
	end
]]
	save_state_callback_exists = save_state	

	local w = {
		save = function(w)
--			printh("## save "..current_filename..  " // unsaved_changes: "..tostr(w:unsaved_changes()))

			if (not save_state) return -- NOP if no callback defined

			local content, meta = save_state()
			if (not meta) meta = {}

			local err = store(current_filename, content, meta)

			if (err) then
				return err
			end

			set_last_synced_state(content, state_hint and state_hint())

			-- use callback to modify current_filename with new location suffix (e.g. foo.lua#23 line number changes)
			if (get_hlocation) then
				w:update_hloc(get_hlocation())
			end

		end,

		load = function(w)
			local content, meta = fetch(current_filename)
			local hloc = split(current_filename, "#", false)[2]

			-- call load_state() even when content is not found; might do some initialisation
			set_last_synced_state(content, state_hint and state_hint())
			load_state(content, meta)
			if (set_hlocation) set_hlocation(hloc, highlight_from_env)

			if not content and save_state then
				-- this is needed when working file doesn't yet exist -- want to set the synced state to the default program state
				--printh("could not load "..current_filename.." --> setting last synced state to current content")
				local content, meta = save_state()
				set_last_synced_state(content, state_hint and state_hint())
			end
			highlight_from_env = false -- first time only


			return content, meta
		end,


		update_hloc = function(w, newloc, extra)

			newloc = tostring(newloc) -- could be a number
			if (type(newloc) ~= "string") return

			current_filename = split(current_filename, "#", false)[1].."#"..newloc

			-- tell wm new location
			window{location = current_filename}

			-- apply the new location via the app callback (e.g. set cursor position in code editor)
			-- extra is a table of arbitrary parameters attached to "jump_to_hloc" messages
			-- ~ ephemeral options that shouldn't be stored in the location; e.g. {highlight = true} for the code editor
			if (set_hlocation) set_hlocation(newloc, extra)

		end,
		
		--[[
			unsaved_changes

			test for changes made by /this/ process since last load / save
			(there might still be changes made by another process or externally)
			currently expensive; later: can be a fallback if app doesn't supply its own unsaved_changes callback
				// update: not really that expensive
				// but in any case app might want finer control in deciding when unsaved changes exist
		]]
		unsaved_changes = function(w)

			local result

			if (not save_state) return false

			-- printh("@@ testing state (expensive)")

			local state1 = pod(save_state(), 0x3)

			result = not (
				(last_synced_state and last_synced_state == state1) or
				(last_synced_state_md5 and last_synced_state_md5 == state1:md5())
			)

			return result
		end

	}

	untitled_filename = untitled_filename or "untitled.pod"
	
	
	-- derive current_file
	
	cd(_env().path)

	-- look for current filename first in environment (location) and then on commandline

	if (fullpath(_env().location)) then
		current_filename = _env().location
	elseif (fullpath(_env().argv and _env().argv[1])) then
		current_filename = _env().argv[1] -- can only ever pass filename as first argument; match sandboxed access rule in terminal.lua::run_program_in_new_process
	else
		current_filename = untitled_filename -- last resort: use default
	end

	current_filename = fullpath(current_filename)

	if not fullpath(current_filename) then
		-- can't resolve: use /appdata. happens when e.g. /ram/cart is not available because sandboxed
		if type(untitled_filename) == "string" then
			current_filename = "/appdata/"..untitled_filename:basename()
		else
			current_filename = "/appdata/wrangler_undefined.txt"
		end
	end

	local current_file_exists = fstat(current_filename)

	-- when file doesn't exist, w:load() also serves to init state by calling load_state(nil, ..)
	-- to do: can this fail?
	w:load()

	-- create  -- 0.2.0h: no need! don't need to assume file exists, and normally don't want to e.g. write untitled.txt to the desktop
--[[
	if (not current_file_exists) then
		w:save() -- don't care about result
	end
]]

	-- tell window manager working file
	-- ** [currently] needs to happen after creating window **

	window{
		title = current_filename:basename(),
		location = current_filename,

		-- extend default timeout to 2 seconds. default in wm is 0.2 seconds
		-- can do this because save_file event sends "back save_file_completed" to wm.lua, and so timeout is almost never needed
		-- custom wrangler implementations should implement save_file_completed if set this value to > ~0.5
		-- using a short timeout is very low stakes; /maybe/ an autosave to /ram/cart will finish late for the requesting save or info command to observe the changes 
		-- but using a timeout that is too long can cause long pauses when running / saving when the save_file_completed message is never received by wm
		save_timeout = 2.0 
	}

	------ install events ------

	-- invoked directly from app menu, and by wm when about to run / save cartridge
	on_event("save_file", function(msg)
		-- if (msg.filename) current_filename = msg.filename -- ** 0.2.0h commented; dangerous! deleteme ~ seems nothing using this (use "save_file_as" instead)

		if (msg.autosave) then
			-- when auto-saving /ram/cart files, don't save if there are no unsaved changes. 
			-- otherwise: strawberry_src /ram/cart/main.lua getting clobbered by default code.p64 tab
			if (not w:unsaved_changes()) then
				if (msg.notify_on_complete) then
					-- still need to send "save_file_completed" message so that wm.lua::pending_saves can reach 0
					_send_message(msg.notify_on_complete, 
						{event = "save_file_completed", filename = current_filename, skipped = true, autosave = msg.autosave})
				end
				
				return
			end
		end

		-- save to current_filename

		_signal(43) -- short-lived high priority operation starting 
			local err = w:save()
			
			if (msg.notify_on_complete) then
				_send_message(msg.notify_on_complete, {event = "save_file_completed", filename = current_filename, err = err, autosave = msg.autosave})
			end
		_signal(44)
		
		if (err) then 

			notify(err) -- uncommented for 0.2.0i ~ was this commented because clobbering some other message?
			return err
	
		elseif not msg.autosave then -- autosaving /ram/cart files does not produce any notifications

			if (fullpath(current_filename) and fullpath(current_filename):sub(1,8) == "/system/") then
				notify("\^:0f19392121213f00 saved "..current_filename.." ** warning: changes to /system/ not written to disk **")
			else
				notify("\^:0f19392121213f00 saved "..current_filename)

			end
		end

	end)

	-- invoked by filenav intention
	on_event("open_file", function(msg)
		set_current_filename(msg.filename)
		w:load()
		update_menu_items()
	end)

	on_event("jump_to_hloc", function(msg)
		-- to do: the msg.extra pattern could be used for other events
		w:update_hloc(msg.hloc, msg.extra)
	end)

	-- invoked by filenav intention
	on_event("save_file_as", function(msg)
		
		if (set_current_filename(msg.filename)) then

			-- 0.1.0c: automatically add extension if none is given
			if (not current_filename:ext() and untitled_filename:ext()) then
				set_current_filename(current_filename.."."..untitled_filename:ext())
			end

			local err = w:save()
			if (err) then
				notify(err)			
			else
				notify("\^:7f4141417f616500 saved as "..current_filename) -- show message even if cart file
			end
		end
		
	end)


	-- autosave /ram/cart file when editor loses focus
	--> when editing multiple copies of same file: means the version auto-saved to disk is LAST EDITED, OR LAST CTRL-S'ed
		-- ahh.. unless that process continues doing something to change the state while in the background
		-- in that case it will keep clobbering after ctrl-r / ctrl-s. but that kind of makes sense!

	on_event("lost_focus", function(msg)

		if (sub(current_filename, 1, 10) == "/ram/cart/") then
			if (w:unsaved_changes()) then
				local err = w:save()
				if (err) notify(err) -- something fundamentally wrong if saving to /ram/cart is unsuccessful
			end
		end
	end)


	on_event("update", function(msg)

		-- optimisation: most of the time editor that is in foreground has unsaved changes
		-- also means state_hint doesn't need to be super lightweight 
		-- (works if not handling 2. below)
		--if (unsaved_changes) return

		local val
		if (state_hint) then
			--dtime()
			val = state_hint()	
			--dtime(0)
		else
			val = time()\1 -- poll every second
		end

		if (not last_synced_hint_value) last_synced_hint_value = val

		if (last_hint_value and val ~= last_hint_value) then

			-- switch changes on
			if not unsaved_changes then
				-- 1. if state hint doesn't match hint value at time of last save/load, then do more expensive test

				if (val ~= last_synced_hint_value) then 

--					dtime()
					local res = w:unsaved_changes()
--					printh("calculating unsaved changes (turn on)") dtime(1)

					if (res) then	
						send_message(3, {event = "set_unsaved_changes", val = true, filename = fullpath(current_filename)})
						unsaved_changes = true
					end

				end

			elseif (state_hint) then -- require that hint is implemented; otherwise too expensive

				-- 2.
				-- same pattern when returning to the state that was saved to disk (usually by undoing)
				-- expensive because need to keep doing expensive state comparisons, but is really nice!
				-- update: doesn't cause /that/ many state comparisons; normally not sitting at the same undo stack position
				-- problem is when polling because hint is not implemented; in that case don't do this step

				if (val == last_synced_hint_value) then
--					dtime()
					local res = w:unsaved_changes()
--					printh("calculating unsaved changes (turn off)") dtime(1)

					if (not res) then -- change no unsaved changes -> unsaved changes
						send_message(3, {event = "set_unsaved_changes", val = false, filename = fullpath(current_filename)})
						unsaved_changes = false
					end
				end
			end
		end

		last_hint_value = val

	end)


	update_menu_items()

	return w
end







:: bios/misc/load_widgets.lua

-- populate tooltray with widgets found in widgets.pod

local widgets = fetch"/appdata/system/widgets.pod"

-- default widgets if no file exists
-- (for no widgets, need to manually remove owl & clock, or store("/appdata/system/widgets.pod",{}) 
if (not widgets) then
	widgets = fetch"/system/misc/default_widgets.pod"
	store("/appdata/system/widgets.pod", widgets)
end


for i=1,#widgets do
	local widget = widgets[i]

	--printh("loading widget: "..pod(widget))
	create_process(widget.prog,{
		window_attribs = {workspace = "tooltray", x=widget.x, y=widget.y, width=widget.width, height=widget.height, had_frame=widget.had_frame},
		location = widget.location
	})
end



:: bios/misc/load_workspaces.lua
-- create and populate initial workspaces

if stat(317) == 0 then 

	local function open_editor(prog, filename)
		create_process(prog or "/system/apps/code.p64", {
			argv={filename},
			fileview = {{location=filename, mode="RW"}}
		})
	end

	local prog_for_ext = fetch("/appdata/system/default_apps.pod")
	if (type(prog_for_ext) ~= "table") prog_for_ext = {}

	-- 0.2.0h: want these files to exist before autosaved. new_cart.p64 is stripped of metadata
	cp("/system/misc/new_cart.p64", "/ram/cart")

	-- matches .workspaces in /system/misc/net_cart.p64 // to do: could iterate and open.lua -- same as load
	open_editor(prog_for_ext.lua or "/system/apps/code.p64", "/ram/cart/main.lua")
	open_editor(prog_for_ext.gfx or "/system/apps/gfx.p64", "/ram/cart/gfx/0.gfx")
	open_editor(prog_for_ext.map or "/system/apps/map.p64", "/ram/cart/map/0.map")
	open_editor(prog_for_ext.sfx or "/system/apps/sfx.p64", "/ram/cart/sfx/0.sfx")


end

-- desktop, wallpaper, tooltray

local sdat = fetch"/appdata/system/settings.pod"
local wallpaper = (sdat and sdat.wallpaper) or "/system/wallpapers/pattern.p64"
if ((stat(317) & 0x1) ~= 0) wallpaper = nil -- placeholder: exports do not observe wallpaper to avoid exported runtime/cart mismatch in exp/shared
if (not fstat(wallpaper)) wallpaper = "/system/wallpapers/pattern.p64"

-- start in desktop workspace (so show_in_workspace = true)
create_process(wallpaper, {window_attribs = {workspace = "new", desktop_path = "/desktop", wallpaper=true, show_in_workspace=true}})

create_process("/system/misc/tooltray.p64", {window_attribs = {workspace = "tooltray", desktop_path = "/appdata/system/desktop2", wallpaper = true}})


if stat(317) == 0 then -- no fullscreen terminal for exports / bbs player
	create_process("/system/apps/terminal.lua",
		{
			window_attribs = {
				fullscreen = true,
				pwc_output = true,        -- run present working cartridge in this window
			}
		}
	)
end



-- 0.2.0h moved from /systemstartup.lua so that can guarantee desktop workspace exists before running /appdata/system/startup.lua

if stat(317) > 0 then 
	-- player startup
	-- mount /system and anything in /cart using fstat

	function fstat_all(path)
		local l = ls(path)
		if (l) then
			for i=1,#l do
				local k = fstat(path.."/"..l[i])
				if (k == "folder") fstat_all(path.."/"..l[i])
			end
		end
	end
	fstat_all("/system")
	fstat_all("/ram/expcart")

	-- no more cartridge mounting (exports are only allowed to load/run the carts they were exported with)
	
	if ((stat(317) & 0x3) == 0x3) then -- player that has embedded rom 
		-- printh("** sending signal 39: disabling mounting **")
		-- _signal(39) -- used to be sent from boot; ~ see mount_p64_path 
	end

	create_process("/system/misc/load_player.lua")

	-- (don't need custom startup.lua -- the exported / bbs cart itself can play that role)

else

	-- populate tooltray with widgets
	create_process("/system/misc/load_widgets.lua")

	-- userland startup
	
	if fstat("/appdata/system/startup.lua") then
		-- 0.2.0h wait for desktop to exist before running startup so that apps launched there can find their target (desktop) workspace
		-- ref: https://www.lexaloffle.com/bbs/?tid=144387#comments
		-- for now, 30 frames is a safe bet (in fact, currently need 0 frames delay) and makes no visual difference
		-- to do: react to a signal from wm? maybe overkill
		for i=1,30 do flip() end
		create_process("/appdata/system/startup.lua")
	end

end




:: bios/misc/readme.txt
--[[pod_format="raw",created="2024-03-10 12:02:52",icon=userdata("u8",16,16,"0000010101010101010101010100000000010c0c0c0c0c0c0c0c0c0c0c0100000107010c0c0c0c0c0c0c0c0c0c0c01000001010c0c0707070707070c0c0c010000010c0c0c070707070707070c0c01000107010c0c0c0c0c0c070e070c0c01000001010c0c0707070c0707070c0c010000010c0c0c070e070c0c0c0c0c0c01000107010c0c070707070707070c0c01000001010c0c0c0707070707070c0c010000010c0c0c0c0c0c0c0c0c0c0c0c01000107010c0c0c0c0c0c0c0c0c0c01010000010101010101010101010101070100000101070707070707070707070c01000000010c0c0c0c0c0c0c0c0c0c01000000000001010101010101010101000000"),lowcol_icon=true,modified="2025-03-26 00:22:49",revision=64,stored="2024-03-10 12:03:12"]]-==================================================-
           Getting Started with Picotron 
-==================================================-


--[[pod_type="image"]]unpod("b64:bHo0AF4HAACACwAA8RlweHUAQyDwZATw-----9Zd8FaN8A2N8DyNUI3wTQ0QDRANAA3wDQ0ACwAh8DwHABKQDQADHwAj-Q8dAII6-QzwNC3wBC0AI-0PPQA3Og0ANgCTAA3wMh0gHfACFgBF0B3ADSkAwfAKDfAwHWAd8AANYBoAEWAWAKgEHTAN8C8NoA3gFwBRQA0QDTAGAJ4gDfAXLdD9C3AfADBQDQAfAJ4WDSANwB3wBx0jABIdfgBgIA3wD-0DLwBf8AUNAA1LAABTAB0ADQAqAJ8d4B1QDRD9BRApAAEiMC0lAIANAA3ADQANUBwBIAMNKwBxUA3gHdANUCsAEp1MAAEpADEQzRAnAD3AHTAoAABTAEFNIA0wKABSDTAtMA0sADFgDTD7AAwwACSNYCwAMyBNICwANRANgCwAYEAN8AAd4AcAETrVAEAQPQAdAQFwMA2wHQAd0CgANB0AHToAXkANYB0wOACBrRAdAA1ADaBcABnAbAAt8AMvAKnwCg2QHQAtAB2wwgAAOwEREAgAYDAN8AAt8IQAAi4AImAtrgARoLYAJCANXAAAagAvAB0yAAEAHgABoQFBHQAtgFYAADkBAjYAQTAdQA0aAAA6ABFdOAASXTYAEUAUABMghgAEhgFtID0wDQBtZgAAFwEGAgAxIA1AUwAA1wARAI8BBe4BARcCSF3wAR1oABQ9ZwIYYDwCITANJwACYQAAGAEGAgATIBAAMABNIJACCZwCC10BEiCGAFJNAC3wEuUCCyEAAlAAERCEAErwEv0LIQAM2QAFSgEQPVcAL-A0TgAEAzoBL-AzTQAKAZwAEz1RAAAtAKBQDbBdwA1QLfA4TAAB5AAVPUoA8gNQDcANME1wDSAtID3wNP0MQB3YAAGHAGBQDdAdYC13AWOQHfBUDRBVASHwNQADgIANMB3QHfBSzQLwJy0ATfAKrfARDVD9BHA98AIN8FKdAA3wCw2gDfAQDVD9BmANEB0wPYAN8EgdcA0ADUAt8AoNwDYDALMA8ALwBT0gDQBtMD1QHfBGHXAtQDoAkOAN8A4dED3wAR0CsA0APTA9MF3wSB2gwQP4AQsN8AEN8CQdgC0AHYAd8FAWAOAjDcA9oA3wPK1gLQAdYCQBEAkjA9jwIB2QnZAd8DjtQB0QGACwHw1ALRAdMB0wHRB5AGA3PRAtED0kABBQYwSACA1AjUAN8B4hASAdQIQDwB0gLSAN8DYtIC0gLS4BEmAnADAwDYBVAlEdTTAdQCsAaDBN8DQ9gCMAESCLA3AgDfAlDTBNTQHVMA3wOw0AHTAtMB0wXSUAANoD8QIgDfAkDSCNIF0gDfA5LUBNQJ4CBWsAIBBN9wRA8CNNEKwCUT0QTfA4aQAHJwCQBU0wjTBN8CZd9gRKAF3wPUYAsgI9EC3gLRA98CJNFwVAAF3wO98ARC1ADTAlAABtA1AgLcAtIA8CAPcAACkAUCBd8DFtigQTQCcA4dAdMC0gLaAtIC0wHfAePgDyAwAN8Db9LWAdYC0g7SAtYB3wIRUA8wQ1DfAtDUANkC0wrTAtkA3wIQ0gLACRQA2wPeA9sA3wZQAxLfA03gMCAgAArgOB0E2gTdAN8BzPAEkQHfAyIABgIA3wAf0B-gETGQQBMvAxDc0ACAQAADcEgPAEzfAEDfAXfwRZDUAd8C9JAO8ADfAnDfAUHZBNQA3wLhsAAHATDUAtMA0AmAHwAS0NAP0pAB3wKQ3wEQ0gnRCHARIsJwACFgBAEE0gPZwAQQAd8DMsAGEN8CsN8BatBhIAfwMCnQEyIB0ACgARPRcAIgkNKgAxFR0gpwMWACoAAtUDAeEDoj2grSAd8C0N8BnMAx41IwAABAhBHXANMCcAEBi8AQYnABUgJQAyAB2Q4gQQL7cHAGYGL-A2TAACNYC9MCUAAMQALvA2TABijSANkA0gJwAB5gYfAE4ABCM9MKIIIPAxUgAB0AINnACAHQANID0QvSAUAQOPA0-wFg0w7wAGQD0QzVAsAD5gDVAsAAlYAPABjRA9ID0gDcANsA1ADVANoI0EWhH9A-AwVwABCgCAEA1gHSBNIE0IAgD1AhGwLQABbQQeMIYAQe0gXTAzAgArCQArAEmQHfAFLQCwIB0A-QwgjbBNoA0PBIKQTbANgD3wBH4A0v0C8AnN8AE98Agt8AEMCFEd8AD9AdECIPAA3gDAoA3wBR0Q-QAQHfAEcAlxXQAd8AEN4PQCIP0DfQCMMN3wB-0E8AYeAACHAAB8AhGgwAGAwA3wCP0A8AdLB2KN8ALt8DIiAAFCAAkeADN98AMeABACEgdy0A3wCG0AfRwAMG3wBCwABB4AYAPdMA3wBxEBuW3wBg1wDQBtII1wIQABXgAg8AZBAEEFDYCN2AcRDSMA8BEx-TDwBP0A8AP9CUANAP0R8FHtcB1wTUD9APABHcB9ILAD0YtdAB0gHTD9AKBd4H1OBfAGk-0X8AV9QC3wlW0g-QLwxw2QDfDUBQAS0woA8ABATfDWDSAN8Nwt8P---0c=")

Congratulations on being the new owner of your very 
own Picotron Fantasy Workstation!

This is a quick guide to get you started using
Picotron and creating your own cartridges.

** Workspaces **

Press ALT+LEFT or ALT+RIGHT to cycle through desktop
workspaces. Click and drag the toolbar to reveal a
tooltray.

** Customizing your Desktop **

You can open the system settings via the Picotron 
menu (top left) or by typing settings at the prompt.
To create your own lists of themes, wallpapers and
screensavers, create the following folders:

/appdata/system/themes
/appdata/system/wallpapers
/appdata/system/screensavers

** Creating a Program **

Picotron always has a global cartridge sitting in RAM
at /ram/cart ready to be edited. Click on the code
workspace (it looks like "()" at the top right) and
type in a program:

function _draw()
	cls(1)
	for i=1,24 do
		circ(240,135, i*t(), i)
	end
end

Now hit CTRL-R to run it. You can do this from
anywhere -- CTRL-R means: "run whatever is in
/ram/cart", and the entry point for any cart is
always main.lua.

To stop a running program, press ESC and then ESC
once more to return to the last desktop workspace.

To create a windowed program, the window size can
be set with: window(width, height), or to run at
different resolution use the vid() function:

	vid(0) 480x270
	vid(3) 240x135
	vid(4) 160x90

Some handy functions to get started:
	
	cls(col) -- clear the screen to a colour (0..63)
	circfill(x,y,radius,col) -- filled circle
	line(x0,y0,x1,y1,col) -- draw a line
	spr(index,x,y) -- draw a sprite
	map() -- draw the default map
	sfx(index) -- play a sfx
	music(index) -- play a pattern
	
Picotron programs can define a function called _draw
that is called each frame, _update that is always
called at 60fps, and _init that is called once when
the program is run.
	
** Saving a Cartridge **

From terminal, use the save command:

/>save mycart

An extension will automatically be added (.p64) and
the contents of /ram/cart will be stored in that
cartridge. Inside Picotron, cartridges are folders, so
you can open them up and look inside! But in the real
world they are stored as single .p64 or p64.png files.

** Commands **

Some handy commands:

ls			list the current directory (folder)
cd			change directory (e.g. cd /desktop)
mkdir		create a folder
folder		open the current folder in your Host OS
open		open a file with an associated editor

To create your own commands, put .p64 or .lua files
in /appdata/system/util.


** Running a Cartridge **

There are some demos in /system/demos:

> cd /system/demos
/system/demos> load carpet.p64

Cartridges are also like regular applications that can
be opened by double clicking on them, or typing their
name from the command prompt. If the cartridge
creates a new fullscreen workspace, you can close it
by pressing ESC and then right-clicking on the
workspace icon.


** GFX Editor **

The second workspace is a sprite editor. Each .gfx
file contains up to 256 sprites, and if the filename
starts with a number, it can be indexed by the map
editor.

Don't forget to save your cartridge after drawing
something -- the default filenames all point to
/ram/cart and isn't actually stored to disk until
you use the save command (or CTRL-S to save the
current cartridge)

s			select
space		pan
f/v			flip selection horizontall or vertically
cursors	move selection
ctrl-c		copy selection
ctrl-v		paste to current sprite
ctrl-b		paste big (2x2)
tab			toggle RH pane
-,+			navigate sprites
ctrl		modify some draw tools (fill)
rmb		pick up colour

Draw sprites from your program with spr(index, x, y).
0.gfx is loaded automatically.


** MAP Editor **

Changes made to /ram/cart/gfx/0.gfx automatically
show up in the map editor.

The map editor uses similar shortcuts, with a few
changes in meaning. For example, f and v also flip
selected tiles, but also set special bits on those
tiles to indicate that the tile itself should also
be drawn flipped. The map() command also observes
those bits.


** SFX Editor **

There are 3 modes to the SFX editor: an instrument
(synth patch) designer, SFX editor (for playing
sequences of notes) and a pattern editor, for
arranging SFXs into groups to play music.

Each instrument is a tree of nodes that can either
create or modify an audio signal. Please refer to the
PFX6416 design document for details:

https://www.lexaloffle.com/dl/docs/picotron_synth.html

Basic node instrument editing:

Click and drag a knob to turn it
Right mouse draw to adjust the range of a knob
Click and drag an envelope to a knob field
-> The envelope now applies to that range

Press SPACE while in the instrument editor to
kill all sound.

** Saving a PNG Cartridge **

To create a .p64.png ready to be uploaded to the
BBS, first capture a label while running it (ctrl-7)
and then save it with a .p64.png filename extension.
To print a title and author/version on the label,
type: about mycart.p64.png

** Loading a BBS Cartridge **

> load #cart_id

This loads the cart with a temporary filename in
/ram. Don't forget to save somewhere to disk if
you want to keep any changes.



** Reading Games Controllers **

Use btn(index) to read the state of game controllers:

	0,1,2,3		Stick L,R,U,D
	4,5  			Buttons: O, X
	6,7  			(reserved)
	8,9,10,11		Secondary Stick
	12,13,14,15  Buttons, SL, SR
	
A secondary stick is not guaranteed on all platforms!
It is preferable to offer an alternative control
scheme that does not require it, if possible.

Keyboard controls are currently hard-coded:

	0~5 	Cursors, Z/X
	8~11	ADWS
	12,13	F,G
	14,15	Q,E


--------------

There are still many unfinished and rough corners
but I hope you enjoy messing around with this first
version. See you on the BBS!

-- zep

:: bios/pm/pm.lua
--[[

	procman.lua

	Process Manager

	doesn't have much to do!
	process slices are run from the kernel mainloop

]]


function _update()

	-- to do: adjust process cpu allocations based on previous frame
	
	-- headless script: shutdown when no userland processes remaining
	if (stat(315) > 0 and #_get_process_list() <= 3) _signal(33)

	-- exported player: shutdown when no userland processes remaining
	-- to do: this test no longer works
	if (stat(317) > 0 and #_get_process_list() <= 3) _signal(33)

end


local file_subscribers = {}

-- request from a userland process to subscribe to a file
-- generated by on_event("modified:...", ...)
-- to do: periodically sweep dead process ids from file_subscribers 
on_event("_subscribe_to_file",
	function(msg)
		local fn = msg.filename_kernal -- if filename is garbage, will just never be triggered		
		if (type(fn) ~= "string" or type(msg.filename_userland) ~= "string") return
		--printh("_subscribe_to_file "..pod{msg})
		file_subscribers[fn] = file_subscribers[fn] or {}
		add(file_subscribers[fn], {proc_id = msg._from, filename_userland = msg.filename_userland})
	end
)

-- generated by store()
on_event("_file_stored",
	function(msg)
		local subscribers = file_subscribers[msg.filename]
		if (not subscribers) return
		for i=1, #subscribers do
			-- printh("sending to subscriber "..pod(subscribers[i]))
			send_message(subscribers[i].proc_id,
			{
				event = "modified:"..subscribers[i].filename_userland,
				filename = subscribers[i].filename_userland,
				proc_id = msg.proc_id
			})
		end
	end
)

-- some settings (e.g. fullscreen) need to be observed by the runtime on change
on_event("modified:/appdata/system/settings.pod", function(msg)
	_apply_system_settings(fetch(msg.filename))
end)



on_event("kill_process", 
	function(msg)

		-- silentely refuse to kill system processes: kernel, process manager, window manager
		-- commented; fun to kill these processes! can have useful error screen when core processes have crashed
		-- if (msg.proc_id < 3) return

--		printh("killing process via message "..tostr(msg.proc_id))

		_kill_process(msg.proc_id)

	end
)

on_event("restart_process", 
	function(msg)
		-- printh("[pm.lua] restart_process: "..msg.proc_id)
		_kill_process(msg.proc_id, 1) -- 1 means restart
		send_message(msg.proc_id, {event = "unpause"})
	end
)


on_event("open_host_path", 
	function(msg)
		_open_host_path(msg.path)
	end
)

-- placeholder; to do: allow communication by program name?
on_event("broadcast",
	function (msg)

		local pl = _get_process_list()

		for i=1,#pl do
			if (pl[i].id > 3) then
				send_message(pl[i].id, msg.msg)
			end
		end

	end
)

-- to do: care about who is asking!
on_event("shutdown",
	function()
		_signal(33)
	end
)

on_event("reboot",
	function()
		_signal(34)
	end
)

on_event("mount_host_desktop",
	function()
		_signal(65)
	end
)

on_event("export",

	function(msg)
		-- cart info in a format exporter can read easily

		if ((msg._flags & 0x1) == 0) return -- invoked by a trusted system app (/system/tools/export.lua)

		memset(0,0,4096)

		poke(0x000, ord(msg.shortname, 1, min(#msg.shortname,255)))
		poke(0x100, ord(msg.outfile, 1, min(#msg.outfile,255)))
		poke(0x200, ord(msg.cartfile, 1, min(#msg.cartfile,255)))
		if (type(msg.export_home) == "string") then
			poke(0x300, ord(msg.export_home, 1, min(#msg.export_home,255)))
		end

		-- current active palette for icon: use wm palette
		for i=0,255 do
			poke(0x400+i, _ppeek(3,0x5000+i))
		end

		if (msg.icon) then 
			-- icon width, height
			poke(0x500, msg.icon:width(), msg.icon:height()) -- only 16x16 supported in 0.2 though
			poke(0x800, msg.icon:get(0,0,256))			
		else
			-- to do: default icon here
			
		end

		_signal(42)

	end

)




:: bios/startup.lua
--bios-like thing

--_printh("** startup")

--bare minimum
create_process("/system/pm/pm.lua")
create_process("/system/wm/wm.lua")

for i=1, 50 do flip() end --initialise pm & wm

--bios cart

if (fstat("/system/bios.p64")) then
	--_printh("** BIOS booting")
	create_process("/system/bios.p64", {window_attribs={fullscreen=true}})

else
	_printh("** BIOS runtime not found!")
end
:: bios/util/config.lua
--[[pod_format="raw",created="2025-06-19 10:38:05",modified="2025-06-20 06:09:44",revision=86]]

argv = env().argv

-- default settings
-- (currently only used as a list of keys)
settings = 
{
	battery_saver=false,
	blit_720p=false,
	snap_to_grid=false,
	floppy_windows=false,
	fullscreen=true,
	mute_audio=false,
	network_access=true,
	pixel_perfect=true,
	rshift_magnify=false,
	sparkles=false,
	squishy_windows=false,
	stretch=false,
	swap_stereo=false,
--	system_volume=64, -- to do
	theme="/system/themes/aqua.theme",
	wallpaper="/system/wallpapers/patchwork.p64"
}

keys = {}
for k,v in pairs(settings) do
	add(keys,k)
end
for j=1,#keys-1 do
for i=1,#keys-1 do
	if (keys[i] > keys[i+1]) keys[i],keys[i+1]=keys[i+1],keys[i]
end
end


sdat = fetch("/appdata/system/settings.pod")

if (not argv[1]) then
	
	for i=1,#keys do
		local k,v = keys[i], sdat[keys[i]]
		print(string.format("\^h%s\^g\-z\-z\-z\-z\-z  \fe%s",k..":",tostr(v)),6)
	end
	print("To change a value, use: \f7config [key] [value]",13)
	exit(0)
end

-- find current
k = argv[1]

if (not argv[2]) then
	print(k..": \fe"..tostring(sdat[k]))
	exit(0)
end

-- set value
if (settings[k] ~= nil) then
	v = argv[2]
	if (v == "nil") v = nil
	if (v == "true") v = true
	if (v == "false") v = false
	if (v == "on") v = true
	if (v == "off") v = false
	
	sdat[k] = v
	store("/appdata/system/settings.pod",sdat)
	print("set "..k.." to \fe"..tostring(sdat[k]))
	exit(0)
end

print("key not found: "..k)
:: bios/util/cp.lua
--[[
	cp src dest

	to do:
		-r recursive  //  cp() is currently recursive though!
		how to do interactive copying? (prompt for overwrite)
]]

cd(env().path)
local argv = env().argv

if (argv[1] == "--help") then
	?"usage: cp [options] src dest"
	?"options:"
	?"-f force overwrite of a folder"
	?"-n no clobber (do not overwrite existing files)"
	exit(0)
end


local force_folder_overwrite = false
local no_clobber = false

local files = {}

for i=1,#argv do
	local v = argv[i]
	if (sub(v,1,1) == "-") then
		if (v == "-f") force_folder_overwrite = true
		if (v == "-n") no_clobber = true
	else
		add(files, v)
	end
end

local src = files[1]
local dest = files[2]

if (not src or not dest) then
	print("usage: cp [options] src dest")
	exit(1)
end

local src_type  = fstat(src)
local dest_type = fstat(dest)


if (not src_type) then
	print("could not find "..src)
	exit(1)
end

-------

-- using . or .. always means copy inside
if (dest == "." or dest == "..") dest ..= "/"

-- when destination is a folder, put inside the folder instead of copying over it
if (dest_type == "folder" and not force_folder_overwrite) then
	if (sub(dest,-1,-1) == "/") then

		copy_inside = true -- take as an explicit indication (when copying p64)
		dest = sub(dest,1,-2) -- cut off trailing /
	
		local segs = split(fullpath(src),"/",false)
		dest = dest .. "/" .. segs[#segs]
		dest_type = fstat(dest) -- update 
	end
end

if (no_clobber and fstat(dest)) then
	print("skipping copy over existing file: "..dest)
	exit(0)
end

if dest_type == "folder" and 
	not force_folder_overwrite and not copy_inside
then

	-- refuse to copy over a folder

	print("can not copy over a folder / cartridge.")
	print("  to copy inside: cp a.p64 b.p64/")
	print("  to force overwrite: cp -f a.p64 b.p64")
	exit(1)

else

	local existed = fstat(dest)

	if (existed) then
		local res = input("\feoverwrite "..dest:basename().."? \f7[y/n] ", 0x2)
		if (res ~= "y" and res ~= "Y") exit()
	end


	local err = cp(src, dest)

	if (err) then
		print(err)
	else
		if (existed) then
			print("copied "..src.." \feover\f7 "..dest)
		else
			print("copied "..src.." to "..dest)
		end
	end
end




:: bios/util/default_app.lua
--[[pod_format="raw",created="2025-07-15 02:15:51",modified="2025-07-15 02:15:51",prog="bbs://strawberry_src.p64",revision=0,xstickers={}]]

local dat = fetch("/appdata/system/default_apps.pod")
if (type(dat) != "table") dat = {}



if (type(env().argv[1]) ~= "string") then
	
	print("\fdUsage: \f7default_app ext path_to_program")
	print("\fcSets the default application for a given file extension.")
	print("\fde.g.: \f7default_app loop /apps/tools/loop_editor.p64")
	print("\fdBBS cart: \f7default_app lua bbs://strawberry_src.p64")
	print("\fcTo remove a default app: \f7default_app lua")
	print("\fcTo list current extensions: \f7default_app -l")
	exit()
end

if env().argv[1] == "-l" then
	for k,v in pairs(dat) do
		print("\fe"..k.." \f7"..v)
	end
	exit()
end

local ext = env().argv[1]
local prog = env().argv[2]

-- #foo shorthand for bbs:// carts
if (type(prog) == "string" and prog[1] == "#") then
	prog = "bbs://"..prog:sub(2)
	if (prog:ext() ~= ".p64") prog..=".p64"
end


if (not prog) then
	if (not dat[ext]) then
		print("there is no app set for that extension")
	else
		print("\f7removing default app for extension: \fe"..ext)
		print("\f6(was: \fe"..tostr(dat[ext]).."\f6)")
		dat[ext] = nil
		store("/appdata/system/default_apps.pod", dat)
	end
else

	if (not fstat(prog)) then
		print("could not find "..prog)
		exit()
	end

	-- modify entry
	dat[ext] = fullpath(prog)
	store("/appdata/system/default_apps.pod", dat)
	print("\f7set \fe."..ext.."\f7 files to be opened with \fe"..prog)
end



:: bios/util/dir.lua
--[[pod_format="raw",created="2023-17-26 21:17:14",modified="2024-04-04 08:23:25",revision=6]]
cd(env().path)

local path0 = env().argv[1] or "."

-- to do: why is this resolving to / when directory no longer exists? maybe terminal is validating pwd?
path = fullpath(path0)

if (not path) then
	print("could not resolve path "..tostr(path0))
	exit(0)
end

local res=ls(path)

if (not res) then
	print("could not find path "..tostr(res))
	exit(0)
end


-- stat each file and show which ones are directories (except for .p64s)
for i=1,#res do

	if (string.sub(res[i],-4) ~= ".p64" and
		 string.sub(res[i],-8) ~= ".p64.rom" and
		 string.sub(res[i],-8) ~= ".p64.png"
		) then
		if (fstat(path.."/"..res[i]) == "folder") then res[i] = res[i].."/" end 
	end

end

if (res) then
	-- to do: pick cols that will fit display width
	-- easiest method: just start at and decrease until fits (or increase until doesn't fit)
	local cols = 2

	-- to do: ahh.. how to get terminal width?
	--printh("target width: "..(get_draw_target() and get_draw_target():width() or 0))

	for i=1,#res,cols do
		local str=""
		for j=0, cols-1 do
			if (i+j <= #res) then
				local col = "6"
				if (sub(res[i+j],-4)==".lua") then col="c" end
				if (sub(res[i+j],-4)==".txt") then col="a" end -- documents: yellow
				if (sub(res[i+j],-4)==".pod") then col="9" end
				--if (sub(res[i+j],-4)==".png") then col="b" end -- images: green?
				--if (sub(res[i+j],-4)==".p64") then col="s" end

				if (
					string.sub(res[i+j],-4) ~= ".p64" and
					string.sub(res[i+j],-8) ~= ".p64.rom" and
					string.sub(res[i+j],-8) ~= ".p64.png"
				) then
					local attrib, size, mount_point = fstat(path.."/"..res[i+j])
					if (attrib == "folder") col = "e"
					if (mount_point) col = "b"
				end

				-- to do: find out width of neighbour and adjust precisely
				str = str .. "\f"..col..res[i+j]
				for k=0,(20 - #res[i+j]) do
					str = str .. " "
				end
				str ..= " " -- make sure there is at least one space between columns

			end
		end
		print(str)
	end
else
print("could not list")
end

:: bios/util/edit.lua
--[[

	edit a file

	choose an editor based on extension [and possibly content if needed]

	** never runs the file -- up to caller to manage that depending on context **

	used by:
		filenav.p64: double click on file
		load.lua: to restore workspace tabs
		open() // can be used from sandboxed programs

]]

cd(env().path)


local argv = env().argv
if (#argv < 1) then
	print("usage: open filename")
	exit(1)
end

-- future: could be a list per extension (open a chooser widget)

local prog_for_ext = fetch("/appdata/system/default_apps.pod")

if (type(prog_for_ext) ~= "table") prog_for_ext = {}

prog_for_ext.lua   = prog_for_ext.lua   or "/system/apps/code.p64"
prog_for_ext.txt   = prog_for_ext.txt   or "/system/apps/notebook.p64"
prog_for_ext.pn    = prog_for_ext.pn    or "/system/apps/notebook.p64"
prog_for_ext.gfx   = prog_for_ext.gfx   or "/system/apps/gfx.p64"
prog_for_ext.map   = prog_for_ext.map   or "/system/apps/map.p64"
prog_for_ext.sfx   = prog_for_ext.sfx   or "/system/apps/sfx.p64"
prog_for_ext.pod   = prog_for_ext.pod   or "/system/apps/podtree.p64"
prog_for_ext.theme = prog_for_ext.theme or "/system/apps/themed.p64"
prog_for_ext.p8    = prog_for_ext.p8    or "/system/apps/view.p64"
prog_for_ext.png   = prog_for_ext.png   or "/system/apps/view.p64"
prog_for_ext["p8.png"]   = prog_for_ext["p8.png"]   or "/system/apps/view.p64"


local show_in_workspace = true



for i = 1, #argv do

	if (argv[i] == "-b") then
		-- open in background
		show_in_workspace = false
	elseif (argv[i] == "-j") then
		-- jump to matching window if one exists
		force_jump = true
	elseif (argv[i] == "-n") then
		-- force open in new window / tab
		force_new_window = false
	elseif fullpath(argv[i]) then

		-- for each file in args list
		filename = fullpath(argv[i])

		-- default: jump to existing editor for cart files, but open in a new window otherwise
--		local jump_to_matching_window = filename:sub(1, 10) == "/ram/cart/"
		local jump_to_matching_window = false -- could be a system-wide option?

		-- override with env().jump_to_matching_window
		if (env().jump_to_matching_window ~= nil) jump_to_matching_window = env().jump_to_matching_window -- set by infobar
		-- -j / -n has final say
		if (force_jump) jump_to_matching_window = true
		if (force_new_window) jump_to_matching_window = false


		if (fstat(filename) == "folder") then

			-- open folder / cartridge
			create_process("/system/apps/filenav.p64", 
			{
				argv = {filename},
				window_attribs = {show_in_workspace = show_in_workspace}
			})

		else

			local prog_name = prog_for_ext[filename:ext()]
			if (not prog_name) then
				-- no preferred program to open with; check metadata for recommended bbs:// program
				-- (bbs:// only -- maybe dangerous to allow un-sandboxed programs to open a file that 
				-- could be crafted to exploit some weakness in that program's loader)
				-- note: bbs program includes the version number! could optionally strip it here
				-- to do: run most recent version by default? [if online]
				local meta = fetch_metadata(filename)
				if (meta and meta.prog and meta.prog:prot() == "bbs") prog_name = meta.prog
			end

			if (prog_name) then
				
				-- tabs are orded by process id, so these will show up in the same order
				-- (see wm.lua "add to tabs")

				create_process(prog_name,
					{
						argv = {filename},
						fileview = {{location=filename, mode="RW"}}, -- let sandboxed app read/write file
						window_attribs = {
							show_in_workspace = show_in_workspace,
							jump_to_matching_window = jump_to_matching_window
						},
						highlight = env().highlight -- used by wrangler; sent by infobar when [ctrl-]click on error message to open new tab
					}
				)

--				flip() flip() flip() flip()

			else
				-- to do: use podtree (generic pod editor)
				print("no program found to open "..filename)

				notify("no program found to open "..filename)
			end
		end
	else
		print("could not resolve: "..argv[i])
		printh("could not resolve: "..argv[i])
	end
end

:: bios/util/export.lua
--[[pod_format="raw",created="2024-08-02 21:52:44",modified="2024-08-05 01:31:27",revision=149]]
--[[

	export:

		foo.html 
		foo.p64.png
		foo.bin
]]

cd(env().path)

src_cart = "/ram/cart" -- to do: allow export something else

local outfile = nil
local extras_file = nil

local index = 1
while index <= #env().argv do
	local val = env().argv[index]
	if (val[1] == "-") then
		-- some option
		if (val=="-e") then
			extras_file = env().argv[index + 1]
			index += 1
		end
	else
		outfile = val
	end
	index += 1
end

for i=1,#env().argv do
	local val = env().argv[i]
	if (val[1] == "-") then
		-- some option
	else
		outfile = val
	end
end

outfile = fullpath(outfile)


ext = type(outfile) == "string" and outfile:ext() or ""

supported_ext = {
	["p64.png"] = true,
	["html"] = true,
	["bin"] = true
}

if (type(outfile) ~= "string" or not supported_ext[ext]) then
	print("export usage: export [outfile]")
	print("outfile format is determined by extension:")
	print("  .p64.png\t png cartridge (bbs format)")
	print("  .html   \t single html file")
	print("  .bin    \t windows, linux and mac binaries")
	exit()
end



-- export .p64.png -- just copy
if (ext == "p64.png") then
	rm(outfile) -- to require -f to copy over cart?
	cp(src_cart, outfile)
	print("saved a copy as "..outfile)
	exit()
end


-- prepare cart for exporting

local cartfile = "/ram/expcart.p64.rom"

if (ext == "bin" or ext == "html") then
	print(string.format("exporting %s", outfile))
	flip()

	rm(cartfile) -- safety; to do: shouldn't be necessary
	-- save the cart to export in .rom format
	cp(src_cart, cartfile)
	-- strip sandbox metadata -- avoid zoo of edge cases 
	store_metadata(cartfile, {sandbox=false})

	_,cartfile_size = fstat(cartfile)
	print("\fsrom size: "..cartfile_size.." bytes")
	flip()
end


-- export binary players
if (ext == "bin") then

	if (cartfile_size >= 1024*1024*32) then
		print("\f8** too big! **")
		print("\f6max binary export rom size: 33,554,432 bytes")
		exit()
	end


	mkdir(outfile) -- foo.bin

	local meta = fetch_metadata(src_cart) or {}

	local icon = meta.export_icon
	if (type(icon) ~= "userdata" or icon:width() ~= 16 or icon:height() ~= 16) icon = meta.icon
	if (type(icon) ~= "userdata" or icon:width() ~= 16 or icon:height() ~= 16) then
		-- default: pink/purple cart icon
		icon = unpod("b64:bHo0ADMAAAA-AAAA-gdweHUAQyAQEATwAPEB1xEHvxIHEQe_BADwCNcRF48OJxEXjRcNEbcNAQABvQEQwfAD")
	end

	-- extras
	rm("/ram/exp_extras")
	mkdir("/ram/exp_extras")
	if (fstat(extras_file)) then
		cp(extras_file, "/ram/exp_extras")
	end


	--[[
		export_home is optional -- used when exported cartridge should have its own separate home directory, 
		with separate drive (and thus a separate /desktop, /appdata/system/settings.pod etc).

		export_home should contain only a-z,_ and be not too long. resulting home will be something like:
			~/.lexaloffle/Picotron/exp/foo
		when no export_home is given in the cart metadata, exports can read/write other exports' data at:
			~/.lexaloffle/Picotron/exp/shared
	]]

	print("\fgplease wait...")
	flip()

	send_message(2, {
		event = "export",
		cartfile = cartfile,
		shortname = outfile:basename():sub(1,-5),
		outfile = outfile,
		icon = icon,
		export_home = meta.export_home or ""
	})

	for i=1,60 do flip() end

	print("\fb[ok]")
--	print("ok") -- to do: is lie; have no idea what the result was / is going to be
	
	exit()
end


--- html

if (cartfile_size >= 1024*1024*8) then
	print("\f8** too big! **")
	print("\f6max html export rom size: 8,388,608 bytes")
	exit()
end

dat = fetch(cartfile) -- .p64.rom raw data

local shell_str = fetch("/ram/system/exp/exp_html.p64.rom/shell.html")

-- grab metadata

meta = fetch_metadata(src_cart) or {}
title = meta.title or "Picotron Cartridge"

print(title)

shell_str = shell_str:gsub("##page_title##", title)

-- generate label if there is one
if (fstat(src_cart.."/label.png")) then
	cp(src_cart.."/label.png", "/ram/label.bin")
	labelpng = fetch"/ram/label.bin" -- fetch raw bytes without .png extension
	
	-- abuse pod() format to get base64 suitable for data url
	b64str = pod("@"..labelpng, 0x24):sub(24,-3)
	b64str = b64str:gsub("_","+")
	b64str = b64str:gsub("-","/")
	--b64str = table.concat(split(b64str,76),"\n")
	
	-- insert data url
	shell_str = shell_str:gsub("##label_file##", "data:image/png;base64,"..b64str)

end

--- generate cart+player

strs = {"\n"}

add(strs, "p64cart_str=\"")

fmt = string.rep("%02x", 1024)

for i=0,#dat\1024 do
	local idx = 1 + i*1024
	local num = min(1024, #dat - idx + 1)
	if (num > 0) then
		--print(pod{idx,num})
		if (num < 1024) fmt = string.rep("%02x", num)
		chunk = string.format(fmt, ord(dat, idx, num))
		add(strs, chunk)
	end
end
add(strs,"\"")
add(strs,";\n")

export_home = meta.export_home or ""
add(strs, "export_home_str = \""..export_home.."\";\n")

local player_str = fetch("/ram/system/exp/exp_html.p64.rom/picotron_player.js")
add(strs, player_str)

picotron_js = table.concat(strs)

strs = nil -- free some memory for the file write

-- why doesn't this work? too big? ("invalid capture index %8")
--store(outfile, 
--	shell_str:gsub("##pcart##", picotron_js),
--	{metadata_format="none"})

-- to do: file appending; otherwise size of cart that can be exported
-- is extra limited by these string operations

local q = string.find(shell_str, "##pcart##") + 10

store(outfile, 
	shell_str:sub(1,q)..picotron_js..shell_str:sub(q+1),
	{metadata_format="none"})


print("\fb[ok]")



:: bios/util/folder.lua
--[[pod_format="raw",created="2023-29-10 02:29:44",modified="2023-29-10 02:29:44",revision=0]]
cd(env().path)
local path = fullpath(env().argv[1] or ".")

if (not path) then
	print("could not resolve path")
	exit(1)
end


if (path:sub(1,5) == "/ram/" or path == "/ram") then
	print("can not open a ram folder on host")
	exit(1)
end

-- send a message to process manager
send_message(2, {event="open_host_path", path = path})

:: bios/util/help.lua
print
"\
\fe\128 Picotron Cheatsheet\
\
\f7 ls (or dir)       \fd list files in the current folder\
\f7 cd <directory>    \fd change directory (folder)\
\f7 mkdir <directory> \fd create a directory\
\f7 load <filename>   \fd load a cartridge (.p64) into /ram/cart\
\f7 save <filename>   \fd save /ram/cart back to a .p64 file\
\f7 reset             \fd reset draw state\
\
\f7 CTRL-R            \fd run the loaded cartridge\
\f7 ESC               \fd stop program or toggle between editor and output\
\f7 CTRL-L            \fd clear the terminal\
\
\fcTo try out a demo:\
\f7$ cd /system/demos\
$ load highway\
\
\fc.. and then CTRL-R to run it\
"



:: bios/util/info.lua
-- info.lua: show info about the present working cartridge (/ram/cart)

-- (dupe from save.lua) save all files and metadata
local completed = false
local num_files = 0
on_event("save_working_cart_files_completed",function(msg)
	completed = true
	num_files = msg.num_files -- num files saved because editors were open, not total files in the cart
end)
-- save all files and metadata (note: normally already saved as happens in wrangler on lost_focus)
-- wait for all save messages to come back via wm, for up to 120 frames
send_message(3, {event="save_working_cart_files", notify_on_complete=pid()})
for i=1,120 do if (not completed) then flip() end end

send_message(3, {event="save_open_locations_metadata"}, true)

---

local pwc = fetch("/ram/system/pwc.pod")

mkdir("/ram/temp") -- to do: should be allowed to assume this exists?
cp("/ram/cart", "/ram/temp/cartsize.p64.rom")
kind, size = fstat("/ram/temp/cartsize.p64.rom")


print("\fecurrent cartridge: "..pwc)

-- size jumps around because timestamp in metadata changes
if (size) then
	local p = (size * 1000 / (256*1024))\1 / 10
	print("compressed rom: "..size.." bytes \fd("..p.."%)")
end

-- blocking
local pwc_unsaved_changes = send_message(3, {event="pwc_unsaved_changes"}, true).result

if (pwc_unsaved_changes) then
	print("\128 cartridge has unsaved changes",9)
else
--	exit() -- nothing more to do
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- show external changes (same happens on run in /system/lib/resources.lua)

found_external_changes = false
cp(pwc, "/ram/system/pwcv1") -- ** subtle: doesn't read from the already modifed mount, because save_working_cart_files re-mounts for this purpose using _signal(39)**

function compare_path(path)
	local fn0 = "/ram/system/pwcv0"..path
	local fn1 = "/ram/system/pwcv1"..path
	if fstat(fn0) == "folder" then
		local l = ls(fn1) -- list fn1 so that can manually add files to .p64 in a text editor on host 
		if (l) then
			for i=1,#l do compare_path(path.."/"..l[i]) end
		end
	elseif path == "label.qoi" then
		-- ignore
	else
		local s0 = fetch(fn0, {raw_str=true})
		local s1 = fetch(fn1, {raw_str=true})
		if (s0 and s0 ~= s1) print("\f9[external changes]\f6 "..path:sub(2)) found_external_changes = true
	end
end

compare_path("")
----------------------------------------------------------------------------------------------------------------------------------------------------------------


if (found_external_changes) then
	?"\f6external changes means that the cartridge file was modified on disk "
	?"\f6since the last time it was loaded or saved inside picotron."
	?"-> to load external changes, run with ctrl-r"
	?"\fd(or to discard them, use ctrl-s to save over them)"
end






:: bios/util/kill.lua

-- send a message to process manager
send_message(2, {event="kill_process", proc_id = tonum(env().argv[1])})

:: bios/util/load.lua


if env().print_to_proc_id then -- to do: -i or env().ignore_unsaved_changes
	local pwc_unsaved_changes = send_message(3, {event="pwc_unsaved_changes"}, true).result

	if (pwc_unsaved_changes) then
		local res = input("\fediscard unsaved changes? \f7[y/n] ", 0x2)
		if (res ~= "y" and res ~= "Y") exit()
	end
end


cd(env().path)

local argv = env().argv
if (#argv < 1) then
	print("\f6usage: load filename -- can be file or directory")
	print("-u to load unsandboxed")
	exit(1)
end

local filename = nil
local unsandbox = false

for i=1,#argv do
	if (argv[i][1] == "-") then
		if (argv[i] == "-u") unsandbox = true
	elseif not filename then
		filename = argv[i]
	end
end


-- load an earlier version of cartridge via anywhen
-- when not explicitly using the anywhen protocol
-- 0.2.0i: commented (deleteme); confusing to have 2 different format
-- and can use filenav foo.p64/@ now to browse versions (easier than typing in times)
-- future: anywhen time browser with visual calendar and utf->local conversion
--[[
if (not filename:prot() not filename:find("/@") and filename:find("@")) then

	filename, when = unpack(split(filename, "@", false))
	filename = fullpath(filename)

	-- expand when into full local time string
	
	local padding = "0000-01-01 00:00:00"
	
	if (when:find(":") == 3) -- 0.2.0i: fixed -- was "(when:find(":"))" breaking all loads with time part specified ._.
	then
		-- time at start: prefix with date
		local now_local = date("%Y-%m-%d %H:%M:%S")
		when = now_local:sub(1,11)..when
	end

	-- pad remaining time
	when ..= padding:sub(#when + 1)

	-- convert to UTC
	when = date(nil, when, stat(87))

	--...

	local loc = "anywhen:/"..filename.."@"..when
	print("fetching: "..loc)

	local a = fetch(loc)
	if (type(a) == "string") then
		-- switcheroony
		filename = "/ram/anywhen_temp."..filename:ext()

--		print("opening as "..filename)
		rm(filename) -- deleteme: relic of debugging store() over existing file
		store(filename, a)
	else
		print("could not locate")
		exit(0)
	end

end
]]

if (not filename:prot(true) and not filename:find("/@") and filename:find("@")) then

	print("this format is no longer supported", 14)
	print("try: \f7open "..split(filename,"@")[1].."/@ \f6instead", 6)
	exit()
end


-- bbs cart: "load #foo" is shorthand for "load bbs://foo.p64"

if (filename:sub(1,1) == "#") then
	filename = "bbs://"..filename:sub(2)..".p64"
end


attrib = fstat(filename)
if (attrib ~= "folder") then
	-- doesn't exist or a file --> try with .p64 extension
	filename = filename..".p64"
	if (fstat(filename) ~= "folder") then
		print("could not load")
		exit(1)
	end
end


-- remove currently loaded cartridge
rm("/ram/cart")

-- create new one
local result = cp(filename, "/ram/cart")
if (result) then
	print(result)
	exit(1)
end

-- keep a copy for comparing external changes
cp("/ram/cart", "/ram/system/pwcv0")

-- set current project filename

store("/ram/system/pwc.pod", fullpath(filename))


-- tell window manager to clear out all workspaces
send_message(3, {event="clear_project_workspaces"})
send_message(3, {event="reset_pwc_unsaved_changes"})


meta = fetch_metadata("/ram/cart")

if (meta and type(meta.runtime) == "number" and meta.runtime > stat(5)) then
	print("** warning: this cart was created using a future version of picotron.")
	print("** some functionality might be broken or behave differently.")
	print("** please upgrade to the latest version of picotron.")
end


if (meta) dat = meta.workspaces

--[[ deleteme
	dat = fetch("/ram/cart".."/.workspaces.pod")
	if (not dat) printh("*** could not find\n")
]]

-- legacy location;  to do: deleteme
if (not dat) then
	dat = fetch("/ram/cart/_meta/workspaces.pod")
	if (dat) printh("** fixme: using legacy _meta/workspaces.pod")
end

-- legacy location;  to do: deleteme
if (not dat) then
	dat = fetch("/ram/cart/workspaces.pod")
	if (dat) printh("** fixme: found /workspaces.pod")
end

-- at the very least, open main.lua if it exists
if ((type(dat) ~= "table" or #dat == 0) and fstat("/ram/cart/main.lua")) then
	dat = {{location="main.lua"}} -- relative to /ram/cart/
end

if (type(dat) == "table") then

	-- open in background (don't show in workspace)
	local edit_argv = {"-b"}

	for i=1,#dat do

		local ti = dat[i]
		local location = ti.location or ti.cproj_file -- cproj_file is dev legacy
		if (location) then
			--print("/ram/cart/"..location)
			add(edit_argv, "/ram/cart/"..location)
		end
	end

	-- open all at once
	create_process("/system/util/open.lua",
		{
			argv = edit_argv,
			pwd = "/ram/cart"
		}
	)

end

print("\f6loaded "..filename.." into /ram/cart")

if (filename:prot() == "bbs") then
	local bbs_id = split(filename:basename(),"-.",false)[1]

	if (unsandbox) then
		print("\fe[unsandboxed] \f6cart has R/W access to picotron drive /*")
		store_metadata("/ram/cart", {sandbox = false})
	else
		print("\fcsandboxed to /appdata/bbs/"..bbs_id)
		print("\fd// to load unsandboxed: load #"..split(filename:basename(),".",false)[1].." -u")  -- -u at end so that easy to add
	end
--	print("\fesandboxed to /appdata/bbs/"..split(filename:basename(),"-.",false)[1].." \fd-- to unsandbox, type: about")
end

if (not env().print_to_proc_id) then
	local m = "\^:007f41417f613f00 loaded cartridge: "..filename:basename()
	notify(m)
end






:: bios/util/ls.lua
--[[pod_format="raw",created="2023-17-26 21:17:14",modified="2024-04-04 08:23:25",revision=6]]
cd(env().path)

local path0 = env().argv[1] or "."

-- to do: why is this resolving to / when directory no longer exists? maybe terminal is validating pwd?
path = fullpath(path0)

if (not path) then
	print("could not resolve path "..tostr(path0))
	exit(0)
end

local res=ls(path)

if (not res) then
	print("could not find path "..tostr(res))
	exit(0)
end


-- stat each file and show which ones are directories (except for .p64s)
for i=1,#res do

	if (string.sub(res[i],-4) ~= ".p64" and
		 string.sub(res[i],-8) ~= ".p64.rom" and
		 string.sub(res[i],-8) ~= ".p64.png"
		) then
		if (fstat(path.."/"..res[i]) == "folder") then res[i] = res[i].."/" end 
	end

end

if (res) then
	-- to do: pick cols that will fit display width
	-- easiest method: just start at and decrease until fits (or increase until doesn't fit)
	local cols = 2

	-- to do: ahh.. how to get terminal width?
	--printh("target width: "..(get_draw_target() and get_draw_target():width() or 0))

	for i=1,#res,cols do
		local str=""
		for j=0, cols-1 do
			if (i+j <= #res) then
				local col = "6"
				if (sub(res[i+j],-4)==".lua") then col="c" end
				if (sub(res[i+j],-4)==".txt") then col="a" end -- documents: yellow
				if (sub(res[i+j],-4)==".pod") then col="9" end
				--if (sub(res[i+j],-4)==".png") then col="b" end -- images: green?
				--if (sub(res[i+j],-4)==".p64") then col="s" end

				if (
					string.sub(res[i+j],-4) ~= ".p64" and
					string.sub(res[i+j],-8) ~= ".p64.rom" and
					string.sub(res[i+j],-8) ~= ".p64.png"
				) then
					local attrib, size, mount_point = fstat(path.."/"..res[i+j])
					if (attrib == "folder") col = "e"
					if (mount_point) col = "b"
				end

				-- to do: find out width of neighbour and adjust precisely
				str = str .. "\f"..col..res[i+j]
				for k=0,(20 - #res[i+j]) do
					str = str .. " "
				end
				str ..= " " -- make sure there is at least one space between columns

			end
		end
		print(str)
	end
else
print("could not list")
end

:: bios/util/mkdir.lua

cd(env().path)

if (not env().argv[1]) then
	print("usage: mkdir path")
	exit(1)
end
local path = env().argv[1]

if (fstat(path) == "folder") then
	print("directory already exists")
	exit(1)
end

if (fstat(path) == "file") then
	print("file already exists")
	exit(1)
end

err = mkdir(path)

if (err) then
	print(err)
end

:: bios/util/mount.lua
--[[pod_format="raw",created="2023-27-22 05:27:04",modified="2023-30-22 05:30:21",revision=2]]
cd(env().path)

local target = env().argv[1]
local origin = env().argv[2]

if (not target or not origin) then
	print("mount target origin")
	exit(1)
end

if (fstat(target)) then
	print("target already exists: "..target)
	exit(1)
end

if (not fstat(origin)) then
	print("origin not found: "..origin)
	exit(1)
end

if (not fullpath(target)) then
	print("could not resolve target path")
	exit(1)
end

local kind = fstat(origin)

print("mounting "..kind.." "..origin.." at "..target)

mount(target, origin)

:: bios/util/mv.lua
--[[
	mv src dest

	same semantics as cp except:
		1. keep original creation date
		2. remove original file
]]

cd(env().path)
local argv = env().argv

if (argv[1] == "--help") then
	?"usage: mv [options] src dest"
	?"options:"
	?"-f force overwrite of a folder"
	?"-n no clobber (do not overwrite existing files)"
	exit(0)
end


local force_folder_overwrite = false
local no_clobber = false

local files = {}

for i=1,#argv do
	local v = argv[i]
	if (sub(v,1,1) == "-") then
		if (v == "-f") force_folder_overwrite = true
		if (v == "-n") no_clobber = true
	else
		add(files, v)
	end
end

local src = files[1]
local dest = files[2]

if (not src or not dest) then
	print("usage: mv [options] src dest")
	exit(1)
end

local src_type  = fstat(src)
local dest_type = fstat(dest)


if (not src_type) then
	print("could not find "..src)
	exit(1)
end

-------

-- using . or .. always means copy inside
if (dest == "." or dest == "..") dest ..= "/"

-- when destination is a folder, put inside the folder instead of copying over it
if (dest_type == "folder" and not force_folder_overwrite) then
	if (sub(dest,-1,-1) == "/") then

		copy_inside = true -- take as an explicit indication (when copying p64)
		dest = sub(dest,1,-2) -- cut off trailing /
	
		local segs = split(fullpath(src),"/",false)
		dest = dest .. "/" .. segs[#segs]
		dest_type = fstat(dest) -- update 
	end
end

if (no_clobber and fstat(dest)) then
	print("skipping move over existing file: "..dest)
	exit(0)
end

if dest_type == "folder" and 
	not force_folder_overwrite and not copy_inside
then

	-- refuse to copy over a folder

	print("can not write over a folder / cartridge.")
	print("  to move inside: mv a.p64 b.p64/")
	print("  to force overwrite: mv -f a.p64 b.p64")
	exit(1)

else

	local existed = fstat(dest)
	local err = mv(src, dest)
	if (err) then
		print(err)
	else
		if (existed) then
			print("moving "..src.." \feover\f7 "..dest)
		else
			print("moving "..src.." to "..dest)
		end
	end

end




:: bios/util/open.lua
--[[

	edit a file

	choose an editor based on extension [and possibly content if needed]

	** never runs the file -- up to caller to manage that depending on context **

	used by:
		filenav.p64: double click on file
		load.lua: to restore workspace tabs
		open() // can be used from sandboxed programs

]]

cd(env().path)


local argv = env().argv
if (#argv < 1) then
	print("usage: open filename")
	exit(1)
end

-- future: could be a list per extension (open a chooser widget)

local prog_for_ext = fetch("/appdata/system/default_apps.pod")

if (type(prog_for_ext) ~= "table") prog_for_ext = {}

prog_for_ext.lua   = prog_for_ext.lua   or "/system/apps/code.p64"
prog_for_ext.txt   = prog_for_ext.txt   or "/system/apps/notebook.p64"
prog_for_ext.pn    = prog_for_ext.pn    or "/system/apps/notebook.p64"
prog_for_ext.gfx   = prog_for_ext.gfx   or "/system/apps/gfx.p64"
prog_for_ext.map   = prog_for_ext.map   or "/system/apps/map.p64"
prog_for_ext.sfx   = prog_for_ext.sfx   or "/system/apps/sfx.p64"
prog_for_ext.pod   = prog_for_ext.pod   or "/system/apps/podtree.p64"
prog_for_ext.theme = prog_for_ext.theme or "/system/apps/themed.p64"
prog_for_ext.p8    = prog_for_ext.p8    or "/system/apps/view.p64"
prog_for_ext.png   = prog_for_ext.png   or "/system/apps/view.p64"
prog_for_ext["p8.png"]   = prog_for_ext["p8.png"]   or "/system/apps/view.p64"


local show_in_workspace = true



for i = 1, #argv do

	if (argv[i] == "-b") then
		-- open in background
		show_in_workspace = false
	elseif (argv[i] == "-j") then
		-- jump to matching window if one exists
		force_jump = true
	elseif (argv[i] == "-n") then
		-- force open in new window / tab
		force_new_window = false
	elseif fullpath(argv[i]) then

		-- for each file in args list
		filename = fullpath(argv[i])

		-- default: jump to existing editor for cart files, but open in a new window otherwise
--		local jump_to_matching_window = filename:sub(1, 10) == "/ram/cart/"
		local jump_to_matching_window = false -- could be a system-wide option?

		-- override with env().jump_to_matching_window
		if (env().jump_to_matching_window ~= nil) jump_to_matching_window = env().jump_to_matching_window -- set by infobar
		-- -j / -n has final say
		if (force_jump) jump_to_matching_window = true
		if (force_new_window) jump_to_matching_window = false


		if (fstat(filename) == "folder") then

			-- open folder / cartridge
			create_process("/system/apps/filenav.p64", 
			{
				argv = {filename},
				window_attribs = {show_in_workspace = show_in_workspace}
			})

		else

			local prog_name = prog_for_ext[filename:ext()]
			if (not prog_name) then
				-- no preferred program to open with; check metadata for recommended bbs:// program
				-- (bbs:// only -- maybe dangerous to allow un-sandboxed programs to open a file that 
				-- could be crafted to exploit some weakness in that program's loader)
				-- note: bbs program includes the version number! could optionally strip it here
				-- to do: run most recent version by default? [if online]
				local meta = fetch_metadata(filename)
				if (meta and meta.prog and meta.prog:prot() == "bbs") prog_name = meta.prog
			end

			if (prog_name) then
				
				-- tabs are orded by process id, so these will show up in the same order
				-- (see wm.lua "add to tabs")

				create_process(prog_name,
					{
						argv = {filename},
						fileview = {{location=filename, mode="RW"}}, -- let sandboxed app read/write file
						window_attribs = {
							show_in_workspace = show_in_workspace,
							jump_to_matching_window = jump_to_matching_window
						},
						highlight = env().highlight -- used by wrangler; sent by infobar when [ctrl-]click on error message to open new tab
					}
				)

--				flip() flip() flip() flip()

			else
				-- to do: use podtree (generic pod editor)
				print("no program found to open "..filename)

				notify("no program found to open "..filename)
			end
		end
	else
		print("could not resolve: "..argv[i])
		printh("could not resolve: "..argv[i])
	end
end

:: bios/util/ps.lua

local p = fetch"/ram/system/processes.pod"

print("\014\fe pid  name                 cpu   pri   mem\|i")
--	print("\014 =============================")

for i=1,#p do

	print(string.format("\014 \f6%-4d \f7%-20s \f6%0.3f %s%0.3f \f6%dk",
		p[i].id, p[i].name, p[i].cpu, p[i].priority <= 0.2 and (p[i].priority < 0.001 and "\f1" or "\fg") or "\f6", p[i].priority, p[i].memory\1024))
	
end

print("\|i\0")

:: bios/util/pwc.lua

?fetch("/ram/system/pwc.pod")

:: bios/util/pwd.lua
?env().path

:: bios/util/reboot.lua
--[[pod_format="raw",created="2024-04-01 02:35:27",modified="2024-04-01 02:35:27",revision=0]]
send_message(2, {event="reboot"})

--[[
print("reboot is not implemented yet")
print("please toggle power manually")
]]
:: bios/util/rm.lua
--[[
	cp src dest

	resulting file should be idential to src (can't just fetch and then store)

	to do:
		-r recursive // rm() is currently recursive by default though
		how to do interactive copying? (prompt for overwrite)
]]

cd(env().path)
local argv = env().argv

if (#argv < 1) then
	print("usage: rm filename")
	exit(1)
end

local filename = fullpath(argv[1])
if (not filename) then
	print("could not resolve path")
	exit(0)
end


local attribs, size, origin = fstat(filename)

if (attribs) then

	-- exists. to do: directories need to be empty?

	local res = rm(filename)
	if (res) then
		print(res)
	else
		print("deleting "..filename)
	end
else

	print("not found")

end







:: bios/util/run.lua
--[[

	run.lua

	run /ram/cart as the present working cartridge (same as ctrl-r), but with commandline arguments

]]

send_message(3, {
	event = "run_pwc",
	argv = env().argv,
	path = env().path
})



:: bios/util/save.lua
--[[pod_format="raw",created="2024-03-23 17:34:07",modified="2024-04-07 23:28:24",revision=6]]
--[[
	save

		copy from /ram/cart to present working cartridge location
		e.g.
		cp("/ram/cart", "/mycart.p64")

]]

function notify_or_print(m)
	(env().show_notifications and notify or print)(m)
end

cd(env().path)

local argv = env().argv or {}

local save_as = argv[1] or fetch("/ram/system/pwc.pod") or "/untitled.p64"
save_as = fullpath(save_as)

if (not save_as) then
	print("error: filenames can only include letters, numbers, or ._-")
	exit()
end


if (save_as:sub(1,10) == "/ram/cart/") then
	print("error: can not save the working cartridge inside itself.")
	print("try \"cd /\" first")
	exit()
end




if (save_as:sub(1,8) == "/system/") then
	print("** warning ** saving to /system will not persist to disk")
end


-- add extension when none is given (to do: how to save to a regular folder with no extension in name? maybe just don't do that?)
--if (sub(save_as, -4) ~= ".p64" and sub(save_as, -8) ~= ".p64.rom" and sub(save_as, -8) ~= ".p64.png") then -- deleteme
if not save_as:ext() or not save_as:ext():is_cart() then
	save_as ..= ".p64"
end


if (fstat(save_as) and argv[1]) then
	local res = input("\feoverwrite "..save_as:basename().."? \f7[y/n] ", 0x2)
	if (res ~= "y" and res ~= "Y") exit()
end

local completed = false
local num_files = 0
on_event("save_working_cart_files_completed",function(msg)
	completed = true
	num_files = msg.num_files -- num files saved because editors were open, not total files in the cart
end)

-- save all files and metadata (note: normally already saved as happens in wrangler on lost_focus)
-- wait for all save messages to come back via wm, for up to 120 frames
send_message(3, {event="save_working_cart_files", notify_on_complete=pid()})
for i=1,120 do if (not completed) then flip() end end

send_message(3, {event="save_open_locations_metadata"}, true) -- block until complete (if wm doesn't get back soon, have worse problems to worry about)

-- no unsaved pwc changes at this point
send_message(3, {event="reset_pwc_unsaved_changes"})


-- set runtime version metadata
-- when loading a cartridge, runtime should be greater or equal to this
-- (splore: refuse to run; otherwise: show a warning)

store_metadata("/ram/cart", {runtime = stat(5)})


-- copy /ram/cart to present working cartridge

pwc_meta = fetch_metadata(save_as)

local result = cp("/ram/cart", save_as, 0x1)

if (result) then
	notify_or_print("save error: "..tostring(result))
	exit(1)
end

-- 0.2.1c: preserve date created by setting in /ram/cart first (otherwise need to store_metadata, and causes an extra flush / anywhen entry)
if (pwc_meta and pwc_meta.created) store_metadata("/ram/cart", {created = pwc_meta.created}) 


-- keep a copy for comparing external changes
cp("/ram/cart", "/ram/system/pwcv0")


-- don't want to clobber existing created timestamp; normally when copying a folder over a folder, target is considered a newly created folder
-- something similar happens inside _cp but handled separately -- don't want to clobber .created when moving via rm,cp
-- 0.2.1c update: causes double flush! (and double anywhen entry) --> set metadata in /ram/cart before copy (above)
-- if (pwc_meta and pwc_meta.created) store_metadata(save_as, {created = pwc_meta.created}) 


res = store("/ram/system/pwc.pod", save_as)

save_message = "\^:007f41417f613f00 saved cart: "..save_as
if (save_as:sub(1,8) == "/system/") save_message..= "    *** changes to /system are in ram only ***"

notify_or_print(save_message)


:: bios/util/shutdown.lua
send_message(2, {event="shutdown"})

:: bios/wm/infobar.lua
--[[

	infobar.lua


	each entry can have a location tied to it (double click to open that location)
		// handy for jumping to code in stack traces

]]



local logdat={
}


local infobar_is_visible = false

local gui = create_gui()
gui.width = 480
gui.height = 270


function get_show_infobar()
	--return #logdat > 0
	return infobar_is_visible
end

function clear_infobar()
	logdat = {}
end

function hide_infobar()
	infobar_is_visible = false
end

-- dorky name because show_infobar is used in wm -- to do: delete old logic and organise names 
function open_infobar()
	infobar_is_visible = true
end


function update_infobar()
	
	gui:update_all()

end


function generate_infobar_gui()

	gui = create_gui{
		-- position,size will be adjusted by window manager
		x=0, y=0, 
		width=480, height=270,

		draw = function(self, msg)

			rectfill(0, 0, self.width, 11, 7)
			rectfill(0, 12, self.width, self.height, 16)

			-- title
			print(logdat[1], 3, 2, 1)
			circ(474, 6, 2, 1)

			-- dummy text
			local yy = 16  -- don't write on the bar -- can leave that empty! active message is drawn separtely.
			local xx = 0

			local mx, my = mouse() -- screen space; relative to head_gui
			my -= gui.y            -- ..so need to adjust manually here

			-- printh("infobar: "..pod{msg.mx, msg.my, mx, my})

			--for i=2, 30 do -- to do: why does printing nil here cause a freeze?
			for i=2, #logdat do

				if (my and my >= yy-1 and my < yy + 10) then
					rectfill(0,yy-2,480,yy+9,10)
					hover_item = i
				end
				xx, yy = print(logdat[i], 3, yy, 6)				
			end
		
		end,

		-- ** don't need update --
		--update = gui_update,

		update = function(self, msg)
			--printh("infobar gui position: "..pod{gui.x, gui.y})
			--printh("msg: "..pod(msg))
		end,


		
		tap = function(self, e)

			-- close // to do: button
			if (e.mx > 460 and e.my < 12) hide_infobar() return

			local str = logdat[hover_item]
			if (type(str) != "string") return

			-- trim whitespace
			while (str[1] == "\t" or str[2] == " ") str = str:sub(2)

			-- separate protocol
			local prot = str:prot() or ""
			str = str:sub(#prot + 1)

			-- 
			local pos1 = 2
			while (pos1 < #str and sub(str,pos1,pos1) ~= ":") pos1 += 1
			if (sub(str,pos1,pos1) == ":") then
				
				-- get number
				local pos2 = pos1+1
				while (pos2 < #str and sub(str,pos2,pos2) ~=  ":") pos2 += 1
				if (sub(str,pos2,pos2) == ":") then
					local loc = prot..sub(str, 1, pos1-1).."#"..sub(str, pos1+1, pos2-1)
					-- printh("[infobar] loc: "..loc)
					create_process("/system/util/open.lua",{
						argv = {loc}, jump_to_matching_window = not key"ctrl", -- hold key to open in a separate file
						highlight = true
					}
				)

				end
			end

		end,

		drag = function(self,e)
			send_message(3, {event="drag_infobar", dy=e.dy})
		end
	}

	return gui

end

function infobar_init()
	return generate_infobar_gui()
end


--[[
on_event("log", function(msg)

	if (type(msg.content) == "string") then

		local strs = split(msg.content, "\n", false)

		for i=1,#strs do

			add(logdat, strs[i], 1)
			while(#logdat > 64) deli(logdat) -- trim

		end

		printh("** log (removeme -- deprecated) "..msg.content) 
	end

	--printh("@@@@@ infobar received log: "..pod(msg))

end)
]]

local last_reported_error_t = 0

on_event("report_error", function(msg)

	if (type(msg.content) == "string") then

		-- don't reset immediately after last error (want to see the first error. e.g syntax error causes runtime error)
		if (sub(msg.content,1,1) == "*" and time() > last_reported_error_t + 1) then
			logdat = {}
			msg.content = sub(msg.content, 2)

			show_reported_error()
			last_reported_error_t = time()
		end

		local strs = split(msg.content, "\n", false)

		-- discard main chunk line of stack traces
		if (strs[#strs]:sub(-14) == " in main chunk") strs[#strs] = nil 

		for i=1,#strs do
			-- maximum: 20 entries
			if (#strs[i] > 0 and #logdat < 20) add(logdat, strs[i])

			-- headless: print to console
			if (stat(315) > 0) printh(strs[i])
		end

		--add(logdat, msg.content)
		infobar_is_visible = true
	end

end)





:: bios/wm/sparkles.lua
--[[

	proof of concept: module that hooks into wm with update, draw callbacks

		** don't really want to invite code running in kernel though
		** and don't want to try to sandbox /within/ a lua state [yet?]

		how to specify callback draw / update order without modifying wm.lua?
		this file should return the module table, including a key that matches settings.pod item (or have own settings)
		
		// result: maybe this kind of thing should just run in a separate process as an overlay
		// expensive, but mostly used for silly things anyway? birds.p64
		// push to homogenous userland patterns as much as possible (see red notebook)

]]

local sparkle = {}

-- currently used to reset when option turned off / on
function init_sparkles()
	sparkle = {}
end


function make_sparkle(x,y)
	local mag = 0.5

	return add(sparkle, {
		x = x, y = y,
		dx = rnd(mag)-rnd(mag),
		dy = rnd(mag)-rnd(mag),
		t = 0, max_t = 40 + rnd(30),
		col = 8+rnd(8)
	})
end

local last_mx, last_my

function update_sparkles()

	local mx,my,mb = mouse()
	mx += 4 my += 4 -- fudge

	if (not last_mx) then
		last_mx, last_my = mx, my
	end

	local dx = mx - last_mx
	local dy = my - last_my

	last_mx, last_my = mx, my

	local steps = min(10, max(abs(dx), abs(dy)))

	if (steps > 1) steps \= 2 -- sparser trail is nicer

	if (steps >= 1) then
		dx /= steps
		dy /= steps
		for i=1,steps do
			make_sparkle(mx, my)
			mx += dx 
			my += dy
		end
	end

	for i=#sparkle,1,-1 do
		local s = sparkle[i]

		s.x += s.dx
		s.y += s.dy

		s.t += 1
		if (s.t >= s.max_t) del(sparkle, s)
		
	end

end

function draw_sparkles()
	for i=1,#sparkle do
		local s = sparkle[i]

		if (s.t > s.max_t - 15) then
			pset(s.x, s.y, 6)
		else
			circ(s.x, s.y, 1, s.col)
			pset(s.x, s.y, 7)
		end
	end
	
end


:: bios/wm/toolbar.lua
--[[

	toolbar.lua

	includeable version -- run in same lua state as window manager
		// implementing as a separate process causes too much complex, fragile interaction between wm <--> toolbar

]]

do -- locals don't conflict with window manager


local toolbar = {}


local picotron_icon = userdata("[gfx]08087777770077777770000070707770777070700000777777700777777000000000[/gfx]")

local minimal = true

local gui = create_gui()

local char_w = peek(0x5600)

local tabs_container

local function has_window_menu_in_toolbar()

--	if (get_workspace().child and #get_workspace().child == 0) return false -- empty workspace
--	return get_workspace().style == "tabbed"

--[[
	-- include app menu on desktop (is always filenav menu)
	-- update: commented for now; feels messy and unclear
	-- and maybe right menu click on files would be nicer? 
	return get_workspace().style ~= "fullscreen"
]]
	-- need app menu iff have one or more tabs
	local tabs = get_workspace_tabs()
	if (tabs and #tabs > 0) return true

end


function make_window_button(parent, label, x, y, width, height, win)
	parent = parent or gui
	local b = {label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.col = 2

	function b:drag(event)
		return true -- stop parent from being draggable
	end

	function b:draw(event)
		local yy = (event.mb > 0 and event.has_pointer) and 1 or 0

		local col = theme(parent.col_k or "toolbar_item")
		for y=yy+2,yy+6,2 do
			line(2,y,8,y,col)
		end

	end

	function b:update()
		-- make space for tiny window
		if (self.parent.width < 32) self.x = 0
	end

	function b:tap(event)
		-- if deskop, always applies to the filenav overlay
		toggle_app_menu(self.sx, self.sy + self.height, win)
	end

	return parent:attach(b)
end



local function make_picotron_button(parent, label, x, y, width, height)
	parent = parent or gui
	local b = {label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.col = 2

	function b:drag(event)
		return true -- stop parent from being draggable
	end


	function b:draw(event)
		local yy = (event.mb > 0 and event.has_pointer) and 2 or 1

		pal(7, theme("toolbar_item"))
			spr(picotron_icon, 1, yy)
		pal(7,7)

	end

	function b:tap(event)
		toggle_picotron_menu()
	end

	return parent:attach(b)
end


local function make_new_tab_button(parent, label, x, y, w, h)

	local tt = parent:attach{x=x, y=y, width=w, height=h, label=label, cursor = "pointer"}

	function tt:drag(event)
		return true -- stop parent from being draggable
	end

	function tt:draw(event)

		local bg_col = theme("toolbar_item") 
		local x = 1 -- self.sx 
		local y = 0 -- self.sy
		if (event.has_pointer and event.mb > 0) y+=1

		-- to do: should just draw tab sprites and recolour them
		rectfill(x,y,x+w-2,y+h-1, bg_col)
		pset(x,y,theme"toolbar_back")
		pset(x+w-2,y,theme"toolbar_back")
		line(0,y,0,y+h-1, theme"toolbar_back")

		local str = self.label
		local text_w = print(str, 0, -1000)
		print(str, x + self.width/2 - text_w\2, y+1, theme"toolbar_back")

	end



	function tt:tap(event)

		-- create new file in same folder as [active window location]

		local awin = get_active_window()
		local loc = awin and awin.location

		local start_path = (loc and loc:dirname()) or get_workspace().last_dir or "/ram/cart"

		-- 0.2.1c: make sure the path exists (e.g. add /ram/cart/map)
		if (start_path:sub(1,10) == "/ram/cart/") mkdir(start_path)

		create_process("/system/apps/filenav.p64", 
		{
			intention = "new_tab",
			path = start_path,
			use_ext = (loc and loc:ext()) or get_workspace().last_ext or ".txt",
			window_attribs = {workspace = "current",autoclose=true},
			open_with = get_workspace().prog,
		})

	end


	return tt

end


-- tab is functionally the same as a window frame
-- window holds any attributes of interest to drawing / updating a tab
local function make_tab_button(parent, win, x, y, w, h)

	win = win or {title="tab_error"}

--[[
	local str = win.title or "_"	
	local text_w = print(str, 0, -1000)
	printh("tab title: "..str.."   width:"..text_w)
	-- to do: width function of title (nice, but complicates drag and switch
	w = text_w + 12
]]

	local tt = parent:attach{win = win, x=x, y=y, width=w, height=h, cursor = "pointer"}

--	
--[[
	-- to do: update variable width tabs / regenerate gui when tab title changes
	function tt:update()

		local str = self.win.title or "_"	
		local text_w = print(str, 0, -1000)
--		printh("tab title: "..str.."   width:"..text_w)
		self.width = text_w + 12
	end
]]


	
	function tt:draw(event)

		-- to do: tool can decide what background colour is for active tab
		-- same as selected workspace colour
		local bg_col = self.win.is_active and theme("toolbar_selected") or theme("toolbar_item") -- active tab is bright
--		local bg_col = self.win.is_active and 1 or 14 -- tried to get tab to match code editor background -- confusing.

		local textcol = theme"toolbar_back"

		-- window is editing the same file: draw inverted to make it obvious something is going on
		local win2 = get_active_window()
		local dupe = win2 ~= win and type(win.location) == "string" and type(win2.location) == "string" and win.location:path() == win2.location:path()

		if dupe then
			bg_col = theme"toolbar_back"
			textcol = theme"toolbar_item"
		end

		local x = 1 -- self.sx -- now relative to gui position
		local y = 0 -- self.sy
		
		if (event.has_pointer and event.mb > 0) y+=1

		rrectfill(x,y,w-1,h+1, 1,bg_col)
		line(0,y,0,y+h-1, theme"toolbar_back") -- gap at x=0 to separate from left neighbour

		if dupe then
			rrect(x,y,w-1,h+1, 1,textcol)
			y += 1
		end



		local title1 = win.title or "-"
		if (win.unsaved_changes and title1[1] ~= "*") title1 = "*"..title1

		-- temp debug: show position in gui element list
		--[[	
		local index = -1
		for i=1,#self.parent.child do
			if (self.parent.child[i] == self) index = i
		end
		title1 = index..title1
		]]

		
		local text_w = print(title1, 0, -1000)
		--local text_w = #str * char_w
		--[[
		if (text_w > self.width and str:ext()) then
			title1 = sub(title1,1,-(2+#title1:ext()))
			text_w = print(title1, 0, -1000)
		end
		]]
		print(title1, x + max(3, self.width/2-text_w\2), y+1, textcol)

		

	end

	function tt:tap(event)

		if (event.last_mb == 1) then -- need to use last_mb for tap because mb is always 0 by this stage

			send_message(3, {event="bring_window_to_front", proc_id = self.win.proc_id})		
			self:bring_to_front()
			--update_tab_widths(self)
		else
			-- right mouse click to bring up app menu
			toggle_app_menu(self.sx, self.sy + self.height, self.win)
		end

		-- variable widthed tabs. messy
		--[[
			-- assume bring_window_to_front will succeed. remove 1 glitch frame
			get_active_window().is_active = false
			tt.win.is_active = true 

			generate_toolbar_gui() -- need if window tabs change size according to status
		]]
	end

	function tt:drag(event)

		if (event.mx < 0 or event.mx >= self.width) then

			local tab = get_workspace_tabs()
			local index = nil
			for i=1,#tab do
				if (tab[i] == self.win) index = i
			end

			-- ** unnecessarily complex
			-- ** to do: re-work how tab ordering is stored
			--    perhaps always just operate on x,y and position in list of gui elements is immaterial

			local index0,index1,index2

			for i=1,#self.parent.child do
				if (self.parent.child[i].win == tab[index])   index0 = i
				if (self.parent.child[i].win == tab[index-1]) index1 = i
				if (self.parent.child[i].win == tab[index+1]) index2 = i
			end
			
			if event.mx < 0 and index1 and tab[index-1] and tab[index-1].label ~= "+" then
				-- switch left
				tab[index], tab[index-1] = tab[index-1], tab[index]
				self.parent.child[index0].x,  self.parent.child[index1].x  = self.parent.child[index1].x,  self.parent.child[index0].x  
				self.parent.child[index0].sx, self.parent.child[index1].sx = self.parent.child[index1].sx, self.parent.child[index0].sx
			end

			if event.mx >= self.width and index2 and tab[index+1] and tab[index+1].label ~= "+" then
				-- switch right
				tab[index], tab[index+1] = tab[index+1], tab[index]
				self.parent.child[index0].x,  self.parent.child[index2].x  = self.parent.child[index2].x,  self.parent.child[index0].x  
				self.parent.child[index0].sx, self.parent.child[index2].sx = self.parent.child[index2].sx, self.parent.child[index0].sx
			end

		end

		return true -- can't also drag toolbar when dragging tab

	end

	return tt
end


-- deleteme -- too messy!
local function make_dock_button(parent, x, y, width, height)

	parent = parent or gui
	local b = {index=index, label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.icon0 = userdata"[gfx]08080000000000000000000700000077700007777700077777000000000000000000[/gfx]"
	b.icon1 = userdata"[gfx]08080000000000000000000000000007700000077000000000000000000000000000[/gfx]"

	function b:draw(event)
		local ws = get_workspace()
		local yy = (event.mb > 0 and event.has_pointer) and 1 or 0
		pal(7, 13)
		spr(ws.show_toolbar and b.icon1 or b.icon0, 0, yy + 1)
		pal(7,7)
		--rectfill(0,0,4,4,8)
	end

	function b:tap()
		local ws = get_workspace()
		ws.show_toolbar = not ws.show_toolbar
	end


	return parent:attach(b)
end


local function make_workspace_button(index, parent, label, x, y, width, height)
	parent = parent or gui
	local b = {index=index, label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.icon = get_workspace_icon(index)

	function b:drag(event)
		return true -- stop parent from being draggable
	end


	function b:draw(event)
		local xx = 0 -- b.sx
		local yy = 0 -- b.sy
		if (event.mb > 0 and event.has_pointer) then 
			yy = yy + 1
		elseif get_workspace_index() == b.index and key("lalt") and (key("left") or key("right")) then
			-- show button down when used alt+l/r to switch workspace
			yy = yy + 1
		elseif get_workspace_index() == b.index then
			--yy = yy + 1
		end

		pal(7, get_workspace_index() == b.index and theme("toolbar_selected") or theme("toolbar_item"))
		
		-- live update
		local ws = get_workspace()
		if (get_workspace_index() == b.index) b.icon = ws.icon

		spr(b.icon, xx + 4, yy + 1)

		pal(7,7)

	end

	-- later: can drag workspace buttons around; so use :tap for activating
	function b:tap(event)
		if (event.last_mb == 1) then
			set_workspace(b.index)
		else
			-- printh(pod(get_workspace(b.index).attribs))
			toggle_workspace_menu(min(370, self.sx), self.sy + self.height, b.index)
		end
	end
	
	return parent:attach(b)
end



local last_num = nil
local last_tabs = nil

--function update_toolbar()

local function gui_update()

	
	-- safety: make sure don't need to update gui because of changing tabs
	-- (but better to do proactively from wm.lua to avoid being one frame behind)
	if (last_tabs ~= get_workspace_tabs() or last_num ~= #get_workspace_tabs()) then
		generate_toolbar_gui()
		last_tabs = get_workspace_tabs()
		if (last_tabs) then
			last_num  = #get_workspace_tabs()
		end
	end

end

--[[
to do: dynamic tab widths
function update_tab_widths(awin)
	local xx = 0

	local tabs = tabs_container.child

	for i = 1, #tabs do
		local tt = tabs[i]
		tt.x = xx
		tt.sx = tt.parent.sx + tt.x -- update now
		tt.width = tt == awin and 64 or 48
		if (tt.label == "+") tt.width=20
		xx += tt.width
	end
end
]]

function generate_toolbar_gui()

--	printh("-- generating toolbar gui --")
	gui = create_gui{
		x=0,y=0,width=480,height=11,
		cursor="grab",

		draw = function(self)
			rectfill(0, 0, self.width, self.height, theme"toolbar_back")
		end,
		update = gui_update,

		drag = function(self,e)
			-- to do: check if is active element; can remove all the children's dummy :drag() callbacks
			-- is this the right pattern for toolbar style buttons that have a container that does something?
			send_message(3, {event="drag_toolbar", dy=e.dy})
		end
	}

	local workspace_w = min(16, 116 / get_num_workspaces())
	local x = 476 - get_num_workspaces()*workspace_w

	for i=1,get_num_workspaces() do

--		if (i == get_num_workspaces()) then x = x + 3 end -- temp formatting hack for twitter code edits code gif
		make_workspace_button(i, gui, "wbtn"..tostr(i),x,1,16,10)
		x = x + workspace_w

	end

	-- experimental: docking button
--	make_dock_button(gui, 480-12, 1, 10, 10)

	local tab = get_workspace_tabs()
	local tab_width = 50 -- overwritten below
	local tabs_container_x = has_window_menu_in_toolbar() and 35 or 20
	local xx = 0

	if (tab) then

		-- container

		tabs_container = gui:attach{
			x=tabs_container_x, y=0, width=320, height=gui.height,cursor="grab",

			drag = function(self,msg)
				--printh("drag container "..msg.dy)
				gui.y += msg.dy
			end,

			draw = function()
				-- for cursor // to do: shouldn't need draw function
			end

		}

		for i=1,#tab do
			if tab[i] then
				if not tab[i].closing and not tab[i].hidden then

					tab_width   = min(64, 308 \ #tab) -- 0.2.0e: minimum width a little wider (was 56). np if squash up when many

					local tt = make_tab_button(tabs_container, tab[i], xx, 1, tab_width-2, 10)
					tt.index = i
					xx += tt.width
				end
			end
		end

		--update_tab_widths(get_active_window())
		

		-- new tab: default to an untitled document

		if (get_workspace().style == "tabbed") then
			
			make_new_tab_button(tabs_container, "+", xx, 1, 17, 10)

		end

	end

	make_picotron_button(gui,"picotron menu", 4,1, 10,10)


	if has_window_menu_in_toolbar() then
		make_window_button(gui, "app menu", 18, 1, 10,10, get_window_by_proc_id(get_workspace().desktop_filenav_proc_id))
	end
	
	return gui

end

function toolbar_init()
	return generate_toolbar_gui()
end



end

:: bios/wm/wm.lua
--[[

	Picotron Window Manager
	(c) Lexaloffle Games LLP

	Warning: this is a WIP -- a lot of internals are experimental and/or will change

]]


include("/system/wm/toolbar.lua")
include("/system/wm/infobar.lua")
include("/system/wm/sparkles.lua")

local default_cursor_gfx = userdata("[gfx]10100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000001710000000000000177100000000000017771000000000001777710000000000177110000000000001171000000000000000000000000000000000000[/gfx]")


local bar_h = 12 -- same as toolbar.lua. how to sync? global data?
local tooltray_default_h = 80

local mx, my, mb, mdx, mdy

local head_gui = nil

local workspace = {} -- desktop workspace
local ws_gui = nil   -- current workspace
local tooltray_gui = nil   -- global tooltray gui
local tooltray_active_window = nil -- set to a tooltray window when has focus
local workspace_index = 1
local last_desktop_workspace = nil
local last_fullscreen_workspace = nil
local toolbar_y        = 0
local toolbar_y_target = 0
local infobar_y        = 270 --270-11
local infobar_y_target = infobar_y
local held_frames = 0
local next_ws_id = 100 -- start high for debugging; easy to distinguish between index vs id
local created_fullscreen_terminal = false

local sdat = fetch"/appdata/system/settings.pod" or {}


local _set_userland_clipboard_text = _set_userland_clipboard_text
local _get_host_clipboard_text = _get_host_clipboard_text

local last_draw_window = nil

function show_reported_error() -- happens when error is reported
	open_infobar()
	infobar_y_target = 200 -- not too high, want to see code
end

-- to do: remove; can use a stat() and keep track at a lower level (do anyway for battery saver logic)
local last_input_activity_t = 0

-- store some things by process so that they can be manipulated before window is created
local proc_icon = {}
local proc_menu = {}

local char_w = peek(0x5600)

local prev_frame = nil

local last_mx, last_my, last_mb

local pending_saves = {}
local pending_save_errors = 0
local save_working_cart_files_t = 0

-- keep track of pwc unsaved changes
local pwc_unsaved_changes = false
on_event("reset_pwc_unsaved_changes",function() pwc_unsaved_changes = false end) -- used by load, save utilities
on_event("pwc_unsaved_changes", function() return {result = pwc_unsaved_changes} end)


-- wrangle.lua uses this to report changes to the in-memory version of the file for that process
on_event("set_unsaved_changes", function(msg) 
	if (time() < 5) return -- ignore changes made during boot (/ram/cart/main.lua etc)
	local win = get_window_by_proc_id(msg._from)
	if (win) win.unsaved_changes = msg.val
	if (msg.filename:sub(1,10) == "/ram/cart/" and msg.val) pwc_unsaved_changes = true -- 0.2.1c: only when msg.val is truthy >_<
end)

-- include present working cartridge and open files
-- (used by shutdown / reboot in confirm.p64)
on_event("any_unsaved_changes", function() 
	if (pwc_unsaved_changes) return {result = true}

	-- search windows
	for i=1,#workspace do
		for j=1, #workspace[i].child do
			local win = workspace[i].child[j]
			if (win.unsaved_changes) return {result = true}
		end
	end

	return {result = false} 
end)



function generate_head_gui()

--	printh("generate_infobar_gui "..time())
	
	head_gui = create_gui{
		x = 0, y = 0, 
		width = 480, height = 270
	}

--[[
	-- debug
	function head_gui:draw()
		cls(9)
		camera() clip()
		rectfill(0,0,1000,1000,8)
		rectfill(0,0,1000,30,10)
		for i=1,#head_gui.child do
			local c = head_gui.child[i]
			print(pod{c.sx, c.sy, c.width, c.height}, 340, 30+i*10, 7)
		end
		for i=1,#ws_gui.child do
			local c = ws_gui.child[i]
			print(pod{c.sx, c.sy, c.width, c.height}, 340, 90+i*10, 7)
		end
	end
]]

	toolbar_gui = generate_toolbar_gui()
	infobar_gui = generate_infobar_gui()

	head_gui.child = {}
	head_gui:attach(tooltray_gui)
	head_gui:attach(tooltray_overlay)
	head_gui:attach(ws_gui)
	head_gui:attach(ws_gui_overlay)

	head_gui:attach(toolbar_gui)
	head_gui:attach(infobar_gui)


	function head_gui:update()

		-- slide infobar / infobar to targets
		toolbar_y = (toolbar_y * 3 + toolbar_y_target) / 4
		infobar_y = (infobar_y * 3 + infobar_y_target) / 4
		
		-- move towards target a pixel so that can reach exact value. also just nicer motion (no single-pixel creep at end; small transitions are faster)

		if (toolbar_y < toolbar_y_target) then
			toolbar_y = min(toolbar_y + 1, toolbar_y_target) else
			toolbar_y = max(toolbar_y - 1, toolbar_y_target) end

		if (infobar_y < infobar_y_target) then
			infobar_y = min(infobar_y + 1, infobar_y_target) else
			infobar_y = max(infobar_y - 1, infobar_y_target) end
		

		-- tooltray visibility
		if (tooltray_is_open() ~= last_tooltray_is_open) then
			for i=1,#tooltray_gui.child do
				send_message(tooltray_gui.child[i].proc_id, {event=tooltray_is_open() and "gained_visibility" or "lost_visibility"})
			end
		end
		last_tooltray_is_open = tooltray_is_open()

		-- don't draw under toolbar (optimisation)
		tooltray_gui.height = toolbar_y - tooltray_gui.y


		-- to do: show_bars should be initial state, and then docked is optional
		local show_toolbar = ws_gui.show_toolbar 
--		local show_infobar = ws_gui.show_infobar
		local show_infobar = get_show_infobar()

		if (key("alt")) show_toolbar = true

		-- auto-showing bars using mouse position is annoying in fullscreen; just for tools / desktop
		-- fullscreen has ESC, but tools have no other way to reach toolbar (without knowing kbd shortcut)
		--if (false) then
		if (ws_gui.style ~= "fullscreen") then
			--if ((my < 2 and mb == 0) or my < toolbar_y + toolbar_gui.height) then 
			if ((my < 2 and mb == 0)) then -- don't need second test if doing ws_gui.show_toolbar = true; allows ctrl-1 to immediately hide even while mouse is at top
				show_toolbar = true
				ws_gui.show_toolbar = true -- experimental: low friction to de-fullscreenify. can turn off at system settings level
			end
			-- if ((my >= 270-2 and mb == 0) or my >= infobar_y) show_infobar = true
		end

		if (screensaver_proc_id) then
			show_toolbar, show_infobar = false, false
		end

		-- never show toolbar when export is locked in fullscreen mode
		if (is_locked_in_fullscreen()) show_toolbar = false

		if (show_toolbar) then
			toolbar_y_target = max(toolbar_y_target, 0)
			-- snap. assumption: never want to leave an 8px (or less) sliver visible at top
			if (toolbar_y_target < 8 and mb == 0) toolbar_y_target = 0
		else
			-- hide [unless pulled out]
			--if (toolbar_y < 40) 
			toolbar_y_target = -toolbar_gui.height 
		end

		if (show_infobar) then
			infobar_y_target = min(infobar_y_target, 270-12)
			-- snap. assumption: never want to leave an 8px (or less) sliver visible at top
			if (infobar_y_target >= 270 - 12-8 and mb == 0) infobar_y_target = 270-12 -- can't use infobar_gui.height -- is 270, not 12!
		else
			-- hide [unless pulled out]
			--if (infobar_y > 270-40) 

			infobar_y_target = 270
		end



		-- jump when workspace changed (otherwise can see uncovered area e.g. above tabbed window)
		if (time() < head_gui.t0 + 0.2) then
			toolbar_y = toolbar_y_target
		end


		--------- apply toolbar / infobar position --------		

--		tooltray_gui.y = min(0, - tooltray_default_h / 1.5 + toolbar_y / 1.5) \ 1 -- move at different speed; feels more like a deep drawer. ottoman
--		tooltray_gui.y = toolbar_y - tooltray_default_h  -- same speed (testing concept: toolbar / tray is more of a single thing. too chunky)
		
		toolbar_gui.y  = toolbar_y \ 1
		toolbar_gui.sy = toolbar_y \ 1
		ws_gui.y       = max(0, toolbar_y \ 1) -- when toolbar is overlapping (fullscreen) and above top, workspace stops moving up at 0
		infobar_gui.y  = infobar_y \ 1
		infobar_gui.sy = infobar_gui.y

	end

end

-- new version: derive attributes from window and calling program
function create_workspace_1(proc_id, win_attribs)
	local ws = head_gui:new()
	ws.x = 0
	ws.y = 0
	ws.width = 480
	ws.height = 270
	ws.id = next_ws_id  next_ws_id += 1
	ws.icon = win_attribs.icon 
	ws.head_proc_id = proc_id
	ws.prog = win_attribs.prog
	ws.tabs = {}

	-- workspace inherits some of the attributes of window; 
	-- used when deciding which workspace to create windows in
	ws.style = "fullscreen"
	if (win_attribs.fullscreen) ws.style = "fullscreen"       -- default, but tested here for clarity
	if (win_attribs.workspace == "new") ws.style = "desktop"  -- requesting new workspace mean requesting new desktop
	if (win_attribs.tabbed) ws.style = "tabbed"               -- ignore fullscreen if it is set

	-- workspace inherits pwc_output during recovery (out of memory crash requires recreating terminal)
	if (win_attribs.pwc_output) ws.pwc_output = true  ws.recovering = false

	-- default desktop workspace icon
	if not ws.icon then
		ws.icon = ws.style == "desktop" and 
			userdata"[gfx]08087777777777777777777777777777777700000000777777777700007700000000[/gfx]" or  -- desktop
			userdata"[gfx]09070007070000000700007777777777700000777700000777700000777777777770[/gfx]"     -- tv
	end

	-- initialise toolbar / infobar docking based on style
	ws.show_toolbar = ws.style ~= "fullscreen"
	ws.show_infobar = false

	-- opening a window into a desktop that has no underlay -> clear each frame 
	-- (harmless if false positive -- just slightly inefficient)
	if (ws.desktop and win_attribs.width < 480) then
		ws.clear_each_frame = true
	end
	
	-- ignore workspace flow while booting
	visit_workspace(ws)

	function ws:draw()
		--cls(3) -- debug: see when workspace is redrawn
		if (not self.child or #self.child == 0) then
--[[
			-- pinboard pattern
			fillp(0x1,0,0,0,0,0,0,0)
			rectfill(0,0,self.width,self.height,0x0501)
			fillp()
			rrectfill(self.width/2-45, self.height/2-5-7, 90, 19, 0, 1)
			
			print("\014[ empty workspace ]",self.width/2-19*2,self.height/2-5,6)
]]			
			rectfill(0,0,self.width,self.height,16)
			print("[ empty workspace ]",self.width/2-19*2.5,self.height/2-5,6)
			-- print("~ click to close ~",self.width/2-18*2.5,self.height/2+10,13)
		end
	end

	-- 0.2.0i: autoclose only fullscreen workspaces (that are not pwc output)
	--> cart can have their own Exit functionality and call exit()
	function ws:update()

		if (not self.child or #self.child == 0) then
			if self.style == "fullscreen" and not self.pwc_output then
				close_workspace(workspace_index)
				set_workspace(previous_workspace)
			else


				-- ctrl-o to open a file; copied and modified from toolbar.lua::make_new_tab_button()
				if key"ctrl" and keyp"o" then

					create_process("/system/apps/filenav.p64", 
					{
						path=get_workspace().last_dir,
						intention="new_tab",
						use_ext= get_workspace().last_ext or ".txt",
						window_attribs={workspace = "current",autoclose=true},
						open_with = get_workspace().prog,
					})

				end



				-- open file navigator
				-- meh ~ can use the [+] new tab button. Don't need to introduce a new concept
--[[
				create_process("/system/apps/filenav.p64", {argv={"/ram/cart"},
					window_attribs = {
						workspace = "current",
						show_in_workspace = true, -- don't become active
						width = 480-80, height = 258-80,
						x = 0+40, y = 11+40,
						has_frame = false,
						moveable = false,
						resizeable = false,
						empty_workspace_file_chooser = true -- a bit different to autoclose; doesn't respond to ESC
					}
				
				})
]]
			end
		end
	end

--[[
	-- deleteme -- fullscreen workspaces now close automatically, and
	-- other workspaces should be harder to close (right click on workspace icon)
	function ws:tap()
		if (not self.child or #self.child == 0) then
			close_workspace(workspace_index)
			set_workspace(previous_workspace)
		end
	end
]]

	local pos = 1
	while (workspace[pos] and ws.head_proc_id > workspace[pos].head_proc_id) do
		pos += 1
	end

	local result = add(workspace, ws, pos)

	return result, pos
end

-- globals used by toolbar.lua

function get_workspace(index)
	if (not index) return ws_gui or {}
	return workspace[index] or {}
end

function get_num_workspaces()
	--printh("get_num_workspaces(): "..tostr(#workspace))
	return #workspace
end

function get_workspace_index()
	return workspace_index
end

function get_workspace_tabs()
	return (ws_gui and ws_gui.tabs) or {}
end

function get_workspace_icon(index)
	local icon = nil
	if (workspace[index]) then
		icon = proc_icon[workspace[index].head_proc_id]
		if (not icon and workspace[index].style == "desktop") then
			icon = userdata("[gfx]08087777777777777777777777777777777700000000777777777700007700000000[/gfx]")
		end
	end

	-- default: tv
	if (not icon) icon = userdata("[gfx]0907000707000000070000777777777770000077770000077770000077777777777[/gfx]")
	return icon
end



local last_active_win = nil


local put_x = 0
local put_y = 0



function tooltray_is_open()
	return toolbar_y > 0
end

-- used for keeping track of which workspace to toggle between (ESC) or where desktop is
-- when deciding to put new windows
function visit_workspace(ws)

	if (ws.style == "fullscreen") last_fullscreen_workspace = ws
	if (ws.style ~= "fullscreen") last_non_fullscreen_workspace = ws
	if (ws.style == "desktop") last_desktop_workspace = ws
	if (ws.style ~= "desktop") last_non_desktop_workspace = ws
	if (ws.pwc_output) last_pwc_output_workspace = ws

end



--[[
	set_workspace(index)

	index can be the workspace value -- this is because index might change
	when creating new workspace, so sometimes references should be by value
	(last_desktop_workspace, last_fullscreen_workspace)
]]
function set_workspace(index)

	if (index == nil) return

--	printh("set_workspace "..tostring(index))

	-- find by value
	if (type(index) == "table") then		
		for i=1,#workspace do
			if (workspace[i] == index) index = i
		end
	end

	-- couldn't find; use first workspace
	if (type(index) == "table") then
		index = 1
	end

	-- hide any modal gui elements
	dismiss_modal()

	-- safety: no workspaces exists
	if (#workspace == 0) then
		return
	end

	-- loop around
	workspace_index = 1 + ((index - 1) % #workspace)

	ws_gui = workspace[workspace_index]
	
	visit_workspace(ws_gui)

	-- invalidate active window if not found
	if (ws_gui.active_window) then
		local found = 0
		for i=1,#ws_gui.child do
			if (ws_gui.child == ws_gui.active_window) found = true
		end
		if (not found) ws_gui.active_window = false
	end

	generate_head_gui()


end

-- can return nil
function get_active_window()

	-- to do: might not need this
	if (tooltray_active_window and tooltray_is_open()) then 
		return tooltray_active_window
	end
	
	if (not ws_gui or #ws_gui.child == 0) then 
		return nil 
	end

	-- prefer last clicked window
	
	if (ws_gui.active_window and not ws_gui.active_window.closing and not ws_gui.active_window.wallpaper) then
		return ws_gui.active_window
	end

	-- look backwards through list of windows
	for i=#ws_gui.child, 1, -1 do
		if not ws_gui.child[i].closing and not ws_gui.child[i].wallpaper then
			return ws_gui.child[i]
		end
	end

	-- safety: return last child // happens during startup?
	-- printh("using last child in get_active_window")
	return ws_gui.child[#ws_gui.child]
end

function _init()

	cursor_gfx = fetch"/system/misc/cursors.gfx"

	prev_frame = userdata("u8", 480, 270)

	------------------------ separate font for window manager ------------------------


	poke(0x4000,get(fetch"/system/fonts/lil.font"))
	poke(0x5600,get(fetch"/system/fonts/p8.font"))

--	poke(0x5600,get(fetch"/system/fonts/pug.font"))

--	poke(0x4002, (@0x4002)+3)
--	poke(0x4004, 1) -- offset_y


	----------------------------------------------------------------------------------


	-- safety: window manager itself needs to be visible! (also safety in foot though)
	send_message(pid(), {event="gained_visibility"})  --  pokes 0x547f:0x1

--	open initial processes: desktop (default workspace), code, gfx, map, sfx, full-screen terminal (esc to toggle)
	
	-- ==========================================================================================================================================
	-- single global tooltray gui
	-- ==========================================================================================================================================
	-- 

	tooltray_gui = {x=0, y=0, width=480, height=270, 
		draw=function(self, msg) 
			--[[
			rectfill(0,0,self.width,self.height, 3) -- green background for debugging
			print("tooltray:"..#self.child, 4,4, 7)
			for i=1,#self.child do
				local c = self.child[i]
				print(pod{c.x,c.y,c.width,c.height},30,12+i*10,7)
				
			end
			]]
		end
	}

	tooltray_overlay = {x=0, y=0, width=0, height=0, -- don't interact
		draw=function(self, msg)
			if (msg.mb and dragging_window and dragging_window.parent ~= tooltray_gui and msg.my < toolbar_y) then
				clip()
				local win = dragging_window
				local x0 = msg.mx - dragging_window_xo
				local y0 = msg.my - (dragging_window_yo - toolbar_y)
				if (win.has_frame) y0 -= 12 -- drop down because titlebar not drawn
				y0 = max(y0, 0) -- snap to y >= 0 when dropped
				_blit_process_video(win.proc_id, 0, 0, nil, nil,x0, y0)
			end
		end,
		-- abuse visibility mechanism: don't draw in window actual position this frame		
		update=function(self, msg)
			local mx,my = mouse()
			if (msg.mb and dragging_window and dragging_window.parent ~= tooltray_gui and msg.my < toolbar_y) then
				dragging_window.visible = false
			end
		end
		
	}

	-- for dragging windows from toolbar -> ws_gui (copied and modified from above)
	ws_gui_overlay = {x=0, y=0, width=0, height=0, -- don't interact
		draw=function(self, msg)
			if (msg.mb and dragging_window and dragging_window.parent == tooltray_gui and msg.my >= toolbar_y) then
				clip()
				local win = dragging_window
				local x0 = msg.mx - dragging_window_xo
				local y0 = msg.my - dragging_window_yo
				if (win.has_frame) y0 -= 12 -- drop down because titlebar not drawn
				y0 = max(y0, toolbar_y + 12) -- snap to under toolbar (same as when dragging from desktop -> tooltray)
				_blit_process_video(win.proc_id, 0, 0, nil, nil,x0, y0)
			end
		end,
		-- abuse visibility mechanism: don't draw in window actual position this frame		
		update=function(self, msg)
			if (msg.mb and dragging_window and dragging_window.parent == tooltray_gui and msg.my >= toolbar_y) then
				dragging_window.visible = false	
			end
		end
	}



	-- ==========================================================================================================================================

	-- forward (low-level) event messages to active window
	-- should be fast; everything has to go through here

	local forward_events = {keydown=1, keyup=1, textinput=1, mousewheel=nil, mouselockedmove=1, pressed_ctrl_v=1, reset_kbd=1}
	local activity_events = {keydown=1, keyup=1, textinput=1, mousewheel=1, mouse=1, pressed_ctrl_v=1}

	_subscribe_to_events( 
		function(msg)
			if (ws_gui == nil) then return end

			if msg.event == "keydown" then

				last_input_activity_t = time()

				-- alt + left,right,enter filtered out (used by window manager)
				-- needs to be here (and not in events.lua) because key state is reset when switching tabs

				if key("alt") then
					if (msg.scancode == 79 or msg.scancode == 80 or msg.scancode == 40) return
				end

				-- filter ctrl combinations
				if key("ctrl") then
					-- needs to be here (and not in events.lua) because key state is reset when switching tabs
					if (msg.scancode == 43) return -- tab / ctrl+shift+tab

					-- moved to events.lua so that can be mapped; especially for ctrl-s
					-- if (msg.scancode == 22) return -- ctrl+s 
					-- if (msg.scancode == 35) return -- ctrl+6 capture screenshot
					-- if (msg.scancode == 36) return -- ctrl+7 capture label
				end

			end


			if (forward_events[msg.event]) then

				local win = get_active_window()
				if (win and win.proc_id) then
					send_message(win.proc_id, msg)
				end

			elseif msg.event == "mousewheel" then
				-- special case: mousewheel sent to window under cursor even when window is not active
				-- e.g. scroll a text file that is partially hidden
				local hover_win = head_gui:el_at_xy(mx, my)
				if (hover_win and hover_win.proc_id) then
					send_message(hover_win.proc_id, msg)
				end
--[[
			else
				printh("wm event: "..msg.event)
]]
			end

		end
	)

	-- 0.1.1e forward drop_items to active window, but need to add mx,my ("drop_items" was in forward_events)
	-- when from hosts, always choose mx,my at center of window for now
	-- (mouse position not available on all platforms, best just to not expose it)
	on_event("drop_items", function(msg)
		-- 0.2.0i only system process can drop items (incl sandboxed filenav)
		-- 0.2.1c fixed; _flags wasn't set when sent by process_dropped_files()
		if (not msg._flags or msg._flags & 0x1 == 0) return 
		local win = get_active_window()
		if (win and win.proc_id) then
			msg.mx = win.width \ 2
			msg.my = win.height \ 2
			msg.from_proc_id = 0 -- special meaning: dropped from host
			send_message(win.proc_id, msg)
		end
	end)

	-- ==========================================================================================================================================

	on_event("drag_toolbar",
		function (msg)
			--toolbar_y_target = mid(0, toolbar_y + msg.dy, tooltray_default_h) -- limiting feels bad
			toolbar_y_target = mid(0, toolbar_y + msg.dy, infobar_y-11)
			toolbar_y = toolbar_y_target
		end
	)

	on_event("drag_infobar",
		function (msg)
			infobar_y_target = mid(0, infobar_y + msg.dy, 270-11)
			infobar_y = infobar_y_target
		end
	)

	-- used by toolbar; maybe should just be a function call
	on_event("bring_window_to_front",
		function (msg)
			local win = get_window_by_proc_id(msg.proc_id)
			if (win) set_active_window(win)		
		end
	)


	on_event("modified:/appdata/system/settings.pod",
		function (msg)
			sdat = fetch"/appdata/system/settings.pod"
		end
	)

	-- window can request that it be grabbed (normally used by frameless windows)
	on_event("grab", function(msg)
		local win = get_window_by_proc_id(msg._from)
		local mx,my,mb = mouse()
		if (win and mb == 1) then
			dragging_window = win
			if (win) set_active_window(win)
			local mx, my = mouse()
			dragging_window_xo = mx - win.x
			dragging_window_yo = my - win.y
			win.start_grab_x = win.x\1
			win.start_grab_y = win.y\1
			win.start_grab_t = time()
		end
	end)

	-- deleteme; staleness is being decomissioned (see wrangle.lua)
--[[
	on_event("set_stale_windows", function(msg)

		local win = get_window_by_proc_id(msg._from)
		if (not win) return

		-- let other windows know they are stale (same test for sameness as next block)
		for i=1,#workspace do
			for j=1, #workspace[i].child do
				local win2 = workspace[i].child[j]
				if win2 ~= win and not win2.closing and type(win.location) == "string" and type(win2.location) == "string" and 
					win.location:path() == win2.location:path() 
				then
					win2.stale = true
					send_message(win2.proc_id, {event = "set_stale", val = true, filename = win2.location})
				end
			end
		end
	end)
]]


	
	toolbar_gui = toolbar_init()
	infobar_gui = infobar_init()

	generate_head_gui()

	--_signal(36) -- finished loading core processes  (deleteme -- shouldn't need)
	--flip()
end

local dark_col = {0,0,1,19, 20,21,22,6, 2,25,9,27, 16,18,24,22,  1,19,1,1, 21,0,5,24, 2,4,27,3, 12,13,24,4}
for i=1,#dark_col do dark_col[i] |= 0x40 end -- it is the colour table entry that sets stencil bits in the target


function draw_window_frame(win)

	-- screen coordinates; want to use clip() for title
	-- to do: how to use clip() relative to camera? there should be a nice way
	camera()
	local x0 = win.sx
	local y0 = win.sy
	local x1 = win.sx + win.width  - 1
	local y1 = win.sy + win.height - 1
	
	local bar_col = theme"dormant_frame"
	local border_col = theme"dormant_border"
	local title_col = theme"dormant_title"

	-- adjust for base gui position; to do: shouldn't be necessary

	

	if (get_active_window() == win) then 
		-- active window colours
		
		bar_col = theme"window_frame"
		border_col = theme"window_border"
		title_col = theme"window_title"
	end

	rectfill(x0,y0-bar_h, x1,y0-1,  bar_col)
	rectfill(x0,y0-1, x1,y0-1,  border_col)

	-- outside outline: cuts into corners by 1 pixel
	y0 = y0 - bar_h


	-- to do: need to calculate width for variable width font
	-- to do: need to calculate y offset based on font

	clip(x0+16, y0, (x1-x0)-26, y1-y0)
	local title1 = win.title
	if (win.unsaved_changes and title1[1] ~= "*") title1 = "*"..title1
	--if (win.stale) title1 = "["..title1.."]" -- debug: show which window(s) are stale   -- deleteme
	print(title1,max(x0 + 16, (x0+x1)/2 - #title1*char_w/2), y0+2, title_col)
	clip()

	line(x0+1, y0-1, x1-1, y0-1, border_col)
	pset(x0,y0,border_col)
	pset(x1,y0,border_col)

	if not sdat.squishy_windows or (get_active_window() != win) then

		-- sides, bottom
		line(x0+1, y1+1, x1-1, y1+1, border_col)
		line(x0-1, y0+1, x0-1, y1-1, border_col)
		line(x1+1, y0+1, x1+1, y1-1, border_col)

		-- bottom corners
		pset(x0,y1,border_col)
		pset(x1,y1,border_col)

	else

		-- partial sides for active squishy window
		line(x0-1, y0+1, x0-1, y0+12, border_col)
		line(x1+1, y0+1, x1+1, y0+12, border_col)
	end


	-- shadow around the side: 2px left 3px down
	-- promising, but need to spend some reserved colours for a more gentle shadow
	-- and needs to support squishy windows, shaped windows (could be a feature of _blit_process_video)
	-- also: _blit_process_video needs to mask out stencil bits and/or observe 0x40 (e.g. for filenav item shadows)
	if (false) then

		poke(0x8000, unpack(dark_col)) -- to do: memmap a 4k block
		poke4(0x5508,0x7f7f7f7f)
		color(0)

		-- left
		rectfill(x0-2, y0+3, x0-2, y1+1)
		rectfill(x0-3, y0+4, x0-3, y1+1)

		-- bottom
		rectfill(x0-3, y1+2, x1-1, y1+2)
		rectfill(x0-2, y1+3, x1-2, y1+3)
		rectfill(x0-1, y1+4, x1-3, y1+4)

		-- L-shaped gap bottom left
		rectfill(x0-1,y1,x0-1,y1+1)
		rectfill(x0,y1+1,x0,y1+1)

		palt(0,true)
		poke4(0x5508,0x3f3f3f)
	end


end


function draw_window_paused_menu(win,sx,sy)
	
	if (not win.pmenu) return

	local ww,hh = 70, 12 + (#win.pmenu) * 6
	local winw = win.width / pixel_scale()
	local winh = win.height / pixel_scale()
	local x0,y0 = sx + winw/2 - ww, sy + winh/2 - hh
	local x1,y1 = x0 + ww*2 - 1, y0 + hh * 2 - 1

	rectfill(x0,y0,x1,y1,0)
	rect(x0+1,y0+1,x1-1,y1-1,7)


	for i=1,#win.pmenu do 
		local xx = x0 + 20
		local yy = y0 + 3 + i * 12
		local label = "??"

		if (type(win.pmenu[i].label) == "function") label = win.pmenu[i].label()
		if (type(win.pmenu[i].label) == "string")   label = win.pmenu[i].label
		print(label, xx, yy, 7)
		if (i == win.pmenu.ii) print("\^:0103070f07030100",xx-10,yy,7)
	end
end

function update_window_paused_menu(win)

	if (not win) return

	poke(0x3, win.paused and 1 or 0) -- for shell

	if (win.paused) then
		local buttons = btnp()
		if (win.pmenu) then

			if ((buttons & 0x73) > 0) then
				-- printh("selected pause menu item "..win.pmenu.ii)
				local item = win.pmenu[win.pmenu.ii]
				if (type(item.action) == "function") item.action(buttons)
			end

			if (btnp(2)) win.pmenu.ii -= 1
			if (btnp(3)) win.pmenu.ii += 1
			if (win.pmenu.ii < 1) win.pmenu.ii = #win.pmenu
			if (win.pmenu.ii > #win.pmenu) win.pmenu.ii = 1
		end

--	else
	elseif (win.pauseable) then -- 0.2.0h
		-- pause button to pause (not within first 0.5 seconds ~ could be left over button state used to launch the window or resume)
		if (btnp(6) and time() > win.created_t + 0.5 and (not win.resumed_t or time() > win.resumed_t + 0.5)) then
			win.paused = true
			generate_paused_menu(win)
			send_message(win.proc_id, {event = "pause"})
		end
	end

end

on_event("resume_pwc", function(msg)
	local win = get_window_by_proc_id(msg._from)
	if (not win) return	
	if (win.was_pauseable ~= nil) win.pauseable = win.was_pauseable -- restore pauseable state at time of last halt
	win.resumed_t = time()-- used to stop pause menu from immediately reopening
end)


on_event("toggle_pause_menu", function(msg)
	local win = get_active_window()
	if (not win or not win.pauseable) return -- e.g. can't pause desktop wallpaper from html shell
	if (win.paused) then
		win.paused = false
		send_message(win.proc_id, {event = "unpause"})
	else
		win.paused = true
		win.pmenu_mode = nil 
		generate_paused_menu(win)
		send_message(win.proc_id, {event = "pause"})
	end
end)

on_event("close_pause_menu", function(msg)
	local win = get_active_window()
	if (win.paused) then -- only happens for fullscreen apps
		win.paused = false
		win.pmenu_mode = nil 
		send_message(win.proc_id, {event = "unpause"})
		send_message(win.proc_id, {event = "update_menu_labels"}) -- might as well; sometimes labels change as a result of selected item
	end
end)

--[[
	fullscreen binary exports:
		- have an Exit option in pause menu that quits to Host OS
		- can not navigate away from the fullscreen workspace they are running in
		-> users who know how can't sneak into desktop and view source code etc

	// to disable this behaviour for exports, set the window's can_escape_fullscreen attribute:
	window{can_escape_fullscreen = true}

]]

function is_fullscreen_export(win)
	local win = win or get_active_window()
	if (not win) return false
	return win.fullscreen and win.player_cart and (stat(317)&0x3) == 0x3 and not win.can_escape_fullscreen
end

function is_locked_in_fullscreen()
	return is_fullscreen_export(get_active_window())
end



function generate_paused_menu(win)
	win.pmenu = {}

	_signal(23) -- block buttons

	if (win.pmenu_mode == "options") then

		add(win.pmenu,{
			label  = function(self) return (sdat.mute_audio and "Sound: Off" or "Sound: On") end,
			action = function(b) send_message(pid(), {event = "toggle_mute"}) end
		})

		add(win.pmenu,{
			label  = function(self) return (sdat.fullscreen and "Fullscreen: On" or "Fullscreen: Off") end,
			action = function(b)  
				sdat.fullscreen = not sdat.fullscreen
				store("/appdata/system/settings.pod", sdat)
			end
		})

		add(win.pmenu,{
			label = "Back",
			action = function() win.pmenu_mode = nil generate_paused_menu(win) end
		})

		win.pmenu.ii = 1

		return
	end


	-- let app know it should update menu items (the ones that are functions)
	-- to do: how to get results back in time to display menu? see last value for a moment
	send_message(win.proc_id, {event = "update_menu_labels"})

	add(win.pmenu, {label = "Continue", action = function() 
		win.paused = false
		send_message(win.proc_id, {event = "unpause"})
	end})

	-- insert userland menu items
	local menu = proc_menu[win.proc_id]

	if (menu) then
		for i=1,#menu do
			add(win.pmenu,
			{
				id = menu[i].id,
				label = menu[i].label or "??",
				action = function(b)
					send_message(win.proc_id, {event="menu_action", id=menu[i].id, b=b})
				end
			})
		end
	end


--[[
	add(win.pmenu, {
		label = function() return "Favourite "..(win.favourited and "\^:367f7f7f3e1c0800" or "\^:3649414122140800") end,
		action = function(b)
			win.favourited = not win.favourited -- to do: keep in sync with favourites.pod
		end 
	}) 
]]


	add(win.pmenu,{
			label = "Options",
			action = function() win.pmenu_mode = "options" generate_paused_menu(win) end
		})

	add(win.pmenu, {label = "Reset Cartridge", action = function() 

		if (haltable_proc_id == win.proc_id) then
			-- pwc: same as hitting ctrl-r (dupe)
			haltable_proc_id = create_process("/system/apps/terminal.lua",{
				corun_program = "/ram/cart/main.lua",       -- program to run // terminal.lua observes this and is also used to set pwd
				window_attribs = {
					pwc_output = true,                      -- replace existing pwc_output process			
					show_in_workspace = true,               -- immediately show running process
				}
			})
		else
			send_message(2, {event="restart_process", proc_id = win.proc_id})
			win.paused = false
			win.resetting = true -- don't kill process in win:update() while resetting
		end

	end})

	-- to do: can the process that launched a process have a say in its pause menu?
	-- add(win.pmenu, {label = "Exit to Splore", action = function() end})

	local has_exit = true -- normally there is "Exit" at end of pause menu, except..
	if (haltable_proc_id == win.proc_id) has_exit = false    -- running /ram/cart via ctrl+r; just press escape instead
	if (win.player_cart and stat(318) == 1) has_exit = false -- running entry point cart / bbs cart under web (nothing to exit to)
	
	if (has_exit) then
		add(win.pmenu, {label = "Exit Cartridge", action = function()
			if is_fullscreen_export(win) and stat(318) == 0 then
				-- 0.2.0b playing the entry point cart in a binary export -> quit to host OS (update: same as esc when autoclose=true)
				send_message(2, {event="shutdown"})
			elseif (haltable_proc_id == win.proc_id) then
				-- halt program and enable command prompt
				win.paused = false
				send_message(win.proc_id, {event = "unpause"})
				send_message(haltable_proc_id, {event="halt"})
				haltable_proc_id = false
			else
				if (win.fullscreen) then
					close_workspace(workspace_index) -- fullscreen: assume running as sole child in a workspace created for that purpose
					set_workspace(previous_workspace)
				else
					close_window(win, true) -- windowed programs can be pauseable too, but is not on by default
				end
			end
		end})
	end

	-- always start at Continue
	win.pmenu.ii = 1

	
	
end

	

-- doesn't kill process -- that's up to process manager
-- update: seems almost always want to kill at the same time; added as a parameter
function close_window(win, do_kill)
	
	_kill_process(do_kill and win and win.proc_id)

	win = win or get_active_window() -- is the get_active_window default ever used? to do: review and remove

	if (win.closing) then return end -- already started the closing process. don't want to send messages twice

	-- invalidate active window
	if (win.parent.active_window == win) win.parent.active_window = nil

	-- headless process should not be hogging cpu / calling _draw
	send_message(win.proc_id, {event="lost_visibility"})

	-- send message to self to close after end of frame
	-- (otherwise can invalidate an iterator somewhere?)

	send_message(pid(), {event="close_window",proc_id = win.proc_id})
	win.closing = true

end

function close_window_with_confirmation(win, do_kill)

	local found_unsaved_changes

	if win.location and string.sub(win.location, 1, 10) ~= "/ram/cart/" then

		if (win.unsaved_changes) then
			create_process("/system/misc/confirm.p64", 
			{prompt = "Discard Unsaved Changes?", title = "Close", window_attribs = {workspace="current", autoclose=true}, proc_id = win.proc_id})
			return
		end

	else
		-- ram/cart/* autosaves when closed
		if (win.unsaved_changes) then
			send_message(win.proc_id, {event="save_file", autosave = true})
			send_message(win.proc_id, {event="exit"}) -- will be processed after save_file
			return
		end
	end

	-- go ahead
	return close_window(win, do_kill)
	
end


function generate_windat()

	local windat = {
		--{x=0,y=infobar_y,width=480,height=270-infobar_y} -- first entry is always infobar
	}

	for i=1,#ws_gui.child do
		local w2 = ws_gui.child[i]
		-- only windows that have a frame and are solid
		-- later: could send a low-res 160x90 mask including non-rectangular windows
		-- minimal information: non-sandboxed programs can use the proc_id to look up more info 
		if (w2.has_frame and _ppeek(w2.proc_id, 0x547d) == 0 and w2 ~= win) then
			add(windat, {
				x = w2.x, y = w2.y - bar_h,
				width = w2.width, height = w2.height + bar_h,
				proc_id = w2.proc_id
			})
		end
	end

	return windat
end


function set_active_window(win)

	if (not win) return

	-- bring to front of same-z group
	win:bring_to_front()

	-- set active window for that sub-gui
	win.parent.active_window = win

	-- give focus to / take focus from tooltray
	tooltray_active_window = (win.parent == tooltray_gui) and win or nil
end


function install_widget(win)

	if (win.prog:sub(1,9) == "/ram/cart" and (win.prog[10] == "/" or win.prog[10] == nil)) then
		notify("installed "..win.prog.." as a temporary widget")
		return
	end

--	printh(pod{win.prog, win.location})

	local widgets = fetch("/appdata/system/widgets.pod") or {}
	add(widgets,{
		x = win.x,
		y = max(win.y, 0),
		width = win.resizeable and win.width or nil,
		height = win.resizeable and win.height or nil,
		location = win.location,
		prog = win.prog,
		had_frame = win.had_frame
	})
	store("/appdata/system/widgets.pod", widgets)
	notify("installed widget: "..win.prog)
end

function update_widget_position(win)

	local widgets = fetch("/appdata/system/widgets.pod") or {}

	local found_widget_to_update

	for i=1,#widgets do
		local wid = widgets[i]
		-- identify by position and prog
		-- always happen after a grab and drag (so start_grab_x/y is set)
		if (wid.x\1 == win.start_grab_x and wid.y\1 == win.start_grab_y and wid.prog == win.prog) 
		then
			found_widget_to_update = true
			wid.x = win.x\1
			wid.y = win.y\1
		end
	end

	if (found_widget_to_update) then
		store("/appdata/system/widgets.pod", widgets)
		--notify("updated widget: "..win.prog)
	end
end


function uninstall_widget(win)
	local widgets = fetch("/appdata/system/widgets.pod") or {}

	local widget_to_delete
	for i=1,#widgets do
		local widget = widgets[i]
		-- identify by (old or grabbed) position and program
		if (widget.x\1 == win.x\1 or widget.x\1 == win.start_grab_x) and (widget.y\1 == win.y\1 or widget.y\1 == win.start_grab_y) and widget.prog == win.prog 
		then
			widget_to_delete = widget		
		end
	end

	if (widget_to_delete) then
		del(widgets, widget_to_delete)
		store("/appdata/system/widgets.pod", widgets)
		notify("uninstalled widget: "..win.prog)
		return widget_to_delete.width
	else
		notify("** could not uninstall widget: "..win.prog)
	end

end

function pop_out_widget(win, new_x, new_y)
	local size_was_set = uninstall_widget(win)
	-- move window to desktop
	win:detach()
	ws_gui:attach(win)
	win.x = new_x
	win.y = max(new_y, 12) -- can't drop on toolbar
	-- give frame -- to do: store original setting
	if (win.had_frame) then
		win.has_frame = true
		win.moveable = true    -- a fair assumption if it was installed in the first place
		if (size_was_set) win.resizeable = true  -- if there was a width set on widgets.pod item, must be resizeable (usually the case)
		create_window_frame(win)
	end
end


local function drag_window(win)

	local mx, my = mouse()
	local x0, y0 = win.sx, win.sy
	local x1 = mx - dragging_window_xo
	local y1 = my - dragging_window_yo
	local min_y1 = win.has_frame and 24 or 12
	if (win.parent == tooltray_gui) min_y1 = 0
	y1 = max(min_y1, y1)

	-- let application know; app can also send message requesting move
	send_message(win.proc_id, {event="move", x = x1, y = y1, dx = x1 - x0, dy = y1 - y0})

	-- this section is needed to keep display size in sync with window size when it is squashed
	-- tricky because gui element changes size too late for display size to change before draw
	--> detect if it is /going/ to be changed, and defer window position change to next frame
	--  via a drag_squashable_window message
	local squashed_display_changed_size = false -- or unsquashed; changed size due to squashing
	if (win.squashable) then
		local pwidth, pheight = _get_process_display_size(win.proc_id)
		-- predict new squashed width this frame -- logic needs to match gui.lua (!)
		local ww = min(win.width0, (x1 + win.width0) - 0)
		ww = max(win.min_width, min(ww, ws_gui.width - x1))
		local hh = min(win.height0, (y1 + win.height0) - 0)
		hh = max(win.min_height, min(hh, ws_gui.height - y1))
		if (ww ~= pwidth or hh ~= pheight) then
			send_message(win.proc_id, {event="squash", width = ww, height = hh})
			squashed_display_changed_size = true
		end
	end

	if (squashed_display_changed_size) then
		-- move next frame (otherwise display size is a frame behind)
		send_message(3, {event="drag_squashable_window", x = x1, y = y1, proc_id = win.proc_id})
	else
		-- can move same frame
		win.x = x1
		win.y = y1
	end
end

function drop_window(win)
	-- drop into tooltray

	local mx,my = mouse()

	if (my < toolbar_y) 
	then
		if (win.parent == tooltray_gui) then
			-- already in tooltray: store position (e.g. can drag owl around)
			-- printh("moved within tooltray")
			if (win.start_grab_x) then
				local dx,dy = win.x - win.start_grab_x,  win.y - win.start_grab_y
				if (dx*dx+dy*dy>=3*3 or time() > win.start_grab_t + 0.7) then
					update_widget_position(win)
				else
					-- snap back when move less than 3 pixels and dragged for less than 0.7 seconds (might be intended to be a click / tap)
					win.x = win.start_grab_x
					win.y = win.start_grab_y
				end
			end
		else
			-- printh("dropped into tooltray: "..my)
			win:detach()				
			win.x = mx - dragging_window_xo
			win.y = my - dragging_window_yo + toolbar_y - (win.has_frame and 12 or 0)
			win.y = max(0, win.y) -- never off the top

			-- remove frame if there is one
			win.had_frame = win.has_frame and true or nil -- remember for when popping out
			win.has_frame = false
			win.child={}
			tooltray_gui:attach(win)

			-- remove squashy attributes (interesting, but maybe later)
			update_squashable_attributes(win)
			
			-- install in /system/appdata/widgets.pod
			install_widget(win)
		end
	elseif (win.parent == tooltray_gui) then
		pop_out_widget(win, mx - dragging_window_xo, my - dragging_window_yo - toolbar_y)
		
	end

end


function create_window_frame(win)

	local bar = win:attach(
		{
			x = 0, y = -bar_h,
			width_rel = 1.0,
			height = bar_h,
			clip_to_parent = false,
			cursor = "grab", -- to do: why doesn't this work? because outside of parent?
			is_window_bar = true
		}
	)

	-- close button
	bar:attach(
		{
			cursor = "pointer",
			x = -2, justify="right",
			y = 0, vjustify="center",
			width = 12, height = 12,
			tap = function(self)
				close_window_with_confirmation(self.parent.parent, true)
			end,
			draw = function(self, msg)
				(msg.has_pointer and circfill or circ)(self.width / 2, self.height / 2 - 1, 2, 
					win.parent.active_window == win and theme("window_button") or theme("dormant_button")) 					
			end,
			update = function(self)
				-- make space for tiny window
				if(self.width < 32) self.x = 0
			end
		}
	)

	-- app menu button
	bar:attach(make_window_button(bar, "app menu", 4, 1, 12, 10 +1)) -- height +1 so that window frame border is not clobbered

	function bar:update(event)
		self.col_k = win.parent.active_window == win and "window_button" or "dormant_button"
	end

	-- to do: keep offset; when go up into tooltray area and back down, relative grab position should stay the same
	function bar:drag(event)
		if (not win.moveable) return
		drag_window(win)
	end

	function bar:release(msg)
		--printh("dropped: "..pod(msg))
		dragging_window = false
		drop_window(win)
	end

	function bar:click(msg)
		if (not key("lshift")) then -- key state test, but actually quite useful! drag windows around underneath
			bar.parent:bring_to_front()
		end
		win.parent.active_window = win -- either way: this window becomes the active window

		if (not win.fullscreen) then
			dragging_window = win
			local mx, my = mouse()
			dragging_window_xo = mx - win.x
			dragging_window_yo = my - win.y
		end
	end

	function bar:doubletap()
		-- maximise
--			win.x = 0
--			win.y = 12

		if (not win.resizeable) return

		if (win.maximised) then
			win.maximised = false
			send_message(win.proc_id, {event="resize", x = win.old_x, y = win.old_y, width = win.old_width, height = win.old_height})
		else
			win.maximised = true
			win.old_x = win.x
			win.old_y = win.y
			win.old_width = win.width
			win.old_height = win.height
			-- space to see frame
			send_message(win.proc_id, {event="resize", x = 1, y = 24, width = 478, height = 245})
		end

	end



	--[[--------------------------------------------------------------------------------------------------------------

		resize widget

		// always attach if not resizeable; window attribute can change after creation

		to do: could be a single large rectangle behind window
		(so only works when cursor is slightly outside of window)
		or -- put in front and use test_point (ha!)
	
	--------------------------------------------------------------------------------------------------------------]]--

	local function resize_click(self, event) 

		-- burn in evaluated size and position (for squashable windows)
		win.x = win.sx - win.parent.sx
		win.y = win.sy - win.parent.sy
		win.width0 = win.width
		win.height0 = win.height

		-- resize modifications relative to a starting position and size
		win.start_mx, win.start_my = mx, my
		win.start_w, win.start_h = win.width, win.height
		win.start_x, win.start_y = win.x, win.y

	end

	function resize_draw(self, event) 
		-- debug: view the widget // don't need to clip() because .clip_to_parent == false
		-- rect(0, 0, self.width-1, self.height-1, 5)
	end

	-- resize bottom right
	if (win.resizeable) then

		win:attach({
			width = 8, height = 8,
			clip_to_parent = false,
			cursor  = 8,

			update = function(self)
				self.x = win.width - 4
				self.y = win.height - 4
			end,
			draw  = resize_draw,
			click = resize_click,
			drag = function(self, event)
				if (win.resizeable and (event.dx ~= 0 or event.dy ~= 0)) then
					-- use window manager mx, my because using relative event.mx,event.my will jump around as window resizes
				
					local new_width  = max(win.min_width, win.start_w + (mx - win.start_mx))
					local new_height = max(win.min_height, win.start_h + (my - win.start_my))
					send_message(win.proc_id, {event="resize", width = new_width, height = new_height})
			
				end
			end
		})

		-- resize bottom left
		win:attach({
			width = 8, height = 8,
			clip_to_parent = false,
			cursor  = 9,

			update = function(self)
				self.x = -4
				self.y = win.height - 4
			end,
			draw  = resize_draw,
			click = resize_click,

			drag = function(self, event) 
				if (win.resizeable and (event.dx ~= 0 or event.dy ~= 0)) then
					-- set x in same message so that visible change is simultaneously (otherwise jitters)
					local new_width  = max(64, win.start_w\1 - (mx - win.start_mx))
					local new_height = max(32, win.start_h + (my - win.start_my))
					send_message(win.proc_id, {event="resize", width = new_width, height = new_height, x = win.start_x + (mx - win.start_mx)
				})

				end
			end
		})
	end
--[[
	-- commented; maybe nice to have just bottom left, bottom right widgets.

	-- resize bottom
	win:attach({
		x = 4, 
		y = win.height - 4,
		width = win.width - 8,
		height = 8,
		clip_to_parent = false,
		update = function(self)
			self.y = win.height - 4
			self.width = win.width - 8
		end,
		draw  = resize_draw,
		click = resize_click,
		drag = function(self, event) 
			if (event.dx ~= 0 or event.dy ~= 0) then
				send_message(win.proc_id, {event="resize", height = win.start_h + (my - win.start_my)})
			end
		end
	})

	-- resize left
	win:attach({
		x = -4, y = 0, 
		width = 8, height = win.height  - 4,
		clip_to_parent = false,
		update = function(self)
			self.height = win.height  - 4
		end,
		draw  = resize_draw,
		click = resize_click,
		drag = function(self, event) 
			if (event.dx ~= 0 or event.dy ~= 0) then
				send_message(win.proc_id, {event="resize", 
					width = win.start_w\1 - (mx - win.start_mx)\1, 
					x = win.start_x + (mx - win.start_mx)
				})
			end
		end
	})

	-- resize right
	win:attach({
		x = win.width-4, y = 0, 
		width = 8, height = win.height  - 4,
		clip_to_parent = false,
		update = function(self)
			self.height = win.height  - 4
			self.x = win.width-4
		end,
		draw  = resize_draw,
		click = resize_click,
		drag = function(self, event) 
			if (event.dx ~= 0 or event.dy ~= 0) then
				send_message(win.proc_id, {event="resize", 
					width = win.start_w\1 + (mx - win.start_mx)\1, 
				})
			end
		end
	})
]]



end

-- wm bundles gui attributes together as "squashable"
-- --> means display is squashable and squash/confine_to_* attributes are set accordingly
-- to do: could use *_to_crop for tabs
function update_squashable_attributes(win)

	local was_squashy = win.squash_to_parent or win.confine_to_parent or win.squash_to_clip or win.confine_to_clip

	win.squash_to_parent  = nil
	win.confine_to_parent = nil
	win.squash_to_clip    = nil
	win.confine_to_clip   = nil

	if (win.squashable and win.has_frame) then
		-- use *_to_parent -- to_clip is too messy
		win.squash_to_parent  = true
		win.confine_to_parent = true
		if not was_squashy then
			-- going from not squishy -> squishy: set base size (safety)
			win.width0 = win.width
			win.height0 = win.height
		end
	elseif was_squashy then
		-- going from squishy -> regular; set window position and size to match evaluated region
		win.x = win.sx - win.parent.sx
		win.y = win.sy - win.parent.sy
		win.width0 = win.width
		win.height0 = win.height
	end

end


-- new version
function create_window(target_ws, attribs)

	local win = nil

--	printh("creating window: "..pod{attribs})

	add(boot_messages, attribs.prog)

	attribs = attribs or {}

	if (not attribs.width or not attribs.height or attribs.fullscreen) then
		attribs.width = 480
		attribs.height = 270
		attribs.x = 0
		attribs.y = 0
		attribs.fullscreen = true
	end

	attribs.x = attribs.x or (attribs.tabbed and 0  or rnd(480 - attribs.width)\1)
	attribs.y = attribs.y or (attribs.tabbed and 11 or (30 + rnd(230 - attribs.height)\1))


	-- default attributes

	if (attribs.has_frame  == nil)   attribs.has_frame  = false
	if (attribs.moveable   == nil)   attribs.moveable   = true
	if (attribs.resizeable == nil)   attribs.resizeable = true
	if (attribs.fullscreen       )   attribs.width, attribs.height, attribs.x, attribs.y = 480, 270, 0, 0
	if (attribs.maximised        )   attribs.width, attribs.height, attribs.x, attribs.y = 480, 248, 0, 11

	if (attribs.pauseable == nil) attribs.pauseable = attribs.fullscreen and not attribs.desktop_filenav and not attribs.wallpaper

	if (attribs.min_width == nil) attribs.min_width = 40
	if (attribs.min_height == nil) attribs.min_height = 20

	-- squashable
	update_squashable_attributes(attribs)

	win = target_ws:attach(attribs)

	-- finished recovering output terminal by creating this window
	target_ws.recovering = false
	
	
	-- position at top of same-z stack
	win:push_to_back()    -- bottom of same-z stack (push behind any foreground layers)
	win:bring_to_front()  -- bring back up to front of same-z stack

	win.send_mouse_update = true -- send mouse message on first frame
	win.created_t = time()

	win.test_point = function(self, x, y)
		-- process is using transparency on display bitmap?
		local alphabits = _ppeek(win.proc_id, 0x547e) -- INTERACT_ALPHABITS_ADDR
		if (not alphabits or alphabits == 0) return true

		if (win.interactive == false) return false -- e.g. cursor charms should never block mouse click

		-- look up the pixel
		local disp_width = _ppeek(win.proc_id, 0x5478) + (_ppeek(win.proc_id, 0x5479) << 8)
		local val = _ppeek(win.proc_id, 0x10000 + (y * disp_width) + x)

		-- considered solid when at least one of the alpha bits is set in this pixel
		return (val & alphabits ~= 0)
	end

	
	function win:draw()

		-- not visible or about to close --> skip
		if (not win.visible or win.closing) return true -- don't draw children

		--if (win.closing) return

		-- don't render on first visible frame as process :draw has likely not been called
		-- without this, get flickering when switching tabs
		-- update: this mechanism seems redundant if entire wm skipping a frame when chaning window focus (see last_draw_window)
			-- but actually prevents a different type of flicker -- e.g. switching from gfx to map editor at start.
			-- to do: investigate why; just a result of 2 frames instead of 1? need to formalise wm guarantees

		-- commented: should be doing this at the workspace level anyway; 
		-- consider stacked tabs that are drawn except for the top one on the first frame after changing workspace

		--[[
		if (not win.process_had_a_chance_to_draw) then
			win.process_had_a_chance_to_draw = true
			return
		end
		]]

		local blit_result = false
		
		if sdat.squishy_windows and win.has_frame and get_active_window() == win then

			local border_col = theme(get_active_window() == win and "window_border" or "dormant_border")

			clip()
			if (not win.sxa) win.sxa = {}
			if (not win.sya) win.sya = {}
			win.sxa[0] = win.sx + 0.5
			win.sya[0] = win.sy + 0.5

			while (#win.sxa < win.height) add(win.sxa, win.sxa[#win.sxa])
			while (#win.sya < win.height) add(win.sya, win.sya[#win.sya] + 1)
			
			for yy = 1, #win.sxa do
				win.sxa[yy] = win.sxa[yy] * 0.03 + win.sxa[yy-1] * 0.97
				win.sya[yy] = win.sya[yy] * 0.03 + (win.sya[yy-1] + 1) * 0.97
				if (abs(win.sya[yy] - (win.sya[yy-1] + 1)) < 0.05) win.sya[yy] = win.sya[yy-1] + 1.0
			end

			camera()
			local yy1 = win.sya[0]
			for yy = 0, win.height-2 do
				local ht = (win.sya[yy+1] - win.sya[yy])\1 -- draw > 1px high when stretched out

				while (yy1 <= win.sya[yy]) do
					blit_result = _blit_process_video(win.proc_id, 0, yy, nil, max(1,ht), win.sxa[yy], yy1)

					if (blit_result) then
						blit(prev_frame, nil, win.sxa[yy], yy1, win.sxa[yy], yy1, win.width, max(1,ht))
					end

					pset(win.sxa[yy] - 1, yy1, border_col)
					pset(win.sxa[yy] + win.width, yy1, border_col)
					yy1 += 1
				end
			end

			-- dupe on last line for efficiency -- sides are one pixel in
			local ht = 1
			local yy = win.height-1
			local ht = (win.sya[yy+1] - win.sya[yy])\1 -- draw > 1px high when stretched out
			while (yy1 <= win.sya[yy]) do
				blit_result = _blit_process_video(win.proc_id, 0, yy, nil, max(1,ht), win.sxa[yy], yy1)
				if (blit_result) then
					blit(prev_frame, nil, win.sxa[yy], yy1, win.sxa[yy], yy1, win.width, max(1,ht))
				end
				pset(win.sxa[yy], yy1, border_col)
				pset(win.sxa[yy] + win.width - 1, yy1, border_col)
				yy1 += 1
			end

			-- bottom line (two pixels in)
			local yy = win.height-1
			line(win.sxa[yy] + 1, yy1, win.sxa[yy] + win.width - 2, yy1, border_col)

		else
			-- regular rectangular blit

			blit_result = _blit_process_video(win.proc_id, 0, 0, nil, nil, win.sx, win.sy)

			-- clear squishy positions

			win.sxa = nil
			win.sya = nil

			-- could not blit (_draw didn't complete?) 
			--> blit from desktop copy instead (when not fullscreen -- fullscreen can just do nothing!)
			-- non-rectangular windows (w/ PROCBLIT_TRANSP_ADDR set) should make sure  [update: ... make sure what?]
			if (blit_result and not win.fullscreen) then
				blit(prev_frame, nil, win.sx, win.sy, win.sx, win.sy, win.width, win.height)
				--clip() circfill(0,0,16,8) circfill(0,0,24,7) -- debug: show that (desktop) window is frame-skipping	
			end

		end
		


		-- debug: show window size
--		local ww,hh = _get_process_display_size(win.proc_id)
--		print(pod{win.width, win.height, ww, hh}, 5,15,8+rnd(16))

		-- always draw frame for now (lazy)  // to do: check visibility
		if (win.has_frame) then
			clip()
			draw_window_frame(win)
		end

		-- paused menu

		if (win.paused) then
			draw_window_paused_menu(win, win.sx, win.sy)
		end

		-- stickers  //  deleteme -- stickers now regular children
		--[[
		if (type(win.stickers) == "table") then
			clip() camera()
			for i=1,#win.stickers do
				local s = win.stickers[i]
				if (type(s) == "table" and type(s.bmp) == "userdata" and s.x and s.y) then
					local ww, hh = s.bmp:attribs()
					if (s.x >= 0 and s.y >= -12 and s.x < win.width and s.y < win.height) then
						spr(s.bmp, win.sx + s.x - ww\2, win.sy + s.y - hh\2)
					else
						-- to do: fall off? sparkle puff?
						del(win.stickers, s)
					end
				end
			end
		end
		]]
		
	end


	function win:update()

		win.is_active = self == get_active_window()

		-- no process --> close 
		-- except when in the middle of resetting cartridge: there might be a few frames where process has no display
		if _process_state(win.proc_id) < 0 and not win.resetting then
			--printh("closing dead process. "..tostring(win.closing))
			close_window(win)
			return
		end

		-- autoclose a non-tabbed window that is covered by a tabbed window
		-- otherwise: need some way to access that window. don't want to tab it! sheesh

		if (win.autoclose or win.empty_workspace_file_chooser) and
			win.parent.child[#win.parent.child].tabbed and
			not win.tabbed and            -- also means that this window isn't the window on top, which is tabbed
			time() > win.created_t + 0.5  -- don't close in the first half a second (give a chance to get focus)
		then
			close_window(win, true)
			return
		end

		-- tabbed: adapt position and size to useable desktop space

		if (win.tabbed) then

			-- slide with toolbar (means change height every frame when transitioning)
			win.y = min(0, toolbar_gui.sy) + toolbar_gui.height
			win.sy = win.y

			if (win.height ~= 270 - win.y) then
				win.height = 270 - win.y
				send_message(win.proc_id, {event="resize", width = win.width, height = 270 - win.y})
			end
		end

		-- 
		update_squashable_attributes(win)

		-- squashable display: keep display size in sync with width, height (instead of width0, height0)
		-- bar:drag handles the common case and ensures elements size matches draw size (drag_squashable_window)
		-- but this is needed for other cases where window is squashed (e.g. app requests position change)
		if (win.squashable) then
			local pwidth, pheight = _get_process_display_size(win.proc_id)
			if (pwidth and pwidth ~= win.width) or (pheight and pheight ~= win.height) then
				-- printh("squash from win:update(): "..pod{pwidth, win.width, win.width, win.height})
				send_message(win.proc_id, {event="squash", 
					width = win.width, 
					height = win.height, 
					x = win.x, y = win.y})
			end
		end

	end

	

	function win:click(msg)

		set_active_window(win)

		-- forward click to window 
		-- to do: review if window be getting gui messages like this? i.e. can use from on_event()
		-- (if so, need to also send tap / doubletap etc. a bit of extra code but not a perf question)
		-- maybe app should always set up a gui; seems nicer to have one consistent way of doing it
		-- BUT -- maybe kinda surprising can't do on_event("click", ...)
		-- send_message(win.proc_id, msg)

		return true -- processed
	end

	function win:tap(msg)

		-- context menu on mb2 (used by filenav -- need to provide nicer mechanism for generating that menu)
		-- inside tap message so that filenav has chance to generate menu based on new selection
		if (win.has_context_menu or win.parent == tooltray_gui) and msg.last_mb == 2
		then
			send_message(3, {event = "toggle_app_menu", 
				_delay = 0.0 , is_context_menu = true, 
				x = win.sx + msg.mx - 70, 
				y = min(win.sy + msg.my - 30, 150), -- keep y above 150 (assume menu is shorter) // to do: maybe need a keep_inside_parent attribute
				proc_id = win.proc_id }
			)
		else
			-- forward tap to window  -- deleteme; apps should set up a gui instead
			-- send_message(win.proc_id, msg)
		end

	end

	-- can move window around by grabbing interior if app sends a "grab" message
	function win:drag(msg)
		if (dragging_window == win) drag_window(win)
	end
	function win:release(msg)
		if (dragging_window == win) then
			drop_window(win)
		end
		dragging_window = nil		
	end


	-- titlebar

	if (win.has_frame) then
		create_window_frame(win)
	end
		

	-- creating a desktop wallpaper --> automatically create a filenav overlay

	if win.wallpaper and target_ws and (win.workspace == "new" or win.workspace == "tooltray") then

		local filenav_workspace = win.workspace == "tooltray" and "tooltray" or target_ws.id

		target_ws.desktop_filenav_proc_id = 
		create_process("/system/apps/filenav.p64",{
			 -- window attribs of the desktop program launching the desktop filenav
			argv = {"-desktop", win.desktop_path or "/desktop"},
			window_attribs = {
				workspace = filenav_workspace, -- same workspace as the wallpaper
				show_in_workspace = false, -- don't become active
				width = win.width, height = win.height,
				x = win.x, y = win.y, z = win.z + 1, -- desktop is -1000 (head.lua)
				has_frame = false,
				moveable = false,
				resizeable = false,
				desktop_filenav = true
			}
		})
	end

	
	return win	
end

function pixel_scale()
	local video_mode = @0x547c
	if (video_mode == 3) return 2
	if (video_mode == 4) return 3
	return 1
end


--[[
	mouse_scaled()
	takes video mode into account
	to do: lower level
]]
function mouse_scaled()

	local x,y,b,dx,dy = mouse()

	x \= pixel_scale()
	y \= pixel_scale()

	return x,y,b,dx,dy
end

local last_draw_t = 0
local smoothed_fps = 0
local show_fps = false
local last_drawn_ws = nil
local ws_gui_frames = 0

local inited_font = false

boot_messages = {}


local xodat = {26,22,19,17,15,14,12,11,10,9,8,7,6,5,5,4,3,3,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,3,3,4,5,5,6,7,8,9,10,11,12,14,15,17,19,22,26}

function polaroid(x0,y0,x1,y1,q0,q1)
	rectfill(x0-4,y0-4,x1+4,y0-1,7)
	rectfill(x0-4,y0,x0-1,y1,7)
	rectfill(x1+1,y0,x1+4,y1,7)
	rectfill(x0-4,y1+1,x1+4,y1+15,7)
	rect(x0-5,y0-5,x1+5,y1+16,1)
	rect(x0-1,y0-1,x1+1,y1+1,1)
	
	rectfill(x0-1,y1+3,x1+1,y1+4,6)
	
	rectfill(x0-1,y1+3,x0+(x1-x0+1)*mid(0,q0/max(1,q1),1),y1+4,13)
	
	if (x1-x0 > 34) then
		print("\014frame "..flr(q0),x0+1,y1+8,13)
	end
	if (x1-x0 > 80) then
		print("\014\^ifin:\^-i ctrl-9",x1-42,y1+8,13)
	end
end

function _draw()



	pal(0) -- reset colourtable but leave rgb display palette alone

	-- don't draw frame when changing window or workspace; allows messages to complete and prevents flicker
	-- (e.g. switch through newly opened tabs, or gfx setting current sprite picked up by map editor)
	if (last_draw_window ~= get_active_window()) then
		last_draw_window = get_active_window()
		return
	end

	-- also skip first frame when changing workspace
	-- to do: unnecessary? prevents gfx->map flicker, but maybe just because skipping 2 frames instead of 1
	-- also: causes no visible refresh when holding alt-right/left (only see where workspace index ended up on release) -> why?
	if (last_drawn_ws ~= ws_gui) then last_drawn_ws = ws_gui return end


	-- sanity
	if (ws_gui) then
		if (ws_gui.width < 480) printh("*** ws_gui.width: "..ws_gui.width)
		if (ws_gui.height < 240) printh("*** ws_gui.height: "..ws_gui.height)
	end

	--[[
		wm should never hold frames (or need to)
		if becomes relevant, then is a bug and is extremely hard to see what's going on with wm holding frames
		e.g. if 30fps app is showing frames every second frame, the ones wm is holding --> appears frozen
		better to just let the wm interface start flickering
		0.1.0h: commented. too many moments that genuinely need to be hidden for a frame! 
		e.g. click between channels in pattern editor -> causes cpu debt that wm can't easily avoid being starved from 	
		--> uncomment while debugging wm refresh issues
	]]
	-- poke(0x547f, peek(0x547f) & ~0x2) -- unset hold_frame bit

	
	-- workspace doesn't have a fullscreen window covering it
	-- e.g. launch filenav when there is no desktop workspace, or running web cart player
	-- ** important not to clear each frame for fullscreen apps -- otherwise get flashing when < 60fps
	-- ** note: can be fullscreen but still width < 480 (because videomode) 
	if (ws_gui and (ws_gui.clear_each_frame or (ws_gui.child[1] and ws_gui.child[1].width < 480 and not ws_gui.child[1].fullscreen))) then
		rectfill(0,0,479, 269, 0x10)
		-- rectfill(0,0,479,10,7) -- toolbar-ish shape for cart player (deleteme -- no longer needed)
--		print("\128 empty workspace // \f6please choose a file", 40, 40 + ws_gui.sy, 7) -- deleteme; just use new tab button
	end

	-- cls(10) -- debug

	local awin = get_active_window()


	if (not ws_gui or #workspace == 0) then
		cls()
		if (time() > 3) print("[no workspaces found] "..#workspace,20,20,13)
		if (#workspace > 0) set_workspace(1)
		return
	end


	if (screensaver_proc_id) then
		local win = get_window_by_proc_id(screensaver_proc_id)
		if (win) win:draw()
	else
		head_gui:draw_all()
	end

	camera()
	clip()


	-- debug: measure _update cost
--	rectfill(30,240,200,246,1) print(string.format("\014cpu: %02d mem: %04dk", stat(1)\0.01, stat(0)\1024), 30,241,7)


	-- keep a copy of window output
	-- cheap, general way to do frame holding. should cost ~2% cpu. just a 128k memcpy!
	-- can optimise later for full-screen programs that don't need cursor (just skip drawing anything)

	if (not awin or not awin.fullscreen) 
	then
		blit(nil, prev_frame)
		--prev_frame:copy(8)
	end


	-- toolbar
	if (do_draw_toolbar) then

		-- toolbar shadow
		-- doesn't work! on top of window. need stencil bit for window frame!
		-- but doesn't work visually anyway
		-- rectfill_shadow(0,ws_gui.y + 11, 480, ws_gui.y + 12) 


--		draw_toolbar()

--		line(0,11,479,11,32) -- too much

--		printh(pod(ws_gui))
--		draw_infobar()
		
	end

	-- sparkles (under mouse cursor)

	if (sdat.sparkles) draw_sparkles()


	-- draw cursor
	-- mouse cursor is visible by default
	-- use hide_cursor() to hide it

	local show_cursor = not screensaver_proc_id

	mx, my, mb = mouse_scaled()
	if (mx >= 479 and my >= 269) show_cursor = false -- can hide cursor at bottom right

	if (show_cursor) then
		
		-- show default cursor when active window doesn't have one, and not holding alt

		local gfx = cursor_gfx[1].bmp or default_cursor_gfx

--		if (head_gui.mouse_cursor_gfx) gfx = head_gui.mouse_cursor_gfx 
		
		if (awin and awin.cursor and not key("alt")) then
			-- 0.2.0e only use window cursor gfx when pointer is inside
			if (mx >= 0 and my >= 0 and mx < awin.width and my < awin.height) then
				gfx = awin.cursor
			end
		end

		if (head_gui.mouse_cursor_gfx) gfx = head_gui.mouse_cursor_gfx -- override with wm cursor (resize window)

		if (gfx == "crosshair") gfx = 2
		if (gfx == "grab") gfx = mb == 0 and 3 or 4
		if (gfx == "pointer") gfx = mb == 0 and 5 or 6
		if (gfx == "dial") gfx = mb == 0 and 7 or 0
		if (gfx == "edit") gfx = 12


		if (type(gfx) == "number") gfx = cursor_gfx[flr(gfx)].bmp
		if (type(gfx) != "userdata") gfx = default_cursor_gfx

		
		

		if (dragging_items) then

			-- dragging: override cursor gfx
			gfx = cursor_gfx[4].bmp

			-- follow: mouse
			local fx = mx - 8
			local fy = my - 8

			for i=1,#dragging_items do
				local item = dragging_items[i]
				if (not item.xo) item.xo = item.x - mx
				if (not item.yo) item.yo = item.y - my
			end

			local hover_win = head_gui:el_at_xy(mx, my)
			local keep_original_positions = not hover_win or hover_win.desktop_filenav
			for i=1,#dragging_items do
				
				local item = dragging_items[i]

				local dx,dy = fx - item.x, fy - item.y
				local aa = atan2(dx, dy)
				local tx,ty

				if (keep_original_positions) then
					tx,ty = mx + item.xo, my + item.yo
				else
					tx,ty = fx - cos(aa)*2, fy - sin(aa)*2
				end

				if (#dragging_items > 10) then
					-- catch up faster
					item.x = (item.x*2 + tx) / 3
					item.y = (item.y*2 + ty) / 3
				else
					item.x = (item.x*3 + tx) / 4
					item.y = (item.y*3 + ty) / 4
				end
	
				if (i==1) item.x, item.y = tx,ty

				-- follow: the item in front
				fx = item.x
				fy = item.y
				
			end

			-- draw with item closest to cursor on top
			for i=#dragging_items,1,-1 do
				local item = dragging_items[i]
				spr(item.icon, item.x, item.y)
			end

		end

		last_mx9, last_my9 = mx, my

		-- 
		local gfx_w, gfx_h = gfx:attribs()
		spr(gfx, mx - (gfx_w+1)\2, my - (gfx_h+1)\2)  -- +1 so exactly at center for odd-sizes bitmaps. ref: paint bucket
	end

	
	-- fps

	if (show_fps) then
		-- has no effect if 0 is transparent! need to be able to turn blending on / off.
		-- gives programmer option of faster code path too
		rectfill(450,259,479,469,32) 
		local fps_target = (1/(time() - last_draw_t))
		smoothed_fps = (smoothed_fps * 31 + fps_target * 1) / 32
		local num_str = (smoothed_fps + 0.5) // 1
		print(tostr(num_str), 452, 261, 7)
		last_draw_t = time()
	end

	-- grab palette and video mode from active window's process (if there is one)

	if (awin) then

		-- 0.1.0c: only update when frame is not held (avoid flashing when running < 60fps)
		local val = _ppeek(awin.proc_id, 0x547f) -- might be nil if process recently ended
		if (val and val & 0x2 == 0)
		then
			--printh("@@ process palette "..time())

			-- grab the rgb display palette and video mode from that process
			-- to do: cross-process memcpy

			if (awin.push_palette ~= false) then -- window can opt to leave palette alone (ref: capture.p64)
				for i=0x5000,0x54ff,4 do
					poke4(i, _ppeek4(awin.proc_id, i))
				end
			end
			if (awin.push_video_mode ~= false) then -- window can opt to leave video mode alone (ditto)
				poke(0x547c, _ppeek(awin.proc_id, 0x547c))
			end
		else
			--printh("-- skipped resetting palette "..time())
		end

		-- copy mouselock state bits

		poke(0x5f28, _ppeek(awin.proc_id, 0x5f28))
		poke(0x5f29, _ppeek(awin.proc_id, 0x5f29))
		poke(0x5f2d, _ppeek(awin.proc_id, 0x5f2d))

	else
		--printh("** default rgb palette "..time())
		pal(2) -- otherwise use default palette
	end

	-- notifications  --  show for 2~3 seconds (to do: customisable)
	-- happens after grabbing palette because modify display palette 3

	local notify_duration = 2
	if (user_notification_message and #user_notification_message > 15) notify_duration = 3
	if (time() < 3) notify_duration = 5 -- startup message; e.g. mended drive.loc

	if (user_notification_message and time() < user_notification_message_t + notify_duration) then
		local y = 270
		if (@0x547c == 3) y = 135
		if (@0x547c == 4) y = 90
		
		--rectfill(0,y-11,479,y-1,32)

		-- tint: wm is allowed to temporarily modify palette 3 per frame for displaying system elements (to do: toolbar)

		for yy = y-11, min(y-1,269) do
			local addr = 0x5400 + (yy>>2)
			local bits = (yy & 3)
			poke(addr, peek(addr) | (0x3 << ((yy & 3)*2)))
		end

		memcpy(0x5300, 0x5000, 0x100)
		
		for i=0x5300,0x53fb, 4 do
			poke4(i, (peek4(i) >> 1) & 0x7f7f7f)
		end 

		poke4(0x53fc, 0x00fff1e8) -- P8 white
		print(user_notification_message, 4,y-9, 63)

	end


	-- magnify

	if (sdat.rshift_magnify and key("rshift")) then

		local masks = peek4(0x5508); -- backup

		poke(0x5508, 0x3f, 0x3f, 0, 0) -- ignore target value; no transparency

		if (not mag_bmp) mag_bmp = userdata("u8", 64, 64)
		blit(get_display(), mag_bmp, mx-32, my-32)
		palt(0) -- nothing is transparent

		local sx,sy = mx-64, my-64
		for y=0,63 do
			local xo = xodat[y+1]
			sspr(mag_bmp, xo, y, 64-xo*2, 1, sx + xo*2, sy+y*2, 128 - xo*4, 2)
		end

		circ(mx,my,65,7) -- close enough

		circfill(mx+38,my-38,5,7) -- haha
		circfill(mx+46,my-28,3,7)

		poke4(0x5508, masks); -- restore
	end

	-- decide when window manager is presentable
	if (not sent_presentable_signal) then
		if (stat(317) > 0) then
			-- exported cartridge / bbs player: show when a window is open, active (0x1) and not holding frame (0x2)
			-- cart is last run process is the cart (/ram/cart/main.lua -> "main
			-- search through all processes for main -- maybe cart generates another windowed process
				-- if /that/ thing is called main and has drawn and is active, then fine -- present that!
			local p = fetch"/ram/system/processes.pod"
			for j=4,#p do
				-- printh(pod{p[j].name, _ppeek(p[j].id, 0x547f)})
				-- main for exports, bbs id for bbs player
				-- to do: could use awin.player_cart instead
				if ((p[j].name == "main" or p[j].name == stat(101)) and (_ppeek(p[j].id, 0x547f) & 0x3) == 0x1) then
					if (last_fullscreen_workspace) set_workspace(last_fullscreen_workspace)
					_signal(37)
					sent_presentable_signal = true
				end
			end
		else
			-- regular binaries:
			-- don't open on a tabbed tool (wait for desktop or terminal to be ready before displaying)
			if (ws_gui.style ~= "tabbed") then
				if (last_desktop_workspace) set_workspace(last_desktop_workspace)
				_signal(37) 
				sent_presentable_signal = true
			end
		end

		-- in any case, show after 7 seconds (safety)
		if (t() > 7.0) then
			_signal(37)
			sent_presentable_signal = true
			-- if (stat(318) > 0) printh("@@ forced signal 37")
		end

	end

	-- show gif capture (don't draw inside captured area!)
	if (stat(320) > 0) then
		local x,y,width,height,scale = peek2(0x40,5)


		polaroid(x,y,x+width-1,y+height-1, stat(321), max_gif_frames())
--[[

		rect(x-1,y-1,x+width,y+height,7)
		rect(x-2,y-2,x+width+1,y+height+1,7)
		rect(x-3,y-3,x+width+2,y+height+2,1)

		rectfill(x-2,y+height+1, x+width+1,y+height+9, 1)
		local maxf = max_gif_frames()
		local q = stat(321) * 32 / maxf
		local x0 = x + width - 40
		local y0 = y + height + 3

		if (width > 100) then
			print("\014frame "..flr(stat(321)).." / "..maxf, x+4,y+height+3, 7)
		else
			-- tiny mode: center capacity bar
			x0 = x + width/2 - 34/2
		end
		
		rect(x0-2, y0, x0 + 34, y0 +5, 7)
		rectfill(x0, y0+2, x0 + q, y0 +3, 7)
]]
	end


	-- debug: show when battery saver is being applied
	-- if (stat(330) > 0) circfill(20,20,10,8) circfill(20,20,5,1)


	--[[
		-- kinda cute but wrong semantic level!
		-- also: doesn't really make sense in a host window
		-- maybe later, in same category as pixel shaders
		pset(0,0,0)
		pset(479,0,0)
		pset(0,269,0)
		pset(479,269,0)
	]]

	
	-- debug cpu
	-- rectfill(30,250,200,256,stat(7) == 60 and 1 or 8) -- red when skipping
	-- print(string.format("\014cpu: %02d mem: %04dk  syscpu: %02d  awin:%02d", stat(1)\0.01, stat(0)\1024, stat(304)\0.01, awin and awin.proc_id or 0), 30,251,7)

	-- debug audio control
--	rectfill(30,250,200,256,1)
--	print("\014 "..stat(498).." ("..stat(499)..")", 30,251,7) -- 498: active pfx6416 channels  499: which process has audio focus

end


--[[
	-- sync_working_cartridge_files
	before running or saving cart, need to make sure that any changes made to location of current window is auto-saved.
	don't care about which window is active; there might have been changes in background! -> save everything

	problem: cart might implement their own wrangler that doesn't send the "save_file_completed" message back
	         -> maybe have a short (30 frames) timeout that is extended by wrangler that /does/ support it
]]
function save_working_cart_files(notify_proc_id)

--	if (pending_saves > 0) return -- problem: if a pending save is never resolved, gets stuck here; 

	-- 0.2.1e: [safety] don't interrupt if there is a save in progress that was initiated recently
	-- only relevant if user saves twice rapidly, or something goes wrong and pending_saves is never cleared by timeouts
	if (#pending_saves > 0 and time() < save_working_cart_files_t + 5.0) return

	save_working_cart_files_t = time()

	notify_on_complete_save_working_cart_files = notify_proc_id

--	printh("= save_working_cart_files =")

	num_files_to_save = 0
	pending_saves = {}
	pending_save_errors = 0

	for i=1,#workspace do
		for j=1, #workspace[i].child do
			local win = workspace[i].child[j]
			--printh(win.proc_id..": "..(win.location or "no location"))
			if (win.location and string.sub(win.location, 1, 10) == "/ram/cart/" and win.need_autosave) then

				-- don't need to autosave until the window has been active again
				win.need_autosave = false
				--printh("autosaving "..pod{win.proc_id, win.location})

				-- this is the only situation where autosave=true is used; save is skipped when no unsaved changes
				send_message(win.proc_id, {event="save_file", autosave = true, notify_on_complete = 3})
				add(pending_saves, win)
				num_files_to_save += 1
			end
		end
	end

	
	--printh("save_working_cart_files files: "..num_files_to_save)

	-- nothing that needs saving; send message right away
	if (num_files_to_save == 0) then
		_signal(39) -- 0.2.1c for detecting external changes 
		send_message(notify_on_complete_save_working_cart_files, {event="save_working_cart_files_completed", num_files = 0})
	end

end

function run_pwc(argv, do_inject, path)

	clear_infobar()
	hide_infobar()

	if (do_inject and haltable_proc_id) then
		-- inject 
		-- printh("injecting")
		local awin = get_active_window()
		if (awin) then
			send_message(awin.proc_id, {event="save_file"})
			flip()flip() -- hack: time for the editor to save. to do: expand notify_on_complete, or more general message chaining mechanism
			send_message(haltable_proc_id, {event="reload_src", location = awin.location}) -- implemented by terminal

			-- jump back to output
			set_workspace(last_pwc_output_workspace)
		end
	else
		-- launch terminal and request it to corun cproj
		-- terminal will skip creating a window and allow guest program to create it
		-- when haltable_proc_id is set, ESC means halt for that process

		-- solve a very specific problem: when ctrl-r a program that opens a socket on a particular port,
		-- need to close that host socket before creating the new process

		_close_process_host_resources(haltable_proc_id)

		-- create new one; because pwc_output is true, will clobber old one (if there is one)
		haltable_proc_id = create_process("/system/apps/terminal.lua",{
			corun_program = "/ram/cart/main.lua",       -- program to run // terminal.lua observes this and is also used to set pwd
			argv = argv,
			path = path,
			window_attribs = {				
				pwc_output = true,                      -- replace existing pwc_output process
				show_in_workspace = true,               -- immediately show running process
			}
		})

	end
end


-- used by util/run.lua
on_event("run_pwc", function(msg)
	if (msg._flags and msg._flags & 0x1 == 0) return

	-- printh("@@ event run_pwc: "..pod(msg))
	run_pwc(msg.argv, false, msg.path)
end)

function max_gif_frames()
	local _,_,w,h,scale,frames = peek2(0x40,6)
	w = max(w, 32)
	h = max(h, 32)
	if (frames == 0) frames = 30*120 -- max: 2 minutes
	return min(frames, (480*270*30*16) \ (w * h)) -- max: 16 seconds at fullscreen
	--return frames
end

function discard_key(k)
	local awin = get_active_window()
	-- prevent e.g. r from reaching the map editor when ctrl-r as key("r")  
	if (awin) send_message(awin.proc_id, {event="clear_key", scancode = k})
	clear_key(k)
end


function dkeyp(k)
	if keyp(k) then
		discard_key(k)
		return true
	end
end


function _update()

	-- debug cpu // should be ~1!
	--printh("[wm] _update:"..(stat(1)\0.001))

	-- happens while loading
	if (not ws_gui) then
		--printh("no ws_gui!!")
		return
	end


	-- make sure fullscreen terminal process exists

	local found_fullscreen_terminal = false
	local found_fullscreen_terminal_workspace = nil

	for i=1,#workspace do
		if ((workspace[i].style == "fullscreen" or workspace[i].style == "tabbed") and workspace[i].pwc_output) then
			found_fullscreen_terminal = true
			if ( #workspace[i].child == 0 and not workspace[i].recovering) then
				found_fullscreen_terminal_workspace = i
				found_fullscreen_terminal = false
			end
		end 
	end

	if (found_fullscreen_terminal) then
		created_fullscreen_terminal = true
	elseif created_fullscreen_terminal then -- a fullscreen terminal must have previously existed (i.e. false on boot)
		-- create
		create_process("/system/apps/terminal.lua",
		{
			window_attribs = {
				fullscreen = true, pwc_output = true,
				workspace = found_fullscreen_terminal_workspace and workspace[found_fullscreen_terminal_workspace].id,
				show_in_workspace = false,
				-- tabbed = true -- test: start with tabbed terminal? search: hybrid
			}
		})
		if (found_fullscreen_terminal_workspace) workspace[found_fullscreen_terminal_workspace].recovering = true
	end



--[[
	if (#ws_gui.child == 0) then
		close_workspace(workspace_index)
		if (not ws_gui) return
	end
]]
	if (screensaver_proc_id) then

		-- allow test to run for at least half a second before observing new input activity
		if (test_screensaver_t0 and time() < test_screensaver_t0 + 0.5) then
			last_input_activity_t = 0
		end

		-- kill when activity happened in the last second
		if (last_input_activity_t > time() - 1) then				
			_kill_process(screensaver_proc_id) -- window will close by itself when process is dead
			test_screensaver_t0 = nil
			screensaver_proc_id = nil
		end
	else
		
		-- 3 minutes; to do: store in settings.pod
		if (stat(317) & 0x1) == 0 then -- placeholder: no screensaver for exports / bbs player (older exported runtimes can end up running newer screensavers)
			if ((time() > last_input_activity_t + 180 or test_screensaver_t0) and not screensaver_proc_id) 
			then
				-- printh(pod(sdat))
				if (sdat and sdat.screensaver) then
					-- note: program doesn't need to know it is a screensaver; just kill process on activity event
					screensaver_proc_id = create_process(sdat.screensaver, 
						{screensaver = true, window_attribs = {workspace="current", autoclose = true}})
					test_screensaver_t0 = time() -- abuse same mechanism to ignore interrupts for first half second
				else
					last_input_activity_t = time() -- don't check again for another 3 minutes
				end
			end
		end
	end


	last_mx, last_my = mx, my
	mx, my, mb, mdx, mdy = mouse_scaled()

	if (mb > 0 and last_mb == 0) then
		start_mx = mx
		start_my = my
	end


	-- update visibility; send message

	local large_front_window = false
	local awin = get_active_window()

	local num_visible = 0

	for i=1,#workspace do
		local found_covering_window = false
--		for j=1,#workspace[i].child do
		for j=#workspace[i].child,1,-1 do

			local w = workspace[i].child[j]
			local was_visible = w.visible
	
			-- rough visibility test:
			-- same workspace, and either top (active) window, or there isn't a large window on top covering everything

			local visible = false
			if (i == workspace_index and (w == awin or not found_covering_window)) then
				visible = true
			end

			-- notify on change
			if (not was_visible and visible) then
				send_message(w.proc_id, {event="gained_visibility"})
			end
			if (was_visible and not visible) then
				send_message(w.proc_id, {event="lost_visibility"})
				-- don't draw on first frame when becomes visible again, because process needs
				-- a chance to :draw first (prevents flickering; showing a single stale frame)
				w.process_had_a_chance_to_draw = false 
			end

			w.visible = visible
			num_visible = num_visible + (visible and 1 or 0)

			-- (optimisation)
			-- placeholder test for window is covering everything underneath it   // 0x547d: alpha bits
			if (w.width==480 and w.y <= bar_h and w.y + w.height >= 270-bar_h and _ppeek(w.proc_id, 0x547d) == 0) then
				found_covering_window = true
				--printh("found covering window")
			end

		end
	end

	-- printh("num_visible: "..num_visible)

	-- tool tray visibility (DUPE)


	for i=1,#tooltray_gui.child do
		local w = tooltray_gui.child[i]
		local was_visible = w.visible
		local visible = tooltray_is_open()

		-- notify on change
		if (not was_visible and visible) then
			send_message(w.proc_id, {event="gained_visibility"})
		end
		if (was_visible and not visible) then
			send_message(w.proc_id, {event="lost_visibility"})
			w.process_had_a_chance_to_draw = false 
		end

		w.visible = visible
	end

	-- ctrl-q to fastquit // dangerous so needs to be turned on
	if (key("ctrl") and dkeyp("q")) then
		if (sdat.fastquit) _signal(33)
	end

	-- alt-f4 always available (er.. does windows do that anyway?	
	if (key("alt") and dkeyp("f4")) then
		_signal(33)
	end


	-- :: ctrl-r  (is a window manager thing!)

	-- happens early in this _update so that there's time to send lost_focus messages to tools 
	-- (so they can save their files to /ram/cart before the running program picks them up)
	if (key("ctrl") and dkeyp("r")) then

		if stat(317) > 0 then
			-- exported player or bbs player: reset cart if it is active
			if awin and (awin.player_cart) then
				local win = get_active_window()
				send_message(2, {event="restart_process", proc_id = win.proc_id})
				win.paused = false
				win.resetting = true -- don't kill process in win:update() while resetting
			end
			-- otherwise nothing happens
		else
			-- run / reset pwc
			run_pwc("", key("shift"))
		end

	end


	-- :: ctrl-p: toggle picotron menu
	-- doesn't mean much now, but later might want to add keyboard navigation [and search]
	-- so should reserve early, as is system-wide
	
	if (key("ctrl") and keyp("p")) then
		toggle_picotron_menu()
		--toolbar_y_target = tooltray_default_h
	end

	-- :: ctrl-o: open file (update: and other custom shortcuts)
	-- to do: more general rules for specifying shortcuts? e.g. not ctrl-
	if (key("ctrl")) then
		local win = get_active_window()
		if (win and proc_menu[win.proc_id]) then
			local menu = proc_menu[win.proc_id]
			for i=1,#menu do
				local mi = menu[i]
				if (type(mi.shortcut) == "string") then
					local letter = string.sub(mi.shortcut, -1)
					if (ord(letter) >= ord("A") and ord(letter) <= ord("Z")) then
						letter = chr(ord(letter) - ord("A") + ord("a"))
						-- handle s separately; context sensitive
						if (letter ~= "s" and keyp(letter)) then
							send_message(win.proc_id, {event="menu_action", id = mi.id, b = 0})
						end
					end
				end
			end
		end
	end

	-- :: ctrl-s

	if (key("ctrl") and dkeyp("s")) then

		local win = get_active_window()

		if (win and win.location and sub(win.location, 1, 10) ~= "/ram/cart/") then
			-- active window is editing a non-cartridge working file --> save only that file
			send_message(win.proc_id, {event="save_file"})
		elseif #pending_saves == 0 then
			-- otherwise, always save the whole cartridge (if there is not already a save in progress)
			-- note that normally files are saved when they lose focus (and so w:unsaved_changes() == false), so only active window is a new save.
			-- see wrangler.lua "lost_focus"

			-- save current file (get rid of unsaved changes * in window title even when there are no changes)
			send_message(win.proc_id, {event="save_file"})
			--win.need_autosave = false

			if (fetch("/ram/system/pwc.pod")) then
--				notify("\^:7f4141417f616500 saving cartridge: "..fetch("/ram/system/pwc.pod"))
				notify("\^:007f41417f613f00 ...") -- looks nice if followed by "saved" message. but some way to skip logging it?
				create_process("/system/util/save.lua", {show_notifications = true, save_last = win and win.location or nil})
			end

		end
	end

	-- only need to autosave if was active for a moment since last autosave
	if (awin) awin.need_autosave = true	

	-- :: ctrl-1, ctrl-2 to toggle toolbar / infobar

	if (key("ctrl") and dkeyp("1")) then
		ws_gui.show_toolbar = not ws_gui.show_toolbar
		if (not ws_gui.show_toolbar) toolbar_y_target = 0 -- immediately close even when mouse cursor is over it (intention + visual feedback)

		-- should show a message near the toolbar? need a "speech bubble" concept?
--		notify(ws_gui.show_toolbar and "docked toolbar" or "auto-hide toolbar")
	end

	if (key("ctrl") and dkeyp("2")) ws_gui.show_infobar = not ws_gui.show_infobar

	-- paste
	if (key("ctrl") and awin and keyp("v")) then

		-- paste from host:
		-- requires proof of intention (ctrl-v)
		-- don't discard at this point -- want the message to go through to active window (except for file references paste below)

		-- set userland clipboard text here if it is available
		-- otherwise (i.e. for web), platform is expected to proactively push using api.c::set_userland_clipboard_text() from inside browser event
		if (_get_host_clipboard_text) _set_userland_clipboard_text(_get_host_clipboard_text())

		-- paste file references
		local p, m = unpod(get_clipboard())
		if m and m.pod_type == "file_references" then
			readtext(true) -- receiving program won't get the ctrl-v message
			discard_key("v")
			send_message(awin.proc_id, {event="drop_items", 
				items = p,
				from_proc_id = 3,
				dx = 0, dy = 0,
				mx = mx, my = my,
				-- hold ctrl / shift to modify drop action (e.g. in filenav means force overwrite)
				ctrl = key"ctrl", shift = key"shift", 
			})
			--notify("pasting "..#p.." items") -- let app handle notifications
		else
			-- commented; should be handled by app -- let the message pass through
			-- notify("no items found to paste")
		end
	end

	
	--============================================== capture =========================================================

	if key("ctrl") and dkeyp("6") then
		if key("shift") then
			-- select first
			create_process("/system/apps/capture.p64", {
				window_attribs = {workspace="current", autoclose = true}, 
				intention = "capture_screenshot",
				vid_mode = 3 -- deleteme; was this a test? seems unused
			})
		else
			capture_screenshot()
		end
	end

	if key("ctrl") and dkeyp("7") then
		capture_screenshot{as_label=true}
	end

	
	-- capture gif
	if key("ctrl") and dkeyp("8") then
		if key("shift") then
			-- select first
			create_process("/system/apps/capture.p64", {
				window_attribs = {workspace="current", autoclose = true}, 
				intention = "record_video"
			})
		else
			notify() -- hide any message
			capture_video()
		end
	end

	-- finish capturing gif
	if (stat(320) > 0) then
		if (key("ctrl") and dkeyp("9") or stat(321) >= max_gif_frames()) then	
			_signal(19)
		end
	end

	-- audio capture
	if (key("ctrl") and dkeyp("0")) then
		if (not fstat("/desktop/host")) _signal(65)
		_signal(16) -- placeholder mechanism
	end

	--================================================================================================================

	-- window focus messages

	local win = get_active_window()

	if (win and last_active_win ~= win) then
		
		if (last_active_win) then 
			send_message(last_active_win.proc_id, {event="lost_focus"})
			last_active_win.is_active = false
		end

		-- give lost_focus message a chance to be processed before next window gains focus
		flip()

		win.is_active = true
		win.gained_focus_t = time()

		send_message(win.proc_id, {event="gained_focus"})

		-- when a click causes focus to change, that click should register in the window's gui immediately
		-- -> need to send updated mouse state below so that click is generated in that window's events.lua
		win.send_mouse_update = true 

		last_active_win = win
	end


	-- forward (filtered, modified) events to active window
	-- vertatim forwards also happen in _subscribe_to_events
	-- only need to send low-level device data -- click,tap etc is generated from them
	
	-- modified mouse position or mouse button
	if (win and win.proc_id) then
		if (mx ~= last_mx or my ~= last_my or mb ~= last_mb or win.send_mouse_update) and
			not (mb == 2 and win.parent == tooltray_gui) -- mb2 reserved for context menu for widgets 
		then

			last_input_activity_t = time() 

			--printh("mouse event "..pod{proc_id = win.proc_id, mx, my, mb})

			win.send_mouse_update = nil

			-- every window can read the mouse position, but only the active window can read mouse button state.
			-- dorky iterator for ws_gui and tooltray_gui
			local pointer_el = head_gui:get_pointer_element()
			if (@0x547c > 0) pointer_el = win -- video mode set -> assume pointing at active window
			for i=1,#ws_gui.child + #tooltray_gui.child do
				local win2 = i <= #ws_gui.child and ws_gui.child[i] or tooltray_gui.child[i - #ws_gui.child]
					send_message(win2.proc_id, {event="mouse",dx = mdx, dy = mdy, mx_abs = mx, my_abs = my, mx = mx-win2.sx, my=my-win2.sy, 
						-- only active window is allowed to read mouse button (title bar / resizer widget doesn't count)
						mb = (win == win2 and win == pointer_el) and mb or 0
					})
			end

		end
		last_mx, last_my, last_mb = mx, my, mb
	end


	-- reset; so that e.g. alt + left doesn't bring up tooltray menu
	if (keyp("alt")) then
		used_alt_navigation = false
	end


	-- to do: terminal AND desktop filenav(!) should be allowed to capture enter
	-- a little different from capture_escapes ~ window can just have pauseable property (turn off to capture enter)
	-- wallpaper should never be pausible
	-- awin.fullscreen and not awin.pwc_output and not awin.desktop_filenav and not awin.wallpaper) then 

	if (awin and awin.pauseable) then

		update_window_paused_menu(awin)

	end

	if (dkeyp("escape")) then

		-- look for haltable process
		-- (assumes there is only one)
		local width, height = _get_process_display_size(haltable_proc_id)

		if (modal_gui) then
			dismiss_modal()
		elseif (awin and awin.paused) then
			awin.paused = false
			send_message(awin.proc_id, {event = "unpause"})
		elseif toolbar_y_target > 0 then
			-- close tooltray if open
			toolbar_y_target = 0
		elseif infobar_y_target < 270 then
			-- close infobar if open
			hide_infobar()
		elseif (awin and awin.capture_escapes) then
			-- let active window handle it
			send_message(awin.proc_id, {event="keydown",scancode=41}) -- added in 0.2.0c; when did this become necessary?
		elseif (awin and awin.autoclose) then
			-- 0.2.0h: moved under capture_escapes; should be able to capture escapes from an auto-closing window
			if is_fullscreen_export(win) then
				-- 0.2.0h playing the entry point cart in a binary export -> quit to host OS (same as Exit Cartridge menu item)
				if (stat(318) == 0) send_message(2, {event="shutdown"}) -- only on binaries; on web, do nothing
			else
				close_window(get_active_window(), true) -- e.g. about / settings
			end
		elseif (width and width > 0 and awin and awin.proc_id == haltable_proc_id) then 
			-- stop haltable process
			--printh("sending halt message to: "..haltable_proc_id)
			local hwin = get_window_by_proc_id(haltable_proc_id)
			hwin.was_pauseable = hwin.pauseable and true or false -- used by restore_pauseable
			send_message(haltable_proc_id, {event="halt"})
			haltable_proc_id = false
		elseif (awin and awin.pauseable) then
			win.paused = true
			generate_paused_menu(win)
			send_message(win.proc_id, {event = "pause"})
		elseif not is_fullscreen_export(awin) then -- 0.2.0h: export that is not pausible -> esc should do nothing
			-- toggle between output / last workspace
			if (ws_gui.style == "fullscreen") then
				set_workspace(last_non_fullscreen_workspace or last_desktop_workspace)
			elseif (awin and awin.pwc_output) then
				-- back to editor
				set_workspace(last_non_desktop_workspace or last_fullscreen_workspace)
			else
				set_workspace(last_fullscreen_workspace)
			end
		end

	end

	-- keyboard control
	if (key("alt") and not is_locked_in_fullscreen()) then
		if (dkeyp("left")) then set_workspace(workspace_index - 1) used_alt_navigation = true end
		if (dkeyp("right")) then set_workspace(workspace_index + 1) used_alt_navigation = true end
	end

	-- toggle (host) fullscreen

	if (key("alt") and key("enter") and not last_enter_key_state) then		
		sdat.fullscreen = not sdat.fullscreen
		store("/appdata/system/settings.pod", sdat)
		-- clear key buffer (avoid "enter" being sent to text editor)
		readtext(true)
		discard_key("enter") -- for good measure: key("enter") shouldn't be true either until repressed
	end
	last_enter_key_state = key("enter")

	-- toggle mute
	if key("ctrl") and dkeyp("m") then
		send_message(pid(), {event = "toggle_mute", notify=true})
	end

	local dtab_index = 0
	if (key("ctrl") and dkeyp("tab")) then
		dtab_index = key("shift") and -1 or 1
	end

--[[
	-- don't need yet -- no flipping through windows, and ctrl-tab is nicer for tabs.
	if (key("alt") and keyp("up")) dtab_index = -1
	if (key("alt") and keyp("down")) dtab_index = 1
]]

	if (dtab_index != 0) then
		local tab = get_workspace_tabs()

		-- to do: for windows, need to keep a list of windows in order they are visited and use that
		-- perhaps only count windows with z==0 or something? don't want desktop, filenav, birds

		-- if (#tab < 2) tab = ws_gui.child -- cycle through windows instead;  

		for i=1,#tab do
			if (tab[i].is_active) then

				j = i + (#tab + dtab_index)
				while (j > #tab) do j = j - #tab end

				set_active_window(tab[j])

			end
		end

	end

	-- to do: while dragging items, switch between active window
	-- causes gui logic complexity but is nice and should drive gui logic to be cleaner
	-- annoying case: drag files out and back in to a window -> spurious events cause selection to start
		-- maybe just up to wm to manage which events get through while dragging files
	-- update: ah.. maybe switching window focus is not desired behaviour anyway
	-- -> light provisional version: just bring to front for a little visual feedback
	if (dragging_items) then
		local win2 = head_gui:el_at_xy(mx, my)
		if (win2) then
			if (win2.is_window_bar) win2 = win2.parent
			win2:bring_to_front()
		end
	end

--[[
	if (dragging_items) then
		local win2 = head_gui:el_at_xy(mx, my)
		if (win2 and win2.is_window_bar) win2 = win2.parent
		if (win2 ~= get_active_window()) then
			set_active_window(win2)
			send_message(win2.proc_id, {event = "block_mouse_events"})  --  need to block events until mb == 0
		end
	end
]]

	-- drop

	if (mb == 0 and dragging_items) then

		-- send a message to whatever window the cursor is over
		local win2 = head_gui:el_at_xy(mx, my)

		-- titlebar counts! (can drag and drop into titlebar, put sticker on titlebar)
		if (win2 and win2.is_window_bar) win2 = win2.parent

		--printh("dropping into proc: "..tostr(win2.proc_id))
		
		if (win2 and win2.proc_id) then

			-- first, window manager might consume some of the items (stickers)
			
			for i=1,#dragging_items do
				local item = dragging_items[i]
				--printh("item: "..pod(item))
				if (item.pod_type == "sticker") then
					--if (type(win2.stickers) != "table") win2.stickers = {} 

					-- imprint location
					if (not item.location and win2.location) then
						item.location = win2.location
						notify("assign location: "..item.location)
					end
					
					win2:attach{
						x = mx - win2.sx + item.xo,
						y = my - win2.sy + item.yo,
						width=12, height=12,
						item = item,
						cursor = "grab",
						clip_to_parent = false,
						draw = function(self, msg)
							spr(self.item.icon,0,0)
						end,
						drag = function(self, msg)
							local dx = msg.mx - msg.mx0
							local dy = msg.my - msg.my0
							if (dx*dx + dy*dy > 2*2 and not dragging_items) then
								dragging_items = {
									item
								}

								self:detach() -- remove
							end
						end,
						tap = function(self, msg)
							if (self.item and self.item.location) then
								create_process("/system/util/open.lua", { argv = {self.item.location} })
							end
						end
					}
				end
			end

			-- send to window for processing
			-- printh("drop_items send to window with mx,my: "..pod{mx - win2.sx, my - win2.sy})
			send_message(win2.proc_id, {event="drop_items", 
				items = dragging_items,
				from_proc_id = dragging_items_from_proc_id,
				dx = mx - start_mx, dy = my - start_my, 
				mx = mx - win2.sx, 
				my = my - win2.sy,
				-- hold ctrl / shift to modify drop action (e.g. in filenav means force overwrite)
				ctrl = key"ctrl", shift = key"shift"
			})
		end

		dragging_items = nil
	end


	-- update gui
	if (not screensaver_proc_id) then
		head_gui:update_all()
	end

	-- store state of windows data // to do: pm could let wm know if anyone is subscribed to alter frequency
	--[[
	if (not last_windat_t or time() > last_windat_t + 0.125) then
		last_windat_t = time()
		store("/ram/shared/windows.pod", generate_windat())
	end
	]]
	store("/ram/shared/windows.pod", generate_windat()) -- every frame; quite cheap

	if (sdat.sparkles) then
		update_sparkles()
	else
		init_sparkles() -- reset. to do: existing sparkles should be allowed to live out their life? anti-module pattern though!
	end

	-- battery saver shouldn't kick in while running a fullcsreen app (unless it is terminal)
	-- exception: pwc_output should  always run full speed even if windowed
	-- to do: configurable -- user should be able to test the effect of battery saver on pwc_output
	if (ws_gui.style == "fullscreen" and not ws_gui.pwc_output) or 
		(awin and awin.proc_id == haltable_proc_id)
 	then
		if (not screensaver_proc_id) then
			_signal(22) -- stay awake
		end
	end


	------ update pending saves

	if #pending_saves > 0 then
		for i=#pending_saves, 1, -1 do
			local win = pending_saves[i]
			-- short timeout (0.2) for non-standard wranglers; usually enough, and not a big deal if proceed too early
			-- (non-standard means can't rely on save_file_completed message being received to resolve the pending save)
			local timeout = min(5.0, win.save_timeout or 0.2) -- never wait more than 5 seconds for an autosave
			--printh("timeout: i,proc_id,timeout  "..pod{i, win.proc_id, timeout})
			if  time() > save_working_cart_files_t + timeout -- taking too long; something went wrong?
				or _process_state(win.proc_id) < 0           -- process died while trying to save?
			then
				pending_saves[i] = nil
			end
		end
		-- let requester (info / save) know they can give up on waiting
		if (#pending_saves == 0 and notify_on_complete_save_working_cart_files) then
			send_message(notify_on_complete_save_working_cart_files, {event="save_working_cart_files_completed", num_files = num_files_to_save})
		end
	end

	------

	-- debug: changing focus
	--[[
		awin = get_active_window()
		if (awin and awin ~= last_awin) then
			printh("active: "..awin.proc_id)
		end
		last_awin = awin
	--]]

	

end


-- to do: could maintain a lookup
-- to do: tooltray_gui windows
--local 
function get_window_by_proc_id(proc_id)

	for i=1,#workspace do
		for j=1,#workspace[i].child do
			if workspace[i].child[j].proc_id == proc_id then
				return workspace[i].child[j], i
			end 
		end
	end

	if (tooltray_gui) then
		for i=1,#tooltray_gui.child do
			if (tooltray_gui.child[i].proc_id == proc_id) return tooltray_gui.child[i], -1
		end
	end

	return nil -- none
end

function remove_workspace(index)
	for i=index, #workspace do
		workspace[i] = workspace[i+1]
	end
	set_workspace(ws_gui)
end



-- close window here so that don't invalidate window iterator
-- 0.2.0i also used by misc/confirm.p64 
on_event("close_window", 
	function(msg)
		if (not msg._flags or msg._flags & 0x1 == 0) return -- only used by system processes

		--printh("received close_window: "..pod{msg})

		for i=1,#workspace do
			local pos = 1
			local num = #workspace[i].child
			
			for j=1,num do
				if workspace[i].child[j].proc_id == msg.proc_id then
					-- remove from list of tabs
					del(workspace[i].tabs, workspace[i].child[j])
					if (workspace[i].child[j].location) then
						workspace[i].last_ext = workspace[i].child[j].location:ext()
						workspace[i].last_dir = workspace[i].child[j].location:dirname()
					end
				else
					-- shunt -- keep only processes that don't match those to be removed
					workspace[i].child[pos] = workspace[i].child[j]					
					pos = pos + 1
				end
			end

			-- clear end
			while (pos <= num) do
				workspace[i].child[pos] = nil
				pos = pos + 1
			end
		end

		generate_head_gui()

		-- finally, kill the process (if not already dead)
		_kill_process(msg.proc_id)
	end
)



function choose_workspace(attribs)

	if (attribs.workspace == "current") return ws_gui

	if (attribs.workspace == "tooltray") return tooltray_gui
	
	-- explicitly requested a new workspace (e.g. New Desktop from toolbar right click menu)
	if (attribs.workspace == "new") return nil

	-- by workspace id
	if (type(attribs.workspace) == "number") then
		for i=1,#workspace do
			if (workspace[i].id == attribs.workspace) return workspace[i]
		end
	end

	---- no particular workspace requested --> choose based on attributes

	-- wallpaper should open in same workspace (when new workspace was not requested)
	if (attribs.wallpaper) return ws_gui

	-- tabbed window get workspace running same program (to do)
	if (attribs.tabbed) then

		for i=1,#workspace do
			if (workspace[i].style == "tabbed" and workspace[i].prog == attribs.prog) then
				return workspace[i]
			end
		end

		return nil
	end

	-- fullscreen window gets new workspace
	if (attribs.fullscreen) return nil

	-- otherwise: desktop app
	return last_desktop_workspace

end

on_event("app_menu_item", function(msg)

	--printh("app_menu_item from "..pod{msg._from})
	
	proc_menu[msg._from] = proc_menu[msg._from] or {}
	local menu = proc_menu[msg._from]

	-- clear
	if (msg.clear) then
		proc_menu[msg._from] = {}
		return
	end

	-- add a divider
	if (msg.attribs.divider) then
		if (menu[#menu] and menu[#menu].divider) return -- skip adding duplicate divider
		add(menu, {id="divider_"..#menu, label="[divider]", divider=true})
		return
	end
	
	-- look for existing item by id
	local pos = #menu + 1 -- default: add new
	for i=1,#menu do
		if (menu[i].id == msg.attribs.id) then

			pos = i -- overwite this slot

			-- update label (might have changed due to callback)
			if (msg.attribs.label) then
				menu[i].label = msg.attribs.label
				local win = get_window_by_proc_id(msg._from)
				if (win and win.pmenu) then
					for i=1,#win.pmenu do
						if (win.pmenu[i].id == msg.attribs.id) then
							win.pmenu[i].label = msg.attribs.label
						end
					end
				end
			end

		end
	end
	
	menu[pos] = msg.attribs

	if (get_active_window() and get_active_window().proc_id == msg._from) then
		-- update live item when this is the active window
		update_app_menu_item(menu[pos])
	end
end)


-- allow dragging a frame late for windows with squashable used when squashing so that display size matches 
-- evaluated element size on draw, by delaying window movement by a frame. stoopid solutions for stoopid problems
on_event("drag_squashable_window", function(msg)
	if (msg._from ~= 3) return
	--printh("drag_squashable_window "..pod{msg})
	local win = get_window_by_proc_id(msg.proc_id)
	win.x = msg.x
	win.y = msg.y
	win.sx = win.parent.sx + win.x
	win.sy = win.parent.sy + win.y
end)

on_event("set_window", function(msg)

--	printh("set_window: "..pod(msg))

	if (msg._from <= 3) return -- safety: don't create window for window manager

	local win = get_window_by_proc_id(msg._from)
	local attribs = msg.attribs or {}
	local target_ws = nil
	local old_win = nil
	local old_location = win and win.location or nil
	

	-- creating cart output window:  replace any existing output window

	if not win and msg.attribs.pwc_output then
		for i=1,#workspace do
			for j=1,#workspace[i].child do
				if (workspace[i].child[j].pwc_output) then
					-- match: replace fullscreen output when running fullscreen program / window when running windowed
					if (attribs.fullscreen == workspace[i].child[j].fullscreen or
						not attribs.fullscreen and not workspace[i].child[j].fullscreen) then 
						old_win = workspace[i].child[j]
						close_window(old_win, true)
						target_ws = workspace[i]
					end
				end
			end
		end
	end

	

	-- if no existing window, create it
	if not win then

		--printh("creating window "..pod(attribs))

		-- 1. find workspace for it
		if (not target_ws) target_ws = choose_workspace(attribs)

		-- 2. if no existing workspace, create it
		if (not target_ws) then
			target_ws = create_workspace_1(msg._from, attribs)
		end

		-- 3. create the window

		-- if tooltray, force fixed position and frameless
		if (target_ws == tooltray_gui) then
			attribs.has_frame  = false
			attribs.moveable   = false
			attribs.resizeable = false
		end

		-- use a copy of attribs -- create_window() adds gui stuff, and want to iterate over original below
		local attribs_1 = unpod(pod(attribs))
		win = create_window(target_ws, attribs_1)

		

		-- if position is specified and has frame, should stay inside
		if (attribs.has_frame) then
			if (attribs.x) attribs.x = mid(0, attribs.x, 480 - attribs.width)
			if (attribs.y) attribs.y = mid(24, attribs.y, 270 - attribs.height)
		end

		-- 4. set starting window attributes. guess a title
		win.proc_id = msg._from

		local segs1 = split(attribs.prog,"/",false) or {}
		win.title = attribs.title or segs1[#segs1] or "proc_"..msg._from

		-- 4.a: when present working cart output, replace existing window at same position
		if (old_win) then
			win.x = old_win.x
			win.y = old_win.y
		end

		-- 5. add to tabs
		if (msg.attribs.tabbed) then
			-- 0.2.0h: sort by process id so that load.lua / open.lua produces tabs in the same order they were stored
			local insert_pos = 1
			for i=1, #target_ws.tabs do
				if (msg._from > target_ws.tabs[i].proc_id) insert_pos = i+1
			end
			-- printh("@@ insert_pos for "..msg._from..": "..insert_pos.."   "..tostring(target_ws))
			add(target_ws.tabs, win, insert_pos)
		end

		-- 6. show in workspace if requested 
		-- 0.1.1b: when show_in_workspace not specified, wm is allowed to decide
		if (msg.attribs.show_in_workspace or
			(msg.attribs.show_in_workspace == nil and msg.attribs.workspace ~= "tooltray")
		) then
			previous_workspace = ws_gui
			set_workspace(target_ws)
			target_ws.active_window = win -- give focus immediately
		end

		-- 7. give focus immediately when requested (autoclose implies should start with focus)
		if (msg.attribs.give_focus or msg.attribs.autoclose) then
			target_ws.active_window = win -- give focus immediately
		end

		-- 8. do some validation 
		-- was removed for 0.1.0f but caused [no workspaces] bug which seems to happen frequently but couldn't reproduce yet. race condition?
		-- to do: what is actually responsible for ensuring a valid workspace? should it really happen here?
		local workspace_index1 = mid(1, workspace_index, #workspace)
		if (workspace_index ~= workspace_index1 or ws_gui ~= workspace[workspace_index1]) then
			set_workspace(workspace_index1)
		end

		-- 8.a: make sure window never goes above toolbar; hard to close it and is rendered overlapping in tooltray area
		win.y = max(24, win.y)

		-- 9. let window know where it is to start with
		-- (e.g. might want to preserve original window position)
		send_message(win.proc_id, {event="move", x = win.x, y = win.y, dx = 0, dy = 0})

		-- 10. let the parent know that their child created a window

		send_message(win.parent_pid, {event="child_created_window", proc_id = win.proc_id})


		generate_head_gui()

		

	end

	
	-- modify / set attributes
	-- these are requested by program itself, so allowed to disregard restrictions in x,y (.moveable), width,height (.resizeable)

	for k,v in pairs(attribs) do
		win[k] = v
	end

	if (attribs.icon) then
		proc_icon[msg._from] = attribs.icon

		-- to do: update workspace button icon
		if (ws_gui and ws_gui.head_proc_id == msg._from) then
			ws_gui.icon = win.icon
			--printh("updating icon "..pod(win.icon))
		end
	end


	-- for squash_to_clip / squash_to_parent
	if (not attribs.squash_event) then -- don't want to do this during a squash event though
		if (attribs.width)  win.width0  = win.width
		if (attribs.height) win.height0 = win.height
		attribs.squash_event = false -- temporary directive sent by squash event in events.lua
	end

	--[[
		look for an existing window with matching tool and working file 
		if jump_to_matching_window is jump to that instead (code errors)
		otherwise, warn user that multiple windows are open editing the same file
	]]

	if (old_location ~= win.location) then

		-- printh("set_window change of location: "..pod{old_location, win.location})

		-- kill self if another window open with same location ** using same program **
		for i=1,#workspace do
--			for j=1, #workspace[i].child do
			for j=#workspace[i].child,1,-1 do -- prefer front window (otherwise end up cycling through when multiple windows open with same file)
				local win2 = workspace[i].child[j]
				if (win2 ~= win and not win2.closing and
					type(win.location) == "string" and type(win2.location) == "string" and
					win.location:path() == win2.location:path()      -- same location (disregarding the hloc part after the #)
					--and win.prog and win.prog == win2.prog           -- editing using same program; commented now that multiple windows is the default. deleteme
				) then

					-- 0.2.0h: observe jump_to_matching_window -- could be set by the client (unusual) /or/ the process calling create_process
					if win.jump_to_matching_window then
					
						-- kill self!  -- to do: don't create the window in the first place
						_kill_process(win.proc_id)
						win.hidden = true

						-- kill newly created workspace if created one for this
						if (target_ws and #target_ws.child == 0) then
							del(ws_gui, target_ws)
						end

						-- go to other window
						-- 0.1.1b: when show_in_workspace not specified, wm is allowed to decide
						if (msg.attribs.show_in_workspace or
							(msg.attribs.show_in_workspace == nil and msg.attribs.workspace ~= "tooltray")
						) then
							set_workspace(i)
							win2:bring_to_front()
						end

						-- tell win2 about the hash location

						send_message(win2.proc_id, {
							event = "jump_to_hloc",
							hloc = win.location:hloc(),
							extra = {highlight = true} -- highlight the line being jumped to (used by code editor)
						})
						
						-- commented; doesn't really need an explanation -- mostly used for opening from error messages
						-- notify("editing "..win.location.." in existing process")
					else
						-- this might be confusing if didn't realise is already open --> should warn gently
						if (not old_location) or old_location:path() ~= win.location:path() -- changing files, not just hash location
						then
							notify("\^:07071717505c4070 "..win.location:path().." is open in multiple "..((win.tabbed and win2.tabbed) and "tabs" or "windows"))
						end
					end
					
					break -- don't need to search for more matching processes
				end
			end
		end
	end

	-- create wallpaper

	if (msg.attribs.wallpaper) then
		-- kill old wallpaper
		for i=1,#target_ws.child do
			if (target_ws.child[i].wallpaper and target_ws.child[i] != win) then
				-- send_message(pid(), {event="close_window",proc_id = target_ws.child[i].proc_id}) -- kill next frame
				_kill_process(target_ws.child[i].proc_id)
				--send_message(2, {event="kill_process", proc_id=target_ws.child[i].proc_id})
			end
		end

	end

	-- sign of life from process -- proof that finished resetting
	if (win.resetting) then
		-- give back focus
		last_active_window = nil
		send_message(win.proc_id, {event="gained_focus"}) -- otherwise can e.g. lose controller input (see events, which keeps track of focus)
		win.resetting = nil
	end

	
	-- not here -- messes up dragging
	--generate_head_gui()

end)

-- program can ask window manager to move self by dx, dy
-- useful for implementing alternative title bar (drag self)
-- to set absolute x,y: use set_window
on_event("move_window", function(msg)
	local win = get_window_by_proc_id(msg._from)

	if (msg.dx) win.x += msg.dx
	if (msg.dy) win.y += msg.dy

end)


on_event("set_haltable_proc_id",
	function(msg)
		haltable_proc_id = msg.haltable_proc_id
	end
)

-- to do: nicer name for this; "log_message"?
on_event("user_notification",
	function(msg)

		if (msg.content == nil) then
			-- 0.2.1c: can hide message
			user_notification_message = nil
		else
			-- printh("##################### "..pod(msg))
			user_notification_message = tostring(msg.content) -- 0.2.0h -- should always be a string
			user_notification_message_t = time()

			-- to do: log it in infobar
			-- send_message(3, {event="log", content = msg.content})
		end		

	end
)

-- used by util/save.lua and lib/resources.lua to autosave everything open to /ram/cart

on_event("save_file_completed", 
	function(msg)
		del(pending_saves, get_window_by_proc_id(msg._from))
		if (msg.err) pending_save_errors += 1
		-- printh("WM MESSAGE save_file_completed: "..msg.filename.." --> pending_saves: "..#pending_saves)
		if (#pending_saves == 0 and notify_on_complete_save_working_cart_files) then
			_signal(39) -- 0.2.1c for detecting external changes on host
			send_message(notify_on_complete_save_working_cart_files, {event="save_working_cart_files_completed", num_files = num_files_to_save})
			-- too noisey; to do: maybe log somewhere later when have log channels?
			--if (not msg.autosave) notify("\^:0f19392121213f00 saved file: "..fetch("/ram/system/pwc.pod"))
		end
	end
)
on_event("save_working_cart_files", 
	function(msg)
		save_working_cart_files(msg.notify_on_complete)
	end
)
on_event("save_open_locations_metadata",
	function(msg)
		save_open_locations_metadata()
	end
)



--[[
	-- used by util/load.lua
	-- close any programs that are editing carts
]]
on_event("clear_project_workspaces",
	function(msg)
		for i=1,#workspace do
			local num = #workspace[i].child
			-- close / kill all windows under that workspace
			for j=1, #workspace[i].child do
				local win = workspace[i].child[j]
				if (win.location and string.sub(fullpath(win.location), 1, 10) == "/ram/cart/") then
					close_window(workspace[i].child[j], true)
					num -= 1
				end
			end
		end
		generate_head_gui()
	end
)


on_event("dock_toolbar",
	function(msg)
		-- to do: should modify the workspace that the window belongs to
		ws_gui.show_toolbar = msg.state
	end
)


on_event("drag_items",
	function(msg)
		-- to do: should modify the workspace that the window belongs to
		dragging_items = msg.items
		if (dragging_items) then
			dragging_items_from_proc_id = msg._from
			local win = get_window_by_proc_id(msg._from)
			for i=1,#dragging_items do
				local item = dragging_items[i]
				item.x = (item.x or 0) + win.sx
				item.y = (item.y or 0) + win.sy
			end
		end
	end
)


on_event("set_wallpaper",
	function (msg)
		-- 0.2.0i: sandboxed process can not set wallpaper // to do: allow but carry over sandbox? meh
		if (msg._flags and msg._flags & 0x2 > 0) then
			notify("can not set wallpaper from sandboxed process") -- to do: separate error log 
			-- printh("can not set wallpaper from: "..msg._from)
			return
		end
		create_process(msg.wallpaper, {window_attribs = { wallpaper = true, workspace = "current"}})
	end
)

on_event("test_screensaver",
	function(msg) 
		test_screensaver_t0 = time()
	end
)

on_event("toggle_app_menu",
	function(msg)
		toggle_app_menu(msg.x, msg.y, get_window_by_proc_id(msg.proc_id), msg.is_context_menu)
	end
)

-- toggle system-wide mute
on_event("toggle_mute",
	function(msg)
		sdat.mute_audio = not sdat.mute_audio
		store("/appdata/system/settings.pod", sdat)

		if (msg.notify) then
			notify("Sound: "..(sdat.mute_audio and "Off" or "On"))		
		end
	end
)


function poke_capture_name(name)
	if not name then
		-- use program name of active window
		local awin = get_active_window()

		if (awin and awin.prog == "/system/apps/capture.p64" and not awin.has_frame) then
			-- using the capture tool -- name should be for the next window down
			awin = ws_gui.child[#ws_gui.child-1]
		end

		if (awin and awin.prog) then
			if (awin.prog == "/ram/cart/main.lua") then
				name = fetch("/ram/system/pwc.pod")
				if (name) name = name:basename():split(".",false)[1]
			else
				name = awin.prog:basename():split(".",false)[1]
			end
		end
	end
	name = name or "picotron" -- safety

	local sdat = fetch"/appdata/system/settings.pod" or {}
	if (sdat.capture_timestamps) then
		-- append a timestamp so that filenames don't collide e.g. when adding files to
		-- a collection of previous captures with the same name
		local d = date()
		name ..= "_"..d:sub(3,4)..d:sub(6,7)..d:sub(9,10)
	end

	-- up to 64 chars
	memset(0x60,0,64)
	if (name) poke(0x60,ord(name:sub(1,64),1,64))
end


function capture_video(cdat)

	if (not fstat("/desktop/host")) _signal(65)

	-- local cdat = fetch"/ram/system/capture.pod" or {}
	local cdat = cdat or {}
	poke2(0x40, 
		tonum(cdat.x)      or 0,
		tonum(cdat.y)      or 0,
		tonum(cdat.width)  or 480 / pixel_scale(),
		tonum(cdat.height) or 270 / pixel_scale(),
		tonum(cdat.scale)  or 2,
		tonum(cdat.frames) or 30*120, -- max: 2 minutes (to do: configurable)
		-- delay: +1 because want to start on the display data that is /going to/ be send to video out this frame
		(tonum(cdat.delay) or 0) + 1, -- frames to skip at start.
		cdat.silent and 1 or 0
	)

	-- name: up to 64 chars long
	poke_capture_name(cdat.name)
	
	_signal(18)
end

function capture_screenshot(cdat)

	-- printh("capture_screenshot "..pod(cdat))
	notify() -- hide any message // almost never want it to be visible (could be optional later)

	if (not fstat("/desktop/host")) _signal(65)

	local cdat = cdat or {}
	poke2(0x50,
		tonum(cdat.x)      or 0,
		tonum(cdat.y)      or 0,
		tonum(cdat.width)  or 480 / pixel_scale(),
		tonum(cdat.height) or 270 / pixel_scale(),
		tonum(cdat.scale)  or 2,
		cdat.as_label and 1 or 0,
		-- delay: +1 because want to start on the display data that is /going to/ be send to video out this frame
		(tonum(cdat.delay) or 0) + 1, -- frames to skip at start.
		cdat.silent and 1 or 0
	)

	-- name: up to 64 chars long
	poke_capture_name(cdat.name)
	
	_signal(21)
end

-- security: sandboxed apps can request captures, but can't read them back (/desktop/* is not visible to them)

on_event("capture_video", capture_video)
on_event("capture_screenshot", capture_screenshot)


function save_open_locations_metadata()
	-- store all cart file locations /ram/cart/.info.pod

	local ws_info = {}
	for i=1,#workspace do
		for j=1, #workspace[i].tabs do
			local tt = workspace[i].tabs[j]

			-- add tab if a cart file (store relative to /ram/cart/)

			if sub(fullpath(tt.location), 1, 10) == "/ram/cart/" then

				-- printh("save_open_locations_metadata location: "..pod(tt.location))

				-- is cart file
				add(ws_info,{
					workspace_index = i,                    -- probably can't use but might be handy to group files
					location = sub(tt.location, #"/ram/cart" + 2)   -- store relative to /ram/cart/ (+2 to skip the /)
				})

			end
		end
	end

	-- metadata is normally not very large
--	printh("@@ storing workspace metadata: "..pod(ws_info))
	store_metadata("/ram/cart", {workspaces = ws_info})

end


function dismiss_modal()
	if (modal_gui) modal_gui:detach()
	modal_gui = nil
end


function create_modal_gui()

	modal_gui = head_gui:attach{
		x = 0, y = 0, width = 480, height = 270,
		--draw = function() rectfill(0,0,480,270,8) end, -- debug
		click = dismiss_modal
	}

	return modal_gui
end

-- close by index (not by id)
function close_workspace(ws_index, force)
	local ws = get_workspace(ws_index)

	if (ws) then
		for i=1,#ws.child do
			_kill_process(ws.child[i].proc_id)
		end
	end

	-- fix workspace index; when delete current, hop to left unless already at left-most
	if (ws_index <= workspace_index and workspace_index > 1) workspace_index -= 1

	deli(workspace, ws_index)
	set_workspace(workspace_index)
end




function toggle_workspace_menu(x, y, ws_index)

	local pulldown = create_modal_gui():attach_pulldown{
		is_app_menu = true,
		x = x, y = y,
		width = 100, 
		ws_index = ws_index,
	}

	pulldown.onclose = dismiss_modal


	pulldown:attach_pulldown_item
	{
		label = "\^:1c3e6b776b3e1c00 Close Workspace", 
		cursor="pointer",
		action = function()
			close_workspace(ws_index)

		end
	}

end


-- update the single label of an appmenu item rather than regenerating the interface on change
function update_app_menu_item(ii)
	if (not app_menu_pulldown) return
	for i=#app_menu_pulldown.child,1,-1 do -- end to start for deletion
		if (app_menu_pulldown.child[i].id == ii.id) then
			if (not ii.label) then
				deli(app_menu_pulldown.child, i) -- no label means remove item
			else
				app_menu_pulldown.child[i].label = ii.label
			end
		end
	end
end

function toggle_app_menu(x, y, win, is_context_menu)

	local win = win or get_active_window()

	if (not win) return

	-- app menu is already open
	if (modal_gui and modal_gui.child[2] and modal_gui.child[2].is_app_menu) then
		modal_gui = nil
		return
	end

	-- empty workspace

	if (#ws_gui.child == 0) return


	local mm = {}

	local pulldown = create_modal_gui():attach_pulldown{
		is_app_menu = true,
		confine_to_clip = true, -- all of menu visible; bump inside when needed
		x = x, y = y,
		width = 144 -- to do: be adaptive when drawing
	}

	pulldown.onclose = dismiss_modal

	app_menu_pulldown = pulldown

	-- add about item // to do: get icon & title from .p64 when create window (can be default title too)

	-- to do: generate icon from win.icon

	if (not is_context_menu) then
		-- special case: view about /ram/cart when running /ram/cart/main.lua
		local about_prog = win.prog == "/ram/cart/main.lua" and "/ram/cart" or win.prog 
		add(mm, {icon = win.icon, label = "About "..about_prog:basename(),
		action = function() 
			create_process("/system/apps/about.p64", {
				prog = about_prog, window_attribs={workspace="current", autoclose = true
			}})
		end})
	end

	-- userland items created by menuitem()

	local menu = proc_menu[win.proc_id]

	if (menu and #menu > 0) then

		if (not is_context_menu) add(mm, {divider=true}) -- divider to separate the about program item at top

		local last_group = nil
		for i=1,#menu do

			if (menu[i].label) then
				local item = menu[i]
				local pulldown_item = unpod(pod(item)) -- copy all attributes

				pulldown_item.action = function(b)
					send_message(win.proc_id, {event="menu_action", id=menu[i].id, b=b})
				end

				add(mm,pulldown_item)

				-- 0.2.1c: add extra divider to separate wrangler items
				if (mm.group ~= last_group) add(mm, {divider=true})
			end
		end

	end

	-- window management items at bottom

	if (win.width == 480 and win.height == 270) then
		-- can't close (fullscreen file navigator on desktop)
	elseif (win.width == 480 and win.sy < 12) then
		-- tab (to do: better test!)
		add(mm, {divider=true})
		add(mm, {label="\^:1c3e6b776b3e1c00 Close Tab", action = function() close_window_with_confirmation(win, true) end})
	elseif (win.parent == tooltray_gui) then
		add(mm, {divider=true})

		add(mm, {label="\^:1c3e6b776b3e1c00 Pop Out Widget", action = function()
			set_workspace(last_desktop_workspace)
			pop_out_widget(win, 240-win.width/2, 30)
		end})

		add(mm, {label="\^:1c3e6b776b3e1c00 Remove Widget", action = function() 
			uninstall_widget(win)
			close_window(win, true)			
		end})
	else
		-- regular window
		add(mm, {divider=true})
		add(mm, {label="\^:1c3e6b776b3e1c00 Close Window", action = function() close_window_with_confirmation(win, true) end})
	end


	-- calculate required width; items use this when attached
	local max_width = 140 -- nominal minimum (can fit everything that ships with system)
	for i=1,#mm do
		if (mm[i].label) then
			local ww = print(mm[i].label..(mm[i].shortcut or "") ,0,-1000) + 20
			max_width = max(max_width, ww) -- push out
		end
	end
	pulldown.width = max_width

	-- attach
	local last_item_is_divider = false
	for i=1,#mm do
		mm[i].cursor = "pointer"
		if (not mm[i].divider or not last_item_is_divider) then
			pulldown:attach_pulldown_item(mm[i]) -- avoid double dividers (added by this function; app menu items are also filtered for duplicates
		end
		last_item_is_divider = mm[i].divider
	end


end

function toggle_picotron_menu()

	-- already open
	if (modal_gui and modal_gui.child[2] and modal_gui.child[2].is_pictron_menu) then
		modal_gui = nil
		return
	end

	-- never open in fullscreen exports
	if (is_locked_in_fullscreen()) then
		modal_gui = nil
		return
	end


	
	----------------------------------------
	-- pulldown
	----------------------------------------

	-- to do: populate some of this from a configurable shortcuts list
	-- could just look for shortcuts in /appdata/system/shortcuts

	local item =
	{
		{"\^:3f7f5077057f7e00 About Picotron", function() create_process("/system/apps/about.p64", 
			{prog="/system",window_attribs={workspace="current",  autoclose = true}}) end},

--[[
		{"\^:00093e5c1c141400 Log In", function() create_process("/system/apps/login.p64", 
			{window_attribs={workspace="current",  autoclose = true}}) end},
]]
		"---",
	}


	-- 2. SYSTEM MANAGEMENT

	-- Capture could go in Accessories though. Normally just used to discover keyboard shortcuts
	-- could also embed some settings right in pulldown (mute / volume, fullscreen)

	add(item, {"\^:307f3000067f0600 System Settings",	function() create_process("/system/apps/settings.p64", 
		{prog="/system",window_attribs={workspace="current", autoclose = true}}) end})

	add(item, {"\^:7f77777f777f0301 Show Messages", show_reported_error})

	if (stat(320) > 0) then
		add(item, {"\^:06ff81b5b181ff00 End Recording", function() _signal(19) end})
	else
		add(item, {"\^:06ff81b5b181ff00 Capture", function() create_process("/system/apps/capture.p64", 
			{window_attribs={workspace="current", autoclose = true}}) end})
	end


-- 3. QUICK LINKS (list-based version)

--[[

	Visual test: categorize carts using splore lists (/appdata/system/lists)
	Each list can be be pinned / unpinned from Picotron menu
		// ** hard to reduce to a categorisation, but at least user can refuse that (except that bbs carts should be tagged using essential categories)
		// ** need to be careful here -- making a category more visible is an invitation to make that type of thing (and to not make something else)
	Can tuck some menu items inside default accesories list: Capture, "files" (filenav), "bbs carts" (splore), Terminal
	use splore to manage lists -- can think of that part as a bookmark manager. (don't call them "bookmarks" though -- implies documents, not carts)
		// update: they are bookmarks :) each list is a list of references (including the dynamically generated bbs lists)

	verbs // reference: categorise by user activity
		accessories: explore
		games: play (with goal)
		system: administer
		tools: create
		toys: play (with no goal) -- can include desktop pets here

	demos:watch // don't need fast access, so can keep inside splore

	// snippets is important; perhaps should be separate, and/or a list in splore

	Accessories: cal filenav notebook snippets splore stickers terminal
	Games: [tiny windowed games]
	System: capture controls kbd logs (messages) podtree procmon themed
	Tools: code gui gfx map sfx
	Toys: alife pets sequin xyzine turtlefx

	Other lists show up in settings: Wallpapers, Screensavers, Themes, [Widgets]

]]

if (false) then
	add(item, "---")
	add(item, {"\^:00387f7f7f7f7f00 Accessories  \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
	add(item, {"\^:00387f7f7f7f7f00 Games        \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
--	add(item, {"\^:00387f7f7f7f7f00 Office       \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
--	add(item, {"\^:00387f7f7f7f7f00 System       \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end}) -- don't need? are accessories
	add(item, {"\^:00387f7f7f7f7f00 Tools        \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/system/apps"}}) end})
	add(item, {"\^:00387f7f7f7f7f00 Toys         \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
	-- better to be "system"? and ambiguous with commandline utilities (/appdata/system/util)
--	add(item, {"\^:00387f7f7f7f7f00 Utilities    >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end}) 

	-- feels wrong here -- should just be an accessory
--	add(item, {"\^:007f41417f613f00 BBS Carts", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})

end


	-- 3. QUICK LINKS

if (true) then
	add(item, "---")

-- tests
--	add(item, {"\^:00367f7f3e1c0800 Splore", function() create_process("/dev/splore/splore3.p64") end})		

--  nope: redundant / competes with quick links themselves. favourites should feel like a place inside splore. usually used for fullscreen things.
--	add(item, {"\^:00367f7f3e1c0800 Favourites        >", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})	

--  nope. just up to user if/how they want to store apps locally.
--	add(item, {"\^:00387f7f7f7f7f00 Apps", function() create_process("/system/apps/filenav.p64", {argv={"/apps"}}) end})

	-- not really crucial; usually have drive.loc on desktop, and could use accessories -> filenav.
	add(item, {"\^:00387f7f7f7f7f00 Files", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})

	

--		add(item, {"\^:7e9f9dfd7a341800 BBS", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})

	-- bbs:// not available for exports (and hide for bbs player)
	if (stat(317) == 0) then
		-- to do: cartridges should launch splore (doubles as Favourites). Naming matches "Files" -- the objects you want to look through
		-- add(item, {"\^:007f41417f613f00 Cartridges", function() create_process("/desktop/splore.p64") end})
		-- can keep bbs://new/0 style browsing, but just a by-product of protocol generality
		-- (nice comment on bsky: feels like looking through shareware catalogue CDs)
		add(item, {"\^:007f41417f613f00 BBS Carts", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})
	end

	--[[
		-- test: should at least be able to browse /system (but not alter anything) while sandboxed
		add(item, {"\^:00387f7f7f7f7f00 Files (sandboxed)", function() create_process("/system/apps/filenav.p64", 
			{argv={"/"}, sandbox = "bbs", bbs_id = "_filenav"}) end})
	]]

	-- terminal // to do: {window_attribs={tabbed=key"ctrl"}} -- need to fix New Tab button, and possibly merge with pwc_output workspace (hybrid / tabbed at start?)
	-- add(item, {"\^:7f7d7b7d7f083e00 Terminal", function() create_process("/system/apps/terminal.lua", {window_attribs={tabbed=key"ctrl"}}) end})
	add(item, {"\^:7f7d7b7d7f083e00 Terminal", function() create_process("/system/apps/terminal.lua") end})

	-- later (using filenav intention); use load / save commands for now
	-- update: too much space! and can use context menu + ctrl+s. maybe: accessories > cartman?
	-- or could fold out of a single menu item
	--[[
		add(item, "---")
		add(item, "\^:00ff8181ffc17f00 Load Cartridge")
		add(item, "\^:00ff8181ffc17f00 Save Cartridge")
		add(item, "\^:00ff8181ffc17f00 Save Cartridge As")
		add(item, {"\^:1c367f7777361c00 Cartridge Info", function() create_process("/system/apps/about.p64") end})
	]]

end

	-- 4. REBOOT / SHUTDOWN

	add(item, "---")

	 -- pop up menu: [Shutdown] [Reboot] [Cancel] 
	 -- perhaps show unsaved changes 
	 -- (checkbox: "discard unsaved changes" ~ once checked, buttons clickable)


	add(item, {"\^:1c22494949221c00 Reboot", function()
		create_process("/system/misc/confirm.p64", 
			{prompt = "Discard Unsaved Changes?", title = "Reboot", window_attribs = {workspace="current", autoclose=true}})
	end})

	-- no need to shutdown on web 
	if (stat(318) == 0) then
		add(item, {"\^:082a494141221c00 Shutdown", function() 
			create_process("/system/misc/confirm.p64", 
				{prompt = "Discard Unsaved Changes?", title = "Shutdown", window_attribs = {workspace="current", autoclose=true}})
		end})
	end

	local pulldown = create_modal_gui():attach_pulldown{
		is_pictron_menu = true,
		x = 4, y = toolbar_y + 11,
		width = 122
	}

	pulldown.onclose = dismiss_modal

	for i=1,#item do
		if item[i] == "---" then
			pulldown:attach_pulldown_item{divider=true}
		elseif (type(item[i]) == "table") then
			pulldown:attach_pulldown_item{label=item[i][1], action = item[i][2]}
		else
			pulldown:attach_pulldown_item{label=item[i]}
		end
	end
	
	
end




:: boot.lua
--[[pod_format="raw",created="2025-12-13 23:17:52",modified="2025-12-14 00:25:33",revision=10]]
--[[
	Distribution loader
	@astralsparv
]]

local distro=fetch("/distributions/active.txt")
local tboot=fetch("/distributions/bootinto.txt")

if (#tboot>0) then
	distro=tboot
	store("/distributions/bootinto.txt","")
end

if (distro==nil) then
	distro="bios"
	store("/distributions/active.txt",distro)
end

distro="/distributions/"..distro

--how do i auto-rename boot.lua to custom_boot.lua??
--[[
mount("/ram/distribution/",distro)
flip()
if (fstat("/ram/distribution".."/boot.lua")) then --rename boot.lua to custom_boot.lua
	_printh("** boot.lua instead of custom_boot.lua, renaming")
	mv("/ram/distribution".."/boot.lua","/ram/distribution".."/custom_boot.lua") --rename
	flip()
	cp("/ram/distribution",distro) --overwrite original
	flip()
end

unmount("/ram/distribution")
flip()
]]--

mount("/system",distro) --replace system, this must not replace boot.lua, instead having custom_boot.lua 

--_printh("** Running Distribution: "..distro)

--run custom boot
local boot=fetch("/system/custom_boot.lua")
if (type(boot) != "string") then
	_printh("** could not read custom_boot.lua")
else
	local boot = load(boot)
	if (type(boot) != "function") then
		_printh("** could not load custom_boot.lua")
	else
		boot()
	end
end
:: main.lua
--[[pod_format="raw",created="2025-12-13 23:16:24",modified="2025-12-14 00:39:06",revision=111]]
window{width=450,height=200,title="Picotron Distribution Installer"}	
notify("Ensure this is loaded and you run it with CTRL+R")

cls()
if (fstat("/distributions")) then --create a distro
	name=input("Create a distribution using your current /system.\n\nName: ")
	cp("/system","/distributions/"..name)
	default=input("Set this to default? [y/n]\n"):lower()
	if (default=="y") then
		store("/distributions/active.txt",name)
	end
	exit()
else
	r=input("This will convert Picotron to be distribution-based.\nThis is experimental.\n\nYour active /system folder will be used as the Picotron Distribution\n\n\nAre you ready? [y/n]\n"):lower()
	
	if (r=="y") then
		local startms=stat(987)
		print(stat(987)-startms.."ms creating distribution folder at /distributions")
		mkdir("/distributions")
		
		print(stat(987)-startms.."ms setting default distribution")
		store("/distributions/active.txt","picotron")
		
		print(stat(987)-startms.."ms installing bios")
		cp("bios","/distributions/bios")
		
		print(stat(987)-startms.."ms saving the picotron distribution")
		cp("/system","/distributions/picotron")
		
		print(stat(987)-startms.."ms adding the bios utility (terminal command)")
		cp("bios.lua","/distributions/picotron/util/bios.lua")
		
		print(stat(987)-startms.."ms patching your picotron distro's boot.lua")
		mv("/distributions/picotron/boot.lua","/distributions/picotron/custom_boot.lua")
		
		print(stat(987)-startms.."ms persisting your system")
		cp("/system","/system.")
		
		print(stat(987)-startms.."ms deleting your system")
		rm("/system")
		
		print(stat(987)-startms.."ms rebuilding your system")
		mkdir("/system")
		
		print(stat(987)-startms.."ms installing boot.lua")
		cp("boot.lua","/system/boot.lua")
		
		print(stat(987)-startms.."ms done! restarting to bios")
		store("/distributions/bootinto.txt","bios")
		
		--delay so that the user has time to process
		for i=1, 500 do flip() end
		
		send_message(2,{event="reboot"})
	else
		exit()
	end
end
:: .info.pod
--[[pod,author="Astralsparv",created="2025-11-13 21:07:43",icon=userdata("u8",16,16,"0000002020202020000000000000000000002020202020202000000000000000002020060620060620200000000000000020062006060620062000000000000000200606191919060620000000000000002020061919190620200000000000000000070707070707200000000000000000000707070707070700000000000000002020060c0c070e072000000000000020200707070c070707202000000000002006070e070c0c0c06062000000000002006070707070707070620000000000020191907070707070719200000000000201919191906191919192000000000000019191919201919191900000000000000001919200020191900000000000000"),modified="2025-12-14 00:47:38",notes="Creates a distribution system\nfor Picotron, allowing different\ndistros, similar to linux!",runtime=24,title="Install Distribution System",version="v0.1",workspaces={{location="main.lua#8",workspace_index=1},{location="boot.lua#1",workspace_index=1},{location="bios.lua#1",workspace_index=1},{location="gfx/0.gfx",workspace_index=2}}]]
:: bios/.info.pod
--[[pod,author="Astralsparv",created="2025-11-13 21:07:44",icon=userdata("u8",16,16,"12121200121212000012120012121200121200000012000012001200120000001200120000120000120012000012120012121200121212001212070012121200000000000000070007000700070000000000000000000700070007000700000000000007070701010101010101070707000000000000011010101010010000000000000707070110101010100107070700000000000001101010101001000000000000070707011010101010010707070000000000000110101010100100000000000007070701010101010101070707000000000000070007000700070000000000000000000700070007000700000000000000000007000700070007000000"),modified="2025-12-14 00:47:38",notes="BIOS for Picotron",stored="2024-03-30 15:36:43",title="Picotron BIOS",version="0.2.1e"]]
:: bios/apps/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-14 00:47:38"]]
:: bios/apps/about.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogY3VzdG9tLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIy
MDI1LTA5LTI4IDE2OjU5OjQ2Iixtb2RpZmllZD0iMjAyNS0wOS0yOCAxNzo1NToxNSIscmV2aXNp
b249NDRdXQpkYXRhdHlwZXM9ewoJImJ5dGUiLAoJImtpbG9ieXRlIiwKCSJtZWdhYnl0ZSIsCgki
Z2lnYWJ5dGUiLAoJInRlcmFieXRlIiwgLS0gd2hhdC4KCSJwZXRhYnl0ZSIsCgkiZXhhYnl0ZSIs
CgkiemV0dGFieXRlIiwKCSJ5b3R0YWJ5dGUiIC0tIG5vLgp9CgpmdWxsU2VhcmNoPXsKCXNpemU9
MCwKCWZvbGRlcnM9MCwKCWZpbGVzPTAsCgljbGVhbnNpemU9e3NpemU9MCxzaXpldHlwZT0iYnl0
ZXMifSwKCXRvQ2hlY2s9ewoJCQoJfSwKCWVtcHR5Rm9sZGVycz17fSwKCWNhcnRyaWRnZXM9e30s
CgljYXJ0cmlkZ2VzRm91bmQ9MAp9CgpmdW5jdGlvbiBzdGFydFNlYXJjaChwYXRoKQoJZnVsbFNl
YXJjaC5zaXplPTAKCWZ1bGxTZWFyY2guZmlsZXM9MAoJZnVsbFNlYXJjaC5mb2xkZXJzPTAKCWZ1
bGxTZWFyY2guZW1wdHlGb2xkZXJzPXt9CglmdWxsU2VhcmNoLnRvQ2hlY2s9e3BhdGh9CglmdWxs
U2VhcmNoLmNhcnRyaWRnZXM9e30KCWZ1bGxTZWFyY2guY2FydHJpZGdlc0ZvdW5kPTAKZW5kCgpm
dW5jdGlvbiBmaWxlZGF0YShwYXRoKQoJbG9jYWwgYXR0cmlicywgc2l6ZSwgb3JpZ2luID0gZnN0
YXQocGF0aCkKCWxvY2FsIGRhdGE9ewoJCXNpemU9c2l6ZSwgLS1ieXRlcwoJCW9yaWdpbj1vcmln
aW4sCgkJZm9sZGVyPWF0dHJpYnMgPT0gImZvbGRlciIKCX0KCXJldHVybiBkYXRhCmVuZAoKZnVu
Y3Rpb24gYnl0ZXNUb1JlYWRhYmxlKG4pCglsb2NhbCBjbGVhbnNpemU9bgoJbG9jYWwgc2l6ZXR5
cGU9ImJ5dGVzIgoJZm9yIGk9MSwjZGF0YXR5cGVzIGRvCgkJaWYgKGNsZWFuc2l6ZT49MTAwMCkg
dGhlbgoJCQljbGVhbnNpemU9Y2xlYW5zaXplLzEwMDAKCQkJc2l6ZXR5cGU9ZGF0YXR5cGVzW2kr
MV0KCQllbHNlCgkJCWJyZWFrCgkJZW5kCgllbmQKCWlmICgjc3BsaXQodG9zdHIoY2xlYW5zaXpl
KSwiLiIpPjEgb3Igc3ViKGNsZWFuc2l6ZSwtMSkhPSIxIikgc2l6ZXR5cGU9c2l6ZXR5cGUuLiJz
IgoJcmV0dXJuIHtzaXplPWNsZWFuc2l6ZSxzaXpldHlwZT1zaXpldHlwZX0KZW5kCgpmdW5jdGlv
biBkaXIocGF0aCkKCWxvY2FsIGxpc3Q9bHMocGF0aCkKCWxvY2FsIG5ld0xpc3Q9e30KCXdoaWxl
ICNsaXN0PjAgZG8KCQlpZiAobGlzdFsxXSE9bmlsKSB0aGVuCgkJCWFkZChuZXdMaXN0LHBhdGgu
Lmxpc3RbMV0pCgkJZW5kCgkJZGVsaShsaXN0LDEpCgllbmQKCXJldHVybiBuZXdMaXN0CmVuZAoK
ZnVuY3Rpb24gcHVzaCh0YWJsZSxuZXdEYXRhKQoJZm9yIGk9MSwgI25ld0RhdGEgZG8KCQlhZGQo
dGFibGUsbmV3RGF0YVtpXSkKCWVuZAoJcmV0dXJuIHRhYmxlCmVuZAoKZnVuY3Rpb24gdXBkR2V0
U2l6ZSgpCglsb2NhbCBjdXJyZW50CglpZiAoI2Z1bGxTZWFyY2gudG9DaGVjaz4wKSB0aGVuCgkJ
d2luZG93e2JhY2tncm91bmRfdXBkYXRlcz10cnVlfQoJCWN1cnJlbnQ9ZmlsZWRhdGEoZnVsbFNl
YXJjaC50b0NoZWNrWzFdKQoJCWZ1bGxTZWFyY2guc2l6ZSs9Y3VycmVudC5zaXplCgkJaWYgKGN1
cnJlbnQuZm9sZGVyKSB0aGVuCgkJCXRvUHVzaD1kaXIoZnVsbFNlYXJjaC50b0NoZWNrWzFdLi4i
LyIpCgkJCWZ1bGxTZWFyY2guZm9sZGVycys9MQoJCQlpZiAoI3RvUHVzaD4wKSB0aGVuCgkJCQlm
dWxsU2VhcmNoLnRvQ2hlY2s9cHVzaChmdWxsU2VhcmNoLnRvQ2hlY2ssdG9QdXNoKQoJCQllbHNl
CgkJCQlhZGQoZnVsbFNlYXJjaC5lbXB0eUZvbGRlcnMsZnVsbFNlYXJjaC50b0NoZWNrWzFdKQoJ
CQllbmQKCQllbHNlCgkJCWZ1bGxTZWFyY2guZmlsZXMrPTEKCQllbmQKCQlndWkuY2hpbGRbc3Rv
cmFnZUxhYmVsXS5sYWJlbD1mdWxsU2VhcmNoLnNpemUuLiIgYnl0ZXMgb24gZGlzayIKCQlkZWxp
KGZ1bGxTZWFyY2gudG9DaGVjaywxKQoJCWlmICgjZnVsbFNlYXJjaC50b0NoZWNrPT0wKSB0aGVu
CgkJCWZ1bGxTZWFyY2guY2xlYW5zaXplPWJ5dGVzVG9SZWFkYWJsZShmdWxsU2VhcmNoLnNpemUp
CgkJCWd1aS5jaGlsZFtzdG9yYWdlTGFiZWxdLmNsZWFuPWZhbHNlCgkJCWd1aS5jaGlsZFtzdG9y
YWdlTGFiZWxdLmN1cnNvcj0icG9pbnRlciIKCQkJZ3VpLmNoaWxkW3N0b3JhZ2VMYWJlbF0udGFw
PWZ1bmN0aW9uKCkKCQkJCWlmIChndWkuY2hpbGRbc3RvcmFnZUxhYmVsXS5jbGVhbj09ZmFsc2Up
IHRoZW4KCQkJCQlndWkuY2hpbGRbc3RvcmFnZUxhYmVsXS5sYWJlbD1mdWxsU2VhcmNoLmNsZWFu
c2l6ZS5zaXplLi4iICIuLmZ1bGxTZWFyY2guY2xlYW5zaXplLnNpemV0eXBlLi4iIG9uIGRpc2si
CgkJCQllbHNlCgkJCQkJZ3VpLmNoaWxkW3N0b3JhZ2VMYWJlbF0ubGFiZWw9ZnVsbFNlYXJjaC5z
aXplLi4iIGJ5dGVzIG9uIGRpc2siCgkJCQllbmQKCQkJCWd1aS5jaGlsZFtzdG9yYWdlTGFiZWxd
LmNsZWFuPW5vdCBndWkuY2hpbGRbc3RvcmFnZUxhYmVsXS5jbGVhbgoJCQllbmQKCQkJZ3VpLmNo
aWxkW3N0b3JhZ2VMYWJlbF0udGFwKCkKCQkJd2luZG93e2JhY2tncm91bmRfdXBkYXRlcz1mYWxz
ZX0KCQllbmQKCWVuZAplbmQKCmZ1bmN0aW9uIHRydW5jYXRlKG4scGxhY2VzKQoJbj10b3N0cihu
KQoJbj1zcGxpdChuLCIuIikKCWlmICgjbj09MSkgcmV0dXJuIG5bMV0KCW5bMl09dG9zdHIoblsy
XSkKCWlmICgjblsyXT5wbGFjZXMpIHRoZW4KCQluWzJdPXN1YihuWzJdLDEscGxhY2VzKQoJZW5k
CglyZXR1cm4gblsxXS4uIi4iLi5uWzJdCmVuZAoKZnVuY3Rpb24gcm1FbXB0eUZvbGRlcnMoKQoJ
d2hpbGUgI2Z1bGxTZWFyY2guZW1wdHlGb2xkZXJzPjAgZG8KCQlybShmdWxsU2VhcmNoLmVtcHR5
Rm9sZGVyc1sxXSkKCQlkZWxpKGZ1bGxTZWFyY2guZW1wdHlGb2xkZXJzLDEpCgllbmQKZW5kCgpm
dW5jdGlvbiB1cGRDdXN0b20oKQoJaWYgKCNmdWxsU2VhcmNoLnRvQ2hlY2s_MCkgdGhlbgoJCXdo
aWxlIChzdG9yYWdlTGFiZWwhPS0xIGFuZCBzdGF0KDEpPDAuNykgZG8KCQkJdXBkR2V0U2l6ZSgp
CgkJZW5kCgllbmQKZW5kCjo6IGd1aS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0i
MjAyMy0xMC0yMiAxMDoxNzo1NyIsbW9kaWZpZWQ9IjIwMjUtMDktMjggMTc6MDA6MzAiLHJldmlz
aW9uPTMwNjRdXQoKCgpmdW5jdGlvbiBjcmVhdGVfaW5mb3RleHQoZWwpCgllbC53aWR0aD0xNDAK
CWVsLmhlaWdodD03CgllbC52anVzdGlmeT0iYm90dG9tIgoJZWwgPSBndWk6YXR0YWNoKGVsKQoJ
ZnVuY3Rpb24gZWw6ZHJhdygpCgkJbG9jYWwgbCA9IGVsLmxhYmVsCgkJaWYgKHR5cGUobCkgPT0g
ImZ1bmN0aW9uIikgbCA9IGwoKQoJCWNvbG9yKGVsLmNvbCkKCQlwcmludCgiXDAxNCIuLmwsMCwx
KQoJZW5kCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVfcHJvY2Vzc19saXN0KGNvbnRh
aW5lcikKCWd1aTphdHRhY2goY29udGFpbmVyKQoJbG9jYWwgZWwgPSBjb250YWluZXI6YXR0YWNo
ewoJCXg9MCwgeT0wLAoJCXdpZHRoX3JlbD0xLjAsCgkJaGVpZ2h0PTIwMCwKCQlsYXN0X251bV9w
ID0gMTAKCX0KCQoJY29udGFpbmVyOmF0dGFjaF9zY3JvbGxiYXJzKCkKCWZ1bmN0aW9uIGVsOnVw
ZGF0ZSgpCgkJLS0gbmVlZCB0byBhZGp1c3QgaGVpZ2h0IGluIHVwZGF0ZSB0byBhdm9pZCBmbGlj
a2VyCgkJc2VsZi5oZWlnaHQgPSBtYXgoc2VsZi5wYXJlbnQuaGVpZ2h0LCBzZWxmLmxhc3RfbnVt
X3AqNiArIDIwKQoJCQoJCWlmIChrZXlwImRlbGV0ZSIgYW5kIHNlbGYuc2VsZWN0ZWRfcGlkKSB0
aGVuCgkJCXNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9ImtpbGxfcHJvY2VzcyIsIHByb2NfaWQgPSBz
ZWxmLnNlbGVjdGVkX3BpZH0pCgkJZW5kCgkJCgllbmQKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykK
CQlsb2NhbCBpbmRleCA9IDEgKyAobXNnLm15LTExKVw2CgkJbG9jYWwgcCA9IGZldGNoIi9yYW0v
c3lzdGVtL3Byb2Nlc3Nlcy5wb2QiCgkJaWYgKHAgYW5kIHBbaW5kZXhdKSBzZWxmLnNlbGVjdGVk
X3BpZCA9IHBbaW5kZXhdLmlkCgllbmQKCWZ1bmN0aW9uIGVsOmRyYXcobXNnKQoJCgkJcmVjdGZp
bGwoMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMCkKCQkKCQlsb2NhbCBwID0gZmV0Y2giL3Jh
bS9zeXN0ZW0vcHJvY2Vzc2VzLnBvZCIKCQlzZWxmLmxhc3RfbnVtX3AgPSAjcAoJCWN1cnNvcigy
LDIpCgkJCgkJLS0gc25pcHBldCBmcm9tIGxzLmx1YQoJCXByaW50KCJcMDE0XGZlIHBpZCAgbmFt
ZSAgICAgICAgICAgICAgICAgY3B1ICAgcHJpICAgbWVtXHxqIikKCgkJZm9yIGk9MSwjcCBkbwoJ
CQlwcmludChzdHJpbmcuZm9ybWF0KCJcMDE0JXMgXGY2JS00ZCBcZjclLTIwcyBcZjYlMC4zZiAl
cyUwLjNmIFxmNiVkayIsCgkJCQlwW2ldLmlkPT1zZWxmLnNlbGVjdGVkX3BpZCBhbmQgIlwjdSIg
b3IgIiIsCgkJCQlwW2ldLmlkLCBwW2ldLm5hbWUsIHBbaV0uY3B1LCBwW2ldLnByaW9yaXR5IDw9
IDAuMiBhbmQgKHBbaV0ucHJpb3JpdHkgPCAwLjAwMSBhbmQgIlxmMSIgb3IgIlxmZyIpIG9yICJc
ZjYiLCBwW2ldLnByaW9yaXR5LCBwW2ldLm1lbW9yeVwxMDI0KSkKCQllbmQKCgllbmQKCXJldHVy
biBjb250YWluZXIgLS0gbm90IHVzZWQKZW5kCgoKZnVuY3Rpb24gZ2VuZXJhdGVfZ3VpKCkKCQoJ
Z3VpID0gY3JlYXRlX2d1aSgpCgkKCWlmIG1vZGUgPT0gInZpZXciIHRoZW4KCQoJCWd1aTphdHRh
Y2hfYnV0dG9uewoJCQl4PS0xMCx5PS00LAoJCQlqdXN0aWZ5PSJyaWdodCIsCgkJCXZqdXN0aWZ5
PSJib3R0b20iLAoJCQlsYWJlbCA9ICJFZGl0IiwKCQkJYm9yZGVyPTB4MGUxMiwKCQkJdGFwID0g
ZnVuY3Rpb24oKQkKCQkJCW1vZGUgPSAiZWRpdCIKCQkJCWdlbmVyYXRlX2d1aSgpCgkJCWVuZAoJ
CX0KCgoJCS0tIGljb24KCQkKCQlndWk6YXR0YWNoewoJCQl4PTEwLHk9OCwKCQkJd2lkdGg9MTcs
IGhlaWdodD0xNyxjdXJzb3I9ImVkaXQiLAoJCQlkcmF3ID0gZnVuY3Rpb24oc2VsZixtc2cpCgkJ
CQlsb2NhbCB4LHk9MCwxCgkJCQlpZiAobWV0YS5pY29uIGFuZCBtc2cuaGFzX3BvaW50ZXIpIHRo
ZW4KCQkJCQltZW1tYXAoc2hhZG93X3BhbCwweDgwMDApCgkJCQkJc3ByKG1ldGEuaWNvbiwwLDEp
CgkJCQkJdW5tYXAoc2hhZG93X3BhbCwweDgwMDApCgkJCQkJeCx5PTEsMAoJCQkJZW5kCgkJCQkK
CQkJCWlmIChtZXRhLmxvd2NvbF9pY29uIGFuZCBtZXRhLmljb24pIHRoZW4KCQkJCQltZW1tYXAo
aWNvbl9wYWwsMHg4MDAwKQoJCQkJCXNwcihtZXRhLmljb24seCx5KQoJCQkJCXVubWFwKGljb25f
cGFsLDB4ODAwMCkKCQkJCWVsc2UKCQkJCQlzcHIobWV0YS5pY29uIG9yIGdldF9zcHIoOCkseCx5
KQoJCQkJZW5kCgkJCWVuZCwKCQkJdGFwID0gZnVuY3Rpb24oKQkKCQkJCW1vZGUgPSAiaWNvbiIK
CQkJCWdlbmVyYXRlX2d1aSgpCgkJCWVuZAoJCX0JCgkJCgkJLS0gcHJvY2VzcyBsaXN0IChoYSEp
CgkJCgkJaWYgaXNfc3lzdGVtIHRoZW4KCQkJY3JlYXRlX3Byb2Nlc3NfbGlzdHt4PTEwLHk9MzUs
CgkJCQl3aWR0aF9yZWw9MS4wLCB3aWR0aF9hZGQ9LTIwLAoJCQkJaGVpZ2h0X3JlbD0xLjAsIGhl
aWdodF9hZGQ9LTYwfQoJCQkJCgkJCWNyZWF0ZV9pbmZvdGV4dHtjb2w9MTMseD0xMCx5PS0xMCxs
YWJlbD0iLy8gXF5pZGVsXF4taSB0byBraWxsIn0KCQllbmQKCQkKCQktLSBpbmZvCgkJCgkJbG9j
YWwgYXR0cmlicywgc2l6ZSwgb3JpZ2luID0gZnN0YXQoZm4pCgkJaWYgKGF0dHJpYnM9PSJmb2xk
ZXIiKSB0aGVuCgkJCXN0YXJ0U2VhcmNoKGZuKQoJCWVuZAoJCWxvY2FsIHl5ID0gLTQyCgoJCWxv
Y2FsIGlzX3NhbmRib3hhYmxlX2NhcnQgPSBmbjpleHQoKSBhbmQgZm46ZXh0KCk6c3BsaXQoIi4i
KVsxXSA9PSAicDY0IgoJCWlmIChmbiA9PSAiL3JhbS9jYXJ0IikgaXNfc2FuZGJveGFibGVfY2Fy
dCA9IHRydWUgLS0gc3BlY2lhbCBjYXNlOyBub3JtYWxseSBkb24ndCB3YW50IHRvIHNhbmRib3gg
cGxhaW4gZm9sZGVycwoJCWlmIChmbjpzdWIoMSw4KSA9PSAiL3N5c3RlbS8iKSBpc19zYW5kYm94
YWJsZV9jYXJ0ID0gZmFsc2UKCQlpZiAobm90IGlzX3NhbmRib3hhYmxlX2NhcnQpIHl5ICs9IDE0
IC0tIGRvbid0IG5lZWQgdGhlIGxhc3QgMiBsaW5lcwoKCQlpZiBub3QgaXNfc3lzdGVtIHRoZW4K
CQkJY3JlYXRlX2luZm90ZXh0e2NvbD0xOCx4PTEwLHk9eXksbGFiZWw9KGZuIG9yICI-Iil9IHl5
ICs9IDcKCQkJY3JlYXRlX2luZm90ZXh0e2NvbD0xMyx4PTEwLHk9eXksbGFiZWw9KHNpemUgYW5k
IChzaXplLi4iIGJ5dGVzIG9uIGRpc2siKSkgb3IgIi0ifSB5eSArPSA3CgkJCWNyZWF0ZV9pbmZv
dGV4dHtjb2w9MTMseD0xMCx5PXl5LGxhYmVsPW1ldGEuY3JlYXRlZCBhbmQgZGF0ZSgiJVktJW0t
JWQgJUg6JU06JVMiLCBtZXRhLmNyZWF0ZWQpIG9yICJbbm8gZGF0ZV9jcmVhdGVkXSJ9IHl5ICs9
IDcKCQkJY3JlYXRlX2luZm90ZXh0e2NvbD0xMyx4PTEwLHk9eXksbGFiZWw9bWV0YS5tb2RpZmll
ZCBhbmQgZGF0ZSgiJVktJW0tJWQgJUg6JU06JVMiLCBtZXRhLm1vZGlmaWVkKSBvciAiW25vIGRh
dGVfbW9kaWZpZWRdIn0geXkgKz0gNwoJCWVuZAoJCQoJCS0tIGZvciBjYXJ0czogc2hvdyBiYnMg
aWQgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIHNhbmRib3ggdG9nZ2xlCgkJaWYgKGlzX3NhbmRib3hh
YmxlX2NhcnQgYW5kIGZuOnByb3QoKSA9PSAiYmJzIikgdGhlbgoJCQktLSBzaG93IGlkIGFuZCBy
ZWFkLW9ubHkgc2FuZGJveCBpbmZvIAoJCQlsb2NhbCBiYnNfaWQgPSBmbjpiYXNlbmFtZSgpOnNw
bGl0KCIuIiwgZmFsc2UpWzFdCgkJCS0tY3JlYXRlX2luZm90ZXh0e2NvbD0xOCx4PTEwLHk9eXks
bGFiZWw9IltiYnNfaWQ6ICIuLmJic19pZC4uIl0ifSAKCQkJeXkgKz0gNwoJCQljcmVhdGVfaW5m
b3RleHR7Y29sPTE4LHg9MTAseT15eSxsYWJlbD0iW3NhbmRib3hlZF0ifSAgLS0gYWx3YXlzIHNh
bmRib3hlZCBiZWNhdXNlIGJiczovLyAtLSBqdXN0IHRvIGF2b2lkIGNvbmZ1c2lvbgoJCQl5eSAr
PSA3CgkJZWxzZWlmIChpc19zYW5kYm94YWJsZV9jYXJ0IGFuZCBmbjpwcm90KCkpIHRoZW4KCQkJ
LS0gc29tZSBvdGhlciBwcm90b2NvbD8KCQkJLS0gbm8gb3RoZXIgcHJvdG9jb2xzIGN1cnJlbnRs
eSBzdXBwb3J0IHJ1bm5pbmcgYSBjYXJ0cmlkZ2UKCQllbHNlaWYgaXNfc2FuZGJveGFibGVfY2Fy
dCB0aGVuCgkJCS0tIGxvY2FsIGNhcnQKCQkJaWYgKG1ldGEuYmJzX2lkKSBjcmVhdGVfaW5mb3Rl
eHR7Y29sPTE4LHg9MTAseT15eSxsYWJlbD0iYmJzX2lkOiAiLi5tZXRhLmJic19pZH0gCgkJCXl5
ICs9IDcKCgkJCS0tIHNhbmRib3ggc3RhdHVzCgoJCQlsb2NhbCBlbCA9IGNyZWF0ZV9pbmZvdGV4
dHtjb2w9MTgseD0xMCx5PXl5LAoJCQkJbGFiZWw9ZnVuY3Rpb24oKQoJCQkJCWlmIChtZXRhLnNh
bmRib3ggPT0gImJicyIpIHJldHVybiAiXGZpWy9dIHNhbmRib3hlZCIKCQkJCQlyZXR1cm4gIlxm
ZFsgXSBzYW5kYm94ZWQiCgkJCQllbmQKCQkJfSB5eSArPSA3CgoJCQllbC50YXAgPSBmdW5jdGlv
bihzZWxmKQoJCQkJaWYgKG1ldGEuc2FuZGJveCA9PSAiYmJzIikgdGhlbgoJCQkJCW1ldGEuc2Fu
ZGJveCA9IGZhbHNlIC0tIGNhbid0IG92ZXJ3cml0ZSBuaWwgd2l0aCBzdG9yZV9tZXRhZGF0YSEK
CQkJCWVsc2UKCQkJCQltZXRhLnNhbmRib3ggPSAiYmJzIgoJCQkJCWlmIChub3QgbWV0YS5iYnNf
aWQpIHRoZW4KCQkJCQkJbWV0YS5iYnNfaWQgPSAiX2RldiIuLmZscihybmQoMTAwMDApKQoJCQkJ
CQlnZW5lcmF0ZV9ndWkoKQoJCQkJCWVuZAoJCQkJZW5kCgkJCQlzeW5jX21ldGFkYXRhKCkKCQkJ
ZW5kCgoJCQllbC5jdXJzb3IgPSAicG9pbnRlciIKCQllbmQKCQoJZW5kCgkKCWlmIG1vZGUgPT0g
Imljb24iIHRoZW4KCQlndWk6YXR0YWNoKGNyZWF0ZV9pY29uX2VkaXRvcigpKQoJCWd1aTphdHRh
Y2goY3JlYXRlX3BhbGV0dGVfY2hvb3NlcigpKQoJCQoJCWd1aTphdHRhY2h7CgkJCXg9MTI4LHk9
MzYsd2lkdGg9NjQsaGVpZ2h0PTEwLAoJCQljdXJzb3I9InBvaW50ZXIiLAoJCQlkcmF3PWZ1bmN0
aW9uKCkKCQkJCWxvY2FsIHN0ciA9ICJcMDE0XGZpWy9dIGxvdy1jb2xvdXIiCgkJCQlpZiAobm90
IG1ldGEubG93Y29sX2ljb24pIHN0ciA9ICJcMDE0XGZkWyBdIGxvdy1jb2xvdXIiCgkJCQlwcmlu
dChzdHIseCx5KQoJCQllbmQsCgkJCXRhcD1mdW5jdGlvbigpCgkJCQltZXRhLmxvd2NvbF9pY29u
ID0gbm90IG1ldGEubG93Y29sX2ljb24KCQkJCWdlbmVyYXRlX2d1aSgpCgkJCWVuZAoJCX0KCQkK
CQktLSBwcmVzZXRzIC8gdGVtcGxhdGVzCgkJZm9yIHk9MCwxIGRvCgkJCWZvciB4PTAsMyBkbwoJ
CQkJZ3VpOmF0dGFjaChjcmVhdGVfcHJlc2V0X2J1dHRvbnt4PTEyMCt4KjIwLCB5PTU0K3kqMjAr
NiwgaW5kZXg9eCt5KjR9KQoJCQllbmQKCQllbmQKCgkJLS0gcHJldmlldwoJCWd1aTphdHRhY2h7
CgkJCXg9NSx5PTEwNSx3aWR0aD0xMTAsaGVpZ2h0PTI0LAoJCQlkcmF3PWZ1bmN0aW9uKHNlbGYs
bXNnKQoJCQkJLS0gdGhlbWVkIHByZXZpZXcgKGdyYXlzY2FsZSB2YWx1ZXMpCgkJCQltZW1tYXAo
bG93Y29sX3BhbCwweDgwMDApCgkJCQlzcHIoYm1wLCA0LCAyKSAKCQkJCXVubWFwKGxvd2NvbF9w
YWwsMHg4MDAwKQoJCQkJCgkJCQktLSBjb2xvdXJmdWwgc3ByaXRlCgkJCQlpZiAobm90IG1ldGEu
bG93Y29sX2ljb24pIHRoZW4KCQkJCQlwYWwoKQoJCQkJCXNwcihibXAsMjQsMikgLS0gY29sb3Vy
ZnVsIHNwcml0ZQoJCQkJZW5kCgkJCQlwYWwoKQoJCQkJCgkJCQlpZiAobXNnLmhhc19wb2ludGVy
KSB0aGVuCgkJCQkJaWYgKG1zZy5teCA8IDIwKSB0aGVuIAoJCQkJCQlwcmludCgiXDAxNGxvdy1j
b2xvdXJcbnByZXZpZXciLDQ4LDQsMTMpCgkJCQkJZWxzZWlmIChtc2cubXggPCA0MCBhbmQgbm90
IG1ldGEubG93Y29sX2ljb24pIHRoZW4KCQkJCQkJcHJpbnQoIlwwMTRmdWxsLWNvbG91clxucHJl
dmlldyIsNDgsNCwxMykKCQkJCQllbmQKCQkJCWVuZAoKCQkJZW5kCgkJfQoJCQoJZW5kCgkKCWlm
IChtb2RlID09ICJlZGl0IikgdGhlbgoJCglmdW5jdGlvbiBjcmVhdGVfZmllbGQobGFiZWwsIGtl
eSwgeCwgeSwgaGVpZ2h0KQoJCgkJLS0gbGFiZWwKCQlndWk6YXR0YWNoewoJCQl4ID0geC0zMCwg
eSA9IHkrNCwgbGFiZWwgPSBsYWJlbCwKCQkJd2lkdGggPSA0MCwgaGVpZ2h0ID0gMTMsCgkJCWRy
YXcgPSBmdW5jdGlvbihzZWxmKQoJCQkJY2xpcCgpCgkJCQlwcmludCgiXDAxNCIuLnNlbGYubGFi
ZWwsIDAsMCwgNSkKCQkJZW5kCgkJfQoJCQoJCWxvY2FsIHRleHRlZCA9IGd1aTphdHRhY2hfdGV4
dF9lZGl0b3J7CgkJCXggPSB4LCB5ID0geSwga2V5ID0ga2V5LAoJCQl3aWR0aCA9IDE3MiwgaGVp
Z2h0ID0gaGVpZ2h0IG9yIDEzLCAtLSB3aWR0aCB3YXMgMTYwOyAwLjIuMGI6IDE3MgoJCQlibG9j
a19zY3JvbGxpbmcgPSB0cnVlLAoJCQltYXhfbGluZXMgPSAyLAoJCQkKCQkJa2V5X2NhbGxiYWNr
ID0gewoJCQkJZW50ZXIgPSAobm90IGhlaWdodCkgYW5kIGZ1bmN0aW9uICgpIAoJCQkJCS0tIGtl
ZXAgbmV3IHZhbHVlIGFuZCBjbG9zZQoJCQkJCS0tbmV3dmFsW2tleV0gPSB0ZXh0ZWQ6Z2V0X3Rl
eHQoKQoJCQkJZW5kLAoJCQkJZXNjYXBlCSA9IGZ1bmN0aW9uKCkKCQkJCQktLSBjbG9zZSB3aXRo
b3V0IGtlZXBpbmcgdmFsdWUKCQkJCQktLSAKCQkJCWVuZCwKCQkJfQoJCX0KCQkKCQlpZiAobWV0
YVtrZXldKSB0ZXh0ZWQ6c2V0X3RleHQobWV0YVtrZXldKQoJCXRleHRlZC5rZXkgPSBrZXkKCQkt
LXByaW50aCgiYWRkZWQgdGV4dCBmaWVsZCB3aXRoIGtleTogIi4udG9zdHIodGV4dGVkLmtleSkp
CgkJcmV0dXJuIHRleHRlZAoJZW5kCgkKCS0tIGZpZWxkcwoJbG9jYWwgeHg9MzQKCWZpZWxkID0g
ewoJCWNyZWF0ZV9maWVsZCgidGl0bGUgICIsICJ0aXRsZSIsIHh4LCAxMCksCgkJY3JlYXRlX2Zp
ZWxkKCJ2ZXJzaW9uIiwgInZlcnNpb24iLCB4eCwgMjUpLAoJCWNyZWF0ZV9maWVsZCgiYXV0aG9y
ICIsICJhdXRob3IiLCB4eCwgNDApLAoJCWNyZWF0ZV9maWVsZCgibm90ZXMgICIsICJub3RlcyIs
IHh4LCA1NSwgMjYrMTQpLAoJCQoJfQoJCgkKCQoJZW5kCgkKCS0tIENhbmNlbCwgU2F2ZSBidXR0
b25zIHNob3duIGluIGJvdGggZWRpdGluZyBtb2RlcwoJaWYgKG1vZGUgfj0gInZpZXciKSB0aGVu
CgkJCgkJZ3VpOmF0dGFjaF9idXR0b257CgkJCWxhYmVsID0gIlNhdmUiLAoJCQl4PS0xMCx5PS00
LGp1c3RpZnk9InJpZ2h0Iix2anVzdGlmeT0iYm90dG9tIiwKCQkJLS1iZ2NvbD0weDA3MGQsCgkJ
CWJvcmRlcj0weDBlMTIsCgkJCXRhcCA9IGZ1bmN0aW9uKCkKCQkJCgkJCQlpZiAobW9kZSA9PSAi
aWNvbiIpIHRoZW4KCQkJCQltZXRhLmljb24gPSBibXA6Y29weSgpCgkJCQllbHNlCgkJCQkJZm9y
IGk9MSwjZmllbGQgZG8KCQkJCQkJbWV0YVtmaWVsZFtpXS5rZXldID0gdGFibGUuY29uY2F0KGZp
ZWxkW2ldOmdldF90ZXh0KCksIlxuIikKCQkJCQllbmQKCQkJCWVuZAoJCQkJCgkJCQlzeW5jX21l
dGFkYXRhKCkKCQkJCW1vZGUgPSAidmlldyIKCQkJCWdlbmVyYXRlX2d1aSgpCgkJCQkKCQkJCS0t
IGxldCBmaWxlbmF2IGtub3cgKGluY2FzZSBpY29uIGNoYW5nZXMpCgkJCQlzZW5kX21lc3NhZ2Uo
MiwgewoJCQkJCWV2ZW50ID0gImJyb2FkY2FzdCIsCgkJCQkJbXNnID0gewoJCQkJCQlldmVudCA9
ICJmaWxlbmF2X3JlZnJlc2giCgkJCQkJfQoJCQkJfSkKCQkJCQoJCQllbmQKCQl9CgkJCgkJZ3Vp
OmF0dGFjaF9idXR0b257CgkJCWxhYmVsID0gIkNhbmNlbCIsCgkJCXg9LTQ1LHk9LTQsanVzdGlm
eT0icmlnaHQiLHZqdXN0aWZ5PSJib3R0b20iLAoJCQktLWJnY29sPTB4MDcwZCwKCQkJYm9yZGVy
PTB4MGUxMiwKCQkJdGFwID0gZnVuY3Rpb24oKQoJCQkJdW5kb19zdGFjazpjaGVja3BvaW50KCkK
CQkJCXN5bmNfbWV0YWRhdGEoKQoJCQkJbW9kZSA9ICJ2aWV3IgoJCQkJZ2VuZXJhdGVfZ3VpKCkK
CQkJZW5kCgkJfQoJCQoJCWlmIChtb2RlID09ICJlZGl0IikgdGhlbgoJCQlndWk6YXR0YWNoX2J1
dHRvbnsKCQkJCWxhYmVsID0gIkVkaXQgSWNvbiIsCgkJCQl4PTEwLHk9LTQsanVzdGlmeT0ibGVm
dCIsdmp1c3RpZnk9ImJvdHRvbSIsCgkJCQktLWJnY29sPTB4MDcwZCwKCQkJCWJvcmRlcj0weDBl
MTIsCgkJCQl0YXAgPSBmdW5jdGlvbigpCgkJCQkJbW9kZT0iaWNvbiIKCQkJCQlnZW5lcmF0ZV9n
dWkoKQoJCQkJZW5kCgkJCX0KCQllbmQKCWVuZAoJCmVuZAoKOjogaWNvbi5sdWEKLS1bW3BvZF9m
b3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yNSAwODo0NToyMCIsbW9kaWZpZWQ9IjIwMjUt
MDUtMjEgMTk6NTI6MDIiLHJldmlzaW9uPTI1MjNdXQotLVtbCgoJc3BlY2lhbGlzZWQgaWNvbiBl
ZGl0b3IKCWp1c3QgZm9yIGFib3V0IGJveAoKXV0KCi0tIGNvcHlwYXN0ZSBmcm9tIGZpbGVuYXYu
cDY0L2ljb24ucDY0CgoKLS0gbWF0Y2ggdGFibGUgaW4gYWJvdXQucDY0IGljb24gZGVzaWduZXIK
bG9jYWwgbG93Y29sX3RhYmxlID0gCnsKCSAgMSwxLDEzLCAxMywxLDYsNywKCTEzLDYsNiw2LCA2
LDEzLDYsNiwKCTEzLDEzLDEzLDEsIDEsMSwxMyw2LAoJMTMsMTMsNiwxMywgNiw2LDEzLDEzCn0K
bG9jYWwgdGhlbWVfaW5kZXggPSB7CglbN10gPSAiaWNvbjAiLAoJWzZdID0gImljb24xIiwKCVsx
M10gPSAiaWNvbjIiLAoJWzFdID0gImljb24zIgp9CmxvY2FsIHRoZW1lX2luZGV4X2J1cmllZCA9
IHsKCVs3XSA9ICJpY29uMSIsCglbNl0gPSAiaWNvbjIiLAoJWzEzXSA9ICJpY29uMyIsCglbMV0g
PSAiaWNvbjMiCn0KCi0tIG5lZWQgdG8gY2FsbCBlYWNoIHRpbWUgdGhlbWUgY2hhbmdlcwpmdW5j
dGlvbiBnZW5lcmF0ZV9pY29uX3BhbGV0dGVzKCkKCglwYWwoKQoJZm9yIGk9MSwzMSBkbwoJCXBh
bChpLCB0aGVtZSh0aGVtZV9pbmRleFtsb3djb2xfdGFibGVbaV1dKSkKCWVuZAoJaWNvbl9wYWwg
PSB1c2VyZGF0YSgidTgiLDQwOTYpCglpY29uX3BhbDpwZWVrKDB4ODAwMCkKCglwYWwoKQoJZm9y
IGk9MSwzMSBkbwoJCXBhbChpLCBsb3djb2xfdGFibGVbaV0pCgllbmQKCWxvd2NvbF9wYWwgPSB1
c2VyZGF0YSgidTgiLDQwOTYpCglsb3djb2xfcGFsOnBlZWsoMHg4MDAwKQoKCXBhbCgpCglmb3Ig
aT0xLDMxIGRvCgkJcGFsKGksIDEzKS0tIG1vZGUgPT0gImRlc2t0b3AiIGFuZCB0aGVtZSJkZXNr
dG9wX3NoYWRvdyIgb3IgNikKCWVuZAoJc2hhZG93X3BhbCA9IHVzZXJkYXRhKCJ1OCIsNDA5NikK
CXNoYWRvd19wYWw6cGVlaygweDgwMDApCgoJcGFsKCkKZW5kCgoKCmZ1bmN0aW9uIGNyZWF0ZV9w
cmVzZXRfYnV0dG9uKGVsKQoKCWVsLndpZHRoPTE2CgllbC5oZWlnaHQ9MTYKCWVsLmJtcD1nZXRf
c3ByKDI0K2VsLmluZGV4KQoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlzcHIoc2VsZi5ibXAsIDAs
IDApCgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWJsaXQoc2VsZi5ibXAsYm1wKQoJZW5k
CgkKCXJldHVybiBlbAoJCmVuZAoKCmZ1bmN0aW9uIGNyZWF0ZV9wYWxldHRlX2Nob29zZXIoKQoK
CWxvY2FsIGVsCgkKCWlmIChtZXRhLmxvd2NvbF9pY29uKSB0aGVuCgkJZWwgPSB7eCA9IDExMCwg
eSA9IDEwLCB3aWR0aCA9IDE5KjUsIGhlaWdodCA9IDE0LCBjb2xibXAgPSBnZXRfc3ByKDYpfQoJ
ZWxzZQoJCWVsID0ge3ggPSAxMTIsIHkgPSA2LCB3aWR0aCA9IDEzKjcsIGhlaWdodCA9IDMqOCwg
Y29sYm1wID0gZ2V0X3Nwcig3KX0KCWVuZAoJCQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJY2xp
cCgpCgkJcmVjdGZpbGwoLTEsLTEsc2VsZi53aWR0aCxzZWxmLmhlaWdodCwwKQoJCWxvY2FsIGNv
bGJtcCA9IHNlbGYuY29sYm1wCgkJc3Nwcihjb2xibXAsMCwwLG5pbCxuaWwsMCwwLHNlbGYud2lk
dGgsc2VsZi5oZWlnaHQpCgkJCgkJbG9jYWwgaGggPSBzZWxmLmhlaWdodCBcIGNvbGJtcDpoZWln
aHQoKQoJCWxvY2FsIHd3ID0gc2VsZi53aWR0aCBcIGNvbGJtcDp3aWR0aCgpCgkJbG9jYWwgZHJh
d249ZmFsc2UKCQlmb3IgeT0wLDIgZG8KCQkJZm9yIHg9MCxjb2xibXA6d2lkdGgoKS0xIGRvCgkJ
CQlpZiAoY29sID09IGNvbGJtcDpnZXQoeCx5KSBhbmQgbm90IGRyYXduKSB0aGVuCgkJCQkJbG9j
YWwgc3ggPSB4ICogd3cKCQkJCQlsb2NhbCBzeSA9IHkgKiBoaAoJCQkJCWxvY2FsIHd3MT13dwoJ
CQkJCWlmKGNvbGJtcDpnZXQoeCsxLHkpPT1jb2wpIHd3MSs9d3cKCQkJCQlyZWN0KHN4LHN5LHN4
K3d3MS0xLHN5K2hoLTEsMCkKCQkJCQlyZWN0KHN4LTEsc3ktMSxzeCt3dzEsc3kraGgsNykKCQkJ
CQlkcmF3bj10cnVlCgkJCQllbmQKCQkJZW5kCgkJZW5kCgkJCi0tCQlwcmludCgiXDAxNFsgXSBj
b2xvdXJmdWwiLDIwLDI4LDEzKQotLQkJcHJpbnQoIlwwMTQtLSB0ZW1wbGF0ZXMgLS0tIiwxOCwz
OCs2LDEzKQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWxvY2FsIGNvbGJtcCA9IHNl
bGYuY29sYm1wCgkJbG9jYWwgeCA9IG1zZy5teCAqIGNvbGJtcDp3aWR0aCgpIC8gc2VsZi53aWR0
aAoJCWxvY2FsIHkgPSBtc2cubXkgKiBjb2xibXA6aGVpZ2h0KCkgLyBzZWxmLmhlaWdodAoJCQoJ
CWNvbCA9IGNvbGJtcDpnZXQoeCx5KQoJZW5kCgkJCglyZXR1cm4gZWwKZW5kCgoKCmZ1bmN0aW9u
IGNyZWF0ZV9pY29uX2VkaXRvcigpCgoJbG9jYWwgZWQgPSB7CgkJeD02LHk9NiwKCQl3aWR0aD05
NixoZWlnaHQ9OTYsCgkJY3Vyc29yPSJjcm9zc2hhaXIiCgl9CgkKCS0tIGdsb2JhbAoJY29sID0g
NwoJCgkKCQoJbG9jYWwgYm1wX3dpZHRoID0gYm1wOndpZHRoKCkKCWxvY2FsIGJtcF9oZWlnaHQ9
IGJtcDpoZWlnaHQoKQoJaWYgKG1ldGEuaWNvbikgYmxpdChtZXRhLmljb24sIGJtcCwgMCwgMCwg
MCwgMCkKCQoJZnVuY3Rpb24gZWQ6Y2xpY2sobXNnKQoJCXVuZG9fc3RhY2s6Y2hlY2twb2ludCgp
CgkJaWYgKGtleSJjdHJsIikgdGhlbgoJCQlsb2NhbCB4ID0gbXNnLm14ICogYm1wX3dpZHRoIC8g
c2VsZi53aWR0aAoJCQlsb2NhbCB5ID0gbXNnLm15ICogYm1wX2hlaWdodCAvIHNlbGYuaGVpZ2h0
CgkJCWxvY2FsIGNvbDAgPSBibXA6Z2V0KHgseSkKCQkJZm9yIGk9MCwjYm1wLTEgZG8KCQkJCWlm
IChibXBbaV0gPT0gY29sMCkgYm1wW2ldID0gY29sCgkJCWVuZAoJCWVuZAoJZW5kCgoJZnVuY3Rp
b24gZWQ6ZHJhdyhtc2cpCgkJY2xpcCgpCgkJcmVjdGZpbGwoLTEsLTEsc2VsZi53aWR0aCxzZWxm
LmhlaWdodCwwKQoJCQoJCWlmIChtZXRhLmxvd2NvbF9pY29uKSBwYWwobG93Y29sX3RhYmxlKQoJ
CXNzcHIoYm1wLDAsMCwxNiwxNiwwLDAsc2VsZi53aWR0aCxzZWxmLmhlaWdodCkKCQlwYWwoKQoJ
ZW5kCgkKCWZ1bmN0aW9uIGVkOmRyYWcobXNnKQoJCWxvY2FsIHggPSBtc2cubXggKiBibXBfd2lk
dGggLyBzZWxmLndpZHRoCgkJbG9jYWwgeSA9IG1zZy5teSAqIGJtcF9oZWlnaHQgLyBzZWxmLmhl
aWdodAoJCWlmIChtc2cubWIgPiAxKSB0aGVuCgkJCWNvbCA9IGdldChibXAseCx5LGNvbCkKCQll
bHNlCgkJCXNldChibXAseCx5LGNvbCkKCQllbmQKCWVuZAoJCgkKCXJldHVybiBlZAplbmQKCgoK
ZnVuY3Rpb24gaWNvbl9lZGl0b3JfdXBkYXRlKCkKCQkKCWlmIChrZXkiY3RybCIpIHRoZW4KCQoJ
CWlmIChtb2RlID09ICJpY29uIikgdGhlbgoJCQlpZiAoa2V5cCgidiIpKSB0aGVuCgkJCQlsb2Nh
bCBjLG0gPSB1bnBvZChnZXRfY2xpcGJvYXJkKCkpCgkJCQoJCQkJaWYgKHR5cGUoYyk9PSJ1c2Vy
ZGF0YSIgYW5kIGM6d2lkdGgoKT09MTYgYW5kIGM6aGVpZ2h0KCk9PTE2KSB0aGVuCgkJCQkJbWV0
YS5pY29uID0gYwoJCQkJCWJsaXQoYyxibXApCgkJCQkJc3luY19tZXRhZGF0YSgpCgkJCQllbmQK
CQkKCQkJZW5kCgkJCgkJCS0tIGNvcHkgaWNvbgoJCQlpZiAoa2V5cCgiYyIpKSB0aGVuCgkJCQls
b2NhbCBiYiA9IGJtcCBvciBtZXRhLmljb24KCQkJCWlmIChiYikgdGhlbiAKCQkJCQlzZXRfY2xp
cGJvYXJkKHBvZChiYikse3BvZF90eXBlPSJpbWFnZSJ9KQoJCQkJCW5vdGlmeSgiY29waWVkIGlj
b24iKQoJCQkJZW5kCgkJCWVuZAoJCQkKCQkJaWYgKGtleXAoInoiKSkgdW5kb19zdGFjazp1bmRv
KCkKCQkJaWYgKGtleXAoInkiKSkgdW5kb19zdGFjazpyZWRvKCkKCQkJCgkJZW5kCgkKCWVuZApl
bmQKCgpmdW5jdGlvbiBpY29uX2luaXQoKQoJYm1wID0gdXNlcmRhdGEoInU4IiwxNiwxNikKCQoJ
dW5kb19zdGFjayA9IGNyZWF0ZV91bmRvX3N0YWNrKAoJCWZ1bmN0aW9uKCkKCQkJcmV0dXJuIGJt
cAoJCWVuZCwKCQlmdW5jdGlvbihzKQoJCQlibGl0KHMsYm1wKQoJCWVuZAoJKQoJCglvbl9ldmVu
dCgibW9kaWZpZWQ6L3JhbS9zaGFyZWQvdGhlbWUucG9kIiwgZnVuY3Rpb24oKQoJCWdlbmVyYXRl
X2ljb25fcGFsZXR0ZXMoKQoJZW5kKQoJZ2VuZXJhdGVfaWNvbl9wYWxldHRlcygpCmVuZAo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTE2IDA2OjMyOjE4
Iixtb2RpZmllZD0iMjAyNS0wOS0yOCAxNzo1MTozMSIscmV2aXNpb249MzA0OF1dCi0tW1sKCglh
NzogZWFzeSBhY2Nlc3MgdG8gMSwxMyw2LDcgcGFsZXR0ZT8KCSAgICAqKiBvbmx5IG5lZWRlZCBp
ZiBkbyBhdXRvIGNvbG91ciBkZXRlY3Rpb24gdGhpbmcgKioKCSAgICAKCSAgIC0tPiBiZXR0ZXI6
IFsvXSBhbHdheXMgdGhlbWVkCgkgICAgICAgKGNhbiB3b3JrIGluIHdpdGggcHJldmlldyBpbnRl
cmZhY2UpCgkgICAgICAgCgkJaG93IHRvIHNheSBpdD8KCQkKCQlbL10gY29sb3VyZnVsIC8vIG1l
YW5zIG5vdCBmb3JjZV90aGVtZWQhIChub2ljZSkKCQkgICAgLT4gY2FuIHB1dCB1bmRlciBwYWxl
dHRlIGFuZCB2aWV3IGRpZmZlcmVudCBwYWxldHRlCgoJYWJvdXQucDY0CglnZW5lcmFsIHB1cnBv
c2UgbWV0YWRhdGEgdmlld2VyIGFuZCBlZGl0b3IKCQoJdG8gZG86CgkJcmFtL2ZvbGRlciBzaXpl
cwoJCW1hbmFnZSBjdXJyZW50IGNhcnRyaWRnZT8gKENhcnQgaW5mbyBmcm9tIHBpY290cm9uIG1l
bnUpCgkJb3BlbiBtdWx0dXBsZSBmaWxlcz8gKGUuZy4gYnJvd3NlIG1hbnkgbWV0YWRhdGEgdy8g
Y3RybC1hLCBjdHJsLWkpCgkJL3N5c3RlbSBpbmZvCl1dCgppbmNsdWRlICJpY29uLmx1YSIKaW5j
bHVkZSAiZ3VpLmx1YSIKaW5jbHVkZSAiY3VzdG9tLmx1YSIKCi0tIHZpZXcsIGVkaXQsIGljb24K
bW9kZSA9ICJ2aWV3IgoKCgoKZnVuY3Rpb24gc3luY19tZXRhZGF0YSgpCgoJaWYgKG1ldGEpIHN0
b3JlX21ldGFkYXRhKGZuLCBtZXRhKQoJbWV0YSA9IG1ldGEgb3IgZmV0Y2hfbWV0YWRhdGEoZm4p
IG9yIHt9CgktLXByaW50aCgiW2Fib3V0XSBmZXRjaGluZyBtZXRhZGF0YSBmb3IgZmlsZTogIi4u
Zm4uLiIgIC8vIHBhdGg6Ii4ucHdkKCkpCgkKZW5kCgpidW5ueSA9IHVzZXJkYXRhIltnZnhdMTAx
MDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTExMTExMDAwMDAxZGRkZGRkZGRkZDEwMDAxZDExMTEx
MTExMTFkMTAxZDExMTExMTExMTExMWQxMWQxMTE3NzExNzcxMTFkMTFkMTExNzcxMTc3MTExZDEx
ZDExMTc3MTE3NzExMWQxMWQxMTE3Nzc3NzcxMTFkMTFkMTExNzE3NzE3MTExZDExZDExMTc3Nzc3
NzExMWQxMWQxMTExMTExMTExMTFkMTAxZDExMTExMTExMTFkMTAwMDFkZGRkZGRkZGRkMTAwMDAw
MTExMTExMTExMTAwMDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iCgpmdW5jdGlvbiBfaW5pdCgpCgoJ
CgkKCWNscyg3KQoJCglwb2tlKDB4NDAwMCxnZXQoZmV0Y2giL3N5c3RlbS9mb250cy9saWwuZm9u
dCIpKQoJcG9rZSgweDU2MDAsZ2V0KGZldGNoIi9zeXN0ZW0vZm9udHMvcDguZm9udCIpKQoJcG9r
ZSgweDU2MDIsNikgLS0gdG8gZG86IHNob3VsZCBiZSBzdGFuZGFyZCBmb3IgcDguZm9udAoJCglj
ZChlbnYoKS5wYXRoKSAtLSBjYW4gdXNlIGZyb20gdGVybWluYWwKCWZuID0gZW52KCkuYXJndlsx
XSBvciBlbnYoKS5wcm9nIG9yICIvc3lzdGVtLyItLSIvcmFtL2NhcnQiCgkKCS0tcHJpbnRoKCJb
YWJvdXRdIGluaXRpYWwgZm46ICIuLmZuKQoJZm4gPSBmdWxscGF0aChmbikKCQoJaXNfc3lzdGVt
ID0gZm4gPT0gIi9zeXN0ZW0iCgkKCWxvY2FsIHNlZ3MgPSBzcGxpdChmbiwiLyIsZmFsc2UpCglm
bl9zaG9ydCA9IHNlZ3NbI3NlZ3NdCglmbl9wYXRoICA9IHN0cmluZy5zdWIoZm4sIDEsIC0jc2Vn
c1sjc2Vnc10gLSAyKQoKCWNkKGZuX3BhdGgpIC0tIHNhbWUgcGF0aCBhcyB0aGUgZmlsZSBvciBm
b2xkZXIgaW4gcXVlc3Rpb24KCQoJLS1wcmludGgoIlthYm91dF0gY2hhbmdlZCB0byBmbl9wYXRo
OiAiLi5mbl9wYXRoKQoKCXN5bmNfbWV0YWRhdGEoKQoJCgl3aW5kb3d7CgkJd2lkdGggPSAyMTIs
IC0tIDAuMi4wYzogMjEwICh3YXMgMjAwKQotLQkJaGVpZ2h0ID0gMTA4LAoJCWhlaWdodCA9IGlz
X3N5c3RlbSBhbmQgMTYwIG9yIDEyOCwgLS0gMC4yLjBjOiAxMjggKHdhcyAxMTYpCgkJdGl0bGUg
PSAiQWJvdXQiCgl9CgkKCWljb25faW5pdCgpCgkKCWdlbmVyYXRlX2d1aSgpCgkKCS0tY3VzdG9t
OgoJc3RvcmFnZUxhYmVsPS0xCglmb3IgaT0xLCAjZ3VpLmNoaWxkIGRvCgkJaWYgKHN1YihndWku
Y2hpbGRbaV0ubGFiZWwsLTE0KT09IiBieXRlcyBvbiBkaXNrIikgc3RvcmFnZUxhYmVsPWkgYnJl
YWsKCWVuZAoJCglsb2NhbCBhdHRyaWJzLCBzaXplLCBvcmlnaW4gPSBmc3RhdChmbikKCWlmIChh
dHRyaWJzPT0iZm9sZGVyIikgdGhlbgoJCXN0YXJ0U2VhcmNoKGZuKQoJZW5kCmVuZAoKZnVuY3Rp
b24gX2RyYXcoKQoJY2xzKDYpCgkKCWlmIChtb2RlID09ICJ2aWV3IikgdGhlbgoJLS1yZWN0Zmls
bCgwLDAsMTAwMCwzMiw3KQoJCgktLSBzcHJpdGUgaGFuZGxlZCBieSBndWkgZWxlbWVudAoJLS1z
cHIobWV0YS5pY29uIG9yIGdldF9zcHIoOCksMTAsOCkKCQoJbG9jYWwgdGl0bGUgPSBtZXRhLnRp
dGxlCglpZiAodHlwZSh0aXRsZSkgfj0gInN0cmluZyIpIHRpdGxlID0gZm5fc2hvcnQgb3IgIiIK
CQoJCQoJbG9jYWwgdmVyc2lvbiA9IG1ldGEudmVyc2lvbgoJaWYgKHR5cGUodmVyc2lvbikgfj0g
InN0cmluZyIpIHZlcnNpb24gPSBuaWwKCQoJbG9jYWwgYXV0aG9yID0gbWV0YS5hdXRob3IgCglp
ZiAodHlwZShhdXRob3IpIH49ICJzdHJpbmciKSBhdXRob3IgPSBuaWwKCQoJdGl0bGUuLj0gIiBc
MDE0XF5pXHxoIi0tLi5tZXRhLnZlcnNpb24KCQoJcHJpbnQodGl0bGUsIDM0LCAodmVyc2lvbiBv
ciBhdXRob3IpIGFuZCA4IG9yIDEyLCAxKQoJCgkJbG9jYWwgc3RyID0gIlwwMTQiCgkJaWYgKHZl
cnNpb24pIHN0ci4uPSAiXF5pIi4ubWV0YS52ZXJzaW9uLi4iXF4taSAiCgkJaWYgKGF1dGhvciBh
bmQgYXV0aG9yIH49ICIiKSBzdHIuLj0gIlxmZGJ5ICIuLm1ldGEuYXV0aG9yOmxvd2VyKCkKCQlw
cmludChzdHIsIDMzLCAyMCwgMTMpCQoJCQotLVtbCglpZiAobWV0YS5hdXRob3IgYW5kIG1ldGEu
YXV0aG9yICE9ICIiKSB0aGVuCgkJY3Vyc29yKDEwLDMyKSBjb2xvcigxMykKCQlwcmludCgiLy8g
YnkgIi4ubWV0YS5hdXRob3IpCgllbmQKXV0KCgktLSAzIGxpbmVzIG9mIG5vdGVzCglpZiAobWV0
YS5ub3RlcyBhbmQgbWV0YS5ub3RlcyAhPSAiIikgdGhlbgoJCWN1cnNvcigxMCwzOCkgY29sb3Io
NSkKCQlwcmludChtZXRhLm5vdGVzKQoJZW5kCgkKCQoJbG9jYWwgYXR0cmlicywgc2l6ZSwgb3Jp
Z2luID0gZnN0YXQoZm4pCgkKCWxvY2FsIHl5ID0gZ2V0X2Rpc3BsYXkoKTpoZWlnaHQoKS00Mgot
LQlpZiAobm90IG9yaWdpbikgeXkgKz0gNgoJaWYgKG5vdCBtZXRhLmJic19pZCkgeXkgKz0gMTIK
CgotLVtbCgljdXJzb3IoMTAsIHl5KSBjb2xvcigxMykKCS0tPyJcMDE0YXV0aG9yOiAgICAiLi4o
InplcCIgb3IgIi0iKQoJLS0-IlwwMTRyZXZpc2lvbjogICIuLihtZXRhLnJldmlzaW9uIG9yICIt
IikKCgktLXJlY3RmaWxsKDAseXktNCwxMDAwLDEwMDAsMSkKCWNvbG9yKDE4KQoJPyJcMDE0Ii4u
KGZuIG9yICI-IikKCT8iXDAxNCIuLigoc2l6ZSBhbmQgKHNpemUuLiIgYnl0ZXMgb24gZGlzayIp
KSBvciAiLSIpCgoJLS0gbG9jYWwgdGltZXM7IHRvIGRvOiBjbGljayB0byB0b2dnbGUgZ210Cgkt
LSB0byBkbzogbiBkYXlzIGFnbwoJY29sb3IoMTMpCgk-IlwwMTQiLi4obWV0YS5jcmVhdGVkIGFu
ZCBkYXRlKCIlWS0lbS0lZCAlSDolTTolUyIsIG1ldGEuY3JlYXRlZCkgb3IgIltubyBkYXRlX2Ny
ZWF0ZWRdIikKCT8iXDAxNCIuLihtZXRhLm1vZGlmaWVkIGFuZCBkYXRlKCIlWS0lbS0lZCAlSDol
TTolUyIsIG1ldGEubW9kaWZpZWQpIG9yICJbbm8gZGF0ZV9tb2RpZmllZF0iKQoKCglpZiAob3Jp
Z2luKSA-IlwwMTRvcmlnaW46ICIuLihvcmlnaW4gb3IgZnVsbHBhdGgoZm4pIG9yICI-IikJCgkK
CWlmIChtZXRhLmJic19pZCkgdGhlbgoJCWNvbG9yKDE4KQoJCT8iXDAxNGJic19pZDogIi4ubWV0
YS5iYnNfaWQKCgkJaWYgKG1ldGEuc2FuZGJveCA9PSAiYmJzIikgdGhlbgoJCQk-IlwwMTRcZmkg
ICAgWy9dIHNhbmRib3hlZCIKCQllbHNlCgkJCT8iXDAxNFxmZCAgICBbIF0gc2FuZGJveGVkIgoJ
CWVuZAoKCWVuZApdXQoKCQoJZW5kIC0tICJ2aWV3IiBtb2RlCgkKCQoJZ3VpOmRyYXdfYWxsKCkK
ZW5kCgpmdW5jdGlvbiBfdXBkYXRlKCkKCS0tY3VzdG9tOgoJdXBkQ3VzdG9tKCkKCS0tbm9ybWFs
OgoKCWlmIChtb2RlID09ICJpY29uIikgaWNvbl9lZGl0b3JfdXBkYXRlKCkKCWd1aTp1cGRhdGVf
YWxsKCkKZW5kCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiAuaW5mby5wb2QKLS1b
W3BvZCxhdXRob3I9InplcCIsYmJzX2lkPSJfZGV2MjM2NiIsY3JlYXRlZD0iMjAyNS0wMy0xNCAx
NDozMjowMSIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAwMDIwMjAyMDIwMjAy
MDAwMDAwMDAwMDAwMDAwMDAyMDIxZTFlMWUxZTFlMWUwMjAyMDAwMDAwMDAwMDAyMWUxZTFlMWUx
ZTFlMWUxZTFlMWUwMjAwMDAwMDAyMWUxZTFlMGUwZTFlMWUwZTBlMWUxZTFlMDIwMDAwMDIxZTFl
MGUxNzA3MDcwNzA3MTcwZTFlMWUwMjAwMDIxZTFlMGUxNzA3MDcwZTBlMDcwNzE3MGUxZTFlMDIw
MjFlMWUwZTA3MDcwNzA3MDcwNzA3MDcwZTFlMWUwMjAyMWUxZTFlMDcwNzA3MGUwZTA3MDcwNzFl
MWUxZTAyMDIxZTFlMWUwNzA3MDcwZTBlMDcwNzA3MWUxZTFlMDIwMjFlMWUwZTA3MDcwNzBlMGUw
NzA3MDcwZTFlMWUwMjAyMWUxZTBlMTcwNzA3MGUwZTA3MDcxNzBlMWUxZTAyMDAwMjFlMWUwZTE3
MDcwNzA3MDcxNzBlMWUxZTAyMDAwMDAyMWUxZTFlMGUwZTFlMWUwZTBlMWUxZTFlMDIwMDAwMDAw
MjFlMWUxZTFlMWUxZTFlMWUxZTFlMDIwMDAwMDAwMDAwMDIwMjFlMWUxZTFlMWUxZTAyMDIwMDAw
MDAwMDAwMDAwMDAwMDIwMjAyMDIwMjAyMDAwMDAwMDAwMCIpLG1vZGlmaWVkPSIyMDI1LTEyLTE0
IDAwOjQ3OjM4Iixub3Rlcz0iRmlsZSBtZXRhZGF0YSB2aWV3ZXIgYW5kIGVkaXRvci5cbkNsaWNr
IG9uIHRoZSBpY29uIHRvIGVkaXQgaXQhXG4iLHJ1bnRpbWU9MjAsc2FuZGJveD1mYWxzZSxzdG9y
ZWQ9IjIwMjQtMDMtMjMgMTk6MzQ6MTUiLHRpdGxlPSJBYm91dCIsdmVyc2lvbj0iMC4yIix3b3Jr
c3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzE4NSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2Nh
dGlvbj0iZ3VpLmx1YSMxMjUiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imljb24ubHVh
IzkiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImN1c3RvbS5sdWEjMTA1Iix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9j
YXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9fV1dCjo6IGdmeC8uaW5mby5wb2QK
LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTE2IDA2OjMxOjUyIixtb2RpZmllZD0iMjAyNS0xMi0x
NCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTMxLTE2IDA2OjMxOjUyIl1dCjo6IGdmeC8wLmdmeApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEUySURBMk9qTXlPakU0SWl4dGIy
UnBabWxsWkQwaU1qQXlOUzB3Ck5TMHlNU0F4T1RvMU1qb3dNaUlzY21WMmFYTnBiMjQ5TWprNU9W
MWRiSG8wQUpBUUFBQnpVQUFBOHhkN1d6QmRQWHRpYlhBOWNIaDEKQUVNZ0JRRUVBQUVOQmdjc1pt
eGhaM005TUN4d1lXNWZlQWdBeTNrOU1DeDZiMjl0UFRoOUxEUUFidzhTRHc0UEZ6Y0FHbDhRRUFU
dwo4REVBQ3kweE5ESUEzZ0QtRWdIWEhnZS1EZ2NlQjcwRUFQOEkxeDRYanhjbkhoZU1Gd3dldHd3
T0FBNjhEaERPOEFObkFCX184UUhYCkVRZS1FZ2NSQjc0RUFQOEcxeEVYanc0bkVSZU5GdzBSdHcw
QkFBRzlBUkRCWmdBZjhCRWdrVUFCbHdFZ0FRZWRCd0VBQVFjOU56MEgKRVFjdEZ4MFhMUWNSQngx
M0hRWUFQeWNkSndnQUFRUW1BQUUwQVA4R0JnZWRCd1lSRnBjV0FRQUJ0Z0VnQVpZQlFKRWdqUUFQ
RC1jQgpIZ3MxQU5BTkF3UUdGdzhhQ3d3UEhBOGQtd0gtRlE4UENRb05EeElERHhFUEd3OFFEeFlQ
SGdnUEdBUVBHUThmQUJFZkV4VVNIeFFmCkZZb0JIdk1GQXhjQU53QVhRQWVRQnlBSHNBY1FCN0FI
OEFJSkFCd1FFUUJSSUFlUUIwQXdBQS16QVNBZjhESUFnZ0tKQXZBRUh4SUsKamdjUkIwb2VHQTRZ
QnhFSERpb3VTQWNBendvT0NqNG9EZ2NSQjQ0SUhwb0NDZ19wQUV4OEZBb0U4REFHQnd3Q1RuQU5E
eElNQW1HQQpBUThURXdVTkFpLXdSR2NBREI4eFp3QUFEWE1DSDJCMEFnTVZjSFFDTC1CRFp3QWEt
d1FRRUFUMk5SOFI5ZzRkOWc0ZkhSWWZGLVpsClFBRWZEeklBLTB2dkNWR0FBUzB2RHdFQVlTMF9F
ZDRDQUFGUEFRRFJBRmNBSXQ4dkhpOFhBUUJoTHg0LUZ4SGVXZ0EyQXNZREw3MEgKQkFBQ0FMUUQ3
eDBuRVJlT0Z3NFJ0dzRCQUFHX3RBTWktd29Ba1ZBQmR3WUJRQUYzRmdFd0FYY21BU0FCZHpZQkVB
RzNCQUFURDlZQQpINUFRb1RBQnFRRVFBUWNHQUJBUkNnQS11UUVBRGdBTTdwa1JFTEVIQVJBUmx3
a0JJQUdacUFZUGRnQVRFYVIyQUVDa0FSQVJDZ0EtCnRBRUFEZ0FNRkpSMkFGOEVBU0FCbEhZQUlX
LXhBUjZYSGhFRUFBVUNHd0tETG9FZUVTNEJOekVHQUVFQkFBRWVDQUF2RU5FWkNDWWgKbnhJYUNB
ZDdDQThFQUFHaER4MEhuZ2NORVIyWEhmRUZQeUFCbmVNQUlTLXc4RElBLTB0d0VkRUFFYmNoMV80
RDZaMFhFUWNORVEwVwpBUVlORVEwSERBQUFIQURQMXhIZEVUMVJQUUVBMGZBUm1RQWZEeklBLS0t
LUN6OEJBUVRpREJ2LUJnd0JCQThYRHgwS0R3OFBHZzhjCkJnOE9EQWtJQzBJQUh2OEZIdzhXQlE4
U0RROGVEeEFQR1FRUEdBOGJEeEZGQUIxUUJ3QWZGUkhOQ2g4VE9nQWEtd0FrRUFSM1B4Yy0KSFRw
LUR6OGFQeHdNQUJHLVB4WTJQdzQ4T1Q4Zk9Ic0xBQTctQURVOVB4NC1FRDhaTkQ4WVB4cy1FUThB
R3E4d01UOFNQeE0tRkhKegpDZ0FMRC1BQUN4ODJFd0lkSHpneEFGLXhQR0FTQUJLUUFnOFhCd0lP
QW9BQ0RoY0NEdzRIQW1BQ0RpY05Gd0pRQWc0ZkQxNENRQUl1CkJ3NEhEZ2NlQWlBQ0RRNEhEUjRO
RGowQ0VBSU5IaDBPSFI0ZEFoQUNIUTRkTGcwZURRb0E0QTBlQVE0TkRnRUNBQklPVFFFT0FnQlEK
QWhBQ0J3NFpBR0VOSGlFU0JqY0pBTjhCSUFJMlp3SXdRa1lDY0dJZzR3QWQ5eUlCQ2VBWjBDbkFP
YkJKb0ZtUUtROFpLWUFwQUE0cApjQ2tRRGlsZ0tTQU9LVkFwTUE0cFFBa1BFU2tOS1EwWk1Ba05B
Z0JQSU03d0FuQUFIZkVqRWg4VEVGOFJRRDhUQng4UkR4d1BFUjhjCkR4TWdIaEFIRHh3ZkVTOGNI
eEVPRUI0QUJ4OGNEeEUtSEM4UkRnQXVCdzhNQUJCUERBRHdDeDFQSEQwT0VDNWNEZ3dOREE0UUJ6
NHMKRFI0Y0RoQUhIWTROQmdELUREd2RIaDBPSUEwTURTd2REaDBPUUExY0hRNWdEVndPZ0UwT01L
VUFIUEFJQVFNUEdoRU9JUU1CRGdFRApEZ0VURGhNT0F3RUhBUU1JQVBFQlhnRVhBVjRCQXc0UkRn
RUhEeDBQRWlNQUVSRVFBUEFuUFJFREVUNFJIUUU5QVFjUkF3NEJCdzBQCkhTRWREQmNSQXdFSERR
d0hEQ0VNRnd3QkhnRU5EQWN0QVF3WEVRQVRBUXdITFFjTUxBQ0FBd0VEQVQwSERCMWtBQ0lCRGdz
QVlRd0IKTGhFSExRa0FjQUFERGhFbkhVRi1BTE1PQVJ3Um5nRURJUTRSRHA0QUQ0QUJIZklYQXJj
Z0J4MHZFRThlSFFjUUhUOFFYeDRkRUEwdgpFRjhTSHg0UERnMFFEUjhRYnhJUEZoOExBRFJmRWg4
TEFHRS1FajhXSHg4TEFESXZFazhMQUhJUEVROFFIeEpmRFFCZ0x4RmZGZzhQCkN3RHdBeDB2RVQ4
YUx3OGRFQzBQRVY4YUR3OHRFS29LSDdFckFoNlRNRmh3bUVDNElCZ0FBZ0R5R1JEb0VDZ1FHQkFv
UUFod0NQQUkKRHg1QURwQU9JQTZRYm5BZUFDNEFIbEN1UUE0QWJnQU9RQTRFQUY5d0hnQWVVSElB
SEFCeERCR21jUXpScGdFUUVSWlhKZ0VRQVNabgpGbGtNVUZZSEJnY1dGZ0JBSndZbkZoZ0FRUWNH
QjFZYUFDQVdaeGdBSUNaWEZnQVJ0aElBRkphRkRCOEdveE1USHpnTUVtSU5kZ0R5CkRHQVJBQkdR
QVJjQkJ3R0FBU2NCQmdjQllBRTNCaGNCVUFHSEFhVU1ZQVlYQmhjR0Iyb09ZQVlYRmdjV0YtSUFj
UllIRmljR0Z3WUsKQU5FR0Z3RUhCZ2NSQUJFSFJnRUhBZ0F3RUFFWEZ3QlFCaGRCQmtjSEFOOEJJ
QUUyWndFd1FVWUJjR0VndndWTzhESVNFUkJkUURFSApIUVlORmdFZ0VSQUhCaDBtSFFFUUVRQUhG
ZzAyTFFFQUlRY0dEVFpOQVFBaEhVWTlBUkFoVmdFR0RRWUJFQWN4SmcwUkZnRVFCeDJCCkRRWUEt
d3MySFJFZEFTQU5CZzBtSFFFZEFVQU5WaDBCWUExV0FZQk5BVmNFSFFic0RSVVc3QTAyRGpkdUJn
QlFCdzVITGhjT0FEQV8KQnc0SUFFTVhIZ2N1Q2dBeUxnZE82d0VfQmdlZUFoWVBpUUFtRlJHSkFO
OHVGeDRYTGdjUkJ4NFhQaGNlQ0FBSUJDZ0FENHNBUGg4ZQpGQUVuTHc4WEZnOEJELTBESUJHcy1R
UFFyQUVRRVJ4WExBRVFBU3huSEpVQVlBRmNCdzRISEJZQVFDY01KeHdZQUVFSERnZGNHZ0FnCkhH
Y1lBQ0FzVnhZQUVid1NBQlNjLVFOZkRBRWdBWndUQVNvZkdSTUJKOTRKQjU0SENSRVpseGtCQUFH
NWdSRVBpUUFTTWtCaGNQTUQKOEFBQlVBRUdGeVlYQmdFd0FRWW5KaWZ0QThBR0owWW5CZ0VBQVJZ
WFJoY0FBa0FHRndaTktnQVRBQm9BQUNNRUlFWVhBQVVRcGpZQQpVUWNHTFFZSFNBQndCeVlIQmdG
d0VTZ0VFWkJ4QTNfZ0FTMEJvRUZBT0FJc09ENDNQc1VDRVhlekFqOG5IaWNJQUFFRUpnQUJOQUFQ
ClBBSXlCbzRBRlJDekFRV01BQXRCQXd3SUFBUW9BTENfQnhFTUI1NEhEQkVjbDNVQ0g3d19BaTRk
SDRzQURRZ0FFVmNHQUZZSERoY08KQnhBQUg3NFZBVDRXRzRvQUVDZWtBZ2dJQUdGZUJ4RUhYaWNN
QUNrWERnZ0FEMklFUGdaaUV3OVBBeDRPZUJNUDdBU3FENG9BQVFfYgpBUnd2RHc2SUFEQUFZZ1R3
RFE0WERoY09BVkFCRGhjdUZ3NEJNQUVPSnk0bkRnRVFBUTRuVGljakYwQWVGMDRYWWhWUURoY09U
eElyCkFCTUFHd0N3RUFFT0YwNFhEZ0VnQWE0M0FGRUhEaTBPQjBrQUFEVUJBR01FUVE0SEVaQkFE
UTlqQkNNQ2ZCZ1FLbnNZUHpvUjJnSUEKQVE0aEdBOVZBQlFRS1ZVQVB6a1IyUUlBQVE5VkFDWXZM
eGNtR1NvZk9DVVpCUklPSlJrLURoSGVXUUE2bnhBc0FRQmhMandSM0FJQQpBUThGQVNjZkhBVUJR
RDh0THgxV0FEc0FfQUx3RHdnWENCY0lBVkFCQ0Jjb0Z3Z0JNQUVJSnlnbkNBRVFBUWduU0NjUEdP
WUNVQVlYClNCY0c4QUp3Q0JjTlFnMFhDQW9BTWlkUERpWUEwUmRJRndnQklBRUlEZ1pJQmc1QUFG
RUhCaUlHQjFJQVFBY3NCd2dCQXhBSUFRTl8KQ0FJSUFhQUJJZ0VERDU0REV5UUhENkFESXdjTm9R
TWpCeDJpQXlNWERhTURKZ2NOcEFNVERhUURJeGNOcFFNcEJ3Mm1BekVzRGcxUApBREFOTGcybUF6
QU5EZzJtQXhBTXBnTWVMS1lERHhZTVB3OGhCek1mRHlFSGN5OFBGb2dBT1JHVWh3QjJ0QWNSQndR
M1pBWUFVQWNFClJ5UVhEZ0F3TkFjRUNBQkRGeFFISkFvQWNTUUhSQWNSQjdTWEJqQ1VCdzRqR3dI
V0hEOGdBWjc2Q2pRTmt3RVBtd0VIRC1vS053OFMKQVFBZ0pDZnVBQWdJQUdGVUJ4RUhWQ2NNQUNr
WEJBZ0FUN1FIRVE0UEFRRVBKZ1JOTXdaQ0JpWUVIMGdsQkJBZktDVUVBd19sQUU0dgpUeEttQUJB
ZkxhWUFPLUFKTUlGUUFSZ1hDQmNZQVRBQkdCY29GeGdCRUFFWUp5Z25uUUFQcGdCM0Q2c0tBUTM0
QWc4QUF3Y1Bxd280CkFUQUJRUjhYQ0I0eEFSTWVNUUVUTGpFQkV5NHhBWEFORHc0ZVNBNFhjUkpT
Q0I0TVRRd3hBVkV1U0E0SERqTUJNUjVJSGpNQlVRME0KU0F3Tk13RlJEZ3d0REE0ekFUQU9LQTR6
QVQ4T0NBN1pBUzhIcVFBVEhxa0FFeTZwQUJZdXFRQVZMcWdBRXg2b0FCOHVwZ0JWQy04bgpnUTBC
RmdFZEFSWUJFaDVFQVJZQkZnd0FVUVlYTmhjR0NnQTVNUjB4Q0FCUkZ4WVhGaGNLQUhzQkJoRVdF
UVlCREFBUEdTZ0NEeVVEClFnRUpBd0lsQXo4SVRnZ2tBd1FUYUNJRFB3Z3VDTWdEUHZNSEh4d1hE
aGNlQVRBQkhoY3VGeDRCRUFFZUp5NG5IaGNNSUE4UTd3RmgKREJkT0Z3d05oZ2dBbHdJUE5Bd0JZ
ZzROREU0TURkQUlQd3d0RERvTUFTOENEaFFGS0M4UEhOZ01Bd19tQUQ0UDRBd21BS1lBSUF3WAps
aGp5QmxBQkRCY3NGd3dCTUFFTUp5d25EQUVRQVF3blRLVUFRUXdPRjB6YkNYRU1GMjRYREFFQUdn
QUJJZ0F3RjB3WDRoSkJEQTVzCkRqb0FVUWNNTGd3SFRBQkFCeXdIREtBQUVBeWdBSDhNRGd3Qm9B
RXUyZ2xSQWRFQU1Sb01Hb1VBTVJvc0dwY0FNU29zS3E4QU15cE0KS3RFQU1ScE1HdEVBTVJwdUd0
RUFJaXBNSWdBNUdrd2EwUUJSQ2d3dURBcE1BREFLTEFyUkFEOEtEQXJSQUZzTUVBYVFEZ0VmRGdF
ZQpBUjBCLVJjZ0RnR1FGZ01NQUZFTkZ6MFhEUW9BT1RFZU1RZ0FVUmNkRngwWENnQjdBUTBSSFJF
TkFRd0FMdzhkZFJJd0FKY0RIeDZXCkF3a1JIb1VGSHhmeEFnY0JEQU1COFFJVGJ1OENEczhQRDVV
REstRVNZQkhBQVJjQnNBRVhBYUFCTndGQVVUZGgxeEVHSncwM0RTY0cKRVJZWERUY055QlF3Rm5j
VzZSZ3hKeDBuWUNmLUV3RkFBVGNXTndFd0FSZFdGd0V3QVFjbUVTWUhBVEFCRmhFUUVSWUJNQ0ZR
SVJDRwpBQjN4RVI4VndBNFhEckFPRnc2Z0RqY09RRjQzYnRjZUR4a25EeDgzRFNjSkhoOFppZ0Qt
S0JrT0FBNGNkeGtPSUE0TUp4MG5DUTVBCkRuY09RQTQzQ1F3M0RqQU9GeWtzRnc0d0RnY3BIaXdI
RGpBT0dSNFFIaHdPTUM1UUxoQ1dCaXNBcENnU2JaRXVSVUVYQVIwT0FEQXQKRjIwVUFFVUJGMEVk
RGdBZnZYSUdNdzhTR1FFUmJ0OElWUjVCRndFZURnQWdMaGNnRTFVZUFSZEJIZzRBRHg4VU5NZnhB
UjJYSFJFZApCd0ZYQVFjSUFBQVVBQUdMQVdJZEVSMG5QU2NTQUJIZEFnQ0lIWkVkRVIweFJ3RUdB
RjhOQVFEUkVIb0FIbEVabHhrUkdYSUFCd2dBCkFCUUFzaGNKTndrWEdSRVpKemtuRWdBQ0hCS0lH
WkVaRVJreFJ3RUdBQjRKZWdBUGFBb2lJRDRYYVE0Z1RoZG5GRFZlRno0R0FBSVMKQUFJZUFBOXpB
VFFBTGdReER4NFBfUk1ZRHpNRUVRMGtCd0FoQkY4TkowNG5EVFFFQlFJZEFBWTBCSkVOSEU0Y0RR
RXdBUTAwQko4TgpBVkFCRFFjdUJ3MDBCQUVQcWdER0wtRHdNUUQtLS0wUHNpNVJEM1VBQWhHdWRR
QkFyZ0VRRVFvQVA3NEJBQTRBREJTZWRRQWZEaVlTCkpBQjFBQ192RjNZQVloOFJkZ0JkTC1Ed01R
Q3ZzQUJoZ0FFZkhDY0JnQUVlQlFEd0EwNEJnQ0VQRUNHZ0FRMEJJRkV3QVExQkhta0sKRVYwR0FG
UU5RVDRCTUJrQUx3SEFJd0FBYjJFX0FaQlJBR2NWTUNBZWRsb0pZUjRHQ0JZUkZnb0FVaVlSQndF
R0NnQVNNUWdBRXpZYQpBQzkySG1rVk55LXc4REVBLXhJUE9SNkFFWmlKQUhhNEJ4RUhDRGRvQmdC
UUJ3aEhLQmNPQURBNEJ3Z0lBRU1YR0Fjb0NnQWdLQWU5CkpoRzRpUUFlbUJ3WEQwUUJUVEh4QVIt
RU13Rm5Dd2NJQUFBVUFMZ1hEamNPRng0UkhpY19KX1l6aUI2UkhoRWVNVWNCQmdBZkR1a0wKbWst
eEFSOFg5UUJtSHg1NkFBb3hEZzhYZkFELUFoMFJIcGNkRVo0dERoR09MUjRSZmkwdWdnQTJMLUR3
VkNTekVadU5BUEFDT3pjNwpCeEVIS3hjYkZ5c0hFUWNiZHhzR0FEOG5HeWNJQUFFRUpnQUJOQUEt
QmdlYnNnMHVMLUR3TVFELS0tLS0tLS0tLS0tLS0tLS0tLS0tCkxWQnRQVGg5ZlE9PQo6OiBtYXAv
LmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0xNiAwNjozMTo1MiIsbW9kaWZpZWQ9
IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyMy0zMS0xNiAwNjozMTo1MiJdXQo6OiBt
YXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFMklEQTJPak15
T2pFNElpeHRiMlJwWm1sbFpEMGlNakF5TlMwdwpOUzB5TVNBeE9UbzFNam93TWlJc2NtVjJhWE5w
YjI0OU1qWTJNVjFkYkhvMEFGc0FBQUJXQkFBQThBaDdlMkp0Y0QxMWMyVnlaR0YwCllTZ2lhVEUy
SWl3eE5nTUFMeUl3QVFELS0tLXY4UWdpS1N4b2FXUmtaVzQ5Wm1Gc2MyVXNjR0Z1WDNnOU1BZ0F3
bms5TUN4MGFXeGwKWDJnOU1Ra0F3SGM5TlN4NmIyOXRQVFI5ZlE9PQo6OiBbZW9jXQo=
:: bios/apps/capture.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTA4LTA3IDAwOjI4OjM3Iixtb2RpZmllZD0iMjAyNC0wOC0xOCAwNzoxOTozNyIs
cmV2aXNpb249MTA1MV1dCi0tW1sKCWNhcHR1cmUucDY0IGJ5IHplcApdXQoKCnNlbGVjdF9tb2Rl
ID0gZmFsc2UKc2VsZWN0X2ludGVudGlvbiA9IGVudigpLmludGVudGlvbgoKbGFzdF9tYiA9IDAK
eDAgPSAwCnkwID0gMAotLXdpbl94ID0gMQotLXdpbl95ID0gMjQKCndpbmRhdCA9IHt9Cm9uX2V2
ZW50KCJtb2RpZmllZDovcmFtL3NoYXJlZC93aW5kb3dzLnBvZCIsIGZ1bmN0aW9uKG1zZykKCXdp
bmRhdCA9IGZldGNoIi9yYW0vc2hhcmVkL3dpbmRvd3MucG9kIgplbmQpCgpjZGF0ID0gZmV0Y2gi
L3JhbS9zeXN0ZW0vY2FwdHVyZS5wb2QiIG9yIHt9CmNkYXQueCA9IGNkYXQueCBvciAwCmNkYXQu
eSA9IGNkYXQueSBvciAwCmNkYXQud2lkdGggPSBjZGF0LndpZHRoIG9yIDQ4MApjZGF0LmhlaWdo
dCA9IGNkYXQuaGVpZ2h0IG9yIDI3MApjZGF0LnNjYWxlID0gY2RhdC5zY2FsZSBvciAyCgp0ZT17
fQoKbG9jYWwgZmllbGQgPSB7CgkieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInNjYWxlIgoJLS0i
ZnJhbWVzIiAtLSBubyBuZWVkIHRvIHNldCBmcmFtZXMgaW4gdGhpcyBjb250ZXh0ICh1c2UgY3Ry
bC05ISkKfQoKZnVuY3Rpb24gdXBkYXRlX2ZpZWxkcygpCgoJY2RhdC54ID0gbWlkKDAsIGNkYXQu
eFwxLCA0NzkpCgljZGF0LnkgPSBtaWQoMCwgY2RhdC55XDEsIDI2OSkKCWNkYXQud2lkdGggPSBt
aW4oY2RhdC53aWR0aFwxLCA0ODAgLSBjZGF0LnhcMSkKCWNkYXQuaGVpZ2h0ID0gbWluKGNkYXQu
aGVpZ2h0XDEsIDI3MCAtIGNkYXQueVwxKQoKCWZvciBpPTEsI2ZpZWxkIGRvCgkJCgkJbG9jYWwg
dmFsID0gIi0iCgkJaWYgKGNkYXQgYW5kIGNkYXRbZmllbGRbaV1dKSB0aGVuCgkJCXZhbCA9IGNk
YXRbZmllbGRbaV1dCgkJZW5kCgkJdGVbaV06c2V0X3RleHQodG9zdHIodmFsKSkKCWVuZAoJCmVu
ZAoKCmZ1bmN0aW9uIGNhcHR1cmVfc2NyZWVuc2hvdCgpCgkKCXNlbmRfbWVzc2FnZSgzLHtldmVu
dCA9ICJjYXB0dXJlX3NjcmVlbnNob3QiLAoJCXggPSBjZGF0LngsIHkgPSBjZGF0LnksCgkJd2lk
dGggPSBjZGF0LndpZHRoLAoJCWhlaWdodCA9IGNkYXQuaGVpZ2h0LAoJCXNjYWxlID0gY2RhdC5z
Y2FsZSwgCgkJZnJhbWVzID0gbmlsLCAtLSBubyBtZWFuaW5nCgkJZGVsYXkgPSAyICAgICAtLSBn
aXZlIHRpbWUgdG8gZ2V0IG91dCB0aGUgd2F5IChhbmQgbWF5YmUgdG8gcmVhY3QgdG8gc29tZXRo
aW5nIGhhcHBlbmluZykKCX0pCgplbmQJCgoKZnVuY3Rpb24gY2FwdHVyZV9naWYoKQoJCglzZW5k
X21lc3NhZ2UoMyx7ZXZlbnQgPSAiY2FwdHVyZV92aWRlbyIsCgkJeCA9IGNkYXQueCwgeSA9IGNk
YXQueSwKCQl3aWR0aCA9IGNkYXQud2lkdGgsCgkJaGVpZ2h0ID0gY2RhdC5oZWlnaHQsCgkJc2Nh
bGUgPSBjZGF0LnNjYWxlLCAKCQlmcmFtZXMgPSBuaWwsIC0tIHVzZSBkZWZhdWx0IGxpbWl0IAoJ
CWRlbGF5ID0gMiAgICAgLS0gZ2l2ZSB0aW1lIHRvIGdldCBvdXQgdGhlIHdheSAoYW5kIG1heWJl
IHRvIHJlYWN0IHRvIHNvbWV0aGluZyBoYXBwZW5pbmcpCgl9KQoKZW5kCQoKZnVuY3Rpb24gX2lu
aXQoKQoKCWlmIChzZWxlY3RfaW50ZW50aW9uKSB0aGVuCgkJZW50ZXJfc2VsZWN0X21vZGUoKQoJ
CXJldHVybgoJZW5kCgkKCS0tIHRyeSB0byBrZWVwIHdpbmRvdyBzbWFsbCAtLSB3YW50IHRvIHNl
ZSB3aGF0IGlzIGJlaW5nIHNlbGVjdGVkIQoJLS0gYWxzbyByZXNldCBzZWxlY3QgbW9kZSBhdHRy
aWJ1dGVzIGhlcmUKCXdpbmRvd3sKCQl4PXdpbl94LCB5PXdpbl95LAoJCXdpZHRoPTE3NiwKCQlo
ZWlnaHQ9MTAwLAoJCXJlc2l6ZWFibGU9ZmFsc2UsCgkJbW92ZWFibGUgPSB0cnVlLAoJCWhhc19m
cmFtZSA9IHRydWUKCX0KCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCglsb2NhbCB4ID0gZ2V0X2Rpc3Bs
YXkoKTp3aWR0aCgpIC0gMzcKCWxvY2FsIHkgPSAyNAoJbG9jYWwgeTAgPSB5CgkKCWZvciBpPTEs
I2ZpZWxkIGRvCgkJZ3VpOmF0dGFjaHsKCQkJeCA9IHggLSAzNCwgeSA9IHksIHdpZHRoPTMyLCBo
ZWlnaHQ9MTAsCgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmLG1zZykgcHJpbnQoZmllbGRbaV0sMCwx
LDUpIGVuZAoJCX0KCQkKCQl0ZVtpXSA9IGd1aTphdHRhY2hfdGV4dF9lZGl0b3IoewoJCQl4ID0g
eCwgeSA9IHksIHdpZHRoPTMyLCBoZWlnaHQ9OSwKCQkJYmdjb2wgPSA2LCBmZ2NvbCA9IDEsCgkJ
CWJsb2NrX3Njcm9sbGluZyA9IHRydWUsIG1heF9saW5lcyA9IDEsCgkJCW1hcmdpbl90b3AgPSAx
LAoJCQlrZXlfY2FsbGJhY2sgPSB7CgkJCQllbnRlciA9IGZ1bmN0aW9uIChzZWxmKSAKCQkJCQlj
ZGF0W2ZpZWxkW2ldXSA9IHRvbnVtYmVyKHNlbGY6Z2V0X3RleHQoKVsxXSkKCQkJCQl1cGRhdGVf
ZmllbGRzKCkKCQkJCWVuZAoJCQl9LAoJCX0pCgkJCgkJeSArPSAxMQoJZW5kCgl1cGRhdGVfZmll
bGRzKCkKCQoJLS0gcmVnaW9uIHNlbGVjdGlvbgoJCglndWk6YXR0YWNoewoJCXg9NCx5PXkwLHdp
ZHRoPTk2LGhlaWdodD01NCwKCQljdXJzb3IgPSAiY3Jvc3NoYWlyIiwKCQlkcmF3PWZ1bmN0aW9u
KHNlbGYsbXNnKQoJCQlyZWN0ZmlsbCgwLDAsOTUsNTMsNikKCQkJZm9yIGk9MSwjd2luZGF0IGRv
CgkJCQlsb2NhbCB3ID0gd2luZGF0W2ldCgkJCQlsb2NhbCB4MCx5MCx4MSx5MSA9IHcueFwxLHcu
eVwxLHcueFwxK3cud2lkdGhcMS01LHcueVwxK3cuaGVpZ2h0XDEtNQoJCQkJeDAseTAseDEseTEg
PSB4MFw1LHkwXDUseDFcNSx5MVw1CgkJCQlyZWN0ZmlsbCh4MCx5MCx4MSx5MSw2KQoJCQkJcmVj
dCh4MCx5MCx4MSx5MSwxMykKCQkJCXJlY3QoeDAseTArMyx4MSx5MCszLDEzKQoJCQllbmQKCQkJ
cmVjdGZpbGwoMCwwLDk1LDIsMTMpCgkJCXJlY3QoY2RhdC54LzUsIGNkYXQueS81LChjZGF0Lngg
KyBjZGF0LndpZHRoKS81LTEsKGNkYXQueStjZGF0LmhlaWdodCkvNS0xLDgpCgkJZW5kLAoJCWNs
aWNrPWZ1bmN0aW9uKHNlbGYsbXNnKQoJCQl4MCA9IG1zZy5teCo1CgkJCXkwID0gbXNnLm15KjUK
CQkJY2RhdC54ID0gbXNnLm14KjUKCQkJY2RhdC55ID0gbXNnLm15KjUKCQkJY2RhdC53aWR0aCA9
IDAKCQkJY2RhdC5oZWlnaHQgPSAwCgkJZW5kLAoJCWRyYWcgPSBmdW5jdGlvbihzZWxmLG1zZykK
CQkJbG9jYWwgeHggPSBtaWQoMCxtc2cubXgqNSw0NzUpCgkJCWxvY2FsIHl5ID0gbWlkKDAsbXNn
Lm15KjUsMjY1KQoJCQlpZiAoeHggPCB4MCkgdGhlbgoJCQkJY2RhdC54ID0geHgKCQkJCWNkYXQu
d2lkdGggPSAoeDAgLSBjZGF0LngpICsgNQoJCQllbHNlCgkJCQljZGF0LnggPSB4MAoJCQkJY2Rh
dC53aWR0aCA9ICh4eCAtIHgwKSArIDUKCQkJZW5kCgkJCQoJCQlpZiAoeXkgPCB5MCkgdGhlbgoJ
CQkJY2RhdC55ID0geXkKCQkJCWNkYXQuaGVpZ2h0ID0gKHkwIC0gY2RhdC55KSArIDUKCQkJZWxz
ZQoJCQkJY2RhdC55ID0geTAKCQkJCWNkYXQuaGVpZ2h0ID0gKHl5IC0geTApICsgNQoJCQllbmQK
CQkJY2RhdC53aWR0aCA9IG1pZCg1LCBjZGF0LndpZHRoLCA0ODAtY2RhdC54KQoJCQljZGF0Lmhl
aWdodCA9IG1pZCg1LCBjZGF0LmhlaWdodCwgMjcwLWNkYXQueSkKCQkJCgkJCXVwZGF0ZV9maWVs
ZHMoKQoJCWVuZAoJfQoJCgktLSBidXR0b25zCgkKCWxvY2FsIHh4PTQKCWxvY2FsIHNwYWNpbmcg
PSA2Cglsb2NhbCB5eT1nZXRfZGlzcGxheSgpOmhlaWdodCgpLTE3CgkKCXh4ICs9IGd1aTphdHRh
Y2hfYnV0dG9uKHt4PXh4LHk9eXksbGFiZWw9IiBTZWxlY3QgIiwgCgkJCWJnY29sPTB4MDgwNiwg
Zmdjb2w9MHgwMTBkLAoJCQl0YXA9ZnVuY3Rpb24oKQoJCQkJZW50ZXJfc2VsZWN0X21vZGUoKQoJ
CQllbmR9KS53aWR0aCArIHNwYWNpbmcKCXh4ICs9IGd1aTphdHRhY2hfYnV0dG9uKHt4PXh4LHk9
eXksbGFiZWw9IiBTY3JlZW5zaG90ICIsIAoJCQliZ2NvbD0weDA4MDYsIGZnY29sPTB4MDEwZCwK
CQkJdGFwPWZ1bmN0aW9uKCkKCQkJCWNhcHR1cmVfc2NyZWVuc2hvdCgpCgkJCQlleGl0KCkgLS0g
Z2V0IG91dCBvZiB0aGUgd2F5IQoJCQllbmR9KS53aWR0aCArIHNwYWNpbmcKCXh4ICs9IGd1aTph
dHRhY2hfYnV0dG9uKHt4PXh4LHk9eXksbGFiZWw9IiBHSUYgIiwgCgkJCWJnY29sPTB4MDgwNiwg
Zmdjb2w9MHgwMTBkLAoJCQl0YXA9ZnVuY3Rpb24oKQoJCQkJY2FwdHVyZV9naWYoKQoJCQkJZXhp
dCgpIC0tIGdldCBvdXQgb2YgdGhlIHdheSEKCQkJZW5kfSkud2lkdGggKyBzcGFjaW5nCQoJCQkK
CW9uX2V2ZW50KCJtb3ZlIiwgZnVuY3Rpb24obXNnKQoJCXdpbl94ID0gbXNnLngKCQl3aW5feSA9
IG1zZy55CgllbmQpCQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWlmIChzZWxlY3RfbW9kZSkgcmV0
dXJuIGRyYXdfc2VsZWN0X21vZGUoKQoJY2xzKDcpCglndWk6ZHJhd19hbGwoKQoJc3ByKDEsNCww
KQoJCgljdXJzb3IoMzgsNCwxMykKCT8iXDAxNFxeeTljdHJsLTYgYW55dGltZSBmb3IgYSBzY3Jl
ZW5zaG90IgoJPyJcMDE0XF55OWN0cmwtOCwgY3RybC05IHRvIGNhcHR1cmUgYSBnaWYiCgkKZW5k
CgpmdW5jdGlvbiBfdXBkYXRlKCkKCWlmIChzZWxlY3RfbW9kZSkgcmV0dXJuIHVwZGF0ZV9zZWxl
Y3RfbW9kZSgpCglndWk6dXBkYXRlX2FsbCgpCmVuZAoKCmZ1bmN0aW9uIGVudGVyX3NlbGVjdF9t
b2RlKCkKCglzZWxlY3RfbW9kZSA9IHRydWUKCQoJcG9rZSgweDU0N2QsIDB4M2YpIC0tIAotLQlw
b2tlKDB4NTQ3ZSwgMHgzZikgLS0gaW50ZXJhY3Rpb24gbWFzayAoY2FuIGNsaWNrIG9uIGJpcmRz
ISkKCQoJCgl3aW5kb3d7CgkJeiA9IDEwLCAtLSBhbHdheXMgb24gdG9wLgoJCQoJCWN1cnNvcj0i
Y3Jvc3NoYWlyIiwKCQkKCQktLSBjb3ZlciwgYnV0IG5vdCAuZnVsbHNjcmVlbiAob3BlbiBpbiBh
IGRlc2t0b3Agd29ya3NwYWNlKQoJCXdpZHRoID0gNDgwLAoJCWhlaWdodCA9IDI3MCwKCQl4PTAs
IHk9MCwKCQltb3ZlYWJsZSA9IGZhbHNlLAoJCWhhc19mcmFtZSA9IGZhbHNlLAoJCXJlc2l6ZWFi
bGUgPSBmYWxzZSwKCQlpbnRlcmFjdGl2ZSA9IHRydWUsIC0tIHJlYWQgY2xpY2tzCgkJcHVzaF9w
YWxldHRlID0gZmFsc2UsIC0tIGRvbid0IGNvcHkgZGlzcGxheSBwYWxldHRlIHRvIHdtCgkJcHVz
aF92aWRlb19tb2RlID0gZmFsc2UsIC0tIGRvbid0IGNvcHkgdmlkZW8gbW9kZSB0byB3bQoJfQpl
bmQKCmZyPTAKZnVuY3Rpb24gZHJhd19zZWxlY3RfbW9kZSgpCgkKCWNscygpCgkKCglsb2NhbCBt
eCxteSxtYiA9IG1vdXNlKCkKCQoJbG9jYWwgcGF0ID0gMGIxMTAwMDExMDAwMTExMDAxCglmcis9
LjI1Cglwb3MgPSAoZnJcMSkgJSA0Cglwb3MgKj0gNAoJcGF0ID0gKHBhdCA8PCBwb3MpIHwgKHBh
dCA_PiAoMTYtcG9zKSkKCWZpbGxwKHBhdCkKCQoJaWYgKG1iID4gMCkgdGhlbgoJCWxvY2FsIHgw
LHgxID0geDAsbXgKCQlsb2NhbCB5MCx5MSA9IHkwLG15CgkJaWYgKHgxIDwgeDApIHgwLHgxPXgx
LHgwCgkJaWYgKHkxIDwgeTApIHkwLHkxPXkxLHkwCgkJCgkJLS1wb2tlKDB4NTUwYiwweDNmKQoJ
CXJlY3QoeDAtMSx5MC0xLHgxKzEseTErMSwweDAxMDcpCi0tCQlyZWN0KHgwLTIseTAtMixteCsy
LG15KzIsMCkKCWVuZAoJZmlsbHAoKQplbmQKCmZ1bmN0aW9uIHVwZGF0ZV9zZWxlY3RfbW9kZSgp
Cglsb2NhbCBteCxteSxtYiA9IG1vdXNlKCkKCWlmIChsYXN0X21iID09IDAgYW5kIG1iID4gMCkg
dGhlbgoJCXgwLCB5MCA9IG14LCBteQoJCQoJZW5kCgkKCWlmIChsYXN0X21iID4gMCBhbmQgbWIg
PT0gMCkgdGhlbgoJCgkJaWYgKG14ID4geDApIHRoZW4KCQkJY2RhdC54ID0geDAKCQkJY2RhdC53
aWR0aCA9IG14LXgwKzEKCQllbHNlCgkJCWNkYXQueCA9IG14CgkJCWNkYXQud2lkdGggPSB4MC1t
eCsxCgkJZW5kCgkJCgkJaWYgKG15ID4geTApIHRoZW4JCQoJCQljZGF0LnkgPSB5MAoJCQljZGF0
LmhlaWdodCA9IG15LXkwKzEKCQllbHNlCgkJCWNkYXQueSA9IG15CgkJCWNkYXQuaGVpZ2h0ID0g
eTAtbXkrMQoJCWVuZAoJCQoJCgkJaWYgKHNlbGVjdF9pbnRlbnRpb24gPT0gImNhcHR1cmVfc2Ny
ZWVuc2hvdCIpIHRoZW4KCQkJY2FwdHVyZV9zY3JlZW5zaG90KCkKCQkJZXhpdCgpCgkJZWxzZWlm
IChzZWxlY3RfaW50ZW50aW9uID09ICJyZWNvcmRfdmlkZW8iKSB0aGVuCgkJCWNhcHR1cmVfZ2lm
KCkKCQkJZXhpdCgpCgkJZWxzZQoJCQktLXN0b3JlKCIvcmFtL3N5c3RlbS9jYXB0dXJlLnBvZCIs
IGNkYXQpCgkJCXNlbGVjdF9tb2RlID0gZmFsc2UKCQkJX2luaXQoKQoJCWVuZAoJZW5kCglsYXN0
X21iID0gbWIKZW5kCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9InplcCIsY3JlYXRlZD0i
MjAyNC0wOC0wNyAwMDoyOToxNyIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MTkxOTE5MTkxOTE5MTkxOTE5MTkwNzAxMDAwMTA3MTkxOTE5MTkxOTE5MTkxOTE5MTkxOTE5
MDcwMTAxMDcxOTE5MDYwNjA2MDYwNjA2MDYwNjE5MTkwNzAxMDEwNzE5MTkwNjA4MDYwNjAxMDEw
NjA2MTkxOTA3MDEwMTA3MTkxOTA2MDYwNjAxMDEwNzAxMDYxOTE5MDcwMTAxMDcxOTE5MDYwNjA2
MDEwMTAxMDEwNjE5MTkwNzAxMDEwNzE5MTkwNjA2MDYwNjAxMDEwNjA2MTkxOTA3MDEwMTA3MTkx
OTA2MDYwNjA2MDYwNjA2MDYxOTE5MDcwMTAxMDcxOTE5MTkxOTE5MTkxOTE5MTkxOTE5MTkwNzAx
MDEwOTA3MTkxOTE5MTkxOTE5MTkxOTE5MTkwNzA5MDEwMTA5MDkwNzA3MDcwNzA3MDcwNzA3MDcw
NzA5MDkwMTAwMDEwOTA5MDkwOTA5MDkwOTA5MDkwOTA5MDkwMTAwMDAwMDAxMDkwOTA5MDkwOTA5
MDkwOTA5MDkwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixub3Rlcz0ic2hpZnQtY3RybC02IGFueXRpbWUgdG8gY2Fw
dHVyZVxuYSByZWdpb24gKHdvcmtzIGluIGZ1bGxzY3JlZW4gdG9vKSIscnVudGltZT04LHRpdGxl
PSJDYXB0dXJlIix2ZXJzaW9uPSIwLjEuMWUiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5s
dWEjMjk3Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFj
ZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2Nh
dGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAot
LVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgtMDcgMDA6Mjg6MzYiLG1vZGlmaWVkPSIyMDI1LTEyLTE0
IDAwOjQ3OjM4Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJ
MExUQTRMVEEzSURBd09qSTRPak0zSWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck9DMHhPQ0F3Tnpv
eE9Ub3pOeUlzY21WMmFYTnBiMjQ5T0RJeFhWMXNlalFBTndFQUFNUXhBQUR6SVh0Yk1GMDllMkp0
Y0Qxd2VIVUEKUXlBUUVBVHdWZ2NRQjhBWDBCZkFCeEFIOEZZc1pteGhaM005TUN4d1lXNWZlQWdB
eDNrOU1DeDZiMjl0UFRoOUxENEEtd2tZR0FUMwpJalpITnBjV0dCWW5GaGdXaHdZNEJpY0dPQVlJ
QUE3MUZfYUhscEUzaGhHR0FTYzJFUllSUmpFV0FSY21BUllCQmhFR0dBWXhCd0VHCkFSZDJFVFpS
QndDd0oyWVJCaEVHVVFZQk4zRXNBUDhESjFFV0VZWUJOMUVta1VkaEZpRzNzZmNxdFFBTE96VjlM
UE1BSC1EbUFBd1AKTVFDXy13Y0lDQVFBRjBDSFVCY0FCd0FYQUJjZ0Z3QVhVSWR3Y3dBZUR6RUEt
MFB4QmZjMUVNZHdkd0JYQUhjQUJ3QUhFQWNBZHdBbgpCZ0J2VndCM2NQZEVmd0FlRHpFQS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS05
VkJ0UFRoOWZRPT0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgtMDcg
MDA6Mjg6MzYiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IG1hcC8wLm1hcApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQTRMVEEzSURBd09qSTRPak0zSWl4dGIy
UnBabWxsWkQwaU1qQXlOQzB3Ck9DMHhPQ0F3TnpveE9Ub3pOeUlzY21WMmFYTnBiMjQ5TnpZelhW
MXNlalFBYUFBQUFGZ1FBQUR3Q0h0N1ltMXdQWFZ6WlhKa1lYUmgKS0NKcE1UWWlMRE15QXdBdklq
QUJBUC0tLS0tLS0tLS0tLS0tLS0tLS0tdnhDQ0lwTEdocFpHUmxiajFtWVd4elpTeHdZVzVmZUQw
dwpDQURTZVQwd0xIUnBiR1ZmYUQweE5nb0FFSGNLQUlCNmIyOXRQVEY5ZlE9PQo6OiBzZngvLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wOC0wNyAwMDoyODozNiIsbW9kaWZpZWQ9IjIw
MjUtMTItMTQgMDA6NDc6MzgiXV0KOjogc2Z4LzAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdW
a1BTSXlNREkwTFRBNExUQTNJREF3T2pJNE9qTTNJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKT0Mw
eE9DQXdOem94T1Rvek55SXNjbVYyYVhOcGIyNDlOell5WFYxc2VqUUFvQUFBQUFzS0FBRC1NSEI0
ZFFBREtBQUFCQUFFRDBBUQpBZzRBQWFBQklBS2dEZ0FQRUFBTjhNb0JBZ05BRHdfUUJBVUdCMEFN
a0FnSkNndEFESkFQREE4TkR3NE1RQXp3LXdFQTYtOG5xZ0VRCkJnOGdFQUVnQVNBQjhBQUNFQUlP
RUFFZ0R5RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JFQVlPTUFELS0tLS0K
LTcwZi13RUFyTS1JRDBBQUR4QkEtLV93OFA4QkFQLXFVUC0tLS04cAo6OiBbZW9jXQo=
:: bios/apps/code.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTAyLTI0IDE5OjAyOjAwIixtb2RpZmllZD0iMjAyNS0wNy0xMCAwMzoyNTo0MSIs
cmV2aXNpb249NDBdXQpsb2NhbCBjZQoKZnVuY3Rpb24gX2RyYXcoKQoKCWc6ZHJhd19hbGwoKSAt
LSBjb3ZlcnMgd2hvbGUgc2NyZWVuOyBkb24ndCBuZWVkIHRvIGNscygpCgplbmQKCmZ1bmN0aW9u
IF91cGRhdGUoKQoKCS0tIGNvZGUgZWRpdG9yIGFsd2F5cyBoYXMga2V5Ym9hcmQgZm9jdXMgd2hl
biBzZWFyY2ggaXMgbm90IG9wZW4KCWlmIChub3QgY2U6c2VhcmNoX2JveF9pc19vcGVuKCkpIGNl
OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoKCWc6dXBkYXRlX2FsbCgpCgplbmQKCmZ1bmN0aW9u
IGFwcGx5X3NldHRpbmdzKCkKCWlmIChub3Qgc2RhdCkgcmV0dXJuCgkKCXBva2UoMHg0MDAwLCBn
ZXQoc2RhdC5tb25vc3BhY2UgYW5kCgkJZmV0Y2goIi9zeXN0ZW0vZm9udHMvbGlsX21vbm8uZm9u
dCIpIG9yCQkKCQlmZXRjaCgiL3N5c3RlbS9mb250cy9saWwuZm9udCIpCgkpKQoKCS0tIHBva2Uo
MHg0MDAwLGdldChmZXRjaCIvc3lzdGVtL2ZvbnRzL3B1ZzMuZm9udCIpKSAtLSB0ZXN0ICAvLyBy
ZXN1bHQ6IHNvIHVucmVhZGFibGUKCgkKCgktLSB1cGRhdGUgbWVudSBpdGVtcwoJbWVudWl0ZW17
aWQ9Im1vbm9zcGFjZSIsIGxhYmVsID0gc2RhdC5tb25vc3BhY2UgYW5kCgkJIlxeOjAwN2Y0ZjRm
NGY3ZjAwMDAgTW9ub3NwYWNlOiBPbiIgb3IKCQkiXF46MDA3Zjc5Nzk3OTdmMDAwMCBNb25vc3Bh
Y2U6IE9mZiIKCX0KCgltZW51aXRlbXtpZD0ic2hvd190YWJzIiwgbGFiZWwgPSBzZGF0LnNob3df
dGFicyBhbmQKCQkiXF46MDA3ZjRmNGY0ZjdmMDAwMCBTaG93IFRhYnM6IE9uIiBvcgoJCSJcXjow
MDdmNzk3OTc5N2YwMDAwIFNob3cgVGFiczogT2ZmIgoJfQoKCW1lbnVpdGVte2lkPSJzaG93X2xp
bmVfbnVtYmVycyIsIGxhYmVsID0gc2RhdC5zaG93X2xpbmVfbnVtYmVycyBhbmQKCQkiXF46MDA3
ZjRmNGY0ZjdmMDAwMCBMaW5lIE51bWJlcnM6IE9uIiBvcgoJCSJcXjowMDdmNzk3OTc5N2YwMDAw
IExpbmUgTnVtYmVyczogT2ZmIgoJfQoJCgktLSBsaXZlIGVkaXRvciB1cGRhdGUgKGp1c3Qgc3R1
ZmYgZXZlcnl0aGluZyBpbiB0aGVyZSkKCWlmIChjZSkgdGhlbgoJCWZvciBrLHYgaW4gcGFpcnMo
c2RhdCkgZG8KCQkJY2Vba10gPSB2CgkJZW5kCgllbmQKCQplbmQKCmZ1bmN0aW9uIHN0b3JlX3Nl
dHRpbmdzKCkKCXN0b3JlKCIvYXBwZGF0YS9zeXN0ZW0vY29kZS5wb2QiLHNkYXQpCmVuZAoKCmZ1
bmN0aW9uIF9pbml0KCkKCglzZGF0ID0gZmV0Y2goIi9hcHBkYXRhL3N5c3RlbS9jb2RlLnBvZCIp
IAoJCglpZiBub3Qgc2RhdCB0aGVuCgkJc2RhdCA9IHsKCQkJbW9ub3NwYWNlID0gZmFsc2UsCgkJ
CXNob3dfdGFicyA9IGZhbHNlLAoJCQliZ2NvbCA9IDEsCgkJCWN1cmNvbCA9IDE0LAoJCQlzZWxj
b2wgPSAxMCwKCQkJbG5jb2wgPSAxNiwKCQkJc3ludGF4X2hpZ2hsaWdodGluZyA9IHRydWUsCgkJ
CXNob3dfbGluZV9udW1iZXJzID0gdHJ1ZQoJCX0KCQlzdG9yZSgiL2FwcGRhdGEvc3lzdGVtL2Nv
ZGUucG9kIiwgc2RhdCkKCWVuZAoKCXdpbmRvd3sKCQl0YWJiZWQgPSB0cnVlLAoJCWljb24gICA9
IHVzZXJkYXRhKCJbZ2Z4XTA4MDgwNzcwMDc3MDc3MDAwMDc3NzcwMDAwNzc3NzAwMDA3Nzc3MDAw
MDc3NzcwMDAwNzcwNzcwMDc3MDAwMDAwMDAwWy9nZnhdIiksCgl9CgoJZyA9IGNyZWF0ZV9ndWko
KQoJCgljZSA9IGc6YXR0YWNoX3RleHRfZWRpdG9yKHsKCQl4PTAseT0wLAoJCXdpZHRoX3JlbD0x
LjAsCgkJaGVpZ2h0X3JlbD0xLjAsCgkJc3ludGF4X2hpZ2hsaWdodGluZz1zZGF0LnN5bnRheF9o
aWdobGlnaHRpbmcsCgkJc2hvd190YWJzPXNkYXQuc2hvd190YWJzLAoJCXNob3dfbGluZV9udW1i
ZXJzPXNkYXQuc2hvd19saW5lX251bWJlcnMsCgkJbWFya3VwPWZhbHNlLCAtLSB0byBkbzogcmVt
b3ZlIG1hcmt1cCBmcm9tIGVkaXRvciB3aWRnZXQKCQllbWJlZF9wb2RzPXRydWUsCgkJaGFzX3Nl
YXJjaD10cnVlLAoJCWJnY29sID0gc2RhdC5iZ2NvbCwKCQljdXJjb2wgPSBzZGF0LmN1cmNvbCwK
CQlzZWxjb2wgPSBzZGF0LnNlbGNvbCwKCQlsbmNvbCA9IHNkYXQubG5jb2wsCgkJc3F1YXNoX3Rv
X2NsaXAgPSB0cnVlCgl9KQoKCWNlOmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoJd3JhbmdsZV93b3Jr
aW5nX2ZpbGUoCgoJCS0tIHNhdmUgdG8gb2JqCgkJZnVuY3Rpb24gKCkKCQkJY2U6Z2V0X3VuZG9f
c3RhY2soKTpjaGVja3BvaW50KCkgLS0gdW5kbyBuZXZlciBqdW1wIG92ZXIgc3RhdGUgb2YgbGFz
dCBzYXZlCgkJCXJldHVybiB0YWJsZS5jb25jYXQoY2U6Z2V0X3RleHQoKSwiXG4iKQoJCWVuZCwK
CgkJLS0gbG9hZCBmcm9tIG9iaiAoYXNzdW1lZCB0byBiZSBhIHN0cmluZykKCQlmdW5jdGlvbiAo
c3RyLCBtZXRhKQoJCQlsb2NhbCB0ZXh0ID0gc3BsaXQoc3RyLCAiXG4iLCBmYWxzZSkKCQkJLS1p
ZiAodGV4dCkgcHJpbnRoKCJjb2RlOiBsb2FkZWQgIi4uI3RleHQuLiIgbGluZXMiKQoJCQlpZiAo
bm90IHRleHQgb3IgI3RleHQgPT0gMCkgdGhlbiB0ZXh0ID0geyIifSBlbmQKCQkJY2U6c2V0X3Rl
eHQodGV4dCkKCQkJY2Uuc3ludGF4X2hpZ2hsaWdodGluZyA9IHB3ZigpOmV4dCgpID09ICJsdWEi
CgkJZW5kLAoKCQktLSBkZWZhdWx0IGZpbGVuYW1lIGFuZCBleHRlbnNpb24KCQkidW50aXRsZWQu
bHVhIiwgCgoJCS0tIGxvY2F0aW9uIHN0cmluZwoJCWZ1bmN0aW9uKCkKCQkJbG9jYWwgeCx5ID0g
Y2U6Z2V0X2N1cnNvcigpCgkJCXJldHVybiB5CgkJZW5kLAoKCQktLSBwcm9jZXNzIGxvY2F0aW9u
IHN0cmluZy4gaWYgaXQgaXMgYSBudW1iZXIsIGp1bXAgdG8gdGhhdCBudW1iZXIKCQktLSB0byBk
bzogImhvZ2UubHVhI2Z1bmN0aW9uOmZvbyI-IG9yIGp1c3QgImhvZ2UubHVhI2ZvbyIgdG8gc2Vh
cmNoIGZvciB0aGF0IHN0cmluZz8KCgkJZnVuY3Rpb24obG9jLCBoaWdobGlnaHQpCgkJCWlmIHRv
bnVtKGxvYykgdGhlbgoJCQkJY2U6anVtcF90b19saW5lKHRvbnVtKGxvYyksIGhpZ2hsaWdodCkK
CQkJCS0tY2U6Y2VudGVyX2N1cnNvcigwLjMpIC0tIDAuMyBwdXQgY3Vyc29yIG5lYXJlciB0byB0
b3AuICB0byBkbzogd2h5IGRvZXMgdGhpcyBub3Qgd29yayBvbiBmaXJzdCBsb2FkIHZpYSBpbmZv
YmFyPwoJCQllbmQKCQllbmQsCgoJCS0tW1sKCQkJc3RhdGVfaGludDogcmV0dXJuIGEgdmFsdWUg
dGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlY3QgcG9zc2libGUgY2hhbmdlcyBpbiB0aGUgZG9jdW1l
bnQuIEl0IHNob3VsZCBiZQoJCQl2ZXJ5IGNoZWFwOyB3aGVuIHRoZSByZXR1cm4gdmFsdWUgY2hh
bmdlcywgYSBtb3JlIGV4cGVuc2l2ZSBzdGF0ZSBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBieSB3
cmFuZ2VyCgkJCXRvIGxvb2sgZm9yIGNoYW5nZXMgKGFuZCBjYXVzZSB0aGUgIioiIHRvIGFwcGVh
ciBpbiBmcm9udCBvZiB0aGUgZmlsZW5hbWUgaW4gdGhlIHdpbmRvdyB0aXRsZSkuCgoJCQlUZXh0
IGZpZWxkcyBjcmVhdGVkIHdpdGggOmF0dGFjaF90ZXh0X2VkaXRvciBwcm92aWRlIHRoZWlyIG93
biBzdGF0ZSBoaW50IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQKCQkJaGVyZSwgd2hpY2ggaXMg
YSBjb21iaW5hdGlvbiBvZiB1bmRvIHN0YWNrIHBvc2l0aW9uIGFuZCBjdXJyZW50IGxpbmUgbGVu
Z3RoLgoJCV1dCgkJZnVuY3Rpb24gKCkKCQkJcmV0dXJuIGNlIGFuZCBjZTpnZXRfc3RhdGVfaGlu
dCgpCgkJZW5kCgoJKQoJCgktLSB0byBkbzogbWVudSBpdGVtcwoJLS1bWwoJIlxeOjMwNDg4NDg0
NGMzNjAzMDAgRmluZCBUZXh0ICAgICAoQ1RSTC1GKSIsCgkiXF46MWYwMDNmMDAzZTAwN2MwMCBK
dW1wIHRvIExpbmUgIChDVFJMLUwpIiwKCV1dCgkKCS0tbWVudWl0ZW17ZGl2aWRlcj10cnVlfSAt
LSB0byBkbwoKCW1lbnVpdGVtewoJCXN0YXlfb3BlbiA9IHRydWUsCgkJaWQ9Im1vbm9zcGFjZSIs
CgkJbGFiZWw9Ik1vbm9zcGFjZSIsCgkJYWN0aW9uPWZ1bmN0aW9uKCkKCQkJc2RhdC5tb25vc3Bh
Y2UgPSBub3Qgc2RhdC5tb25vc3BhY2UKCQkJc3RvcmVfc2V0dGluZ3MoKSAtLSB0cmlnZ2VycyBh
cHBseV9zZXR0aW5ncygpIHZpYSBmaWxlIGNoYW5nZQoJCWVuZAoJfQoJCgltZW51aXRlbXsKCQlz
dGF5X29wZW4gPSB0cnVlLAoJCWlkPSJzaG93X3RhYnMiLAoJCWxhYmVsPSJTaG93IFRhYnMiLAoJ
CWFjdGlvbj1mdW5jdGlvbigpCgkJCXNkYXQuc2hvd190YWJzID0gbm90IHNkYXQuc2hvd190YWJz
CgkJCXN0b3JlX3NldHRpbmdzKCkgLS0gdHJpZ2dlcnMgYXBwbHlfc2V0dGluZ3MoKSB2aWEgZmls
ZSBjaGFuZ2UKCQllbmQKCX0KCgltZW51aXRlbXsKCQlzdGF5X29wZW4gPSB0cnVlLAoJCWlkPSJz
aG93X2xpbmVfbnVtYmVycyIsCgkJbGFiZWw9IkxpbmUgTnVtYmVycyIsCgkJYWN0aW9uPWZ1bmN0
aW9uKCkKCQkJc2RhdC5zaG93X2xpbmVfbnVtYmVycyA9IG5vdCBzZGF0LnNob3dfbGluZV9udW1i
ZXJzCgkJCXN0b3JlX3NldHRpbmdzKCkgLS0gdHJpZ2dlcnMgYXBwbHlfc2V0dGluZ3MoKSB2aWEg
ZmlsZSBjaGFuZ2UKCQllbmQKCX0KCgoJYXBwbHlfc2V0dGluZ3MoKQoKCS0tIHRlc3QKCWNlOmNl
bnRlcl9jdXJzb3IoMC41KQoKZW5kCgpvbl9ldmVudCgibW9kaWZpZWQ6L2FwcGRhdGEvc3lzdGVt
L2NvZGUucG9kIiwKCWZ1bmN0aW9uKG1zZykKCQlzZGF0ID0gZmV0Y2gobXNnLmZpbGVuYW1lKQoJ
CWFwcGx5X3NldHRpbmdzKCkKCWVuZAopCgoKCjo6IHVudGl0bGVkLnR4dAotLVtbcG9kX2Zvcm1h
dD0icmF3IixjcmVhdGVkPSIyMDI1LTA0LTE1IDAyOjUzOjEwIixtb2RpZmllZD0iMjAyNS0wNC0x
NSAwMzowOToyOSIscmV2aXNpb249MjBdXQoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6
IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0ibGV4YWxvZmZsZSIsY3JlYXRlZD0iMjAyNS0wNC0x
NSAwMjo1MjozNSIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEw
MTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBk
MGQwZDBkMGQwZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcw
ZDBkMGQwNzA3MGQwZDA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwNzA3MGQwZDBkMGQwNzA3MGQwZDA3
MDEwMTA3MGQwZDA3MDcwZDBkMGQwZDA3MDcwZDBkMDcwMTAxMDcwZDBkMDcwNzBkMGQwZDBkMDcw
NzBkMGQwNzAxMDEwNzBkMGQwNzA3MGQwZDBkMGQwNzA3MGQwZDA3MDEwMTA3MGQwZDBkMDcwNzBk
MGQwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQw
ZDBkMGQwZDBkMGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAw
MDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYw
MTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUs
bW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLG5vdGVzPSIiLHJ1bnRpbWU9MTksc3RvcmVk
PSIyMDIzLTU0LTEyIDEwOjU0OjA2Iix0aXRsZT0iUGljb3Ryb24gQ29kZSBFZGl0b3IiLHZlcnNp
b249IjAuMiIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxMCIsd29ya3NwYWNlX2lu
ZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9u
PSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfX1dXQo6OiBnZngvLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyMy0wMS0yNCAxOTowMTo1NiIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6
NDc6MzgiLHN0b3JlZD0iMjAyMy0wMS0yNCAxOTowMTo1NiJdXQo6OiBnZngvMC5nZngKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRJMUlEQTNPalEzT2pVd0lpeHRiMlJwWm1s
bFpEMGlNakF5TlMwdwpOQzB4TlNBd016b3hNRG94TmlJc2NtVjJhWE5wYjI0OU1qTmRYV3g2TkFC
dEFBQUFCVEVBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lXZHpQVEFzY0dG
dVgzZ0lBTTk1UFRBc2VtOXZiVDA0ZlN3eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUWJUMDRmWDA9Cjo6IG1hcC8uaW5m
by5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTAxLTI0IDE5OjAxOjU2Iixtb2RpZmllZD0iMjAy
NS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTAxLTI0IDE5OjAxOjU2Il1dCjo6IG1hcC8w
Lm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEkxSURBM09qUTNPalV3
SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB3Ck5DMHhOU0F3TXpveE1Eb3hOaUlzY21WMmFYTnBiMjQ5
TWpKZFhXeDZOQUJvQUFBQVdCQUFBUEFJZTN0aWJYQTlkWE5sY21SaGRHRW8KSW1reE5pSXNNeklE
QUM4aU1BRUEtLS0tLS0tLS0tLS0tLS0tLS0tLV8tRUlJaWtzYUdsa1pHVnVQV1poYkhObExIQmhi
bDk0UFRBSQpBTko1UFRBc2RHbHNaVjlvUFRFMkNnQVFkd29BZ0hwdmIyMDlNWDE5Cjo6IHNmeC8u
aW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTAxLTI0IDE5OjAxOjU2Iixtb2RpZmllZD0i
MjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTAxLTI0IDE5OjAxOjU2Il1dCjo6IFtl
b2NdCg==
:: bios/apps/filenav.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IGdmeC9kZWxtZS8KOjogZ2Z4L2RlbG1lMi8KOjogZ2Z4L2hhLwo6OiBnZngvenhjLwo6
OiBtYXAvCjo6IHNmeC8KOjogZGVza3RvcC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRl
ZD0iMjAyMy0xMC0wNCAxNToxMzo0MSIsbW9kaWZpZWQ9IjIwMjUtMDQtMTkgMTk6MjA6NDIiLHJl
dmlzaW9uPTMyNDEsc3RvcmVkPSIyMDIzLTIxLTI5IDA5OjIxOjE5Il1dCi0tIG1vZGU6IGRlc2t0
b3AKbG9jYWwgZGVza3RvcF9pdGVtcyA9IG5pbApsb2NhbCBkZXNrdG9wX2NvbnRlbnQgPSBuaWwK
bG9jYWwgc2VsCgoKZnVuY3Rpb24gdmFsaWRhdGVfZGkoZmlsZW5hbWUsIHZhbGlkYXRlX3h5KQoJ
aWYgKG5vdCBkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lXSkgdGhlbgoJCWRlc2t0b3BfaXRlbXNbZmls
ZW5hbWVdID0ge30KCWVuZAoKCS0tIGdpdmUgaXRlbSB4eSBpZiBuZWVkZWQKCWlmIHZhbGlkYXRl
X3h5IGFuZCAobm90IGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVdLnggb3Igbm90IGRlc2t0b3BfaXRl
bXNbZmlsZW5hbWVdLnkpIHRoZW4KCQlzZXRfZGVza3RvcF9pdGVtX3Bvc2l0aW9uKGZpbGVuYW1l
KQoJZW5kCgoJcmV0dXJuIGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVdCmVuZAoKLS0gdXNlZCB3aGVu
IHJlbmFtaW5nIGEgZmlsZQpmdW5jdGlvbiBjb3B5X2Rlc2t0b3BfaXRlbV9hdHRyaWJ1dGVzKHNy
YywgZGVzdCkKCWlmIChub3QgZGVza3RvcF9pdGVtc1tzcmNdKSByZXR1cm4KCXZhbGlkYXRlX2Rp
KGRlc3QpCglmb3Igayx2IGluIHBhaXJzKGRlc2t0b3BfaXRlbXNbc3JjXSkgZG8KCQlkZXNrdG9w
X2l0ZW1zW2Rlc3RdW2tdID0gdgoJZW5kCglzdG9yZV9kZXNrdG9wX2l0ZW1zKCkKZW5kCgoKZnVu
Y3Rpb24gc2V0X2Rlc2t0b3BfaXRlbV9wb3NpdGlvbihmaWxlbmFtZSwgeCwgeSkKCWlmIChub3Qg
ZGVza3RvcF9pdGVtc1tmaWxlbmFtZV0pIGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVdID0ge30KCglp
ZiAobm90IHggb3Igbm90IHkpIHRoZW4KCgkJLS0gZmluZCBhbiB1bnVzZWQgc3BvdAoKCQlsb2Nh
bCB1c2VkID0gdXNlcmRhdGEoInU4Iiw0OCs4LDI3KzgpCgkJCgkJZm9yIGssaXRlbSBpbiBwYWly
cyhkZXNrdG9wX2l0ZW1zKSBkbwoJCQlpZiAoZnN0YXQoaykpIHRoZW4gLS0gY2hlY2sgdGhhdCBm
aWxlIGFjdHVhbGx5IGV4aXN0cwoJCQkJaWYgKGl0ZW0ueCBhbmQgaXRlbS55KSB0aGVuCgkJCQkJ
bG9jYWwgeHggPSBpdGVtLnggXCAxMAoJCQkJCWxvY2FsIHl5ID0gaXRlbS55IFwgMTAKCQkJCQlm
b3IgeHgxPXh4KzMseHgrNSBkbwoJCQkJCQlmb3IgeXkxPXl5KzMseXkrNSBkbwoJCQkJCQkJdXNl
ZDpzZXQoeHgxLHl5MSwxKQoJCQkJCQllbmQKCQkJCQllbmQKCQkJCWVuZAoJCQllbHNlCgkJCQkt
LSBlLmcuIGZpbGUgdGhhdCB3YXMgZGVsZXRlZDsgYnV0IGlmIHJlY3JlYXRlIG9yIGNvcHkgdGhh
dCBmaWxlIGJhY2sKCQkJCS0tIGl0IHdpbGwgYXBwZWFyIGluIHRoZSBzYW1lIHBsYWNlIGFzIGVh
cmxpZXIKCQkJCS0tIHByaW50aCgiQEAgZG9lc24ndCBleGlzdDogIi4ucG9ke2t9KQoJCQllbmQK
CQkJLS0gc2V0X2NsaXBib2FyZChwb2QodXNlZCwweDcpKSAtLSBkZWJ1ZwoJCWVuZAoJCQoJCWxv
Y2FsIGluY194LGluY195ID0gMTAsIDEwCgoJCWlmIChzZXR0aW5ncy5zbmFwX3RvX2dyaWQpIHRo
ZW4KCQkJaW5jX3ggPSA2NgoJCQlpbmNfeSA9IDUwCgkJZW5kCgoJCWxvY2FsIHN0YWdnZXIgPSAw
CgkJZm9yIHh4ID0gLTIxLCA0MDAsIGluY194IGRvCgkJCWZvciB5eSA9IDE2ICsgc3RhZ2dlciwg
MjMwLCBpbmNfeSBkbyAJCQkKCQkJCWlmIHVzZWQ6Z2V0KDQreHhcMTAsNCt5eVwxMCkgPT0gMCAt
LSBxdWljayBzYW1wbGUgaW4gbWlkZGxlCgkJCQl0aGVuCgoJCQkJCWxvY2FsIGVtcHR5ID0gdHJ1
ZQoJCQkJCWZvciBkeD0tMiwyLDIgZG8KCQkJCQkJZm9yIGR5PS0yLDEsMyBkbwoJCQkJCQkJaWYg
KHVzZWQ6Z2V0KDQreHhcMTArZHgsNCt5eVwxMCtkeSkgPiAwKSBlbXB0eSA9IGZhbHNlCgkJCQkJ
CWVuZAoJCQkJCWVuZAoKCQkJCQlpZiBlbXB0eSB0aGVuCgkJCQkJCXggPSB4eCB5ID0geXkKCQkJ
CQkJZ290byBmb3VuZF9zbG90CgkJCQkJZW5kCgkJCQllbmQKCQkJZW5kCgkJCWlmIChub3Qgc2V0
dGluZ3Muc25hcF90b19ncmlkKSBzdGFnZ2VyID0gKHN0YWdnZXIgKyAxMikgJSAzNgoJCWVuZAoK
CQktLSBjYW4ndCBmaW5kOyBjcmVhdGUgYSBqdW1ibGVkIG1lc3Mgb24gdGhlIGxlZnQgaGFuZCBz
aWRlCgkJeCA9IDQwICsgcm5kKDIwMCkKCQlpZiAobm90IHkpIHkgPSA0MCArIHJuZCgyMDApCgoJ
ZW5kCgoJOjpmb3VuZF9zbG90OjoKCglkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lXS54ID0geAoJZGVz
a3RvcF9pdGVtc1tmaWxlbmFtZV0ueSA9IHkKZW5kCgpmdW5jdGlvbiBmZXRjaF9kZXNrdG9wX2l0
ZW1zKCkKCWxvY2FsIG1ldGEgPSBmZXRjaF9tZXRhZGF0YShwd2QoKSkKCWRlc2t0b3BfaXRlbXMg
PSBtZXRhIGFuZCBtZXRhLmZpbGVfaXRlbSBvciB7fQoJLS1wcmludGgoImZldGNoZWQgZGVza3Rv
cCBpdGVtczogIi4ucG9kKGRlc2t0b3BfaXRlbXMpKQplbmQKZnVuY3Rpb24gc3RvcmVfZGVza3Rv
cF9pdGVtcygpCgktLXByaW50aCgiQEAgc3RvcmVfZGVza3RvcF9pdGVtczogIi4ucHdkKCkpCgkK
CS0tIHNlY3VyaXR5OiBvbmx5IHN0b3JlIGl0ZW1zIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIGZpbGUu
CgktLSAod2hlbiBkZWxldGUgYSBmaWxlLCBkb24ndCBleHBlY3QgdGhlIGZpbGVuYW1lIHRvIGJl
IGtpY2tpbmcgYXJvdW5kIGhlcmUpCglmb3Igayx2IGluIHBhaXJzKGRlc2t0b3BfaXRlbXMpIGRv
CgkJaWYgKG5vdCBmc3RhdChrKSkgZGVza3RvcF9pdGVtc1trXSA9IG5pbAoJCQoJCS0tIGFsc286
IHN0b3JlIGFzIGludHMKCQl2LnggXD0gMSAgdi55IFw9IDEKCQkKCWVuZAoJCglzdG9yZV9tZXRh
ZGF0YShwd2QoKSwge2ZpbGVfaXRlbSA9IGRlc2t0b3BfaXRlbXN9KQoJCmVuZApmdW5jdGlvbiBz
aGlmdF9zZWxlY3RlZF9kZXNrdG9wX2l0ZW1zKGR4LCBkeSkKCglmb3IgaT0xLCNmaSBkbwoJCWxv
Y2FsIGVsMiA9IGZpW2ldCgkJaWYgKGVsMi5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQlsb2NhbCB3
MiA9IGVsMi53aWR0aC8yCgkJCWxvY2FsIGgyID0gZWwyLmhlaWdodC8yCgkJCQoJCQktLSBjbGFt
cAoJCQkKCQkJZWwyLnggPSBtaWQoLXcyLCBlbDIueCArIGR4LCB3MiArIDQ4MCAtIGVsMi53aWR0
aCkKCQkJZWwyLnkgPSBtaWQoLWgyLCBlbDIueSArIGR5LCBoMiArIDI3MCAtIGVsMi5oZWlnaHQp
CgkJCQoJCQktLSBzbmFwIHRvIGdyaWQKCQkJaWYgKHNldHRpbmdzLnNuYXBfdG9fZ3JpZCkgdGhl
bgoJCQkJZWwyLnggPSA0NSsoKC00NSArIGVsMi54ICsgMzMpIFwgNjYpICogNjYKCQkJCWVsMi55
ID0gMjArKCgtMjAgKyBlbDIueSArIDI1KSBcIDUwKSAqIDUwIC0tIHdhcyAxNissLTE2IGluIDAu
MS4xYwoJCQkJCgkJCQktLSBhZGQgc3RhY2sgZ3JvdXAgcG9zIHRvIHBvc2l0aW9uIHRvIHByZXNl
cnZlIHN0YWNrIG9yZGVyCgkJCQlpZiAoZWwyLmdyb3VwX3BvcykgdGhlbgoJCQkJCWVsMi54IC09
IGVsMi5ncm91cF9wb3MKCQkJCQllbDIueSAtPSBlbDIuZ3JvdXBfcG9zCgkJCQllbmQKCQkJCQoJ
CQkJLS1wcmludGgoImRyb3BwZWQgYXQgIi4uZWwyLnguLiIgIi4uZWwyLnkpCgkJCQllbDIueCA9
IG1pZCgtMjEsZWwyLngsMzc1KQoJCQkJZWwyLnkgPSBtaWQoMTYsZWwyLnksMjE2KQoJCQkJCgkJ
CQkKCQkJCS0tIHdoZW4gcGFydCBvZiBhIGdyb3VwLCBvZmZzZXQgeCx5IHRvIHByZXNlcnZlIHN0
YWNrIG9yZGVyCgkJCQlpZiAoZWwyLmdyb3VwX2lkKSB0aGVuCgkJCQkJbG9jYWwgZyA9IGdyb3Vw
W2VsMi5ncm91cF9pZF0KCQkJCQlpZiAoI2cgPiAxKSB0aGVuCgkJCQkJCQoJCQkJCWVuZAoJCQkJ
ZW5kCgkJCWVuZAoKCQkJLS0gY3JlYXRlIC8gdXBkYXRlIGRlc2t0b3AgaXRlbSB0b28KCgkJCWxv
Y2FsIGRpID0gdmFsaWRhdGVfZGkoZWwyLmZpbGVuYW1lKSAtLSBjcmVhdGUgbmV3IGlmIG5lZWRl
ZAoJCQlkaS54ID0gZWwyLngKCQkJZGkueSA9IGVsMi55CgkJCQoJCWVuZAoJZW5kCgkKCXN0b3Jl
X2Rlc2t0b3BfaXRlbXMoKQoJdXBkYXRlX2Rlc2t0b3BfZ3JvdXBzKCkKZW5kCgpsb2NhbCBmdW5j
dGlvbiBjcmVhdGVfZmlsZV9pdGVtKHBhcmVudCwgZmYsIHgsIHkpCglpZiAobm90IGZmIG9yIG5v
dCBmZi5maWxlbmFtZSkgcmV0dXJuCgkKCXZhbGlkYXRlX2RpKGZmLmZpbGVuYW1lLCB0cnVlKQoJ
Cglsb2NhbCBlbCA9IHsKCQl4PXgseT15LAoJCXdpZHRoPTEyOCwgaGVpZ2h0PTQyLCAtLSBkZXNr
dG9wIGl0ZW1zIGNhbiBiZSBxdWl0ZSB3aWRlCgkJZmluZm8gICAgPSBmZiwKCQlmaWxlbmFtZSA9
IGZmLmZpbGVuYW1lLAoJCS0tIGN1cnNvciA9IDUgLS0gbmVlZHMgdG8gYmUgY29uc2lzdGVudCB3
aXRoIGdyaWQgdmlldwoJfQoJCglmdW5jdGlvbiBlbDp1cGRhdGUobXNnKQoJCQoJCWxvY2FsIG14
LG15ID0gbW91c2UoKQoJCQoJCWxvY2FsIGR4LGR5ID0gbXggLSAoc2VsZi5zeCtzZWxmLndpZHRo
LzIpLCBteSAtIChzZWxmLnN5K3NlbGYuaGVpZ2h0LzIpCgoJCS0tIHJlc2V0IGF1dG8tb3BlbiBt
ZWNoYW5pc20KCQlpZiAobm90IGRyYWdnaW5nX2ZpbGVzKSB0aGVuCgkJCXNlbGYub3BlbmVkX3do
aWxlX2RyYWdnaW5nX2ZpbGVzID0gZmFsc2UKCQkJc2VsZi5ob3Zlcl9jb3VudGVyID0gMAoJCQly
ZXR1cm4KCQllbmQKCQkKCQktLSBhdXRvLW9wZW4gd2hlbiBub3Qgc2VsZWN0ZWQgYW5kIGRyYWdn
aW5nIGZpbGVzIG92ZXJoZWFkCgkJaWYgbm90IHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIAoJCQlk
eCpkeCtkeSpkeTwyNTYgYW5kIAoJCQlub3Qgc2VsZi5vcGVuZWRfd2hpbGVfZHJhZ2dpbmdfZmls
ZXMKCQl0aGVuCgkJCXNlbGYuaG92ZXJfY291bnRlciA9IHNlbGYuaG92ZXJfY291bnRlciBvciAw
CgkJCXNlbGYuaG92ZXJfY291bnRlciArPSAxCgkJCWlmIChtc2cuZHggfj0gMCBvciBtc2cuZHkg
fj0gMCkgc2VsZi5ob3Zlcl9jb3VudGVyIFw9IDIgLS0gaG9sZCB3aXRob3V0IG1vdmluZyBidXQg
Y2FuIHJlY292ZXIgCgkJCWlmIHNlbGYuZmluZm8uYXR0cmliID09ICJmb2xkZXIiIGFuZCBzZWxm
LmhvdmVyX2NvdW50ZXIgPiA2MCB0aGVuIC0tIGhvbGQgZm9yIGEgc2Vjb25kLiBhY2NpZGVudGFs
IG9wZW5zIGFyZSBhbm5veWluZwoJCQkJaWYgbm90IGlzX2NhcnQoc2VsZi5maW5mby5maWxlbmFt
ZSkgdGhlbiAtLSBvbmx5IGF1dG8tb3BlbiB3aGVuIG5vdCBhIGNhcnQKCQkJCQlzZWxmLm9wZW5l
ZF93aGlsZV9kcmFnZ2luZ19maWxlcyA9IHRydWUKCQkJCQljcmVhdGVfcHJvY2VzcygiL3N5c3Rl
bS9hcHBzL2ZpbGVuYXYucDY0IiwKCQkJCQl7CgkJCQkJCWFyZ3YgPSB7ZWwuZmluZm8uZnVsbHBh
dGh9LCAKCQkJCQkJd2luZG93X2F0dHJpYnM9ewoJCQkJCQkJZ2l2ZV9mb2N1cyA9IHRydWUsCgkJ
CQkJCQl4ID0gbWF4KC0yLCBteCAtIDgwKSwgLS0gcG9zaXRpb24gd2luZG93IHVuZGVyIGN1cnNv
cgoJCQkJCQkJeSA9IG1heCgtMiwgbXkgLSA0MCkgIC0tIHJlYWR5IHRvIGNhdGNoIGZpbGUKCQkJ
CQkJfQoJCQkJCX0pCgkJCQllbmQKCQkJZW5kCgkJZWxzZQoJCQlzZWxmLmhvdmVyX2NvdW50ZXIg
PSAwCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJZHJhZ19zZWxlY3RlZF9m
aWxlcyhtc2cpCgllbmQKCQoJZnVuY3Rpb24gZWw6cmVsZWFzZShtc2cpCgkJZHJhZ2dpbmdfZmls
ZXMgPSBuaWwKCWVuZAoKCWZ1bmN0aW9uIGVsOmhvdmVyKG1zZykKCQktLSBrZWVwIGRyYXdpbmcg
d2hpbGUgb3ZlciBhbiBpdGVtCgkJaWYgKG1zZy5keH49MCBvciBtc2cuZHl_PTApIGZpbmZvX3Zl
cnNpb24gKz0gMQoJZW5kCgoJCglmdW5jdGlvbiBlbDp0ZXN0X3BvaW50KHgsIHkpCgkJCgkJbG9j
YWwgbGwgPSBlbC5sYXN0X2xhYmVsX2FyZWEKCQlpZiAobm90IGxsKSByZXR1cm4gdHJ1ZQoJCQoJ
CS0tIHNwcml0ZSBwaXhlbCBpcyBzZXQsIG9yIGluc2lkZSBmaWxlbmFtZSBsYWJlbAoJCXJldHVy
biBnZXQoc2VsZi5maW5mby5pY29uLCB4IC0gbGxbNV0sIHkgLSBsbFs2XSkgPiAwCgkJCW9yICh4
ID49IGxsWzFdIGFuZCB5ID49IGxsWzJdIGFuZCB4IDw9IGxsWzNdIGFuZCB5IDw9IGxsWzRdKQoJ
ZW5kCgkKCQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgoJCWNsaXAoKSAtLSBhbGxvdyBkZXNrdG9w
IGl0ZW1zIHRvIGJlIGRyYXduIGFueSBzaXplIChlLmcuIHN1cGVyIGxvbmcgZmlsZW5hbWVzKQoK
CQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDIpIC0tIGRlYnVnOiBzaG93
IHdpZHRoCgkJcGFsKCkKCQlsb2NhbCBzcHJ4LCBzcHJ5ID0gc2VsZi53aWR0aC8yIC0gOCwgNgoJ
CWxvY2FsIHNwcngwLCBzcHJ5MCA9IHNwcngsIHNwcnkKCQkKCQktLWxvY2FsIGR4LGR5ID0gbXNn
Lm14IC0gKHNlbGYuc3grc2VsZi53aWR0aC8yKSwgbXNnLm15IC0gKHNlbGYuc3krc2VsZi5oZWln
aHQvMikKCQktLWlmIChkeCpkeCtkeSpkeTwyNTYpIGNpcmNmaWxsKHNlbGYud2lkdGgvMixzZWxm
LmhlaWdodC8yLDE2LDEzKQoJCgkJLS0gZGV0ZXJtaW5lIGlmIHVuZGVyIGEgcGlsZSBvZiBpdGVt
cwoJCWxvY2FsIGc9Z3JvdXBbc2VsZi5ncm91cF9pZF0KCQlsb2NhbCBidXJpZWQgPSBzZWxmLmZp
bmZvLmZpbGVuYW1lIH49IGdbI2ddLmZpbGVuYW1lCgkJCgkJaWYgKHNlbGYuZmluZm8uc2VsZWN0
ZWQpICB0aGVuCgkJCgkJCS0tIGRyYXcgc2hhZG93IHdoZW4gc2luZ2xlIGl0ZW0gaW4gZ3JvdXAK
CgkJCWlmICgjZz09MSkgdGhlbgoJCQkJbWVtbWFwKHNoYWRvd19wYWwsIDB4ODAwMCkKCQkJCXNw
cihzZWxmLmZpbmZvLmljb24sc3ByeCxzcHJ5KQoJCQkJdW5tYXAoc2hhZG93X3BhbCwgMHg4MDAw
KQoJCQllbmQKCgkJCXNwcnggKz0gMQoJCQlzcHJ5IC09IDEKCQkJCgkJZW5kCgkJCgkJLS0gcG9w
IHVwIDFweCBvbiBob3ZlciAoYnV0IG5vdCBmb3IgbGFiZWwgaG92ZXIpCgkJLS0gYnVtcCBmaW5m
b192ZXJzaW9uIHRvIHJlZHJhdwoJCWlmIChtc2cuaGFzX3BvaW50ZXIgYW5kIG1zZy5teSA8IDI0
KSBzcHJ5IC09IDEgZmluZm9fdmVyc2lvbiArPSAxCgkJCgkJLS0gYXBwbHkgc2h1ZmZsZV90IC0t
IGJ1bXAgZmluZm9fdmVyc2lvbiBzbyB0aGF0IGl0IGtlZXBzIGFuaW1hdGluZwoJCXNwcnggKz0g
c2VsZi5zaHVmZmxlX3QgKiBzZWxmLnNodWZmbGVfc3BhY2luZwoJCXNwcnkgKz0gc2VsZi5zaHVm
ZmxlX3QgKiBzZWxmLnNodWZmbGVfc3BhY2luZwoJCWlmIChzZWxmLnNodWZmbGVfdCA8IDApIHNl
bGYuc2h1ZmZsZV90ID0gbWluKDAsIHNlbGYuc2h1ZmZsZV90KzAuMSkgZmluZm9fdmVyc2lvbiAr
PSAxCgkJaWYgKHNlbGYuc2h1ZmZsZV90ID4gMCkgc2VsZi5zaHVmZmxlX3QgPSBtYXgoMCwgc2Vs
Zi5zaHVmZmxlX3QtMC4xKSBmaW5mb192ZXJzaW9uICs9IDEKCQkKCQoJCQoJCWlmIChub3QgZHJh
Z2dpbmdfZmlsZXMgb3Igbm90IHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJCgkJCWlmIChz
ZXR0aW5ncy5sb3djb2xfaWNvbnMgb3Igc2VsZi5maW5mby5sb3djb2xfaWNvbikgdGhlbgoJCQkJ
bG9jYWwgcCA9IGJ1cmllZCBhbmQgYnVyaWVkX3BhbCBvciBpY29uX3BhbCAtLSBsb3djb2wgaWNv
bnMgcmVtYWluIGxvdyBldmVuIHdoZW4gYnVyaWVkCi0tCQkJCWxvY2FsIHAgPSBidXJpZWQgYW5k
IChzZXR0aW5ncy5sb3djb2xfaWNvbnMgYW5kIGJ1cmllZF9wYWwgb3IgYnVyaWVkX3BhbDIpIG9y
IGljb25fcGFsCgkJCQltZW1tYXAocCwgMHg4MDAwKQoJCQkJc3ByKHNlbGYuZmluZm8uaWNvbixz
cHJ4LHNwcnkpCgkJCQl1bm1hcChwLCAweDgwMDApCgkJCWVsc2UKCQkJCWlmIChidXJpZWQpIG1l
bW1hcChidXJpZWRfcGFsMiwgMHg4MDAwKQoJCQkJc3ByKHNlbGYuZmluZm8uaWNvbixzcHJ4LHNw
cnkpCgkJCQlpZiAoYnVyaWVkKSB1bm1hcChidXJpZWRfcGFsMiwgMHg4MDAwKQoJCQllbmQKCgkJ
ZW5kCgkJCgkJCgkJLS1sb2NhbCBzdHIgPSAiXDAxNCIuLnNlbGYuZmlsZW5hbWUKCQktLSBwb2tl
KDB4NWYzNiwgMHg4MCkgLS0gdHVybiBvbiB3cmFwIHRvIGNsaXBfcmlnaHQgLS0gMC4yLjBpOiBj
b21tZW50ZWQ7IG1lc3NlcyB1cCBsb2NhdGlvbiBiYXIKCQkKCQlsb2NhbCBzdHIgPSBzZWxmLmZp
bGVuYW1lCgkJLS0gaWYgKHN0cjpzdWIoLTQpID09ICIubG9jIikgc3RyID0gc3RyOnN1YigxLC01
KSAtLSB0ZXN0OiBkb24ndCBzaG93IC5sb2MKCQkKCQlsb2NhbCB3dyxoaCA9IHByaW50KHN0ciwg
MCwgLTEwMDAwMDApCgkJaGggKz0gMTAwMDAwMAoKLS0JCXd3ID0gbWluKHd3LCBzZWxmLndpZHRo
LTgpIC0tIGRvbid0IGNsaXAgbGVmdCB0ZXh0LCBvbmx5IHJpZ2h0CgkJCgkJbG9jYWwgdzIgPSBz
ZWxmLndpZHRoIC8gMgoJCWxvY2FsIHl5ID0gMzAKCQkKCQlpZiAobm90IGJ1cmllZCkgdGhlbgoJ
CQljb2xvcihzZWxmLmZpbmZvLnNlbGVjdGVkIGFuZCAxIG9yIDcpCgkJCQoJCQlyZWN0ZmlsbCh3
Mi13dy8yLTUseXktNCx3Mit3dy8yKzMseXkraGgtMSkgCgkJCXJlY3RmaWxsKHcyLXd3LzItNix5
eS0zLHcyK3d3LzIrNCx5eStoaC0yKQoJCQkKCQkJcHJpbnQoc3RyLCB3MiAtIHd3IC8gMiwgeXks
IHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIDcgb3IgMTMpCgkJZW5kCgkJCgkJLS0gZm9yIHRlc3Rf
cG9pbnQKCQlpZiAoYnVyaWVkKSB0aGVuCgkJCS0tIHRlc3Qgb25seSBpY29uLCBub3QgbGFiZWwK
CQkJZWwubGFzdF9sYWJlbF9hcmVhID0gezEwMDAsMCwxMDAwLDAsc3ByeDAsc3ByeTB9CgkJZWxz
ZQoJCQllbC5sYXN0X2xhYmVsX2FyZWEgPSB7dzItd3cvMi01LHl5LTQsdzIrd3cvMiszLHl5K2ho
LTEsc3ByeDAsc3ByeTB9CgkJZW5kCgkJCgkJLS0gZm9yIGRyYWdnaW5nIGZpbGUgaWNvbnMKCQlz
ZWxmLmZpbmZvLnggPSBzcHJ4ICsgc2VsZi5zeAoJCXNlbGYuZmluZm8ueSA9IHNwcnkgKyBzZWxm
LnN5IAoKCQktLSBwc2V0KHNwcngsIHNwcnksIHJuZCgzMikpIC0tIGRlYnVnOiBzaG93IHdoZW4g
cmVkcmF3IGlzIGhhcHBlbmluZwoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQkKCQkt
LSBhZGp1c3QgeiBmb3IgYWxsIGl0ZW1zIGluIGdyb3VwLCBhbmQgYnJpbmcgYWxsIHRvIGZyb250
CgkJaWYgc2VsZi5ncm91cF9pZCB0aGVuCgkJCWxvY2FsIGc9Z3JvdXBbc2VsZi5ncm91cF9pZF0K
CQkJZm9yIGk9MSwjZyBkbwoJCQkJZ1tpXS56ID0gdG9wX3oKCQkJCWdbaV06YnJpbmdfdG9fZnJv
bnQoKQoJCQllbmQKCQkJdG9wX3ogKz0gMQoJCWVsc2UKCQkJLS0gZG9lc24ndCBoYXBwZW47IGFs
d2F5cyBncm91cCBvZiAxCgkJCXNlbGY6YnJpbmdfdG9fZnJvbnQoKQoJCWVuZAoJCQoJCWlmIChr
ZXkoImN0cmwiKSkgdGhlbgoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gbm90IHNlbGYuZmluZm8u
c2VsZWN0ZWQKCQllbHNlCgkJCS0tIGlmIHdhc24ndCBhbHJlYWR5IHNlbGVjdGVkLCBkZXNlbGVj
dCBldmVyeXRoaW5nIGVsc2UKCQkJaWYgKG5vdCBzZWxmLmZpbmZvLnNlbGVjdGVkKSBkZXNlbGVj
dF9hbGwoKSAgc2VsID0gbmlsCgkJCS0tIC4uIGJ1dCBlaXRoZXIgd2F5LCB0aGlzIG9uZSBpcyBn
b2luZyB0byBiZSBzZWxlY3RlZAoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCWVuZAoK
CQl1cGRhdGVfY29udGV4dF9tZW51KCkKCgkJcmV0dXJuIHRydWUKCWVuZAoKCWZ1bmN0aW9uIGVs
OnRhcChtc2cpCgkJLS0gdW5zZWxlY3QgYWxsIGJ1dCBjdXJyZW50IGl0ZW0gKG5lZWQgdG8gcHJl
c2VydmUgc2VsZWN0aW9uIG9uIGNsaWNrIGZvciBkcmFnZ2luZyAvIGNvbnRleHQgbWVudSkKCQlp
ZiBub3Qga2V5ImN0cmwiIGFuZCBub3Qga2V5InNoaWZ0IiBhbmQgbXNnLmxhc3RfbWIgPT0gMSB0
aGVuCgkJCWRlc2VsZWN0X2FsbCgpCgkJCXNlbGYuZmluZm8uc2VsZWN0ZWQgPSB0cnVlCgkJZW5k
CgllbmQKCQoJLS0gc2h1ZmZsZSBwaWxlCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCgkJ
aWYgKG5vdCBzZWxmLmdyb3VwX2lkKSByZXR1cm4KCQlsb2NhbCBnID0gZ3JvdXBbc2VsZi5ncm91
cF9pZF0KCQlpZiAoI2cgPCAyKSByZXR1cm4KCgkJLS0gc2FmZXR5IC0tIHNob3VsZCBhbHJlYWR5
IGV4aXN0IGFuZCBoYXZlIHBvc2l0aW9ucwoJCWZvciBpPTEsI2cgZG8KCQkJdmFsaWRhdGVfZGko
Z1tpXS5maWxlbmFtZSwgdHJ1ZSkKCQllbmQKCgkJaWYgKG1zZy53aGVlbF95IDwgMCkgdGhlbgoJ
CQlsb2NhbCB4MCwgeTAgPSBkZXNrdG9wX2l0ZW1zW2dbMV0uZmlsZW5hbWVdLngsZGVza3RvcF9p
dGVtc1tnWzFdLmZpbGVuYW1lXS55CgkJCWZvciBpPTEsI2ctMSBkbwoJCQkJZGVza3RvcF9pdGVt
c1tnW2ldLmZpbGVuYW1lXS54LGRlc2t0b3BfaXRlbXNbZ1tpXS5maWxlbmFtZV0ueSA9CgkJCQkJ
ZGVza3RvcF9pdGVtc1tnW2krMV0uZmlsZW5hbWVdLngsZGVza3RvcF9pdGVtc1tnW2krMV0uZmls
ZW5hbWVdLnkKCQkJZW5kCgkJCWRlc2t0b3BfaXRlbXNbZ1sjZ10uZmlsZW5hbWVdLnggPSB4MAoJ
CQlkZXNrdG9wX2l0ZW1zW2dbI2ddLmZpbGVuYW1lXS55ID0geTAKCQllbmQKCQlpZiAobXNnLndo
ZWVsX3kgPiAwKSB0aGVuCgkJCWxvY2FsIHgwLCB5MCA9IGRlc2t0b3BfaXRlbXNbZ1sjZ10uZmls
ZW5hbWVdLngsZGVza3RvcF9pdGVtc1tnWyNnXS5maWxlbmFtZV0ueQoJCQlmb3IgaT0jZy0xLDEs
LTEgZG8KCQkJCWRlc2t0b3BfaXRlbXNbZ1tpKzFdLmZpbGVuYW1lXS54LGRlc2t0b3BfaXRlbXNb
Z1tpKzFdLmZpbGVuYW1lXS55ID0KCQkJCQlkZXNrdG9wX2l0ZW1zW2dbaV0uZmlsZW5hbWVdLngs
ZGVza3RvcF9pdGVtc1tnW2ldLmZpbGVuYW1lXS55CgkJCWVuZAoJCQlkZXNrdG9wX2l0ZW1zW2db
MV0uZmlsZW5hbWVdLnggPSB4MAoJCQlkZXNrdG9wX2l0ZW1zW2dbMV0uZmlsZW5hbWVdLnkgPSB5
MAoJCWVuZAoJCQoJCS0tIHN5bmMgZ3VpIGVsZW1lbnQgcG9zaXRpb25zIGFuZCBzZXQgdHJhbnNp
dGlvbiBhbmltYXRpb24KCQlmb3IgaT0xLCNmaSBkbwoJCQlmaVtpXS54ID0gZGVza3RvcF9pdGVt
c1tmaVtpXS5maWxlbmFtZV0ueAoJCQlmaVtpXS55ID0gZGVza3RvcF9pdGVtc1tmaVtpXS5maWxl
bmFtZV0ueQoJCQlpZihmaVtpXS5ncm91cF9pZCA9PSBzZWxmLmdyb3VwX2lkKSB0aGVuCgkJCQlm
aVtpXS5zaHVmZmxlX3QgPSBzZ24obXNnLndoZWVsX3kpCgkJCQlmaVtpXS5zaHVmZmxlX3NwYWNp
bmcgPSBtaWQoMSwgMjBcI2dyb3VwW3NlbGYuZ3JvdXBfaWRdLCAzKQoJCQllbmQKCQllbmQKCQkt
LSByZWJ1aWxkIGdyb3VwcyBmcm9tIGRlc2t0b3AgaXRlbXMKCQlzdG9yZV9kZXNrdG9wX2l0ZW1z
KCkKCQl1cGRhdGVfZGVza3RvcF9ncm91cHMoKQoJZW5kCgkKCQoJZnVuY3Rpb24gZWw6ZG91Ymxl
Y2xpY2soKQoJCWNsaWNrX29uX2ZpbGUoc2VsZi5maWxlbmFtZSkKCWVuZAoJCglyZXR1cm4gZWwK
ZW5kCgpmdW5jdGlvbiBzb3J0X2ZpbGVfaXRlbXNfYnlfeSgpCgoJZm9yIHBhc3M9MSwjZmkgZG8K
CQlmb3IgaT0yLCNmaSBkbwoJCQlsb2NhbCBmbjA9ZmlbaV0uZmlsZW5hbWUKCQkJbG9jYWwgZm4x
PWZpW2ktMV0uZmlsZW5hbWUKCQkJaWYoCgkJCQlkZXNrdG9wX2l0ZW1zW2ZuMF0gYW5kIGRlc2t0
b3BfaXRlbXNbZm4xXSBhbmQKCQkJCWRlc2t0b3BfaXRlbXNbZm4wXS55IDwgZGVza3RvcF9pdGVt
c1tmbjFdLnkpIHRoZW4KCQkJCWZpW2ldLGZpW2ktMV09ZmlbaS0xXSxmaVtpXQoJCQllbmQKCQll
bmQKCWVuZAoJCmVuZAoKZnVuY3Rpb24gdXBkYXRlX2Rlc2t0b3BfZ3JvdXBzKCkKCQoJc29ydF9m
aWxlX2l0ZW1zX2J5X3koKQoJCgktLWRlc2t0b3BfY29udGVudC5jaGlsZCA9IHt9CgkKCglncm91
cD17fQoJLS0gY2xlYXIKCWZvciBpPTEsI2ZpIGRvCgkJZmlbaV0uZ3JvdXBfaWQgPSBuaWwKCWVu
ZAoKCWxvY2FsIGdyb3VwX2lkID0gMQoKCWZvciBpPTEsI2ZpIGRvCgkJbG9jYWwgbGlzdCA9IGZp
IC0tIHRvIGRvOiBvY2N1cGFuY3kgZ3JpZAoJCWxvY2FsIGZvdW5kX2dyb3VwX2lkID0gbmlsCgkJ
Zm9yIGo9MSwjbGlzdCBkbwoJCQlpZiBsaXN0W2pdfj1maVtpXSBhbmQgbGlzdFtqXS5ncm91cF9p
ZCB0aGVuCgkJCQlsb2NhbCBkeCA9IGxpc3Rbal0ueCAtIGZpW2ldLngKCQkJCWxvY2FsIGR5ID0g
bGlzdFtqXS55IC0gZmlbaV0ueQoJCQkJaWYgKGR4KmR4K2R5KmR5PDEyKjEyKSB0aGVuCgkJCQkJ
Zm91bmRfZ3JvdXBfaWQgPSBsaXN0W2pdLmdyb3VwX2lkCgkJCQkJLS1wcmludGgoImZvdW5kIGdy
b3VwX2lkOiAiLi5mb3VuZF9ncm91cF9pZCkKCQkJCWVuZAoJCQllbmQKCQllbmQKCQlpZiAoZm91
bmRfZ3JvdXBfaWQpIHRoZW4KCQkJZmlbaV0ueiA9ICNncm91cFtmb3VuZF9ncm91cF9pZF0KCQkJ
YWRkKGdyb3VwW2ZvdW5kX2dyb3VwX2lkXSwgZmlbaV0pCgkJCWZpW2ldLmdyb3VwX2lkID0gZm91
bmRfZ3JvdXBfaWQKCQllbHNlCgkJCS0tIHN0YXJ0IG5ldyBncm91cAoJCQlncm91cFtncm91cF9p
ZF0gPSB7ZmlbaV19CgkJCWZpW2ldLmdyb3VwX2lkICA9IGdyb3VwX2lkCgkJCWdyb3VwX2lkKz0x
CgkJZW5kCgllbmQKCQoJLS0gb3JnYW5pc2UgYnVyaWVkIGl0ZW0gcG9zaXRpb25zOiAzcHggYXBh
cnQKCWZvciBpPTEsI2dyb3VwIGRvCgkJbG9jYWwgZz1ncm91cFtpXQoJCS0tIHVzZSBzZWNvbmQg
dG8gbGFzdCAoMm5kIGZyb20gdG9wKSBzbyB0aGF0IHN0YWNrIGRvZXNuJ3QganVzdCBhcm91bmQK
CQktLSBhZGRpbmcgYSBuZXcgaXRlbSBvbiBmcm9udCAoY29tbW9uKQoJCWxvY2FsIGFuY2hvciA9
IG1pZCgxLCNnLTEsI2cpIC0tIHdhcyAjZ1wyCgkJbG9jYWwgc3BhY2luZyA9IG1pZCgxLCAyMFwj
ZywgMykKCQlsb2NhbCB4ID0gZ1thbmNob3JdLngKCQlsb2NhbCB5ID0gZ1thbmNob3JdLnkKCQkK
CQlmb3Igaj0xLCNnIGRvCgkJCWdbal0ueCA9IHggLSAoYW5jaG9yLWopKnNwYWNpbmcKCQkJZ1tq
XS55ID0geSAtIChhbmNob3Itaikqc3BhY2luZwoJCQktLSBnYXRoZXIgYWN0dWFsIGl0ZW1zIHRv
IHNhbWUgcG9pbnQKCQkJLS0gbWVhbnMgc3RhY2sgd29uJ3QgZ2V0IGJyb2tlbiB3aGVuIHJlbW92
aW5nIG1pZGRsZSBpdGVtCgkJCS0tIGFuZCBjcmVhdGVzIG1vcmUgY29uc2lzdGVudCBjb2xsaXNp
b24gd2l0aCBwaWxlIChlLmcuIHdoZW4gaW5zZXJ0aW5nKQoKCQkJLS0gZGVza3RvcF9pdGVtc1tn
W2pdLmZpbGVuYW1lXSA9IGRlc2t0b3BfaXRlbXNbZ1tqXS5maWxlbmFtZV0gb3Ige30KCQkJLS0g
ZGVza3RvcF9pdGVtc1tnW2pdLmZpbGVuYW1lXS54ID0gZ1tqXS54CgkJCS0tIGRlc2t0b3BfaXRl
bXNbZ1tqXS5maWxlbmFtZV0ueSA9IGdbal0ueQoJCQlzZXRfZGVza3RvcF9pdGVtX3Bvc2l0aW9u
KGdbal0uZmlsZW5hbWUsIGdbal0ueCwgZ1tqXS55KQoJCQkKCQkJLS0gdXNlZCBmb3IgcHJlc2Vy
dmluZyBvcmRlciB3aGVuIHNuYXBwaW5nIHRvIGdyaWQKCQkJZ1tqXS5ncm91cF9wb3MgPSAoYW5j
aG9yLWopKnNwYWNpbmcKCQkJIC0tIHNuYXAgdG8gZ3JpZDogbWFrZSBzdXJlIGdvZXMgb24gdG9w
CgkJCWlmIChzZXR0aW5ncy5zbmFwX3RvX2dyaWQgYW5kICNnID09IDApIGdbal0uZ3JvdXBfcG9z
ID0gLTMKCQkJCgkJZW5kCgllbmQKCglmaW5mb192ZXJzaW9uICs9IDEgLS0gcmVkcmF3CmVuZAoK
ZnVuY3Rpb24gZ2VuZXJhdGVfZmVsc19kZXNrdG9wKCkKCglmaSA9IHt9CgkKCS0tIGxvYWQgaXRl
bSBpbmZvIG9uIGZpcnN0IGdlbmVyYXRlCglpZiAobm90IGRlc2t0b3BfaXRlbXMpIHRoZW4KCQlm
ZXRjaF9kZXNrdG9wX2l0ZW1zKCkKCWVuZAoJLS0gYXR0YWNoIHRvIGNvbnRlbnQgaW5jYXNlIHdh
bnQgdG8gaGF2ZSBzY3JvbGxhYmxlIGRlc2t0b3AgZmlsZXMgbGF0ZXIgKD8pCgktLSBzdGFydCBh
dCAxMiB0byBtYWtlIHNwYWNlIGZvciB0aXRsZWJhcgoKCWxvY2FsIHB1dF94ID0gLTIxCglsb2Nh
bCBwdXRfeSA9IDE2CgkKCWZvciBpPTEsI2ZpbGVuYW1lcyBkbwoJCgkJLS0gc3RhcnQgYXQgcmFu
ZG9tIHBvc2l0aW9uCgkJaWYgKGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVzW2ldXSA9PSBuaWwpIHRo
ZW4KCgkJCXNldF9kZXNrdG9wX2l0ZW1fcG9zaXRpb24oZmlsZW5hbWVzW2ldLCBuaWwsIG5pbCkK
CQkJCgkJCS0tIHRlbXBvcmFyeSBoYWNrIGZvciBkZWZhdWx0IGRlc2t0b3AgaXRlbXMKCQkJbG9j
YWwgZm4gPSBmaWxlbmFtZXNbaV0KCQkJaWYgKGZuOmJhc2VuYW1lKCkgPT0gImRyaXZlLmxvYyIg
b3IgZm46YmFzZW5hbWUoKSA9PSAicmVhZG1lLnR4dCIpIAoJCQl0aGVuCgkJCQlkZXNrdG9wX2l0
ZW1zW2ZpbGVuYW1lc1tpXV0ueCA9IHB1dF94CgkJCQlkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lc1tp
XV0ueSA9IHB1dF95CQkKCQkJCXB1dF95ICs9IDUwCgkJCQlpZiAocHV0X3kgPiAyMzApIHB1dF95
ID0gMTYgcHV0X3ggKz0gNjYKCQkJZW5kCgkJZW5kCgkJCgkJbG9jYWwgZGVza3RvcF9pdGVtID0g
ZGVza3RvcF9pdGVtc1tmaWxlbmFtZXNbaV1dCgkJZmlbaV0gPSBjcmVhdGVfZmlsZV9pdGVtKGd1
aSwgZmluZm9bZmlsZW5hbWVzW2ldXSwgCgkJCWRlc2t0b3BfaXRlbS54LAoJCQlkZXNrdG9wX2l0
ZW0ueSkKCWVuZAoJCglzb3J0X2ZpbGVfaXRlbXNfYnlfeSgpCgoJLS0gYXR0YWNoIGV2ZXJ5dGhp
bmcKCWRlc2t0b3BfY29udGVudC5jaGlsZCA9IHt9Cglmb3IgaT0xLCNmaSBkbwoJCWZpW2ldLmN1
cnNvciA9ICJwb2ludGVyIgoJCWZpW2ldLnNodWZmbGVfdCA9IDAKCQlmaVtpXS5zaHVmZmxlX3Nw
YWNpbmcgPSAwCgkJZGVza3RvcF9jb250ZW50OmF0dGFjaChmaVtpXSkKCWVuZAoJLS0gZmkgc2hv
dWxkIGJlIHRoZSBzYW1lIGxpc3QgKGlzIHNvcnRlZCBieSB5IGJ5IHVwZGF0ZV9kZXNrdG9wX2dy
b3VwcykKCS0tIChub3cgd2l0aCBkcmVjb3JhdGlvbnMgYWRkZWQgYnkgOmF0dGFjaCkKCWZpID0g
ZGVza3RvcF9jb250ZW50LmNoaWxkCgkKCXVwZGF0ZV9kZXNrdG9wX2dyb3VwcygpCgkKZW5kCi0t
IG9ubHkgY2FsbGVkIG9uY2Ugb24gc3RhcnR1cCAtLSBkb24ndCBuZWVkIHRvIGJlIGFkYXB0aXZl
CmZ1bmN0aW9uIGdlbmVyYXRlX2ludGVyZmFjZV9kZXNrdG9wKHkwLCBhZGRfaGVpZ2h0KQoJCgls
b2NhbCBpdGVtX3cgPSA2OAoJbG9jYWwgaXRlbV9oID0gNDIKCWxvY2FsIGl0ZW1zX3ggPSBnZXRf
ZGlzcGxheSgpOndpZHRoKCkgXCBpdGVtX3cKCQkKCWxvY2FsIGNvbnRhaW5lciA9IGd1aTphdHRh
Y2h7CgkJeD0wLCB5PXkwLAoJCXdpZHRoX3JlbCAgPSAxLjAsCgkJaGVpZ2h0X3JlbCA9IDEuMCwK
CQloZWlnaHRfYWRkID0gLXkwICsgYWRkX2hlaWdodCwKCQlkcmF3X2RlcGVuZGVuY3kgPSBmaWxl
dmlld19zdGF0ZSAKCX0KCgktLSBhZGQgdG8gZ3VpOyB1c2UgcmVndWxhciB1bm9wdGltaXNlZCBn
dWkgc2NoZW1lCgktLSAoY291bGQgYWRkIGJ1Y2tldHMgbGF0ZXIgb3IgYmFja3BhZ2UgY2FjaGlu
ZywgYnV0IHByb2JhYmx5IHVubmVjZXNzYXJ5KQoJY29udGVudCA9IGNvbnRhaW5lcjphdHRhY2h7
CgkJeD0wLHk9MCx3aWR0aF9yZWw9MS4wLGhlaWdodF9yZWw9MS4wLAoJCWNsaXBfdG9fcGFyZW50
ID0gdHJ1ZSwKCQlkcmF3X2RlcGVuZGVuY3kgPSBmaWxldmlld19zdGF0ZSAtLSB3aHkgZG9lc24n
dCB0aGlzIHdvcmsgaW4gdGhlIGNvbnRhaW5lciBsaWtlIGdyaWQgLyBsaXN0IG1vZGVzPwoJfQoJ
CglkZXNrdG9wX2NvbnRlbnQgPSBjb250ZW50CgoJbG9jYWwgZnVuY3Rpb24gZmlfZm9yX3h5KHgs
IHkpCgkJLS0gZWFybHkgcmVqZWN0IGJ5IHJlYWRpbmcgZHJhd24gc3RhdGUKCQlpZiAocGdldCh4
LHkpID09IDApIHJldHVybgoJCWxvY2FsIGVsID0gZ3VpOmVsX2F0X3h5KHgseSkKCQlpZiAoZWwg
YW5kIGVsLnRlc3RfcG9pbnQpIHJldHVybiBlbCAtLSAudGVzdF9wb2ludCBtZWFucyBpcyBhIGZp
bGUgZWwKCWVuZAoJCglmdW5jdGlvbiBjb250ZW50OmNsaWNrKG1zZykKCQlpZiAobm90IGtleSJj
dHJsIikgZGVzZWxlY3RfYWxsKCkKCQlzZWwgPSB7bXNnLm14LCBtc2cubXl9CgllbmQKCQoJLS0g
Y29weSBwYXN0ZWQgZnJvbSBncmlkLmx1YQoJLS0gZnVkZ2VkIHN0ZXAgc2l6ZSBiZWNhdXNlIHRl
c3RfcG9pbnQgaXMgc2xvdyAodmlhIGd1aTplbF9hdF94eSkKCS0tIHRvIGRvOiBtb3JlIHNlbnNp
YmxlIGNvbGxpc2lvbiBjYWxjdWxhdGlvbgoJZnVuY3Rpb24gY29udGVudDpkcmFnKG1zZykKCQlp
ZiAoc2VsKSB0aGVuCgkJCWlmIChhYnMobXNnLm14LXNlbFsxXSkgPiA0IG9yIGFicyhtc2cubXkt
c2VsWzJdKSA_IDQpIHRoZW4KCQkJCXNlbFszXSxzZWxbNF0gPSBtc2cubXgsIG1zZy5teSAtLSBy
ZWxhdGl2ZSB0byBndWkgZWxlbWVudAoJCQkJLS0gdXBkYXRlIHNlbGVjdGlvbgoJCQkJaWYgKG5v
dCBrZXkiY3RybCIpIGRlc2VsZWN0X2FsbCgpCgkJCQlsb2NhbCB4eDAgPSBtaW4oc2VsWzFdLHNl
bFszXSkKCQkJCWxvY2FsIHh4MSA9IG1heChzZWxbMV0sc2VsWzNdKQoJCQkJbG9jYWwgeXkwID0g
bWluKHNlbFsyXSxzZWxbNF0pCgkJCQlsb2NhbCB5eTEgPSBtYXgoc2VsWzJdLHNlbFs0XSkKCgkJ
CQlmb3IgaT0xLCAjZmkgZG8KCQkJCQlsb2NhbCBpdGVtID0gZmlbaV0KCgkJCQkJbG9jYWwgdXUw
ID0gbWlkKHh4MCwgaXRlbS54LCB4eDEpCgkJCQkJbG9jYWwgdnYwID0gbWlkKHl5MCwgaXRlbS55
LCB5eTEpCgkJCQkJbG9jYWwgdXUxID0gbWlkKHh4MCwgdXUwICsgaXRlbS53aWR0aCwgeHgxKQoJ
CQkJCWxvY2FsIHZ2MSA9IG1pZCh5eTAsIHZ2MCArIGl0ZW0uaGVpZ2h0LCB5eTEpCgkJCQkJCgkJ
CQkJZm9yIHkgPSB2djAsIHZ2MSwgNCBkbwoJCQkJCQlmb3IgeCA9IHV1MCwgdXUxLCA0IGRvCgkJ
CQkJCQlpZiAoaXRlbTp0ZXN0X3BvaW50KHggLSBpdGVtLngsIHkgLSBpdGVtLnkpKSBpdGVtLmZp
bmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQkJCQllbmQKCQkJCQllbmQKCgkJCQllbmQKCgkJCWVsc2UK
CQkJCXNlbFszXSxzZWxbNF0gPSBuaWwsbmlsCgkJCWVuZAoJCQkKCQllbmQKCWVuZAoJCglmdW5j
dGlvbiBjb250ZW50OnJlbGVhc2UoKQoJCXNlbCA9IG5pbAoJZW5kCgkKCS0tIGRyYXduIGZpcnN0
IC0tIG1heWJlIG5lZWQgc2VwYXJhdGUgbGF5ZXIgaW4gY29udGFpbmVyCgktLSB0byBkcmF3IHNl
bGVjdGlvbgoJCglmdW5jdGlvbiBjb250ZW50OmRyYXcoKQoJCWNscygpCgkJcG9rZSgweDU0N2Qs
MHhmZikgLS0gd20gZHJhdyBtYXNrOyBpbnRlcmFjdCBtYXNrIGlzIHN0aWxsIDAKCgkJaWYgKHNv
bGlkX2Rlc2t0b3ApIHJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSw1KSAt
LSB0byBkbzogY29sb3VyIC8gYmFja2dyb3VuZCBpcyBwcm9wZXJ0eSBvZiBmb2xkZXIhCgllbmQK
CQotLVtbCglmdW5jdGlvbiBjb250ZW50OmRyYXcyKCkKCQlpZiAoc2VsIGFuZCAjc2VsID09IDQp
IHRoZW4KCQkJCXJlY3Qoc2VsWzFdLHNlbFsyXSxzZWxbM10sc2VsWzRdLCA3KQoJCQkJcmVjdChz
ZWxbMV0rMSxzZWxbMl0rMSxzZWxbM10tMSxzZWxbNF0tMSwgMSkKCQkJZW5kCgllbmQKXV0KCS0t
IGRyYXcgc2VsZWN0aW9uIG9uIHRvcAoJY29udGFpbmVyOmF0dGFjaHsKCQl4PTAseT0wLHdpZHRo
X3JlbD0xLjAsaGVpZ2h0X3JlbD0xLjAsCgkJZ2hvc3QgPSB0cnVlLAoJCWRyYXcgPSBmdW5jdGlv
bigpCgkJCS0tY2xpcCgpCgkJCWlmIChzZWwgYW5kICNzZWwgPT0gNCkgdGhlbgoJCQkJcmVjdChz
ZWxbMV0sc2VsWzJdLHNlbFszXSxzZWxbNF0sIDcpCgkJCQlyZWN0KHNlbFsxXSsxLHNlbFsyXSsx
LHNlbFszXS0xLHNlbFs0XS0xLCAxKQoJCQllbmQKCQllbmQKCX0KCgl1cGRhdGVfZmlsZV9pbmZv
KHRydWUpIC0tIGRpZmZlcmVudCBwYXR0ZXJuIGZyb20gZ3JpZC9kZXNrdG9wOyB1cGRhdGUgYXQg
ZW5kLiB0byBkbzogd2h5PyBzaG91bGQgYmUgY2xlYXIgYWJvdXQgdGhhdAplbmQKCgo6OiBkcm9w
Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTExIDA5OjE5OjIwIixt
b2RpZmllZD0iMjAyNS0wNC0xOSAxOToyMDo0MiIscmV2aXNpb249MTA0OCxzdG9yZWQ9IjIwMjMt
MjEtMjkgMDk6MjE6MTkiXV0KCmZ1bmN0aW9uIGNoZWNrX2Zvcl9vdmVyd3JpdGVzKG1zZykKCgls
b2NhbCBmbgoJbG9jYWwgbnVtID0gMAoKCWZvciBpPTEsI21zZy5pdGVtcyBkbwoJCWxvY2FsIGl0
ZW0gPSBtc2cuaXRlbXNbaV0KCQlpZiAoaXRlbS5wb2RfdHlwZSA9PSAiZmlsZV9yZWZlcmVuY2Ui
KSB0aGVuCgkJCWxvY2FsIGRlc3QgPSBwd2QoKS4uIi8iLi5pdGVtLmZ1bGxwYXRoOmJhc2VuYW1l
KCkKCQkJLS1wcmludGgoImNoZWNraW5nOiAiLi5kZXN0KQoJCQkKCQkJaWYgZnN0YXQoZGVzdCkg
dGhlbgoJCQkJaWYgKG5vdCBmbikgZm4gPSBpdGVtLmZ1bGxwYXRoOmJhc2VuYW1lKCkKCQkJCW51
bSArPSAxCgkJCWVuZAoJCWVuZAoJZW5kCgkKCWlmIChmbiBhbmQgbnVtID4gMSkgcmV0dXJuIGZu
Li4iICgrIi4uKG51bS0xKS4uIikiCglpZiAoZm4pIHJldHVybiBmbgoJCglyZXR1cm4gbmlsCgpl
bmQKCgotLSBoYXBwZW5zIGFmdGVyIGRyb3BwaW5nIGZpbGVzCmZ1bmN0aW9uIGJyaW5nX3NlbGVj
dGVkX2l0ZW1zX3RvX2Zyb250KCkKCWlmIChtb2RlIH49ICJkZXNrdG9wIikgcmV0dXJuCgotLVtb
Cglmb3IgaT0xLCNmaSBkbwoJCWlmIChmaVtpXS5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQlsb2Nh
bCBpdGVtID0gZmlbaV0KCQkJaXRlbS56ID0gdG9wX3oKCQkJaXRlbTpicmluZ190b19mcm9udCgp
CgkJCXRvcF96ICs9IDEKCQllbmQKCWVuZApdXQoKCWxvY2FsIHByb2Nlc3NlZCA9IHt9Cglmb3Ig
aT0xLCNmaSBkbwoJCWxvY2FsIGl0ZW0gPSBmaVtpXQoJCWlmIChpdGVtLmZpbmZvLnNlbGVjdGVk
KSB0aGVuCgkJCWlmIGl0ZW0uZ3JvdXBfaWQgdGhlbgoJCQkJbG9jYWwgZz1ncm91cFtpdGVtLmdy
b3VwX2lkXQoJCQkJaWYgKG5vdCBwcm9jZXNzZWRbZ10pIHRoZW4KCQkJCQlwcm9jZXNzZWRbZ10g
PSB0cnVlCgkJCQkJZm9yIGk9MSwjZyBkbwoJCQkJCQlnW2ldLnogPSB0b3BfegoJCQkJCQlnW2ld
OmJyaW5nX3RvX2Zyb250KCkKCQkJCQllbmQKCQkJCWVuZAoJCQllbHNlCgkJCQktLSBkb2Vzbid0
IGhhcHBlbjsgYWx3YXlzIGdyb3VwIG9mIDEKCQkJCWl0ZW0ueiA9IHRvcF96CgkJCQlpdGVtOmJy
aW5nX3RvX2Zyb250KCkKCQkJZW5kCgkJCXRvcF96ICs9IDEKCQllbmQKCWVuZAoKZW5kCgoKCm9u
X2V2ZW50KCJkcm9wX2l0ZW1zIixmdW5jdGlvbihtc2cpCgotLQlwcmludGgoIkBAIGRyb3BwZWQg
aXRlbXMgZnJvbSBwcm9jX2lkOiIuLm1zZy5mcm9tX3Byb2NfaWQuLiIgLy8gbW9kZToiLi5tb2Rl
KQotLQlwcmludGgoIiAgLy8gbXNnLm14LG1zZy5teTogIi4ucG9ke21zZy5teCxtc2cubXl9KQoK
CS0tIGRyb3AgaW50byBzZWxmCgkKCWlmIChtc2cuZnJvbV9wcm9jX2lkID09IHBpZCgpKSB0aGVu
CgkJaWYgKG1vZGUgPT0gImRlc2t0b3AiKSB0aGVuCgkJCXNoaWZ0X3NlbGVjdGVkX2Rlc2t0b3Bf
aXRlbXMobXNnLmR4LCBtc2cuZHkpCgkJZW5kCgkJYnJpbmdfc2VsZWN0ZWRfaXRlbXNfdG9fZnJv
bnQoKSAtLSB0byBkbwoJCXJldHVybgoJZW5kCgkKCS0tIGRyb3AgZnJvbSBzb21ld2hlcmUgZWxz
ZQoJCgktLSAuLiBtYWtlIHN1cmUgbm90IGdvaW5nIHRvIG92ZXJ3cml0ZSBzb21ldGhpbmcgZmly
c3QKCWlmIChub3QgbXNnLnNoaWZ0KSB0aGVuCgkJbG9jYWwgcmVzID0gY2hlY2tfZm9yX292ZXJ3
cml0ZXMobXNnKQoJCWlmIHJlcyB0aGVuCgkJCW5vdGlmeSgiKiogY2FuIG5vdCBvdmVyd3JpdGUg
Ii4ucmVzLi4iICoqIChob2xkIHNoaWZ0IHRvIGZvcmNlKSIpCgkJCXJldHVybgoJCWVuZAoJZW5k
CgkKCS0tcHJpbnRoKCJAQCBkcm9wIGZyb20gYSBkaWZmZXJlbnQgcHJvY2VzczoiLi5wb2QobXNn
KSkKCQoJbG9jYWwgZm91bmRfY29weV9vcCA9IGZhbHNlCglsb2NhbCBlcnIgPSBuaWwKCWxvY2Fs
IG51bV9vayA9IDAKCglmb3IgaT0xLCNtc2cuaXRlbXMgZG8KCQlsb2NhbCBpdGVtID0gbXNnLml0
ZW1zW2ldCgkJaWYgKGl0ZW0ucG9kX3R5cGUgPT0gImZpbGVfcmVmZXJlbmNlIikgdGhlbgoKCQkJ
LS0gTU9WRQoJCQktLXByaW50aChwb2QoaXRlbSkpCgkJCS0tIHByaW50aCgiQEAgbW92aW5nICIu
LnRvc3RyaW5nKGl0ZW0uZnVsbHBhdGgpLi4iIHRvICIuLnB3ZCgpKQoJCQkKCQkJLS0gdG8gZG86
IGRlZmluZSB3aGljaCBhdHRyaWJ1dGVzIGFyZSByZXF1aWVkIGZvciBhIHdlbGwgZm9ybWVkIGZp
bGVfcmVmZXJlbmNlIGl0ZW0KCQkJLS0gc2hvdWxkbid0IGV2ZXIgbmVlZCAuZmlsZW5hbWUKCQkJ
LS0gYXZvaWQgaW50cm9kdWNpbmcgb3B0aW9uYWwgYXR0cmlidXRlcyAvIGhpbnRzIC0tIGVhc3kg
Zm9yIGFub3RoZXIgYXV0aG9yIHRvIGV4cGVjdCB0byBleGlzdCBvbiByZWNlaXZpbmcgZW5kCgoJ
CQktLSBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBleGlzdGluZyBmaWxlcyBpbiB0aGlzIGNhc2UKCgkJ
CWxvY2FsIHJlcyA9IG5pbAoKCQkJaWYgKGl0ZW0ub3AgPT0gImNvcHkiKSB0aGVuCgkJCQlyZXMg
PSBjcChpdGVtLmZ1bGxwYXRoLCBwd2QoKS4uIi8iLi5pdGVtLmZ1bGxwYXRoOmJhc2VuYW1lKCkp
CgkJCQlmb3VuZF9jb3B5X29wID0gdHJ1ZQoJCQllbHNlCgkJCQktLSBldmVyeXRoaW5nIGVsc2U6
IG1vdmUgKCJjdXQiKQoJCQkJcmVzID0gbXYoaXRlbS5mdWxscGF0aCwgcHdkKCkuLiIvIi4uaXRl
bS5mdWxscGF0aDpiYXNlbmFtZSgpKQoJCQllbmQKCgkJCWlmIHJlcyB0aGVuCgkJCQllcnIgPSB0
b3N0cmluZyhyZXMpCgkJCWVsc2VpZiAobW9kZSA9PSAiZGVza3RvcCIpIHRoZW4JCgkJCQludW1f
b2sgKz0gMQoJCQkJc2V0X2Rlc2t0b3BfaXRlbV9wb3NpdGlvbigKCQkJCQlpdGVtLmZ1bGxwYXRo
OmJhc2VuYW1lKCksIAoJCQkJCW1zZy5teCAtIDU4ICsgKGl0ZW0ueG8gYW5kIGl0ZW0ueG8gb3Ig
MCksIAoJCQkJCW1zZy5teSAtIDYgKyAoaXRlbS55byBhbmQgaXRlbS55byBvciAwKQoJCQkJKQoJ
CQllbmQKCgkJZW5kCgllbmQKCglsb2NhbCB0b3RhbF9zdHIgPSAjbXNnLml0ZW1zCglpZiAobnVt
X29rIDwgI21zZy5pdGVtcykgdG90YWxfc3RyID0gbnVtX29rLi4iIC8gIi4uKCNtc2cuaXRlbXMp
Cglsb2NhbCBlcnJfc3RyID0gZXJyIGFuZCAoIi8vICIuLmVycikgb3IgIiIKCgoJaWYgKGZvdW5k
X2NvcHlfb3ApIHRoZW4KCQlub3RpZnkoImNvcGllZCAiLi4jbXNnLml0ZW1zLi4iIGl0ZW1zICIu
LmVycl9zdHIpCgllbHNlCgkJbm90aWZ5KCJtb3ZlZCAiLi4jbXNnLml0ZW1zLi4iIGl0ZW1zICIu
LmVycl9zdHIpCgllbmQKCgktLSB0byBkbzogYnJpbmcgc2VsZWN0ZWQgKGRyb3BwZWQpIGl0ZW1z
IHRvIGZyb250IG5leHQgdGltZSAKCS0tW1sKCQl1cGRhdGVfZmlsZV9pbmZvKHRydWUpCgkJYnJp
bmdfc2VsZWN0ZWRfaXRlbXNfdG9fZnJvbnQoKQoJXV0KCmVuZCkKCgo6OiBmaW5mby5sdWEKLS1b
W3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0wOCAwOToyNDo1MCIsbW9kaWZpZWQ9
IjIwMjUtMDQtMTkgMTk6MjA6NDIiLHJldmlzaW9uPTMwNjAsc3RvcmVkPSIyMDIzLTIxLTI5IDA5
OjIxOjE5Il1dCi0tW1sKCWZpbmZvLmx1YQoJCgljb2xsZWN0aW9uIG9mIGZpbGUgaW5mbyB0YWJs
ZXMsIGluZGVwZW5kZW50IG9mIGd1aQoJaW5kZXhlZCBieSBmaWxlbmFtZTsgZmVsIChmaWxlIGd1
aSBlbGVtZW50cykgY2FuIHBvaW50IGF0IHRoaXMKXV0KLS0gZ2xvYmFsCmZpbmZvID0ge30KZmlu
Zm9fdmVyc2lvbiA9IDAgLS0gYnVtcCBlYWNoIHRpbWUgaXQgY2hhbmdlcwoKCi0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLVtbCgkwLjEuMWU6Cgl3aGVuIHJ1bm5pbmcg
ZmlsZW5hdiBhcyBhIGJic19jb21wYW5pb24sIGxvY2F0aW9ucyBhcmUgc2FuZGJveGVkCgktPiBu
ZWVkIHRvIHVuc2FuZGJveCB0aGVtIHRvIGNvcHkgbG9jYXRpb25zIHRvIGNsaXBib2FyZCAvIG9w
ZW4gaW4gaG9zdAoJa2luZGEgbWVzc3ksIGJ1dCBuZWVkIHRvIHN0cmFkZGxlIGJvdGg6CgkJMS4g
ZXhwZWN0YXRpb24gdGhhdCBmaWxlbmF2IGNhbiBhbHdheXMgaW50ZXJhY3Qgd2l0aCByZXN0IG9m
IHN5c3RlbSBhcyB1c3VhbAoJCTIuIGV4cGVjdGF0aW9uIHRoYXQgZmlsZW5hdiByZXR1cm5zIGEg
cGF0aCB0aGF0IGlzIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGZpbGV2aWV3IGFzIHJlcXVlc3Rpbmcg
cHJvY2VzcyAKXV0KbG9jYWwgZnVuY3Rpb24gcGF0aF9pc19pbnNpZGUocGF0aCwgY29udGFpbmVy
X3BhdGgpCglsb2NhbCBsZW4gPSAjY29udGFpbmVyX3BhdGggLS0gdGhlIHNob3J0ZXIgc3RyaW5n
CglpZiAoY29udGFpbmVyX3BhdGggPT0gIioiKSByZXR1cm4gdHJ1ZQoJcmV0dXJuIHBhdGg6c3Vi
KDEsbGVuKSA9PSBjb250YWluZXJfcGF0aCBhbmQgKCNwYXRoID09IGxlbiBvciBwYXRoW2xlbiAr
IDFdID09ICIvIikKZW5kCmZ1bmN0aW9uIGZ1bGxwYXRoX3Vuc2FuZGJveChwYXRoKQoJbG9jYWwg
cGF0aCA9IGZ1bGxwYXRoKHBhdGgpCglsb2NhbCBwYXRoMSA9IHBhdGgKCglsb2NhbCBmaWxldmll
dyA9IGVudigpLmZpbGV2aWV3CglpZiAoZmlsZXZpZXcpIHRoZW4gLS0gc2FmZXR5OyBzaG91bGQg
YWx3YXlzIGV4aXN0CgkJZm9yIGk9MSwjZmlsZXZpZXcgZG8KCQkJbG9jYWwgcnVsZSA9IGZpbGV2
aWV3W2ldCgkJCWlmIChydWxlLm1vZGVbMV0gPT0gIlIiKSB0aGVuCgkJCQlpZiBydWxlLnRhcmdl
dCBhbmQgcGF0aF9pc19pbnNpZGUocGF0aCwgcnVsZS5sb2NhdGlvbikgdGhlbgoJCQkJCXBhdGgx
ID0gcnVsZS50YXJnZXQuLnBhdGg6c3ViKCNydWxlLmxvY2F0aW9uKzEpCgkJCQllbmQKCQkJZW5k
CgkJZW5kCgllbmQKLS0JcHJpbnRoKCJmdWxscGF0aF91bnNhbmRib3g6ICIuLnBhdGguLiIgLT4g
Ii4ucGF0aDEpCglyZXR1cm4gZnVsbHBhdGgocGF0aDEpCmVuZAotLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0KCmZ1bmN0aW9uIGRlc2VsZWN0X2FsbCgpCglmb3Igayx2IGlu
IHBhaXJzKGZpbmZvKSBkbwoJCXYuc2VsZWN0ZWQgPSBmYWxzZQoJZW5kCgl1cGRhdGVfY29udGV4
dF9tZW51KCkKCWZpbmZvX3ZlcnNpb24gKz0gMSAtLSByZWZyZXNoCmVuZAoKLS1bWwoJZmlsZXZp
ZXdfc3RhdGUKCXJldHVybnMgYSBzdHJpbmcgZW5jb2RpbmcgdGhlIHN0YXRlIHRoYXQgZHJhd2lu
ZyB0aGUgbWFpbiBmaWxlIHZpZXcgZGVwZW5kcyBvbgoJd2hlbiB0aGUgc3RhdGUgZG9lc24ndCBj
aGFuZ2UsIHRoZSBmaWxlIHZpZXcgKGdyaWQgLyBkZXNrdG9wKSBkb2VzIG5vdCBuZWVkIHRvIGJl
IHJlZHJhd24KCShleHBlcmltZW50YWwgZm9yIDAuMS4xYyAtLSBzYXZlcyB_MzAlIGNwdSB3aGVu
IG1hbnkgZmlsZW5hdiB3aW5kb3dzIG9wZW4pCl1dCmZ1bmN0aW9uIGZpbGV2aWV3X3N0YXRlKHNl
bGYpCgoJbG9jYWwgbXgsbXksbWIgPSBtb3VzZSgpCglpZiAobWIgPT0gMCkgbXgsbXkgPSAwLDAg
LS0gY2FuIGlnbm9yZSBtb3N1ZSBwb3NpdGlvbiB3aGVuIG5vdCBwcmVzc2luZwoJbG9jYWwgcmV0
ID0gewoJCS0tcm5kKCksIC0tIGRlYnVnOiBmb3JjZSByZWZyZXNoCgkJbW9kZSwgCgkJZmluZm9f
dmVyc2lvbiwgLS0gbm90IGZpbmZvIGl0c2VsZiEgdG9vIGV4cGVuc2l2ZQoJCW14LCBteSwgbWIs
IHNlbGYubGFzdF9zdGF0ZV9tYiwKCQl0aGVtZSJpY29uMCIsdGhlbWUiaWNvbjEiLHRoZW1lImlj
b24yIix0aGVtZSJpY29uMyIsCgkJc2VsZi5jaGlsZFsxXSBhbmQgc2VsZi5jaGlsZFsxXS5zeSBv
ciBzZWxmLnN5LAoJCXNlbGYuY2hpbGRbMV0gYW5kIHNlbGYuY2hpbGRbMV0uc3ggb3Igc2VsZi5z
eCwKCQlzZWxmLndpZHRoLCBzZWxmLmhlaWdodCAtLSBwZXJoYXBzIHNob3VsZCBiZSBzdGFuZGFy
ZCwgaGFuZGxlZCBpbiBndWkubHVhIChhbG9uZyB3aXRoIHNjcm9sbGluZykKCX0KCXNlbGYubGFz
dF9zdGF0ZV9tYiA9IG1iCgoJcmV0dXJuIHBvZChyZXQpCmVuZAoKCi0tIHJlYWxseSBtZWFuczog
Y29weSBsaXN0IG9mIGZpbGUgcmVmZXJlbmNlcyB0byBjbGlwYm9hcmQKZnVuY3Rpb24gY29weV9z
ZWxlY3RlZF9maWxlcyhvcCkKCWxvY2FsIGl0ZW1zID0ge30KCWZvciBrLHYgaW4gcGFpcnMoZmlu
Zm8pIGRvCgkJaWYgKHYuc2VsZWN0ZWQpIHRoZW4KCQkJdi5mdWxscGF0aCA9IGZ1bGxwYXRoX3Vu
c2FuZGJveCh2LmZpbGVuYW1lKQoJCQl2Lm9wID0gb3AKCQkJYWRkKGl0ZW1zLCB2KQoJCWVuZAoJ
ZW5kCglzZXRfY2xpcGJvYXJkKHBvZChpdGVtcywweDcse3BvZF90eXBlPSJmaWxlX3JlZmVyZW5j
ZXMifSkpCglpZiBvcCA9PSAiY29weSIgdGhlbgoJCW5vdGlmeSgiY29waWVkICIuLiNpdGVtcy4u
IiBpdGVtcyB0byBjbGlwYm9hcmQiKQoJZWxzZQoJCW5vdGlmeSgibWFya2VkICIuLiNpdGVtcy4u
IiBpdGVtcyBmb3IgbW92ZSIpCgllbmQKZW5kCgoKZnVuY3Rpb24gZGVsZXRlX3NlbGVjdGVkX2Zp
bGVzKCkKCglta2RpcigiL3JhbS9jb21wb3N0IikKCQoJbG9jYWwgbnVtID0gMAoJbG9jYWwgZXJy
Cglmb3Igayx2IGluIHBhaXJzKGZpbmZvKSBkbwoJCWlmICh2LnNlbGVjdGVkKSB0aGVuCgkJCWxv
Y2FsIGZ1bGxwYXRoID0gZnVsbHBhdGgodi5maWxlbmFtZSkKCQkJbG9jYWwgcmVzID0gbXYoZnVs
bHBhdGgsICIvcmFtL2NvbXBvc3QvIi4uZnVsbHBhdGg6YmFzZW5hbWUoKSkKCQkJaWYgKHJlcykg
ZXJyID0gcmVzCgkJCW51bSArPSAxCgkJZW5kCgllbmQKCWlmIChlcnIpIHRoZW4KCQlub3RpZnko
Im1vdmVkICIuLm51bS4uIiBpdGVtcyB0byAvcmFtL2NvbXBvc3QgLy8gKiogZXJyb3IgKiogIi4u
ZXJyKQoJZWxzZQoJCW5vdGlmeSgibW92ZWQgIi4ubnVtLi4iIGl0ZW1zIHRvIC9yYW0vY29tcG9z
dCIpCgllbmQKCgl1cGRhdGVfZmlsZV9pbmZvKHRydWUpCgplbmQKCgotLSBtZWFucyAic3RhcnQg
ZHJhZ2dpbmciCmZ1bmN0aW9uIGRyYWdfc2VsZWN0ZWRfZmlsZXMobXNnKQoJCgkKCS0tIHNraXAg
aWYgYWxyZWFkeSBkcmFnZ2luZyBmaWxlcyBvciBoYXZlbid0IG1vdmVkIGZhciBlbm91Z2ggZnJv
bSBpbml0aWFsIHBvaW50CglpZiAoZHJhZ2dpbmdfZmlsZXMpIHJldHVybgoKCS0tIDAuMS4xZDog
Y2hhbmdlZCB0byA8IDIgZnJvbSA8IDMKCWlmIChhYnMobXNnLm14IC0gbXNnLm14MCkgPCAyIGFu
ZCBhYnMobXNnLm15IC0gbXNnLm15MCkgPCAzKSByZXR1cm4KCgoJLS0gbGlzdDogcmVsYXRpdmUg
aXRlbSBwb3NpdGlvbnMgbm90IHNldCB5ZXQuIGNhbGN1bGF0ZSBoZXJlCglpZiBtb2RlID09ICJs
aXN0IiB0aGVuCgkJbG9jYWwgbXgsbXk9bW91c2UoKQoJCWxvY2FsIG51bSA9IDAKCQlmb3IgaT0x
LCNmaSBkbwoJCQlpZiAoZmlbaV0uZmluZm8uc2VsZWN0ZWQpIG51bSArPSAxCgkJZW5kCgkJbG9j
YWwgaWR4ID0gMAoJCWZvciBpPTEsI2ZpIGRvCgkJCWlmIChmaVtpXS5maW5mby5zZWxlY3RlZCkg
dGhlbgoJCQkJZmlbaV0uZmluZm8ueCA9IG14IC0gOAoJCQkJZmlbaV0uZmluZm8ueSA9IG15IC0g
bnVtKjItMitpZHgqMiAtIDQKCQkJCWlkeCArPSAxCQoJCQllbmQKCQllbmQKCWVuZAoKCgkKCXVw
ZGF0ZV9jb250ZXh0X21lbnUoKQoJCglkcmFnZ2luZ19maWxlcyA9IHt9CgoJbG9jYWwgaWR4PTAK
Cglmb3Igayx2IGluIHBhaXJzKGZpbmZvKSBkbwoJCWlmICh2LnNlbGVjdGVkKSB0aGVuCgkJCWxv
Y2FsIHYwPXYKCQkJdiA9IHVucG9kKHBvZCh2KSkgLS0gbWFrZSBhIGNvcHkKCQkJdi5mdWxscGF0
aCA9IGZ1bGxwYXRoKHYuZmlsZW5hbWUpCgkJCWxvY2FsIG14LCBteSA9IG1vdXNlKCkKCQkJLS0g
MC4xLjBjOiBzZXQgb2Zmc2V0cyBoZXJlICh3bSBoYW5kbGVzIHRoaXMsIGJ1dCBtb3VzZSBtb3Zl
ZCBieSB0aGUgdGltZSBtZXNzYWdlIGFycml2ZXMpCgkJCXYueG8gPSB2LnggYW5kICh2LnggLSBt
eCkgb3IgMAoJCQl2LnlvID0gdi55IGFuZCAodi55IC0gbXkpIG9yIDAKCgkJCS0tIGJ1cm4gaW4g
cGFsZXR0ZQoJCQlpZiAodi5sb3djb2xfaWNvbiBvciBzZXR0aW5ncy5sb3djb2xfaWNvbnMpIHRo
ZW4KCQkJCW1lbW1hcChpY29uX3BhbCwgMHg4MDAwKQoJCQkJdi5pY29uID0gdXNlcmRhdGEoInU4
IiwxNiwxNikKCQkJCXNldF9kcmF3X3RhcmdldCh2Lmljb24pCgkJCQlzcHIodjAuaWNvbiwwLDAp
CgkJCQlzZXRfZHJhd190YXJnZXQoKQoJCQkJdW5tYXAoaWNvbl9wYWwsMHg4MDAwKQoJCQllbmQK
CgkJCWFkZChkcmFnZ2luZ19maWxlcywgdikKCQkJLS1wcmludGgoImFkZGVkICIuLnYuZnVsbHBh
dGguLnN0cmluZy5mb3JtYXQoIiAlZCAlZCIsdi54LHYueSkpCgkJZW5kCgllbmQKCQoJLS0tLS0t
LSAgc29ydCBieSBkaXN0YW5jZSB0byBtb3VzZSBjdXJzb3IgKGdyaWQsIGRlc2t0b3ApCglsb2Nh
bCBteCwgbXkgPSBtb3VzZSgpCgoJZm9yIGk9MSwjZHJhZ2dpbmdfZmlsZXMgZG8KCQlsb2NhbCB2
ID0gZHJhZ2dpbmdfZmlsZXNbaV0KCQl2LmRpc3QgPSAodi54IC0gbXgpXjIgKyAodi55IC0gbXkp
XjIKCQktLXYuZGlzdCA9IHYueG9eMiArIHYueW9eMgoJZW5kCgoJbG9jYWwgdGJsID0gZHJhZ2dp
bmdfZmlsZXMKCWZvciBwYXNzPTEsI3RibCBkbwoJCWZvciBpPTEsI3RibC0xIGRvCgkJCWlmICh0
YmxbaV0uZGlzdCA9PSB0YmxbaSsxXS5kaXN0IGFuZCB0YmxbaV0uZmlsZW5hbWUgPiB0YmxbaSsx
XS5maWxlbmFtZSkgb3IKCQkJCXRibFtpXS5kaXN0ID4gdGJsW2krMV0uZGlzdAoJCQl0aGVuCgkJ
CQl0YmxbaV0sdGJsW2krMV0gPSB0YmxbaSsxXSx0YmxbaV0KCQkJZW5kCgkJZW5kCgllbmQKCgkJ
CglpZiAoI2RyYWdnaW5nX2ZpbGVzID4gMCkgdGhlbgoJCS0tIHNlbmQgYSBtZXNzYWdlIHRvIHdp
bmRvdyBtYW5hZ2VyCgkJc2VuZF9tZXNzYWdlKDMsewoJCQlldmVudCA9ICJkcmFnX2l0ZW1zIiwK
CQkJaXRlbXMJID0gZHJhZ2dpbmdfZmlsZXMKCQl9KQoJZWxzZQoJCWRyYWdnaW5nX2ZpbGVzID0g
bmlsIC0tIGNhbmNlbDsgbm90aGluZyB0byBkcmFnCgllbmQKCQkKZW5kCgoKCmZ1bmN0aW9uIHVw
ZGF0ZV9maWxlX2luZm8oY2xlYXIpCgotLQlwcmludGgoInVwZGF0ZV9maWxlX2luZm8uLiIpCglm
aW5mb192ZXJzaW9uICs9IDEKCgktLSBmb3IgZGVidWdnaW5nOyBjbGVhciB3aGVuIGludGVyZmFj
ZSBpcyByZWdlbmVyYXRlZAoJLS0gdXBkYXRlOiB1c2VkIHRvIHVwZGF0ZSBpY29ucyB2aWEgZmls
ZW5hdl9yZWZyZXNoIGJyb2FkY2FzdGVkIG1lc3NhZ2UKCWlmIChjbGVhcikgdGhlbgoJCWZpbmZv
ID0ge30KCQlsYXN0X2ZpbGVzX3BvZCA9IG5pbAoJCWxhc3RfaW5kZXggPSBuaWwKCWVuZAoJCgl1
cGRhdGVfY29udGV4dF9tZW51KCkKCQoJaWYgKGNkX2ZhaWxlZCkgdGhlbgoJCWZpbGVuYW1lcyA9
IHt9CgkJcmV0dXJuCgllbmQKCQoJLS0gZmV0Y2ggY3VycmVudCBsaXN0Cglsb2NhbCBmaWxlcyA9
IGxzKHB3ZCgpKSBvciB7fSAtLSB0byBkbzogbmlsIHJldHVybiBtZWFucyBjb3VsZG4ndCBsaXN0
OyBzb21lIHZpc3VhbCBpbmRpY2F0aW9uIHRoYXQgcGF0aCBpcyBpbnZhbGlkIChjZCBzaG91bGQg
ZmFpbCBmaXJzdCB0aG91Z2ggYW55d2F5PykKCQoJLS0gbm8gY2hhbmdlOyBubyBuZWVkIHRvIHVw
ZGF0ZQoJbG9jYWwgZmlsZXNfcG9kID0gcG9ke21vZGUscHdkKCksZmlsZXN9CglpZiAoZmlsZXNf
cG9kID09IGxhc3RfZmlsZXNfcG9kKSB0aGVuCgkJcmV0dXJuCgllbmQKCQoJbGFzdF9maWxlc19w
b2QgPSBmaWxlc19wb2QKCQoJZmlsZW5hbWVzID0ge30KCgktLSBzZWFyY2ggZm9yIGFkZGVkIC9j
aGFuZ2VkIGZpbGVzCglsb2NhbCBmb3VuZCA9IHt9Cglmb3IgaT0xLCNmaWxlcyBkbwoJCWxvY2Fs
IGZpbGVuYW1lID0gZmlsZXNbaV0KCQlpZiAoZmlsZW5hbWUpIHRoZW4gLS0gdG8gZG86IHdoeSBp
cyB0aGlzIG5pbCBzb21ldGltZT8gKG9ic2VydmVkIGluIGJicyBwbGF5ZXIpCgkJCWZvdW5kW2Zp
bGVuYW1lXSA9IHRydWUKCQkJaWYgKG5vdCBmaW5mb1tmaWxlbmFtZV0pIGZpbmZvW2ZpbGVuYW1l
XSA9IHt9CgkJCWxvY2FsIGYgPSBmaW5mb1tmaWxlbmFtZV0KCQkJCgkJCS0tbG9jYWwgYXR0cmli
LCBzaXplLCBtb3VudF9kZXNjID0gImZpbGUiLCAwLCBuaWwgLS1mc3RhdChmaWxlbmFtZSkKCQkJ
bG9jYWwgYXR0cmliLCBzaXplLCBtb3VudF9kZXNjID0gZnN0YXQoZmlsZW5hbWUpCgkJCQoJCgkJ
CS0tIHVwZGF0ZSAvIGNyZWF0ZSBpbmZvCgkJCWYucG9kX3R5cGUgICAgPSAiZmlsZV9yZWZlcmVu
Y2UiIC0tIHVzZWQgYnkgZHJhZ2dpbmdfaXRlbXMKCQkJZi5maWxlbmFtZSAgICA9IGZpbGVuYW1l
CgkJCWYuZnVsbHBhdGggICAgPSBmdWxscGF0aChmaWxlbmFtZSkKCQkJZi5zZWxlY3RlZCAgICA9
IGYuc2VsZWN0ZWQgb3IgZmFsc2UKCQkJZi5hdHRyaWIgICAgICA9IGYuYXR0cmliIG9yIGF0dHJp
YgoJCQlmLnNpemUgICAgICAgID0gZi5zaXplIG9yIHNpemUKCQkJZi5tZXRhICAgICAgICA9IGZl
dGNoX21ldGFkYXRhKGZpbGVuYW1lKSBvciB7fQoJCQlmLmljb24sIAoJCQlmLmxvd2NvbF9pY29u
ID0gZ2V0X2ZpbGVfaWNvbihmaWxlbmFtZSwgZi5tZXRhKQoJCQlmLmluZGV4ICAgICAgID0gaQoJ
CQlmLmlzX25vbl9jYXJ0X2ZvbGRlciA9IGZhbHNlCgkJCgkJCS0tIGRlcml2ZSBwcmludGFibGUg
ZmlsZW5hbWUgKGhhcyBmb2xkZXIgaWNvbiBpbmZyb250IGZvciBmb2xkZXJzIHRoYXQgYXJlbid0
IGNhcnRzMAoJCQlmLmZpbGVuYW1lX3ByaW50YWJsZSA9IGYuZmlsZW5hbWUKCQkJCgkJCWlmIChm
LmF0dHJpYiA9PSAiZm9sZGVyIikgdGhlbgoJCQkJaWYgaXNfY2FydChmLmZpbGVuYW1lKSB0aGVu
CgkJCQkJLS0gY2FydCBpY29uPwkKCQkJCQktLSBmLmZpbGVuYW1lX3ByaW50YWJsZSA9ICJcXjow
MGZmODE4MWZmYzE3ZjAwICIuLmYuZmlsZW5hbWVfcHJpbnRhYmxlCgkJCQllbHNlCgkJCQkJZi5p
c19ub25fY2FydF9mb2xkZXIgPSB0cnVlCgkJCQkJZi5maWxlbmFtZV9wcmludGFibGUgPSAiXF46
MDAzODdmN2Y3ZjdmN2YwMCAiLi5mLmZpbGVuYW1lX3ByaW50YWJsZQoJCQkJZW5kCgkJCWVuZAoJ
CgkJCWFkZChmaWxlbmFtZXMsIGYuZmlsZW5hbWUpCgkJZW5kCgllbmQKCQotLVtbCgktLSBjbGVh
ciBvdXQgbWlzc2luZyBpdGVtcwoJZm9yIGssdiBpbiBwYWlycyhmaW5mbykgZG8KCQlpZiAobm90
IGZvdW5kW2tdKSBmaW5mb1trXSA9IG5pbAoJZW5kCl1dCgoKCS0tIHVwZGF0ZSBndWkgZWxlbWVu
dHMKCWlmIChtb2RlID09ICJncmlkIikgZ2VuZXJhdGVfZmVsc19ncmlkKCkKCWlmIChtb2RlID09
ICJsaXN0IikgZ2VuZXJhdGVfZmVsc19saXN0KCkKCWlmIChtb2RlID09ICJkZXNrdG9wIikgZ2Vu
ZXJhdGVfZmVsc19kZXNrdG9wKCkKCQoJLS1wcmludGgoIj09PT09PT09PSB1cGRhdGVkX2ZpbGVf
aW5mbyA9PT09PT09PT0iKQoJLS1wcmludGgocG9kKGZpbmZvKSkKCmVuZAoKZnVuY3Rpb24gb3Bl
bl9zZWxlY3RlZF9maWxlX2luZm8oKQoJZm9yIGssdiBpbiBwYWlycyhmaW5mbykgZG8KCQlpZiAo
di5zZWxlY3RlZCkgdGhlbgoJCQljcmVhdGVfcHJvY2VzcygiL3N5c3RlbS9hcHBzL2Fib3V0LnA2
NCIsIAoJCQl7CgkJCQlhcmd2PXt2LmZ1bGxwYXRofSwKCQkJCXdpbmRvd19hdHRyaWJzID0ge3dv
cmtzcGFjZSA9ICJjdXJyZW50IiwgYXV0b2Nsb3NlPXRydWV9CgkJCX0pCgkJZW5kCgllbmQKZW5k
CgotLSByZWdlbmVyYXRlIGZyb20gc2NyYXRjaCBlYWNoIHRpbWUKLS0gKGVhcmxpZXIsIHRyaWVk
IHBhdGNoaW5nIGNoYW5nZXMgYnV0IGlzIGEgYmFkIHBlcmYvY29tcGxleGl0eSB0cmFkZSkKZnVu
Y3Rpb24gdXBkYXRlX2NvbnRleHRfbWVudSgpCgoJbG9jYWwgd2hpY2ggPSBuaWwKCWxvY2FsIG51
bV9zZWxlY3RlZCA9IDAKCWZvciBrLHYgaW4gcGFpcnMoZmluZm8pIGRvCgkJaWYgKHYuc2VsZWN0
ZWQpIHdoaWNoID0gdi5mdWxscGF0aCAgbnVtX3NlbGVjdGVkICs9IDEKCWVuZAoKCS0tIGNsZWFy
OyBuZWVkIGZvciBkeW5hbWljIG1lbnVzIHdoZXJlIGl0IGlzIGVhc2llciB0byByZWJ1aWxkIGZy
b20gc2NyYXRjaAoJbWVudWl0ZW0oKQoKCgoJLS0gc3BlY2lhbCBjYXNlOiB1bm1vdW50IGhvc3Qg
ZGVza3RvcCAKCWlmIChudW1fc2VsZWN0ZWQgPT0gMSBhbmQgd2hpY2ggPT0gIi9kZXNrdG9wL2hv
c3QiKSB0aGVuCgoJCS0tIGR1cGUKCQltZW51aXRlbXsKCQkJaWQ9Im9wZW5faG9zdF9wYXRoIiwJ
CgkJCWxhYmVsID0gIlxeOjAwMzA0ZjQxNDE0MTdmMDAgT3BlbiBIb3N0IE9TIEZvbGRlciIsCgkJ
CWFjdGlvbiA9IGZ1bmN0aW9uKCkgc2VuZF9tZXNzYWdlKDIsIHtldmVudD0ib3Blbl9ob3N0X3Bh
dGgiLCBwYXRoID0gIi9kZXNrdG9wL2hvc3QiLCBfZGVsYXkgPSAwLjI1fSkgZW5kCgkJfQoKCQkt
LSB0byBkbzogaGFuZGxlIHVubW91bnRpbmcgaW4gYSBtb3JlIGdlbmVyYWwgd2F5ICh3aGVuIHRo
ZXJlIGFyZSBtb3JlIHRoaW5ncyB0byBtb3VudCkKCQltZW51aXRlbXsKCQkJaWQ9InVubW91bnRf
aG9zdF9kZXNrdG9wIiwJCgkJCWxhYmVsID0gIlxeOjAwMmEwMTIwMDEyMDE1MDAgVW5tb3VudCIs
CgkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkgcm0iL2Rlc2t0b3AvaG9zdCIgZW5kCgkJfQoJCXJldHVy
bgoJZW5kCgoKCgktLSAwLiBoZWFkZXIgLy8gc2hvd3MgbWFpbiBjb250ZXh0ICh3aGF0IGlzIHNl
bGVjdGVkKQoKCWlmIChudW1fc2VsZWN0ZWQgPT0gMCkgdGhlbgoJCS0tW1sKCQltZW51aXRlbXsK
CQkJaWQ9ImZpbGVfaW5mbyIsCgkJCWxhYmVsPSJEZXNrdG9wIgoJCX0KCQldXQoJZWxzZWlmIChu
dW1fc2VsZWN0ZWQgPT0gMSkgdGhlbgoJCW1lbnVpdGVtewoJCQlpZD0iZmlsZV9pbmZvIiwJCgkJ
CWxhYmVsID0gIkFib3V0ICIuLndoaWNoOmJhc2VuYW1lKCksCgkJCS0tbGFiZWwgPSAiXF46MWMz
NjdmNzc3NzM2MWMwMCBBYm91dCAiLi53aGljaDpiYXNlbmFtZSgpLAoJCQktLWxhYmVsID0gIlxe
OjFjMzY3Zjc3NzczNjFjMDAgIi4ud2hpY2g6YmFzZW5hbWUoKSwKCQkJLS1zaG9ydGN1dCA9ICJD
dHJsLUkiLCAtLSBkb2Vzbid0IGZpdCBmb3IgbG9uZyBmaWxlc25hbWVzOyBqdXN0IGRvbid0IHNo
b3cgdGhpcyBzaG9ydGN1dCEKCQkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQkJY3JlYXRlX3Byb2Nl
c3MoIi9zeXN0ZW0vYXBwcy9hYm91dC5wNjQiLCAKCQkJCQl7YXJndj17d2hpY2h9LCB3aW5kb3df
YXR0cmlicz17d29ya3NwYWNlID0gImN1cnJlbnQiLCBhdXRvY2xvc2U9dHJ1ZX19KQkJCQkKCQkJ
ZW5kCgkJfQoJZWxzZQoJCW1lbnVpdGVtewoJCQlpZD0iZmlsZXNfaW5mbyIsCi0tCQkJbGFiZWw9
bnVtX3NlbGVjdGVkLi4iIEl0ZW1zICAgICAgICAgXGY2XF5pRGVzZWxlY3QiLAotLQkJCWFjdGlv
biA9IGZ1bmN0aW9uKCkgZGVzZWxlY3RfYWxsKCkgIHNlbCA9IG5pbCBlbmQKCQkJbGFiZWw9bnVt
X3NlbGVjdGVkLi4iIEl0ZW1zIiwKCQl9CgllbmQKCgktLSAxYjogdmlldyBjb250ZW50cyBvZiBj
YXJ0cmlkZ2UKCglpZiAobnVtX3NlbGVjdGVkID09IDEpIHRoZW4KCQkKCQlpZiBpc19jYXJ0KHdo
aWNoKSB0aGVuCgoJCQltZW51aXRlbXtkaXZpZGVyPXRydWV9CgoJCQltZW51aXRlbXsKCQkJCWlk
PSJzaG93X2NhcnRfY29udGVudHMiLAkKCQkJCWxhYmVsID0gIlxeOjAwN2Y0MTQxN2Y2MTNmMDAg
U2hvdyBDYXJ0IENvbnRlbnRzIiwKCQkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkKCQkJCQljcmVhdGVf
cHJvY2VzcygiL3N5c3RlbS9hcHBzL2ZpbGVuYXYucDY0IiwKCQkJCQl7IAoJCQkJCQlhcmd2ID0g
ewoJCQkJCQkJZnVsbHBhdGgod2hpY2gpLCAKCQkJCQkJCWZ1bGxwYXRoKHdoaWNoKQoJCQkJCQl9
CgkJCQkJfSkKCQkJCWVuZAoJCQl9CgkJCW1lbnVpdGVtewoJCQkJaWQ9ImxvYWRfY2FydCIsCQoJ
CQkJbGFiZWwgPSAiXF46MDA3ZjQxNDE3ZjYxM2YwMCBMb2FkIENhcnRyaWRnZSIsCgkJCQlhY3Rp
b24gPSBmdW5jdGlvbigpCgkJCQkJY3JlYXRlX3Byb2Nlc3MoIi9zeXN0ZW0vbWlzYy9jb25maXJt
LnA2NCIsIAoJCQkJCQl7cHJvbXB0ID0gIkRpc2NhcmQgVW5zYXZlZCBDaGFuZ2VzPyIsIHRpdGxl
ID0gIkxvYWQiLCAKCQkJCQkJY2FydF90b19sb2FkID0gZnVsbHBhdGgod2hpY2gpLAoJCQkJCQl3
aW5kb3dfYXR0cmlicyA9IHt3b3Jrc3BhY2U9ImN1cnJlbnQiLCBhdXRvY2xvc2U9dHJ1ZX19KQoJ
CQkJCS0tIGNyZWF0ZV9wcm9jZXNzKCIvc3lzdGVtL3V0aWwvbG9hZC5sdWEiLCB7IGFyZ3YgPSB7
ZnVsbHBhdGgod2hpY2gpfSB9KQoJCQkJZW5kCgkJCX0KCQllbmQKCWVuZAoKCglpZiAobnVtX3Nl
bGVjdGVkID4gMCkgbWVudWl0ZW17ZGl2aWRlcj10cnVlfQoKCQoKCgoJLS0gMWEuIG9wZXJhdGlv
bnMgb24gc2VsZWN0ZWQgZmlsZXMKCglpZiAobnVtX3NlbGVjdGVkID4gMCkgdGhlbgoKCQltZW51
aXRlbXsKCQkJaWQ9ImN1dF9maWxlcyIsCQoJCQlsYWJlbCA9ICJcXjowMDE1MjAwMTIwMDEyYTAw
IEN1dCIsCgkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkgY29weV9zZWxlY3RlZF9maWxlcygiY3V0Iikg
ZW5kCgkJfQoJCW1lbnVpdGVtewoJCQlpZD0iY29weV9maWxlcyIsCQoJCQlsYWJlbCA9ICJcXjow
ZjAxM2QyNTI1MjQzYzAwIENvcHkiLAoJCQlhY3Rpb24gPSBmdW5jdGlvbigpIGNvcHlfc2VsZWN0
ZWRfZmlsZXMoImNvcHkiKSBlbmQKCQl9CgkJbWVudWl0ZW17CgkJCWlkPSJkZWxldGVfZmlsZSIs
CQoJCQlsYWJlbCA9ICJcXjozZTdmNWQ1ZDc3M2UyYTAwIERlbGV0ZSIsCgkJCS0tIGxhYmVsID0g
IlxeOjNlN2Y1ZDVkNzczZTJhMDAgTW92ZSB0byBDb21wb3N0IiwgLS0gdG8gZG86IG5lZWQgaWNv
biArIGNvbXBvc3Qgd2lkZ2V0IAoJCQlhY3Rpb24gPSBkZWxldGVfc2VsZWN0ZWRfZmlsZXMKCQl9
CgkJCgkJaWYgbnVtX3NlbGVjdGVkID09IDEgdGhlbgoJCQltZW51aXRlbXsKCQkJCWlkPSJyZW5h
bWUiLAoJCQkJbGFiZWwgPSAiXF46MGYxOTM5MjEyMTNmMDAxNSBSZW5hbWUiLAoJCQkJYWN0aW9u
ID0gZnVuY3Rpb24oKQoJCQkJCXB1c2hfaW50ZW50aW9uKCJyZW5hbWUiLCBuaWwsIHdoaWNoLCB0
cnVlKQoJCQkJZW5kCgkJCX0KCQllbmQKCgkJbWVudWl0ZW17ZGl2aWRlcj10cnVlfQoJZW5kCgoJ
LS0gMWIuIG5vdGhpbmcgc2VsZWN0ZWQgLT4gY3JlYXRlIG5ldyBpdGVtcyAvIHBhc3RlCgoJaWYg
KG51bV9zZWxlY3RlZCA9PSAwKSB0aGVuCgoJCS0tIGNoZWNrIGNsaXBib2FyZAoKCQlsb2NhbCBw
LCBtID0gdW5wb2QoZ2V0X2NsaXBib2FyZCgpKQkKCQlpZiBtIGFuZCBtLnBvZF90eXBlID09ICJm
aWxlX3JlZmVyZW5jZXMiIGFuZCB0eXBlKHApID09ICJ0YWJsZSIgdGhlbgkKCQkJbWVudWl0ZW17
CgkJCQlpZCA9ICJwYXN0ZV9maWxlcyIsCgkJCQlsYWJlbCA9ICJcXjoxZTJkMjEyMTIxMjEzZjAw
IFBhc3RlICIuLiNwLi4iIEl0ZW0iLi4oI3AgPT0gMSBhbmQgIiIgb3IgInMiKSwKCgkJCQlhY3Rp
b24gPSBmdW5jdGlvbigpIAoJCQkJCWxvY2FsIG14LG15LG1iID0gbW91c2UoKQoJCQkJCXNlbmRf
bWVzc2FnZShwaWQoKSwge2V2ZW50PSJkcm9wX2l0ZW1zIiwgCgkJCQkJCWl0ZW1zID0gcCwKCQkJ
CQkJZHggPSAwLCBkeSA9IDAsCgkJCQkJCW14ID0gbXgsIG15ID0gbXksIC0tIChkcm9wIHdoZXJl
IHRoZSBjb250ZXh0IG1lbnUgaXRlbSBpcyEpCgkJCQkJCS0tIGhvbGQgY3RybCAvIHNoaWZ0IHRv
IG1vZGlmeSBkcm9wIGFjdGlvbiAoZS5nLiBpbiBmaWxlbmF2IG1lYW5zIGZvcmNlIG92ZXJ3cml0
ZSkKCQkJCQkJLS0gY2FuIHVzZSBmcm9tIGNvbnRleHQgbWVudSEKCQkJCQkJY3RybCA9IGtleSJj
dHJsIiwgc2hpZnQgPSBrZXkic2hpZnQiLCAKCQkJCQl9KQoJCQkJZW5kCgkJCX0KCQkJbWVudWl0
ZW17ZGl2aWRlcj10cnVlfQoJCWVuZAoKCQltZW51aXRlbXsKCQkJaWQgPSAibmV3X2ZpbGUiLAoJ
CQlsYWJlbCA9ICJcXjowZjE5MzkyMTIxMjEzZjAwIE5ldyBGaWxlIiwKCQkJYWN0aW9uID0gZnVu
Y3Rpb24oKSBwdXNoX2ludGVudGlvbigibmV3X2ZpbGUiLCBuaWwsIG5pbCwgdHJ1ZSkgZW5kCgkJ
fQoJCQoJCW1lbnVpdGVtewoJCQlpZCA9ICJuZXdfZm9sZGVyIiwKCQkJbGFiZWwgPSAiXF46MDAz
ODdmN2Y3ZjdmN2YwMCBOZXcgRm9sZGVyIiwKCQkJYWN0aW9uID0gZnVuY3Rpb24oKSAKCQkJCXB1
c2hfaW50ZW50aW9uKCJuZXdfZm9sZGVyIiwgbmlsLCBuaWwsIHRydWUpCgkJCWVuZAoJCX0KCgkJ
bWVudWl0ZW17CgkJCWlkID0gIm5ld19jYXJ0IiwKCQkJbGFiZWwgPSAiXF46MDA3ZjQxNDE3ZjYx
M2YwMCBOZXcgQ2FydHJpZGdlIiwKCQkJYWN0aW9uID0gZnVuY3Rpb24oKSAKCQkJCWNyZWF0ZV9w
cm9jZXNzKCIvc3lzdGVtL21pc2MvY29uZmlybS5wNjQiLCB7cHJvbXB0ID0gIkRpc2NhcmQgVW5z
YXZlZCBDaGFuZ2VzPyIsIHRpdGxlID0gIk5ldyBDYXJ0IiwgY2FydF9wYXRoID0gcHdkKCl9KQoJ
CQkJLS0gcHVzaF9pbnRlbnRpb24oIm5ld19jYXJ0cmlkZ2UiLCBuaWwsIG5pbCwgdHJ1ZSkKCQkJ
ZW5kCgkJfQoKCQltZW51aXRlbXtkaXZpZGVyPXRydWV9CgoJZW5kCgoJLS0gMmE6IG9wZW4gKHNh
bWUgYXMgZG91YmxlLWNsaWNraW5nOyBzaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIFBpY290cm9u
IHdpdGhvdXQgZXZlciBkb3VibGUtY2xpY2tpbmc-KQoKCS0tW1sKCQltZW51aXRlbXsKCQkJaWQ9
Im9wZW5faXRlbSIsCQoJCQlsYWJlbCA9ICJcXjowMDMwNGY0MTQxNDE3ZjAwIE9wZW4iLAoJCQlh
Y3Rpb24gPSBmdW5jdGlvbigpCgkJCQktLSBzYW1lIGFzIGNsaWNraW5nCgkJCWVuZAoJCX0KCV1d
CgoKCS0tIDJiOiBzdGVwIG92ZXIgaW50byBhbnl3aGVuCgktLSB0byBkbzogY291bGQgc2hvdyBk
ZXNrdG9wIGF0IGRpZmZlcmVudCB0aW1lcz8gcmVsb2FkIGZpbGUgaXRlbXMgZnJvbSB0ZXJtcG9y
YWwgLmluZm8ucG9kIGFuZCBsZXQgaWNvbnMganVtcCBhcm91bmQ-IHlpa2VzIG5vcGUuCglpZiAo
bW9kZSB_PSAiZGVza3RvcCIgYW5kIHdoaWNoIH49ICJAIiBhbmQgbm90IHN0cmluZy5maW5kKHB3
ZCgpLCJAIiwxLHRydWUpKQoJdGhlbgoJCS0tIGRvbid0IHNob3cgdXAgZm9yIGZpbGVzIGluc2lk
ZSBhIGNhcnQKCQlpZiB3aGljaCBhbmQgbm90IChzdHJpbmcuZmluZCh3aGljaCwiLnA2NC8iLDEs
dHJ1ZSkgb3Igc3RyaW5nLmZpbmQod2hpY2gsIi5wNjQucm9tLyIsMSx0cnVlKSBvciBzdHJpbmcu
ZmluZCh3aGljaCwiLnA2NC5wbmcvIiwxLHRydWUpKSB0aGVuCgkJCgkJCW1lbnVpdGVtewoJCQkJ
aWQ9Im9wZW5fcGF0aF9pbl9hbnl3aGVuIiwJCgkJCQlsYWJlbCA9ICJcXjo3ZjdkN2I3ZDdmMDgz
ZTAwIEFueXdoZW4iLAoJCQkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQkJCWNkKHdoaWNoLi4iL0Ai
KQoJCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQkJZW5kCgkJCX0KCQllbmQKCWVuZAoJCgoJLS0g
MmM6IG9wZW4gaG9zdCBmb2xkZXIgKHRvIGRvOiBjb3VsZCBhbHdheXMgYWRkIGFuZCBjaGVjayBv
cmlnaW4gd2hlbiBvcGVuaW5nKQoKCWxvY2FsIGtpbmQsIHNpemUsIG9yaWdpbiA9IGZzdGF0KHB3
ZCgpKQoKCWlmIChraW5kID09ICJmb2xkZXIiKSB0aGVuCgoJCQltZW51aXRlbXsKCQkJCWlkPSJv
cGVuX3BhdGhfaW5fdGVybWluYWwiLAkKCQkJCWxhYmVsID0gIlxeOjdmN2Q3YjdkN2YwODNlMDAg
T3BlbiBJbiBUZXJtaW5hbCIsCgkJCQlhY3Rpb24gPSBmdW5jdGlvbigpCgkJCQkJY3JlYXRlX3By
b2Nlc3MoIi9zeXN0ZW0vYXBwcy90ZXJtaW5hbC5sdWEiLCB7CgkJCQkJCWFyZ3Y9e3doaWNofSwK
CQkJCQkJcGF0aCA9IGZ1bGxwYXRoX3Vuc2FuZGJveChwd2QoKSkKCQkJCQl9KQoJCQkJZW5kCgkJ
CX0KCgoJCWlmIChub3Qgb3JpZ2luKSB0aGVuCgkJCW1lbnVpdGVtewoJCQkJaWQ9Im9wZW5faG9z
dF9wYXRoIiwJCgkJCQlsYWJlbCA9ICJcXjowMDMwNGY0MTQxNDE3ZjAwIE9wZW4gSG9zdCBPUyBG
b2xkZXIiLAoJCQkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQkJCXNlbmRfbWVzc2FnZSgyLCB7ZXZl
bnQ9Im9wZW5faG9zdF9wYXRoIiwgcGF0aCA9IGZ1bGxwYXRoX3Vuc2FuZGJveChwd2QoKSksIF9k
ZWxheSA9IDAuMjV9KQoJCQkJZW5kCgkJCX0KCQllbmQKCWVuZAoKCgktLSAyZC4gb3BlbiBpdGVt
IGluIGhvc3QgKGhvdyB0byBsYWJlbCB0aGlzPykKCglpZiAobnVtX3NlbGVjdGVkID09IDEpIHRo
ZW4KCQlraW5kLCBzaXplLCBvcmlnaW4gPSBmc3RhdCh3aGljaCkKCQlpZiAoa2luZCA9PSAiZmls
ZSIpIHRoZW4KCQkJbWVudWl0ZW17CgkJCQlpZD0ib3Blbl9ob3N0X3BhdGgiLAkKCQkJCWxhYmVs
ID0gIlxeOjBiMWIzYjAzM2YzZjNmMDAgVmlldyBpbiBIb3N0IE9TIiwKCgkJCQlhY3Rpb24gPSBm
dW5jdGlvbigpCgkJCQkJLS0gZGVsYXkgc28gdGhhdCBtb3VzZSBpc24ndCBoZWxkIHdoaWxlIG5l
dyB3aW5kb3cgaXMgb3BlbmluZyAuXy4KCQkJCQlzZW5kX21lc3NhZ2UoMiwge2V2ZW50PSJvcGVu
X2hvc3RfcGF0aCIsIHBhdGggPSBmdWxscGF0aF91bnNhbmRib3god2hpY2gpLCBfZGVsYXkgPSAw
LjI1fSkgCgkJCQllbmQKCQkJfQoJCWVuZAoJZW5kCgoJCgktLSAyZS4gbW91bnQgaG9zdCBkZXNr
dG9wCgkKCWlmIChudW1fc2VsZWN0ZWQgPT0gMCBhbmQgbm90IGZzdGF0KCIvZGVza3RvcC9ob3N0
IikpIHRoZW4KCQltZW51aXRlbXsKCQkJaWQ9Im1vdW50X2hvc3RfZGVza3RvcCIsCQoJCQlsYWJl
bCA9ICJcXjowMDMwNGY0MTQxNDE3ZjAwIE1vdW50IEhvc3QgRGVza3RvcCIsCgkJCWFjdGlvbiA9
IGZ1bmN0aW9uKCkKCQkJCXNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9Im1vdW50X2hvc3RfZGVza3Rv
cCJ9KQoJCQllbmQKCQl9CgllbmQKCgplbmQKCgoKOjogZ3JpZC5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yMCAwNjoyNzo1OSIsbW9kaWZpZWQ9IjIwMjUtMDQtMTkg
MTk6MjA6NDIiLHJldmlzaW9uPTMxNTYsc3RvcmVkPSIyMDIzLTIxLTI5IDA5OjIxOjE5Il1dCi0t
IG1vZGU6IGljb25zIG9uIGEgZ3JpZCAoZGVmYXVsdCBmb2xkZXIgdmlldzsgaXMgY3V0ZXN0IGZv
ciA8IH4xMDAgZmlsZXMpCmxvY2FsIHNlbCA9IG5pbApsb2NhbCBmdW5jdGlvbiBjcmVhdGVfZmls
ZV9pdGVtKHBhcmVudCwgZmYsIHgsIHkpCglpZiAobm90IGZmIG9yIG5vdCBmZi5maWxlbmFtZSkg
cmV0dXJuCglsb2NhbCBlbCA9IHsKCQl4ID0geCwgeSA9IHksCgkJd2lkdGg9NjQsIGhlaWdodD00
NiwKCQlmaW5mbyAgICA9ICBmZiwKCQlmaWxlbmFtZSA9IGZmLmZpbGVuYW1lLAoJCXBhcmVudCA9
IHBhcmVudCwKCX0KCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWRyYWdfc2VsZWN0ZWRfZmlsZXMo
bXNnKQoJZW5kCglmdW5jdGlvbiBlbDpyZWxlYXNlKG1zZykKCQlkcmFnZ2luZ19maWxlcyA9IG5p
bAoJZW5kCgkKCQoJLS0gbmVlZCB0byB0ZXN0IGluIGN1c3RvbSBjbGljayBldmVudCBiZWxvdwoJ
ZnVuY3Rpb24gZWw6dGVzdF9wb2ludCh4LCB5KQoJCQoJCWxvY2FsIGxsID0gZWwubGFzdF9sYWJl
bF9hcmVhCgkJaWYgKG5vdCBsbCkgcmV0dXJuIHRydWUKCQkKCQktLSBzcHJpdGUgcGl4ZWwgaXMg
c2V0LCBvciBpbnNpZGUgZmlsZW5hbWUgbGFiZWwKCQlyZXR1cm4gZ2V0KHNlbGYuZmluZm8uaWNv
biwgeCAtIGxsWzVdLCB5IC0gbGxbNl0pID4gMAoJCQlvciBsbCBhbmQgeCA_PSBsbFsxXSBhbmQg
eSA_PSBsbFsyXSBhbmQgeCA8PSBsbFszXSBhbmQgeSA8PSBsbFs0XQkKCWVuZAoJCgktLSBkcmF3
IGljb24gb24gZ3JpZAoJZnVuY3Rpb24gZWw6ZHJhdygpCgoJCWNsaXAoKQoJCQoJCWxvY2FsIHNw
cngsIHNwcnkgPSBzZWxmLndpZHRoLzIgLSA4LCA2CgkJbG9jYWwgc3ByeDAsIHNwcnkwID0gc3By
eCwgc3ByeQoJCQoJCS0tIHNoYWRvdzsgaGVscHMgd2l0aCB3aGl0ZSBvdXRsaW5lIG9uIHdoaXRl
ICh3aGVuIGludmVydGVkKQoJCW1lbW1hcChzaGFkb3dfcGFsLCAweDgwMDApCgkJaWYgKHNlbGYu
ZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJIC0tIHBvcCB1cCBhbmQgc2hvdyBzaGFkb3cuIHRoYXQg
d29ya3MhCgkJCSBzcHIoc2VsZi5maW5mby5pY29uLHNwcngsc3ByeSkKCQkJIHNwcnggKz0gMgoJ
CQkgc3ByeSAtPSAxCgkJZW5kCgkJdW5tYXAoc2hhZG93X3BhbCwgMHg4MDAwKQoJCQoJCS0tIG5v
bmUgb2YgdGhlc2Ugc29sdmUgdGhlIHdoaXRlLW9uLXdoaXRlIHByb2JsZW0gd2VsbDsKCQktLSB1
c2UgcG9wLXVwIGZvciBub3cuIGtpbmRhIGN1dGUgYW5kIHN1Z2dlc3RzIG1vYmlsaXR5CgkJLS1b
WwoJCWlmIChzZWxmLmZpbmZvLnNlbGVjdGVkKSB0aGVuCgkJCS0tIGludmVydCBvbmx5IGNvbDAs
IGNvbDIuIG5lZWRzIHNoYWRvd3Mgd2hlbiBvbiB3aGl0ZSAoZm9sZGVyKQoJCQktLXBhbCg3LDEp
IHBhbCgxLDcpCgkJCQoJCQktLSByb3RhdGU-IG5haAoJCQktLXBhbCgxLDEzKSBwYWwoMTMsNykg
cGFsKDcsMSkKCQkJCgkJCS0tIHJlY3RhbmdsZTogdG9vIG11Y2gsIGJ1dCBraW5kYSBpbnRlcmVz
dGluZwoJCQktLXJlY3RmaWxsKDAsMixzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMyw2KQoJCWVu
ZAoJCV1dCgkJCgkJLS0gZHJhdyBncmlkCgoJCWlmIChub3QgZHJhZ2dpbmdfZmlsZXMgb3Igbm90
IHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJCgkJCWlmIChzZXR0aW5ncy5sb3djb2xfaWNv
bnMgb3Igc2VsZi5maW5mby5sb3djb2xfaWNvbikgdGhlbgoJCQkJbG9jYWwgcCA9IGljb25fcGFs
CgkJCQltZW1tYXAocCwgMHg4MDAwKQoJCQkJc3ByKHNlbGYuZmluZm8uaWNvbixzcHJ4LHNwcnkp
CgkJCQl1bm1hcChwLCAweDgwMDApCgkJCWVsc2UKCQkJCS0tIHRvIGRvOiBob3cgdG8gaGFuZGxl
IGZ1bGwtY29sb3VyIGJ1cmllZD8KCQkJCXNwcihzZWxmLmZpbmZvLmljb24sc3ByeCxzcHJ5KQoJ
CQllbmQKCgkJZW5kCgkJCgkJCgkJLS1sb2NhbCBzdHIgPSAiXDAxNCIuLnNlbGYuZmlsZW5hbWUK
CQktLSBwb2tlKDB4NWYzNiwgMHg4MCkgLS0gdHVybiBvbiB3cmFwIHRvIGNsaXBfcmlnaHQgLS0g
MC4yLjBpOiBjb21tZW50ZWQ7IG1lc3NlcyB1cCBsb2NhdGlvbiBiYXIKCQkKCQkKCQlsb2NhbCBz
dHIgPSBzZWxmLmZpbGVuYW1lCgkJCgkJbG9jYWwgd3csaGggPSBwcmludChzdHIsIDAsIC0xMDAw
MDAwKQoJCWhoICs9IDEwMDAwMDAKCQkKCQktLXd3ID0gbWluKHd3LCBzZWxmLndpZHRoKSAtLSBk
b24ndCBjbGlwIGxlZnQgdGV4dCwgb25seSByaWdodAoKCQlsb2NhbCBkeCA9IG1pbih3dywgc2Vs
Zi53aWR0aCkgLyAyCgoKCQlsb2NhbCB3MiA9IHNlbGYud2lkdGgvMgoJCWxvY2FsIHl5ID0gMjgK
CQkKLS0JCWxvY2FsIGxsd3cgPSBzZWxmLmZpbmZvLnNlbGVjdGVkIGFuZCAzIG9yIC0zICAgLS0g
dGVzdDogbGFiZWwgaXMgb25seSB3aWRlIHdoZW4gc2VsZWN0ZWQKCQlsb2NhbCBsbHd3ID0gMwoK
CQljb2xvcihzZWxmLmZpbmZvLnNlbGVjdGVkIGFuZCAxIG9yIDcpCgkJcmVjdGZpbGwodzItZHgt
bGx3dy0yLHl5LTMsdzItZHgrd3crbGx3dyswLHl5K2hoLTApIAoJCXJlY3RmaWxsKHcyLWR4LWxs
d3ctMyx5eS0yLHcyLWR4K3d3K2xsd3crMSx5eStoaC0xKQoJCQoJCXByaW50KHN0ciwgdzIgLSBk
eCwgeXksIHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIDcgb3IgMSkKCQkKCQktLSBmb3IgdGVzdF9w
b2ludAoJCXNlbGYubGFzdF9sYWJlbF9hcmVhID0ge3cyLWR4LTUseXktNCx3Mi1keCt3dyszLHl5
K2hoLTEsc3ByeDAsc3ByeTB9CgkJCgkJLS0gZm9yIGRyYWdnaW5nIGZpbGUgaWNvbnM7IHNlbGYu
c3gsc3kgaXNuJ3Qgc2V0CgkJc2VsZi5maW5mby54ID0gc3ByeCArIHNlbGYueCArIHNlbGYucGFy
ZW50LnN4CgkJc2VsZi5maW5mby55ID0gc3ByeSArIHNlbGYueSArIHNlbGYucGFyZW50LnN5CgkJ
CQoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQlpZiAoa2V5KCJjdHJsIikpIHRoZW4K
CQkJc2VsZi5maW5mby5zZWxlY3RlZCA9IG5vdCBzZWxmLmZpbmZvLnNlbGVjdGVkCgkJZWxzZWlm
IGtleSJzaGlmdCIgYW5kIGxhc3RfaW5kZXggdGhlbgoJCQktLSBzZWxlY3QgcmFuZ2UKCQkJbG9j
YWwgaTAsaTEgPSBsYXN0X2luZGV4LCBzZWxmLmZpbmZvLmluZGV4CgkJCWlmIChpMCA_IGkxKSBp
MCxpMT1pMSxpMAoJCQlmb3IgaT1pMCxpMSBkbwoJCQkJZmluZm9bZmlsZW5hbWVzW2ldXS5zZWxl
Y3RlZCA9IHRydWUKCQkJZW5kCgkJZWxzZQoJCQktLSBpZiB3YXNuJ3QgYWxyZWFkeSBzZWxlY3Rl
ZCwgZGVzZWxlY3QgZXZlcnl0aGluZyBlbHNlCgkJCWlmIChub3Qgc2VsZi5maW5mby5zZWxlY3Rl
ZCkgdGhlbiAKCQkJCWRlc2VsZWN0X2FsbCgpICBzZWwgPSBuaWwKCQkJCS0tIHNldCBmaWxlIG5h
dmlnYXRvciB0ZXh0CgkJCQluYXZ0ZXh0OnNldF90ZXh0e2Z1bGxwYXRoKGVsLmZpbGVuYW1lKX0K
CQkJZW5kCgkJCS0tIC4uIGJ1dCBlaXRoZXIgd2F5LCB0aGlzIG9uZSBpcyBnb2luZyB0byBiZSBz
ZWxlY3RlZAoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQlsYXN0X2luZGV4ID0gc2Vs
Zi5maW5mby5pbmRleAoJCWVuZAkKCgkJdXBkYXRlX2NvbnRleHRfbWVudSgpCgoJCWlmIGludGVu
dGlvbiA9PSAic2F2ZV9maWxlX2FzIiBvciBpbnRlbnRpb24gPT0gInNlbGVjdF9maWxlIiBvciBp
bnRlbnRpb24gPT0gIm5ld19maWxlIiBvciBpbnRlbnRpb24gPT0gIm5ld19jYXJ0IiB0aGVuCgkJ
CS0tIHNldCB0ZXh0CgkJCWludGVudGlvbl90ZXh0OnNldF90ZXh0KHtlbC5maWxlbmFtZX0pCgkJ
CW5hdnRleHQ6c2V0X3RleHR7cHdkKCl9CgkJZW5kCgllbmQKCglmdW5jdGlvbiBlbDp0YXAobXNn
KQoJCS0tIHVuc2VsZWN0IGFsbCBidXQgY3VycmVudCBpdGVtIChuZWVkIHRvIHByZXNlcnZlIHNl
bGVjdGlvbiBvbiBjbGljayBmb3IgZHJhZ2dpbmcgLyBjb250ZXh0IG1lbnUpCgkJaWYgbm90IGtl
eSJjdHJsIiBhbmQgbm90IGtleSJzaGlmdCIgYW5kIG1zZy5sYXN0X21iID09IDEgdGhlbgoJCQlk
ZXNlbGVjdF9hbGwoKQoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCWVuZAoJCXVwZGF0
ZV9jb250ZXh0X21lbnUoKSAtLSBuZWVkIHRvIGFnYWluIGZvciBhcHAgbWVudQoJZW5kCgoJZnVu
Y3Rpb24gZWw6ZG91YmxlY2xpY2soKQoJCWNsaWNrX29uX2ZpbGUoc2VsZi5maWxlbmFtZSkKCWVu
ZAoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGdlbmVyYXRlX2ZlbHNfZ3JpZCgpCgktLSBoYW5k
bGUgZmlsZSBpdGVtcyBsYXllciBvZiBndWkgbWFudWFsbHkgc28gY2FuIG9wdGltaXNlCgktLSAo
ZS5nLiBvbmx5IGRyYXcgLyB1cGRhdGUgdmlzaWJsZSBpdGVtcykKCQkKCWxvY2FsIHh4LHl5ID0g
MCwwCglsb2NhbCBpdGVtX3cgPSA2OAoJbG9jYWwgaXRlbV9oID0gNDYKCS0tIHRvIGRvOiBzaG91
bGQgYmUgcGFyZW50Cglsb2NhbCBpdGVtc194ID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIFwgaXRl
bV93CgkKCWZpID0ge30KCQoJZm9yIGk9MSwjZmlsZW5hbWVzIGRvCgkJLS0gdG8gZG86IGF1dG8t
c3RhZ2dlciBmb3IgbG9uZyBmaWxlIG5hbWVzPyArICh4eCYxKSoxNgoJCS0tYWRkKGZpLCBjcmVh
dGVfZmlsZV9pdGVtKGNvbnRlbnQsIGZpbmZvW2ZpbGVuYW1lc1tpXV0sIDIgKyB4eCppdGVtX3cs
IDIgKyB5eSppdGVtX2ggKyAoeHgmMSkqMTYpKQoJCWFkZChmaSwgY3JlYXRlX2ZpbGVfaXRlbShj
b250ZW50LCBmaW5mb1tmaWxlbmFtZXNbaV1dLCAyICsgeHgqaXRlbV93LCAyICsgeXkqaXRlbV9o
KSkKCQl4eCs9MQoJCWlmICh4eCA_PSBpdGVtc194KSB4eD0wIHl5Kz0xCgllbmQKZW5kCgoKZnVu
Y3Rpb24gZ2VuZXJhdGVfaW50ZXJmYWNlX2dyaWQoeTAsIGFkZF9oZWlnaHQpCgl1cGRhdGVfZmls
ZV9pbmZvKHRydWUpCi0tCXByaW50aCgiQEAgZ2VuZXJhdGluZyBncmlkIGludGVyZmFjZSIpCgls
b2NhbCBwb2ludGVyX2VsID0gbmlsCglsb2NhbCBpdGVtX3cgPSA2OAoJbG9jYWwgaXRlbV9oID0g
NDYKCWxvY2FsIGl0ZW1zX3ggPSAzCglsb2NhbCBsYXN0X2l0ZW1zX3gKCQoJLS0gYXR0cmlidXRl
IGhlYWRlcnMKCS0tIGNsaWNrIGZvciBzb3J0aW5nIGJ5IHRoYXQgYXR0cmlidXRlCgkKCS0tIGxv
Y2F0aW9uIGlzIGluIHdpbmRvdyB0aXRsZSEKCWxvY2FsIGNvbnRhaW5lciA9IGd1aTphdHRhY2h7
CgkJeD0wLHk9eTAsCgkJd2lkdGhfcmVsID0gMS4wLAoJCWhlaWdodF9yZWwgPSAxLjAsCgkJaGVp
Z2h0X2FkZCA9IC15MCArIGFkZF9oZWlnaHQsCgkJCgkJdXBkYXRlID0gZnVuY3Rpb24oc2VsZikK
CQkJLS0gIHJlLWNhbGN1bGF0ZSBpdGVtIHBvc2l0aW9ucyBvbiBjaGFuZ2UKCQkJaXRlbXNfeCA9
IHNlbGYud2lkdGggXCBpdGVtX3cKCQkJaWYgKGl0ZW1zX3ggfj0gbGFzdF9pdGVtc194KSB0aGVu
CgkJCQlnZW5lcmF0ZV9mZWxzX2dyaWQoZmluZm8pCgkJCQlsYXN0X2l0ZW1zX3ggPSBpdGVtc194
CgkJCWVuZAoJCWVuZCwKCQkKCQktLSBuZWVkcyB0byBleGlzdCBmb3IgY2xpcHBpbmcgLl8uCgkJ
ZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJZW5kLAoKCQlkcmF3X2RlcGVuZGVuY3kgPSBmaWxldmll
d19zdGF0ZQoJfQoJY29udGVudCA9IGNvbnRhaW5lcjphdHRhY2h7CgkJeD0wLHk9MCwKCQl3aWR0
aF9yZWw9MS4wLAoJCWhlaWdodD0oKCNmaWxlbmFtZXMgKyBpdGVtc194IC0gMSkgXCBpdGVtc194
KSAqIGl0ZW1faCwKCQljbGlwX3RvX3BhcmVudCA9IHRydWUKCX0KCQoJZnVuY3Rpb24gY29udGVu
dDpjbGFtcF9zY3JvbGxpbmcoKQoJCWxvY2FsIG1heF95ID0gbWF4KDAsIGNvbnRlbnQuaGVpZ2h0
IC0gY29udGFpbmVyLmhlaWdodCkKCQljb250ZW50LnkgPSBtaWQoMCwgY29udGVudC55LCAtbWF4
X3kpCgkJY29udGVudC54ID0gbWluKDAsIGNvbnRlbnQueCkKCWVuZAoJCglsb2NhbCBmdW5jdGlv
biBmaV9mb3JfeHkoeCwgeSkKCQlsb2NhbCBpdGVtX3ggPSB4IFwgaXRlbV93CgkJbG9jYWwgaXRl
bV95ID0geSBcIGl0ZW1faAoJCWxvY2FsIGluZGV4ID0gMSArIGl0ZW1feCArIGl0ZW1feSAqIGl0
ZW1zX3gKCQlyZXR1cm4gZmlbZmxyKGluZGV4KV0KCWVuZAoJZnVuY3Rpb24gY29udGVudDp1cGRh
dGUobXNnKQoJCWNvbnRlbnQ6Y2xhbXBfc2Nyb2xsaW5nKCkKCQkKCQktLSB1cGRhdGUgcG9pbnRl
ciBlbGVtZW50CgkJbG9jYWwgbXgsbXksbWIgPSBtb3VzZSgpCgkJCgkJaWYgKHNlbGYuc3gpIHBv
aW50ZXJfZWwgPSBmaV9mb3JfeHkobXggLSBzZWxmLnN4LCBteSAtIHNlbGYuc3kpCgkJCgkJLS0g
dGVzdCBwb2ludAoJCWlmIChwb2ludGVyX2VsIGFuZCBwb2ludGVyX2VsLnBhcmVudCkgdGhlbgoJ
CQoJCQlwb2ludGVyX2VsLnN4ID0gcG9pbnRlcl9lbC54ICsgcG9pbnRlcl9lbC5wYXJlbnQuc3gK
CQkJcG9pbnRlcl9lbC5zeSA9IHBvaW50ZXJfZWwueSArIHBvaW50ZXJfZWwucGFyZW50LnN5CgkJ
CQoJCQkKCQkJcG9pbnRlcl9lbCA9IHBvaW50ZXJfZWw6dGVzdF9wb2ludChteCAtIHBvaW50ZXJf
ZWwuc3gsIG15IC0gcG9pbnRlcl9lbC5zeSkKCQkJCWFuZCBwb2ludGVyX2VsIG9yIG5pbAoJCWVu
ZAoKCQktLSB0byBkbzogYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcz8KCQlpZiAobXNnLmhhc19w
b2ludGVyKSB0aGVuCgkJCWlmIChwb2ludGVyX2VsKSB0aGVuCgkJCQl3aW5kb3d7Y3Vyc29yID0g
InBvaW50ZXIifQoJCQllbHNlCgkJCQl3aW5kb3d7Y3Vyc29yID0gMX0KCQkJZW5kCgkJCXNlbGYu
aGFkX2N1cnNvciA9IHRydWUKCQllbHNlCgkJCWlmIChzZWxmLmhhZF9jdXJzb3IpIHdpbmRvd3tj
dXJzb3IgPSAxfSAtLSByZXR1cm4gdG8gZGVmYXVsdAoJCQlzZWxmLmhhZF9jdXJzb3IgPSBuaWwK
CQllbmQKCQkKCQlzZWxmLmhlaWdodD0oKCNmaWxlbmFtZXMgKyBpdGVtc194IC0gMSkgXCBpdGVt
c194KSAqIGl0ZW1faAoJCXNlbGYuaGVpZ2h0PW1heChzZWxmLmhlaWdodCwgc2VsZi5wYXJlbnQu
aGVpZ2h0KSAtLSBhbGxvdyBzZWxlY3QgZnJvbSBkZWFkIHNwYWNlCgllbmQKCS0tIAoJCQoJLS0g
ZHJhdyBncmlkIHZpZXcKCWZ1bmN0aW9uIGNvbnRlbnQ6ZHJhdygpCgkJcmVjdGZpbGwoMCwwLDEw
MDAsc2VsZi5oZWlnaHQsNykKCgkJaWYgKCNmaSA9PSAwKSByZXR1cm4KCQoJCS0tbG9jYWwgbWlu
aSA9IG1pZCgxLCAoLWNvbnRlbnQueSAgICAgICAgICAgICAgICAgICApIFwgaXRlbV9oICsgMSwg
I2ZpKQoJCS0tbG9jYWwgbWF4aSA9IG1pZCgxLCAoLWNvbnRlbnQueSArIGNvbnRhaW5lci5oZWln
aHQpIFwgaXRlbV9oICsgMSwgI2ZpKQoJCQoJCS0tIHRvIGRvOiBjYWxjdWxhdGUKCQlsb2NhbCBt
aW5pID0gMQoJCWxvY2FsIG1heGkgPSAjZmkKCQkKCQlmb3IgcGFzcz0xLDIgZG8gLS0gZHJhdyBz
ZWxlY3RlZCBmaWxlcyBvbiB0b3AKCQlmb3IgaT1taW5pLG1heGkgZG8KCQkJCgkJCWxvY2FsIGZm
ID0gZmlbaV0KCQkJaWYgKGZmLmZpbmZvLnNlbGVjdGVkIGFuZCAyIG9yIDEpID09IHBhc3MgdGhl
bgoJCQkJbG9jYWwgc3ggPSBmZi54ICsgY29udGVudC54IFwgMSArIGNvbnRhaW5lci54IAoJCQkJ
bG9jYWwgc3kgPSBmZi55ICsgY29udGVudC55IFwgMSArIGNvbnRhaW5lci55IAoJCQkKCQkJCWNh
bWVyYSgtc3gsIC1zeSkKCQkJCQoJCQkJLS0gY2xpcHBpbmcgaGFjazogZG9uJ3QgZHJhdyBvdmVy
IHRvb2xiYXIgYXQgdG9wCgkJCQktLWNsaXAoc3gsIG1heChzeSwgY29udGFpbmVyLnkpLCBmZi53
aWR0aCwgZmYuaGVpZ2h0KQoJCQkJZmY6ZHJhdygpCgkJCWVuZAoJCWVuZAoJCWVuZAoKCQktLWNs
aXAoKQoJCQoJCS0tIGRyYXcgc2VsZWN0aW9uCgkJY2FtZXJhKC1zZWxmLnN4LCAtc2VsZi5zeSkK
CQkKCQlpZiAoc2VsIGFuZCAjc2VsID09IDQpIHRoZW4KCQkJcmVjdChzZWxbMV0sc2VsWzJdLHNl
bFszXSxzZWxbNF0sIDcpCgkJCXJlY3Qoc2VsWzFdKzEsc2VsWzJdKzEsc2VsWzNdLTEsc2VsWzRd
LTEsIDEpCgkJZW5kCgkJCgllbmQKCQoJLS0gZm9yd2FyZCBtZXNzYWdlcwoJLS0gdG8gZG86IGFs
bG93IHN1YnNjcmliZV90b19ldmVudHMgYXQgZ3VpIGVsZW1lbnQgbGV2ZWw-CgkKCWZ1bmN0aW9u
IGNvbnRlbnQ6Y2xpY2sobXNnKQoJCWlmIChwb2ludGVyX2VsKSB0aGVuCgkJCXBvaW50ZXJfZWw6
Y2xpY2sobXNnKQoJCWVsc2UKCQkJaWYgKG5vdCBrZXkiY3RybCIpIGRlc2VsZWN0X2FsbCgpCgkJ
CXNlbCA9IHttc2cubXgsIG1zZy5teX0gLS0gcmVsYXRpdmUgdG8gZ3VpIGVsZW1lbnQKCQllbmQK
CWVuZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6dGFwKG1zZykKCQlpZiAocG9pbnRlcl9lbCBhbmQgcG9p
bnRlcl9lbC50YXApIHBvaW50ZXJfZWw6dGFwKG1zZykKCWVuZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6
ZHJhZyhtc2cpCgkKCQktLSBkcmFnZ2luZyBhIGZpbGUKCQlpZiAocG9pbnRlcl9lbCBhbmQgcG9p
bnRlcl9lbC5maW5mbyBhbmQgcG9pbnRlcl9lbC5kcmFnIGFuZAoJCQlub3Qgc2VsKSB0aGVuCgkJ
CXBvaW50ZXJfZWw6ZHJhZyhtc2cpCgkJZW5kCgkJCgkJaWYgKHNlbCkgdGhlbgoJCQlpZiAoYWJz
KG1zZy5teC1zZWxbMV0pID4gMiBvciBhYnMobXNnLm15LXNlbFsyXSkgPiAyKSB0aGVuCgkJCQlz
ZWxbM10sc2VsWzRdID0gbXNnLm14LCBtc2cubXkgLS0gcmVsYXRpdmUgdG8gZ3VpIGVsZW1lbnQK
CQkJCS0tIHVwZGF0ZSBzZWxlY3Rpb24KCQkJCWlmIChub3Qga2V5ImN0cmwiKSBkZXNlbGVjdF9h
bGwoKQoJCQkJbG9jYWwgeHgwID0gbWluKHNlbFsxXSxzZWxbM10pCgkJCQlsb2NhbCB4eDEgPSBt
YXgoc2VsWzFdLHNlbFszXSkKCQkJCWxvY2FsIHl5MCA9IG1pbihzZWxbMl0sc2VsWzRdKQoJCQkJ
bG9jYWwgeXkxID0gbWF4KHNlbFsyXSxzZWxbNF0pCgoJCQkJLS0gdG8gZG86IG9ubHkgbmVlZCB0
byB0ZXN0IHRoZSB2aXNpYmxlIG9uZXMKCQkJCWZvciBpPTEsICNmaSBkbwoJCQkJCWxvY2FsIGl0
ZW0gPSBmaVtpXQoKCQkJCQlsb2NhbCB1dTAgPSBtaWQoeHgwLCBpdGVtLngsIHh4MSkKCQkJCQls
b2NhbCB2djAgPSBtaWQoeXkwLCBpdGVtLnksIHl5MSkKCQkJCQlsb2NhbCB1dTEgPSBtaWQoeHgw
LCB1dTAgKyBpdGVtLndpZHRoLCB4eDEpCgkJCQkJbG9jYWwgdnYxID0gbWlkKHl5MCwgdnYwICsg
aXRlbS5oZWlnaHQsIHl5MSkKCQkJCQkKCQkJCQlmb3IgeSA9IHZ2MCwgdnYxLTEsIDQgZG8KCQkJ
CQkJZm9yIHggPSB1dTAsIHV1MS0xLCA0IGRvCgkJCQkJCQlpZiAoaXRlbTp0ZXN0X3BvaW50KHgg
LSBpdGVtLngsIHkgLSBpdGVtLnkpKSBpdGVtLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQkJCQll
bmQKCQkJCQllbmQKCQkJCWVuZAoKCQkJZWxzZQoJCQkJc2VsWzNdLHNlbFs0XSA9IG5pbCxuaWwK
CQkJZW5kCgkJCQoJCWVuZAoJZW5kCgkKCWZ1bmN0aW9uIGNvbnRlbnQ6cmVsZWFzZSgpCgkJc2Vs
ID0gbmlsCgkJZHJhZ2dpbmdfZmlsZXMgPSBuaWwgLS0gdG8gZG86IGRyb3AKCWVuZAoJCgkKCWZ1
bmN0aW9uIGNvbnRlbnQ6ZG91YmxlY2xpY2soLi4uKQoJCWlmIChwb2ludGVyX2VsKSBwb2ludGVy
X2VsOmRvdWJsZWNsaWNrKC4uLikKCWVuZAoKCQoJCgkKCS0tIHVwZGF0ZV9maWxlX2luZm8odHJ1
ZSkKCWNvbnRhaW5lcjphdHRhY2hfc2Nyb2xsYmFyc3thdXRvaGlkZT10cnVlfQoJCmVuZAoKCgo6
OiBpY29uLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTA0LTI4IDE0OjM1
OjEwIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMTUxNTE1MTUxNTE1MTUxNTE1MTUwMDAw
MDAwMDAwMDAxNTA3MDcwNzA3MDcwNzA3MDcwZjE1MDAwMDAwMDAwMDE1MDcwNzA3MDcwNzA3MDcw
NzBmMGYxNTAwMDAwMDAwMTUwNzA3MDcwNzA3MDcwNzA3MGYwZjBmMTUwMDAwMDAxNTA3MTYxNjE2
MTYwNzE2MDcwZjBmMGYwZjE1MDAwMDE1MDcxNjE2MTYxNjA3MTYxNjA3MDcwNzA3MTUwMDAwMTUw
NzE2MTYxNjE2MDcxNjE2MTYwNzA3MDcxNTAwMDAxNTA3MTYxNjE2MTYwNzA3MDcwNzA3MDcwNzE1
MDAwMDE1MDcxNjE2MTYxNjE2MTYxNjE2MDcwNzA3MTUwMDAwMTUwNzE2MTYwNzE2MDcxNjE2MTYw
NzA3MDcxNTAwMDAxNTA3MTYwNzE2MTYxNjA3MTYxNjA3MDcwNzE1MDAwMDE1MDcxNjA3MTYxNjE2
MDcxNjE2MDcwNzA3MTUwMDAwMTUwNzE2MTYwNzE2MDcxNjE2MTYwNzA3MDcxNTAwMDAxNTA3MTYx
NjE2MTYxNjE2MTYxNjA3MDcwNzE1MDAwMDE1MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MTUwMDAw
MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTE1MTUxNTAwIiksbG93Y29sX2ljb249ZmFsc2UsbW9kaWZp
ZWQ9IjIwMjUtMTAtMjMgMDA6MTk6NTMiLHJldmlzaW9uPTE4NV1dCi0tW1sKCWljb24ubHVhCgkK
CWdldCBhbiBpY29uIGZvciBhIGZpbGUgYnkgdHlwZSAvIG1ldGFkYXRhCglnZXRfZmlsZV9pY29u
KGZpbGVuYW1lKQpdXQpsb2NhbCBpbmRleF9mb3JfdHlwZSA9IHsKCWx1YSA9IGdldF9zcHIoOCks
CglnZnggPSBnZXRfc3ByKDkpLAoJbWFwID0gZ2V0X3NwcigxMCksCglzZnggPSBnZXRfc3ByKDEx
KSwKCXBvcyA9IGdldF9zcHIoMTIpLAoJdHh0ID0gZ2V0X3NwcigxMyksCglwNjQgPSBnZXRfc3By
KDE2KSwKCVsicDY0LnBuZyJdID0gZ2V0X3NwcigxNiksCglbInA2NC5yb20iXSA9IGdldF9zcHIo
MTYpLAoJLS1BU1RSQUxTUEFSVjogYWRkZWQgWyJwOC5wbmciXSwgcDggZnJvbSBuZXcgaWNvbi5s
dWEKCVsicDgucG5nIl0gPSBnZXRfc3ByKDE3KSwKCXA4ID0gZ2V0X3NwcigxNyksCgkKCWxvYyA9
IGdldF9zcHIoMyksCglwb2QgPSBnZXRfc3ByKDEyKQoJCn0KbG9jYWwgYmFzZV90YWJsZT1mZXRj
aCgiL2FwcGRhdGEvaWNvbl9iYXNlL2ljb24uYmFzZSIpIG9yIHt9CmluZGV4X2Zvcl90eXBlPWJh
c2VfdGFibGUuZmlsZSBvciBpbmRleF9mb3JfdHlwZQpsb2NhbCBiYXNlX2RlZmF1bHQ9ewoJZmls
ZT1iYXNlX3RhYmxlLmJ1aWx0X2luLmZpbGUgb3IgZ2V0X3NwcigxKSwKCWZvbGRlcj1iYXNlX3Rh
YmxlLmJ1aWx0X2luLmZvbGRlciBvciBnZXRfc3ByKDIpLAoJaG9zdD1iYXNlX3RhYmxlLmJ1aWx0
X2luLmhvc3Qgb3IgZ2V0X3Nwcig0KQp9CmxvY2FsIGJhc2VfZm9sZGVycz1iYXNlX3RhYmxlLmZv
bGRlciBvciB7fQpsb2NhbCBiYXNlX2xvd2NvbD1iYXNlX3RhYmxlLmxvd2NvbCBvciB7fQoKLS0g
bWF0Y2ggdGFibGUgaW4gYWJvdXQucDY0IGljb24gZGVzaWduZXIKbG9jYWwgbG93Y29sX3RhYmxl
ID0gCnsKCSAgMSwxLDEsIDEzLDEsNiw3LAoJMTMsNiw2LDYsIDYsMTMsNiw2LAoJMTMsMTMsMTMs
MSwgMSwxLDEzLDYsCgkxMywxMyw2LDEzLCA2LDYsMTMsMTMKfQpsb2NhbCB0aGVtZV9pbmRleCA9
IHsKCVs3XSA9ICJpY29uMCIsCglbNl0gPSAiaWNvbjEiLAoJWzEzXSA9ICJpY29uMiIsCglbMV0g
PSAiaWNvbjMiCn0KbG9jYWwgdGhlbWVfaW5kZXhfYnVyaWVkID0gewoJWzddID0gImljb24xIiwK
CVs2XSA9ICJpY29uMiIsCglbMTNdID0gImljb24zIiwKCVsxXSA9ICJpY29uMyIKfQoKbG9jYWwg
ZGFya190YWJsZSA9IAp7CgkxLDIxLDE5LCAyMCwyMSwyMiw2LAoJMjQsMjUsOSwyNywgMTYsMTgs
OCwzMSwKCgkxOSwxNiwxLDEsIDIxLDIxLDUsMTQsCgkyLDQsMjcsMywgMTcsMTMsMjQsNAp9Cgot
LSBuZWVkIHRvIGNhbGwgZWFjaCB0aW1lIHRoZW1lIGNoYW5nZXMKZnVuY3Rpb24gZ2VuZXJhdGVf
aWNvbl9wYWxldHRlcygpCgoJcGFsKCkKCWZvciBpPTEsMzEgZG8KCQlwYWwoaSwgdGhlbWUodGhl
bWVfaW5kZXhbbG93Y29sX3RhYmxlW2ldXSkpCgllbmQKCWljb25fcGFsID0gdXNlcmRhdGEoInU4
Iiw0MDk2KQoJaWNvbl9wYWw6cGVlaygweDgwMDApCgoJcGFsKCkKCWZvciBpPTEsMzEgZG8KCQlw
YWwoaSwgdGhlbWUodGhlbWVfaW5kZXhfYnVyaWVkW2xvd2NvbF90YWJsZVtpXV0pKQoJZW5kCgli
dXJpZWRfcGFsID0gdXNlcmRhdGEoInU4Iiw0MDk2KQoJYnVyaWVkX3BhbDpwZWVrKDB4ODAwMCkK
CgktLSBmdWxsIGNvbG91ciBwYWxldHRlIGZvciB3aGVuIGJ1cmllZAoJcGFsKCkKCWZvciBpPTEs
MzEgZG8KCQlwYWwoaSwgZGFya190YWJsZVtpXSkKCWVuZAoJYnVyaWVkX3BhbDIgPSB1c2VyZGF0
YSgidTgiLDQwOTYpCglidXJpZWRfcGFsMjpwZWVrKDB4ODAwMCkKCglwYWwoKQoJZm9yIGk9MSwz
MSBkbwoJCXBhbChpLCBtb2RlID09ICJkZXNrdG9wIiBhbmQgdGhlbWUiZGVza3RvcF9zaGFkb3ci
IG9yIDYpCgllbmQKCXNoYWRvd19wYWwgPSB1c2VyZGF0YSgidTgiLDQwOTYpCglzaGFkb3dfcGFs
OnBlZWsoMHg4MDAwKQoKCXBhbCgpCmVuZAoKLS1BU1RSQUxTUEFSVjogYWRkZWQgaXNfY2FydCBm
dW5jdGlvbiBmcm9tIG5ldyBpY29uLmx1YQpmdW5jdGlvbiBpc19jYXJ0KGZuKQoJaWYgKHR5cGUo
Zm4pIH49ICJzdHJpbmciKSByZXR1cm4gZmFsc2UKCWZuID0gcHdkKCkuLiIvIi4uZm4gLS0gbmVl
ZCBwd2QoKS4uIHNvIHRoYXQgY2FuIGFueXdoZW4gdGVzdHMgd29yayAoY2FuIHNlZSBwcm90b2Nv
bCwgYW5kIC5wNjQgcGFydCBpcyBidXJpZWQgaW4gcGF0aCkKLS0JaWYgKGZuOnByb3QodHJ1ZSkg
PT0gImFueXdoZW4iIGFuZCBub3Qgc3RyaW5nLmZpbmQoZm4sIkAiLDEsdHJ1ZSkpIHJldHVybiBm
YWxzZSAtLSBvcGVuIGNhcnQgYXMgYW4gYW55d2hlbiBmb2xkZXIgIC0tIGRlbGV0ZW1lOyBub3cg
cmVkdW5kYW50Cglsb2NhbCBleHQgPSBmbjpleHQoKSAtLSBkb24ndCBuZWVkIGlmIHVzaW5nIGZ1
bGxwYXRoIGFib3ZlCglyZXR1cm4gZXh0IGFuZCBleHQ6aXNfY2FydCgpCmVuZAoKZnVuY3Rpb24g
Z2V0X2ZpbGVfaWNvbihmaWxlbmFtZSwgbWQpCgoJLS0gbG9vayBmb3IgaWNvbiBpbiBtZXRhZGF0
YQoKCWlmIChtZCBhbmQgbWQuaWNvbiBhbmQgbWQuaWNvbjp3aWR0aCgpID09IDE2KSB0aGVuCgkJ
cmV0dXJuIG1kLmljb24sIG1kLmxvd2NvbF9pY29uCgllbmQKCQoJbG9jYWwgZXh0ID0gZmlsZW5h
bWU6ZXh0KCkKCQoJLS0gZm9sZGVyIHNwcml0ZSBpZiBhIGZvbGRlciAoYnV0IC5wNjQgZG9lc24n
dCBjb3VudCkKCgktLVtbCglhc3RyYWxzcGFydgoJZm9sZGVycyBuYW1lZCB3aXRoIGEgLmFueXRo
aW5nIGdldCBzZWVuIGFzIGEgZmlsZSEKCWZpeGVkIGhlcmUKCWUuZzogZm9sZGVyIG5hbWVkICJ2
My4xIiBpcyB0cmVhdGVkIGFzIGEgZmlsZSB3aXRoIGV4dGVuc2lvbiAiMSIKCV1dLS0KCQoJbG9j
YWwga2luZCxzaXplLG9yaWdpbiA9IGZzdGF0KGZpbGVuYW1lKQoJaWYga2luZCA9PSAiZm9sZGVy
IiBhbmQgbm90IChleHQgYW5kIGV4dDppc19jYXJ0KCkpIHRoZW4KCQlpZiAob3JpZ2luIGFuZCBv
cmlnaW46c3ViKDEsNSkgPT0gImhvc3Q6IikgcmV0dXJuIGJhc2VfZGVmYXVsdC5ob3N0LCBiYXNl
X2xvd2NvbFsiYnVpbHRfaW4uaG9zdCJdCgkJCgkJaWYoYmFzZV9mb2xkZXJzW2ZpbGVuYW1lXSkg
cmV0dXJuIGJhc2VfZm9sZGVyc1tmaWxlbmFtZV0sIGJhc2VfbG93Y29sWyJmb2xkZXIuIi4uZmls
ZW5hbWVdCgkJcmV0dXJuIGJhc2VfZGVmYXVsdC5mb2xkZXIsIGJhc2VfbG93Y29sWyJidWlsdF9p
bi5mb2xkZXIiXQoJZW5kCgoJaWYoaW5kZXhfZm9yX3R5cGVbZXh0XSkgcmV0dXJuIGluZGV4X2Zv
cl90eXBlW2V4dF0sIGJhc2VfbG93Y29sWyJmaWxlLiIuLmV4dF0KCXJldHVybiBiYXNlX2RlZmF1
bHQuZmlsZSwgYmFzZV9sb3djb2xbImJ1aWx0X2luLmZpbGUiXQoJCmVuZAo6OiBpbnRlbnRpb24u
bHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMDUgMjE6NDk6NTEiLG1v
ZGlmaWVkPSIyMDI1LTA0LTE5IDE5OjIwOjQyIixyZXZpc2lvbj0xNTMzXV0KLS1bWwoKCWludGVu
dGlvbi5sdWEKCQoJb3BlbiBmaWxlbmF2IHdpdGggaW50ZW50aW9uIHRvIHBlcmZvcm0gc29tZSBv
cGVyYXRpb24KCS0_IGNoYW5nZXMgc2VtYW50aWNzIG9mIGRvdWJsZSBjbGljaywgYW5kIGFkZHMg
aW50ZW50aW9uIHBhbmVsIGF0IGJvdHRvbQoJCWUuZy46IFNhdmUgQXMgLi4gICBbU2F2ZV0KCQoJ
dXBkYXRlOiByZXVzZSBmb3IgdGFza3MgdGhhdCBuZXZlciBsZWF2ZSBmaWxlbmF2IChuZXcgZm9s
ZGVyKQpdXQoKLS1pbnRlbnRpb24gPSAib3BlbiIgLS0gZGVidWdnaW5nCgpsb2NhbCBpbnRlbnRp
b25fc3RhY2sgPSB7fQoKZnVuY3Rpb24gcHVzaF9pbnRlbnRpb24ocDAscDEscDIsbmV3X2ZpbGVu
YXYpCgoJLS0gb24gZGVza3RvcDogdXNlIGFub3RoZXIgZmlsZW5hdiBpbnN0YW5jZQoJaWYgbmV3
X2ZpbGVuYXYgYW5kIG1vZGUgPT0gImRlc2t0b3AiIHRoZW4KCQktLSBvcGVuIGEgbmV3IGZpbGVu
YXYKCQljcmVhdGVfcHJvY2VzcygiL3N5c3RlbS9hcHBzL2ZpbGVuYXYucDY0IiwKCQl7IAoJCQlh
cmd2ID0ge3B3ZCgpfSwKCQkJaW50ZW50aW9uID0gcDAsCgkJCWludGVudGlvbl9maWxlbmFtZSA9
IHAyLCAtLSBwYXNzIGFsb25nIGlmIHRoZXJlIGlzIG9uZQoJCQl3aW5kb3dfYXR0cmlicz17YXV0
b2Nsb3NlPXRydWV9IC0tIGNsb3NlIGFmdGVyIHByb2Nlc3NpbmcgaW50ZW50aW9uOyB0aGUgd20g
d2luZG93IHN0YWNrIGlzIHRoZSBpbnRlbnRpb24gc3RhY2shCgkJfSkKCQlyZXR1cm4KCWVuZAoK
CS0tIHByaW50aCgicHVzaGluZyBpbnRlbnRpb246Ii4ucG9ke3AwLHAxLHAyfSkKCWFkZChpbnRl
bnRpb25fc3RhY2ssCgkJewoJCQlpbnRlbnRpb24sCgkJCWludGVudGlvbl9yZXF1ZXN0ZXJfcHJv
Y19pZCwKCQkJaW50ZW50aW9uX2ZpbGVuYW1lCgkJfQoJKQoJaW5pdF9pbnRlbnRpb24ocDAsIHAx
LCBwMikKCXJlZnJlc2hfZ3VpID0gdHJ1ZQplbmQKCmZ1bmN0aW9uIHBvcF9pbnRlbnRpb24oKQoK
CS0tIHdoZW4gZmlsZW5hdiB3YXMgY3JlYXRlZCB0byBwcm9jZXNzIGEgc2luZ2xlIGludGVudGlv
biwgYWx3YXlzIGNsb3NlIGFmdGVyIGl0IHdhcyBwcm9jZXNzZXMKCS0tIGUuZy4gbmV3IGNhcnQg
LyByZW5hbWUgZnJvbSBkZXNrdG9wCglpZiAoZW52KCkuaW50ZW50aW9uID09IGludGVudGlvbiBh
bmQgZW52KCkud2luZG93X2F0dHJpYnMgYW5kIGVudigpLndpbmRvd19hdHRyaWJzLmF1dG9jbG9z
ZSkgZXhpdCgpCgoJbG9jYWwgaXRlbT1kZWxpKGludGVudGlvbl9zdGFjaykgb3Ige30KCWluaXRf
aW50ZW50aW9uKGl0ZW1bMV0sIGl0ZW1bMl0sIGl0ZW1bM10pCglyZWZyZXNoX2d1aSA9IHRydWUK
CQoJcmV0dXJuIGl0ZW0gLS0gbmV2ZXIgdXNlZAplbmQKCgpmdW5jdGlvbiBpbml0X2ludGVudGlv
bihwMCwgcDEsIHAyKQoKCS0tIGNhbiBiZSBuaWxsIChlLmcuIHBvcCBsYXN0IGludGVudGlvbiBv
ZmYgc3RhY2sgdG8gcmVtb3ZlIGludGVudGlvbiBwYW5lbCkKCWludGVudGlvbiA9IHAwCglpbnRl
bnRpb25fcmVxdWVzdGVyX3Byb2NfaWQgPSBwMQoJaW50ZW50aW9uX2ZpbGVuYW1lID0gcDIKCQoJ
aW50ZW50aW9uX2RhdCA9IHsKCQlzYXZlX2ZpbGVfYXMgID0geyJTYXZlIEFzIiwgIlNhdmUifSwg
LS0gIlNhdmUgRmlsZSBBcyIgZG9lc24ndCBmaXQKCQlzZWxlY3RfZmlsZSAgID0geyJTZWxlY3Qg
RmlsZSIsICJTZWxlY3QifSwgLS0gc2ltaWxhciB0byBzYXZlX2ZpbGVfYXMgYnV0IGdlbmVyYWwg
cHVycG9zZSBuYW1lICh1cCB0byByZXF1ZXN0ZXIgd2hhdCB0byBkbyB3aXRoIHNlbGVjdGVkIGZp
bGUpCgkJb3Blbl9maWxlICAgICA9IHsiT3BlbiBGaWxlIiwgIk9wZW4ifSwKCQluZXdfZmlsZSAg
ICAgID0geyJOZXcgRmlsZSIsICJDcmVhdGUifSwKCQluZXdfZm9sZGVyICAgID0geyJOZXcgRm9s
ZGVyIiwgIm1rZGlyIn0sCgkJbmV3X2NhcnRyaWRnZSA9IHsiTmV3IENhcnQiLCAiQ3JlYXRlIn0s
CgkJbmV3X3RhYiAgICAgICA9IHsiTmV3IEZpbGUiLCAiQ3JlYXRlIiwgIk5ldyBUYWIifSwgLS0g
Y2FuIGVpdGhlciBvcGVuIGEgZmlsZSwgb3IgY3JlYXRlIGEgZmlsZSAgLS0_ICB3aW5kb3cgdGl0
bGUgaXMgIk5ldyBUYWIiCgkJcmVuYW1lICAgICAgICA9IHsiUmVuYW1lIiwgIlJlbmFtZSJ9LCAt
LSBjb3VsZCBiZSBmaWxlIG9yIGZvbGRlcgoJCWNvbmZpcm1fZmlsZV9vdmVyd3JpdGUgPSB7Ik92
ZXJ3cml0ZT8iLCAiT3ZlcndyaXRlIn0gLS0gbm90ICJDb25maXJtIiBvbiByaWdodCAtLSBjb25m
aXJtIHdoYXQ-IGFuZCB0b28gdmlzdWFsbHkgc2ltaWxhciB0byAiQ2FuY2VsIgoJfQoKCWlmIGlu
dGVudGlvbiBhbmQgaW50ZW50aW9uX2RhdFtpbnRlbnRpb25dIHRoZW4KCQlpbnRlbnRpb25fdGl0
bGUgID0gaW50ZW50aW9uX2RhdFtpbnRlbnRpb25dWzFdIC0tIHdpbmRvdyB0aXRsZSBhbmQgYm90
dG9tIGxlZnQKCQlpbnRlbnRpb25fYWN0aW9uID0gaW50ZW50aW9uX2RhdFtpbnRlbnRpb25dWzJd
IC0tIGJ1dHRvbiBvbiByaWdodAoJCWludGVudGlvbl93aW5kb3dfdGl0bGUgPSBpbnRlbnRpb25f
ZGF0W2ludGVudGlvbl1bM10gb3IgaW50ZW50aW9uX3RpdGxlCgllbmQKCglpZiAoaW50ZW50aW9u
X3RpdGxlID09ICJPdmVyd3JpdGU-IikgaW50ZW50aW9uX3RpdGxlID0gIlxmMU92ZXJ3cml0ZSAi
Li5pbnRlbnRpb25fdGV4dDpnZXRfdGV4dCgpWzFdLi4iPyIKZW5kCgpmdW5jdGlvbiBnZW5lcmF0
ZV9pbnRlbnRpb25fcGFuZWwoKQoKCWxvY2FsIHBhbmVsID0gZ3VpOmF0dGFjaHsKCQl4ID0gMCwg
eSA9IDAsIHZqdXN0aWZ5ID0gImJvdHRvbSIsCgkJd2lkdGhfcmVsID0gMS4wLAoJCWhlaWdodCA9
IDE5LAoJfQoKCWZ1bmN0aW9uIHBhbmVsOmRyYXcoKQoJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRo
LTEsc2VsZi5oZWlnaHQtMSw2KQoJCWxvY2FsIGxhYmVsID0gaW50ZW50aW9uX3RpdGxlLi4iOiIK
CQlpZiAoaW50ZW50aW9uX3RpdGxlID09ICJSZW5hbWUiKSBpbnRlbnRpb25fdGl0bGUgPSAiUmVu
YW1lIEFzOiIKCQlwcmludChpbnRlbnRpb25fdGl0bGUsNiw2LDEzKQoJZW5kCgkKCWxvY2FsIHd3
YSA9IDgwCglsb2NhbCB4eCA9IC02CgkKCS0tIDAuMi4waTogY29uZmlybWVkIGFjdGlvbiBhbHdh
eXMgb24gdGhlIHJpZ2h0CgoJbG9jYWwgYnRuMSA9IHBhbmVsOmF0dGFjaF9idXR0b257CgkJeCA9
IHh4LCBqdXN0aWZ5ID0gInJpZ2h0IiwgeSA9IDMsCgkJbGFiZWwgPSBpbnRlbnRpb25fYWN0aW9u
LAoJCS0tYmdjb2wgPSAweDA3MDcsCgkJLS1mZ2NvbCA9IDB4MGUwMSwKCQlib3JkZXIgPSAweDBl
MTIsCgkJdGFwID0gcHJvY2Vzc19pbnRlbnRpb24KCX0KCgl4eCAtPSBidG4xLndpZHRoCgl4eCAt
PSA0Cgl3d2EgKz0gYnRuMS53aWR0aCs0CgoJaWYgKCNpbnRlbnRpb25fc3RhY2sgPiAxKSB0aGVu
CiAJCWxvY2FsIGVsID0gcGFuZWw6YXR0YWNoX2J1dHRvbnsKCQkJeCA9IHh4LCBqdXN0aWZ5ID0g
InJpZ2h0IiwgeSA9IDMsCgkJCWxhYmVsID0gIkNhbmNlbCIsCgkJCS0tYmdjb2wgPSAweDA3MDcs
CgkJCS0tZmdjb2wgPSAweDBlMDEsCgkJCWJvcmRlciA9IDB4MGUxMiwKCQkJdGFwID0gZnVuY3Rp
b24oKQoJCQkJcG9wX2ludGVudGlvbigpCgkJCWVuZAoJCX0KCQl4eCAtPSBlbC53aWR0aAoJCXh4
IC09IDQKCQl3d2EgKz0gZWwud2lkdGgrNAoJZW5kCgoJCglpZiAoaW50ZW50aW9uID09ICJjb25m
aXJtX2ZpbGVfb3ZlcndyaXRlIikgdGhlbgoJCS0tIGludGVudGlvbl90ZXh0IHN0aWxsIGV4aXN0
czsganVzdCBpcyBub3QgdmlzaWJsZQoJCW5hdnRleHQ6c2V0X2tleWJvYXJkX2ZvY3VzKGZhbHNl
KSAtLSBkb24ndCB3YW50IG5hdmJhciBjdXJzb3IgYmxpbmtpbmcKCWVsc2UKCQlpbnRlbnRpb25f
dGV4dCA9IHBhbmVsOmF0dGFjaF90ZXh0X2VkaXRvcnsKCQkJeD02NCx5PTQsCgkJCXdpZHRoPTEw
MCwKCQkJd2lkdGhfcmVsID0gMS4wLAoJCQl3aWR0aF9hZGQgPSAtIHd3YSwKCQkJaGVpZ2h0PTEy
LAoJCQltYXhfbGluZXMgPSAxLAkKCQkJa2V5X2NhbGxiYWNrID0geyAKCQkJCWVudGVyID0gcHJv
Y2Vzc19pbnRlbnRpb24sIC0tIHNhbWUgYXMgY2xpY2tpbmcgb24gdGhlIGJ1dHRvbiBuZXh0IHRv
IGl0ICgiU2F2ZSBBcyIpCgoJCQkJLS0gMC4yLjBoOiBjYW4gdGFiIGNvbXBsZXRlIGJvdHRvbSB0
ZXh0IGZpZWxkCgkJCQl0YWIgPSBmdW5jdGlvbiAoKQoJCQkJCWxvY2FsIHBhdGggPSBpbnRlbnRp
b25fdGV4dDpnZXRfdGV4dCgpWzFdCgkJCQkJcGF0aCA9IHRhYl9jb21wbGV0ZV9maWxlbmFtZShw
YXRoKQoJCQkJCQoJCQkJCWludGVudGlvbl90ZXh0OnNldF90ZXh0e3BhdGh9CgkJCQkJLS0gaGFj
a3kgd2F5IHRvIHB1dCB0aGUgbW91c2UgY3Vyc29yIGF0IHRoZSBlbmQKCQkJCQlpbnRlbnRpb25f
dGV4dDpjbGljayh7bXg9MTAwMCxteT0yfSkKCQkJCQkKCQkJCWVuZAoJCQl9CgkJfQoJCQoJCWlu
dGVudGlvbl90ZXh0OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoJZW5kCgoJaWYgKGludGVudGlv
bl9maWxlbmFtZSkgdGhlbgoJCWxvY2FsIHN0ciA9IGludGVudGlvbl9maWxlbmFtZTpiYXNlbmFt
ZSgpCgkJbG9jYWwgZXh0ID0gc3RyOmV4dCgpIG9yICIiCgkJaW50ZW50aW9uX3RleHQ6c2V0X3Rl
eHR7c3RyfQoJCWludGVudGlvbl90ZXh0OnNldF9jdXJzb3IoI3N0ciAtICNleHQsMSkKCWVuZAoK
CS0taW50ZW50aW9uX3RleHQ6c2V0X3RleHR7cGF0aH0KCS0taW50ZW50aW9uX3RleHQ6Y2xpY2so
e214PTEwMDAsbXk9Mn0pCgkKZW5kCgoKZnVuY3Rpb24gcHJvY2Vzc19pbnRlbnRpb24oKQoKCWlm
IChub3QgaW50ZW50aW9uX3RleHQpIHJldHVybgoKCWxvY2FsIGZpbGVuYW1lID0gZnVsbHBhdGgo
aW50ZW50aW9uX3RleHQ6Z2V0X3RleHQoKVsxXSkKCglpZiAobm90IGZpbGVuYW1lKSB0aGVuCgkJ
bm90aWZ5KCJjb3VsZCBub3QgcmVzb2x2ZTsgZmlsZW5hbWVzIG11c3QgY29udGFpbiBvbmx5IGEu
LnosMC4uOSxfLS4iKQoJCXJldHVybgoJZW5kCgoJLS0gb3ZlcndyaXRlCglpZiBpbnRlbnRpb24g
PT0gInNhdmVfZmlsZV9hcyIgdGhlbgoJCWlmIGZzdGF0KGZ1bGxwYXRoKGludGVudGlvbl90ZXh0
OmdldF90ZXh0KClbMV0pKSB0aGVuCgkJCS0tbm90aWZ5KCJleGlzdHMhIikKCgkJCXB1c2hfaW50
ZW50aW9uKAoJCQkJImNvbmZpcm1fZmlsZV9vdmVyd3JpdGUiLCAKCQkJCWVudigpLmludGVudGlv
biBhbmQgZW52KCkucGFyZW50X3BpZCwgCgkJCQllbnYoKS5pbnRlbnRpb24gYW5kIGVudigpLmlu
dGVudGlvbl9maWxlbmFtZQoJCQkpCgoJCQlyZXR1cm4KCQllbmQKCWVuZAoKCS0tIGNvbmZpcm1l
ZCBjb25maXJtX2ZpbGVfb3ZlcndyaXRlOiBwcm9jZXNzIHNhdmVfZmlsZV9hcwoJLS0gKGkuZS4g
c2VuZCBjb25maXJtYXRpb24gYmFjayB0byB0b29sIHdpdGggdGhlIHNhdmVfYXMgbWVzc2dlIH4g
Y2FsbGVyIGRvZXNuJ3QgbmVlZCB0byBrbm93IGlmIG92ZXJ3cml0aW5nIG9yIG5vdCkKCWlmIChp
bnRlbnRpb24gPT0gImNvbmZpcm1fZmlsZV9vdmVyd3JpdGUiKSB0aGVuCgkJaW50ZW50aW9uID0g
InNhdmVfZmlsZV9hcyIKCWVuZAoKCS0tIDAuMi4waCBjYW4gbmF2aWdhdGUgdG8gYSBmb2xkZXIg
dmlhIHRoZSBpbnRlbnRpb24gYm94CgktLSBhc3N1bWVzOiBuZXZlciBjaG9vc2luZyBhIGZvbGRl
ciAobGF0ZXI6IHNwZWNpYWwgY2hvb3NlciBmb3IgdGhhdCwgYnV0IG1heWJlIG5ldmVyIG5lZWQp
CglpZiBmc3RhdChmaWxlbmFtZSkgPT0gImZvbGRlciIgdGhlbgoJCWNkKGZpbGVuYW1lKQoJCXJl
ZnJlc2hfZ3VpID0gdHJ1ZQoJCXJldHVybgoJZW5kCgkKCS0tIHByaW50aCgicHJvY2VzcyBpbnRl
bnRpb246ICIuLnBvZHtpbnRlbnRpb24sZmlsZW5hbWV9KQoJCgktLSBuZXdfZmlsZSBpcyBwcm9j
ZXNzZWQgYnkgb3Blbi5sdWEKCS0tICoqIG5ldmVyIHByb2Nlc3NlZCBieSByZXF1ZXN0ZXIgKioK
CWlmIChpbnRlbnRpb24gPT0gIm5ld19maWxlIiBvciBpbnRlbnRpb24gPT0gIm5ld190YWIiKSB0
aGVuCgkJaWYgKG5vdCBmaWxlbmFtZTpleHQoKSBhbmQgZW52KCkudXNlX2V4dCkgZmlsZW5hbWUu
Lj0iLiIuLmVudigpLnVzZV9leHQKCQljcmVhdGVfcHJvY2VzcyhlbnYoKS5vcGVuX3dpdGggYW5k
IGVudigpLm9wZW5fd2l0aCBvciAiL3N5c3RlbS91dGlsL29wZW4ubHVhIiwKCQkJewoJCQkJYXJn
diA9IHtmaWxlbmFtZX0sCgkJCQlmaWxldmlldyA9IHt7bG9jYXRpb249ZnVsbHBhdGgoZmlsZW5h
bWUpLG1vZGU9IlJXIn19LCAtLSBncmFudCBwZXJtaXNzaW9uIHRvIGFjY2VzcyBpdCAoaW4gY2Fz
ZSBvcGVuaW5nIHByb2dyYW0gaXMgc2FuZGJveGVkKQoJCQl9KQoJCXBvcF9pbnRlbnRpb24oKQoJ
CXJldHVybgoJZW5kCgkKCS0tIG5ld19mb2xkZXIgYWx3YXlzIGludGVybmFsCglpZiAoaW50ZW50
aW9uID09ICJuZXdfZm9sZGVyIikgdGhlbgoJCW1rZGlyKGZpbGVuYW1lKQoJCXBvcF9pbnRlbnRp
b24oKQoJCXJldHVybgoJZW5kCgoJaWYgKGludGVudGlvbiA9PSAibmV3X2NhcnRyaWRnZSIpIHRo
ZW4KCQlpZiAobm90IGZpbGVuYW1lOmV4dCgpKSBmaWxlbmFtZS4uPSIucDY0IgoJCWNwKCIvc3lz
dGVtL21pc2MvbmV3X2NhcnQucDY0IiwgZmlsZW5hbWUpCgkJLS0gMC4yLjBpOiBhbHNvIGxvYWQK
CQljcmVhdGVfcHJvY2VzcygiL3N5c3RlbS91dGlsL2xvYWQubHVhIiwgeyBhcmd2ID0ge2Z1bGxw
YXRoKGZpbGVuYW1lKX0gfSkKCQktLW1rZGlyKGZpbGVuYW1lKQoJCXBvcF9pbnRlbnRpb24oKQoJ
CXJldHVybgoJZW5kCgoJaWYgKGludGVudGlvbiA9PSAicmVuYW1lIikgdGhlbgoJCS0tIHByaW50
aCgicmVuYW1lOiAiLi5pbnRlbnRpb25fZmlsZW5hbWUuLiIgdG86ICIuLmZpbGVuYW1lKQoJCWlm
IChmc3RhdChmaWxlbmFtZSkpIHRoZW4KCQkJbm90aWZ5KCJjYW4gbm90IHJlbmFtZSB0byBhbiBl
eGlzdGluZyBmaWxlIikKCQllbHNlCgkJCWlmIChub3QgZmlsZW5hbWU6ZXh0KCkgYW5kIGludGVu
dGlvbl9maWxlbmFtZTpleHQoKSkgdGhlbgoJCQkJZmlsZW5hbWUuLj0iLiIuLmludGVudGlvbl9m
aWxlbmFtZTpleHQoKQoJCQllbmQKCQkJbG9jYWwgcmVzID0gbXYoaW50ZW50aW9uX2ZpbGVuYW1l
LCBmaWxlbmFtZSkKCQkJaWYgKHJlcykgdGhlbgoJCQkJbm90aWZ5KCJlcnJvcjogIi4ucmVzKQoJ
CQllbHNlaWYgKG1vZGUgPT0gImRlc2t0b3AiKSB0aGVuCgkJCQljb3B5X2Rlc2t0b3BfaXRlbV9h
dHRyaWJ1dGVzKGludGVudGlvbl9maWxlbmFtZTpiYXNlbmFtZSgpLCBmaWxlbmFtZTpiYXNlbmFt
ZSgpKQoJCQllbmQKCQllbmQKCgkJcG9wX2ludGVudGlvbigpCgkJcmV0dXJuCgllbmQKCQoJLS0g
aW50ZW50aW9uIGNhbWUgZnJvbSBleHRlcm5hbCByZXF1ZXN0ZXIKCS0tIGUuZy4gc2F2ZSwgc2F2
ZSBhcwoJaWYgKGludGVudGlvbl9yZXF1ZXN0ZXJfcHJvY19pZCkgdGhlbgoJCS0tIHByaW50aCgi
c2VuZGluZyBpbnRlbnRpb24gdG86ICIuLmludGVudGlvbl9yZXF1ZXN0ZXJfcHJvY19pZCkKCgkJ
LS0gMS4gZmlsZW5hdiBoYXMgdGhlIHBvd2VyIHRvIGdyZWVubGlnaHQgUi9XIGFjY2VzcyB0byBh
IGZpbGUgYWZ0ZXIgdXNlciBoYXMgaW50ZW50aW9uYWxseSBzZWxlY3RlZCBpCgkJc2VuZF9tZXNz
YWdlKGludGVudGlvbl9yZXF1ZXN0ZXJfcHJvY19pZCwge2V2ZW50PSJleHRlbmRfZmlsZXZpZXci
LCBmaWxlbmFtZT1maWxlbmFtZX0pCgoJCS0tIDIuIHRlbGwgdGhlIHJlcXVlc3RlcgoJCXNlbmRf
bWVzc2FnZShpbnRlbnRpb25fcmVxdWVzdGVyX3Byb2NfaWQsIC0tIGVudigpLnBhcmVudF9waWQs
IAoJCQl7ZXZlbnQ9aW50ZW50aW9uLCBmaWxlbmFtZT1maWxlbmFtZX0pCgoJCWV4aXQoKSAtLSB0
byBkbzogaXMgdGhpcyBhbHdheXMgY29ycmVjdD8gc2hvdWxkIG9ic2VydmUgd2luZG93X2F0dHJp
YnMuYXV0b2Nsb3NlIHRoZSB3YXkgdGhhdCBvcGVuX3dpdGggZG9lcz8KCQlyZXR1cm4KCWVuZAkK
CmVuZAoKCgoKOjogaW50ZXJmLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIz
LTExLTIwIDA4OjExOjM5Iixtb2RpZmllZD0iMjAyNS0wNC0xOSAxOToyMDo0MiIscmV2aXNpb249
MzgzNyxzdG9yZWQ9IjIwMjMtMjEtMjkgMDk6MjE6MTkiXV0KLS0gaW50ZXJmYWNlCgoKdG9wX3og
PSAxCgotLSBzaG9ydGN1dAotLSBkb24ndCBuZWVkIGRlc2t0b3AgKGp1c3QgdXNlIGRlc2t0b3Ah
KSBvciBmYXZvdXJpdGVzICh0b28gbWFueSBjb25jZXB0cykKc2hvcnRjdXRzID0KewoJLS0gImZh
dnMiIHRvIGF2b2lkIGRlY2lkaW5nIHdoaWNoIHNwZWxsaW5nIHRvIHVzZQoJeyIvcmFtL2NhcnQi
LHVzZXJkYXRhIltnZnhdMDgwODc3Nzc3Nzc3NzAwMDAwMDc3MDAwMDAwNzcwMDAwMDA3Nzc3Nzc3
Nzc3MDAwMDA3Nzc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0ifSwKCS0teyIvZGVza3RvcCIsIHVzZXJk
YXRhIltnZnhdMDgwODc3Nzc3Nzc3MDAwMDAwMDA3Nzc3Nzc3NzcwNzc3Nzc3Nzc3Nzc3Nzc3MDc3
Nzc3Nzc3Nzc3Nzc3MDAwMDAwMDBbL2dmeF0ifSwKCS0teyIvYXBwZGF0YS9maWxlbmF2L2ZhdnMi
LHVzZXJkYXRhIltnZnhdMDgwODAwMDAwMDAwMDc3MDc3MDA3Nzc3Nzc3MDc3Nzc3NzcwMDc3Nzc3
MDAwMDc3NzAwMDAwMDcwMDAwMDAwMDAwMDBbL2dmeF0ifSwKCXsiLyIsdXNlcmRhdGEiW2dmeF0w
ODA4MDAwMDAwMDAwMDAwMDc3MDAwMDA3NzAwMDAwNzcwMDAwMDc3MDAwMDA3NzAwMDAwNzcwMDAw
MDAwMDAwMDAwMFsvZ2Z4XSJ9LAp9CmJ1dHRvbl9nZnggPQp7Cgl1cGRpciA9IHVzZXJkYXRhIltn
ZnhdMDgwODAwMDAwMDAwMDA3NzAwMDAwNzc3NzAwMDc3Nzc3NzAwMDA3NzAwMDAwMDc3MDAwMDAw
Nzc3NzAwMDAwMDAwMDBbL2dmeF0iLAoJLS1saXN0ICA9IHVzZXJkYXRhIltnZnhdMDgwODc3Nzcw
NzcwMDAwMDAwMDA3Nzc3MDc3MDAwMDAwMDAwNzc3NzA3NzAwMDAwMDAwMDc3NzcwNzcwMDAwMDAw
MDBbL2dmeF0iLAoJbGlzdCAgPSB1c2VyZGF0YSJbZ2Z4XTA4MDg3NzcwNzA3MDAwMDAwMDAwNzc3
MDcwNzAwMDAwMDAwMDc3NzA3MDcwMDAwMDAwMDA3NzcwNzA3MDAwMDAwMDAwWy9nZnhdIiwgLS0g
dG8gZG86IHN0aWxsIHRvbyBzaW1pbGFyIHRvIGFwcCBtZW51IAoJZ3JpZCAgPSB1c2VyZGF0YSJb
Z2Z4XTA4MDg3NzcwNzc3MDc3NzA3NzcwNzc3MDc3NzAwMDAwMDAwMDc3NzA3NzcwNzc3MDc3NzA3
NzcwNzc3MDAwMDAwMDAwWy9nZnhdIiwKfQpmdW5jdGlvbiBnZW5lcmF0ZV90b29sYmFyKCkKCWxv
Y2FsIHNob3J0Y3V0X3cgPSAxNgoJbG9jYWwgc2hvcnRjdXRzX3cgPSBzaG9ydGN1dF93ICogI3No
b3J0Y3V0cyArIDgKCQoJdG9vbGJhciA9IGd1aTphdHRhY2h7CgkJeCA9IDAsIHkgPSAwLAoJCXdp
ZHRoX3JlbCA9IDEuMCwKCQloZWlnaHQgPSAxNgoJfQoJCglmdW5jdGlvbiB0b29sYmFyOmRyYXco
KQoJCXJlY3RmaWxsKDAsMCwxMDAwLHNlbGYuaGVpZ2h0LDYpCgllbmQKCQoJLS0gbmF2YmFyCgkt
LSB0byBkbzogcHV0IHVwX2ZvbGRlciBidXR0b24gb24gbGVmdD8gbWF5YmUgbm90IQoJbmF2dGV4
dCA9IHRvb2xiYXI6YXR0YWNoX3RleHRfZWRpdG9yewoJCXg9MzQseT0yLAoJCXdpZHRoPTEwMCwK
CQl3aWR0aF9yZWwgPSAxLjAsCgkJd2lkdGhfYWRkID0gLXNob3J0Y3V0c193IC0gMzQsCgkJaGVp
Z2h0PTEyLAoJCW1heF9saW5lcyA9IDEsCQoJCWtleV9jYWxsYmFjayA9IHsgCgkJCgkJCWVudGVy
ID0gZnVuY3Rpb24gKCkgCgkJCQkKCQkJCWxvY2FsIHBhdGggPSBuYXZ0ZXh0OmdldF90ZXh0KClb
MV0KCQkJCWxvY2FsIGF0dHJpYnMgPSBmc3RhdChwYXRoKQoKCQkJCS0tIHByaW50aCgicHJlc3Nl
ZCBlbnRlciAiLi5wb2R7bmF2dGV4dDpnZXRfdGV4dCgpWzFdLCBwYXRoLCBhdHRyaWJzfSkKCQkJ
CQoJCQkJaWYgYXR0cmlicyA9PSAiZm9sZGVyIiB0aGVuCgkJCQkJY2QocGF0aCkKCQkJCWVsc2Vp
ZiBpbnRlbnRpb24gdGhlbgoJCQkJCXByb2Nlc3NfaW50ZW50aW9uKCkKCQkJCWVsc2VpZiAoYXR0
cmlicyA9PSAiZmlsZSIpIHRoZW4KCQkJCQktLSBvcGVuIGl0OyBzYW1lIGFzIGRvdWJsZSBjbGlj
a2luZyBvbiBpdAoJCQkJCWNsaWNrX29uX2ZpbGUocGF0aCkKCQkJCWVsc2UKCQkJCQktLSBjcmVh
dGUgZmlsZT8KCQkJCQktLT4gdG8gZG86IHN3aXRjaCB0byBOZXcgRmlsZSBpbnRlbnRpb24KCQkJ
CQkJLS0gKHVzZWQgY2FuIGNhbmNlbCBpZiBpdCB3YXMgYSB0eXBvKQoJCQkJZW5kCgkJCQkJCgkJ
CQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJCQoJCQllbmQsCgkJCQoJCQl0YWIgPSBmdW5jdGlvbiAo
KQoJCQkJbG9jYWwgcGF0aCA9IG5hdnRleHQ6Z2V0X3RleHQoKVsxXQoJCQkJcGF0aCA9IHRhYl9j
b21wbGV0ZV9maWxlbmFtZShwYXRoKQoJCQkJCgkJCQluYXZ0ZXh0OnNldF90ZXh0e3BhdGh9CgkJ
CQktLSBoYWNreSB3YXkgdG8gcHV0IHRoZSBtb3VzZSBjdXJzb3IgYXQgdGhlIGVuZAoJCQkJbmF2
dGV4dDpjbGljayh7bXg9MTAwMCxteT0yfSkKCQkJCQoJCQllbmQKCQkKCQl9Cgl9CgkKCQoJbG9j
YWwgcGF0aCA9IHB3ZCgpCglpZiAoc3RyaW5nLnN1YihwYXRoLC0xKSAhPSAiLyIpIHBhdGggPSBw
YXRoLi4iLyIKCW5hdnRleHQ6c2V0X3RleHR7cGF0aH0KCW5hdnRleHQ6c2V0X2tleWJvYXJkX2Zv
Y3VzKHRydWUpCgktLSBoYWNreSB3YXkgdG8gcHV0IHRoZSBtb3VzZSBjdXJzb3IgYXQgdGhlIGVu
ZAoJbmF2dGV4dDpjbGljayh7bXg9MTAwMCxteT0yfSkKCQoJLS0gc2hvcnRjdXQgYnV0dG9ucwoJ
Cglmb3IgaT0xLCNzaG9ydGN1dHMgZG8KCQl0b29sYmFyOmF0dGFjaHsKCQkJY3Vyc29yID0gInBv
aW50ZXIiLAoJCQktLXggPSBnZXRfZGlzcGxheSgpOndpZHRoKCktc2hvcnRjdXRzX3cgKyA1ICsg
KGktMSkgKiBzaG9ydGN1dF93LAoJCQl4ID0gLXNob3J0Y3V0c193ICsgNSArIGkgKiBzaG9ydGN1
dF93LAoJCQlqdXN0aWZ5ID0gInJpZ2h0IiwKCQkJeSA9IDMsCgkJCXdpZHRoPXNob3J0Y3V0X3cs
CgkJCWhlaWdodD0xMCwKCQkJbG9jYXRpb249c2hvcnRjdXRzW2ldWzFdLAoJCQlpY29uPXNob3J0
Y3V0c1tpXVsyXSwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJCQktLXJlY3RmaWxsKDAsMCxz
ZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSw3KQoJCQkJcGFsKDcsc2VsZi5sb2NhdGlvbj09cHdk
KCkgYW5kIDcgb3IgMTMpCgkJCQlzcHIoc2VsZi5pY29uLHNlbGYud2lkdGgvMi1zZWxmLmljb246
d2lkdGgoKS8yLDEpCgkJCQlwYWwoNyw3KQoJCQllbmQsCgkJCXRhcCA9IGZ1bmN0aW9uKHNlbGYp
CgkJCQljZChzZWxmLmxvY2F0aW9uKQoJCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJCWVuZAoJCX0K
CWVuZAoJCgktLSB1cGRpciBidXR0b24KCQoJdG9vbGJhcjphdHRhY2h7CgkJCWN1cnNvciA9ICJw
b2ludGVyIiwKCQkJeCA9IDE2LHkgPSAzLHdpZHRoPXNob3J0Y3V0X3csaGVpZ2h0PTEwLAoJCQlp
Y29uPWJ1dHRvbl9nZngudXBkaXIsCgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmKQoJCQkJcGFsKDcs
MTMpIC0tcHdkKCkgPT0gIi8iIGFuZCA2IG9yIDEzKQoJCQkJc3ByKHNlbGYuaWNvbixzZWxmLndp
ZHRoLzItc2VsZi5pY29uOndpZHRoKCkvMiwxKQoJCQkJcGFsKDcsNykKCQkJZW5kLAoJCQl0YXAg
PSBmdW5jdGlvbihzZWxmKQoJCQkJaWYgKGZzdGF0KCIuLiIpID09ICJmaWxlIikgdGhlbiAtLSBo
YXBwZW5zIGZvciBlLmcuIC9mb28udHh0L0AKCQkJCQljZCgiLi4vLi4iKQoJCQkJZWxzZQoJCQkJ
CWNkKCIuLiIpCgkJCQllbmQKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQl9CgkJCgkt
LSB0b2dnbGUgdmlldyBtb2RlCgkKCXRvb2xiYXI6YXR0YWNoewoJCQljdXJzb3IgPSAicG9pbnRl
ciIsCgkJCXggPSAyLHkgPSAzLHdpZHRoPXNob3J0Y3V0X3csaGVpZ2h0PTEwLAoJCQlkcmF3ID0g
ZnVuY3Rpb24oc2VsZikKCQkJCWxvY2FsIGljb24gPSBtb2RlID09ICJsaXN0IiBhbmQgYnV0dG9u
X2dmeC5saXN0IG9yIGJ1dHRvbl9nZnguZ3JpZAoJCQkJcGFsKDcsMTMpCgkJCQlzcHIoaWNvbixz
ZWxmLndpZHRoLzItaWNvbjp3aWR0aCgpLzIsMSkKCQkJCXBhbCg3LDcpCgkJCWVuZCwKCQkJdGFw
ID0gZnVuY3Rpb24oc2VsZikKCQkJCW1vZGUgPSAobW9kZSA9PSAiZ3JpZCIpIGFuZCAoa2V5ImN0
cmwiIGFuZCAiZGVza3RvcCIgb3IgImxpc3QiKSBvciAiZ3JpZCIKCQkJCXNvbGlkX2Rlc2t0b3Ag
PSB0cnVlCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZW5kCgkJfQoJCgkKZW5kCgoKZnVuY3Rp
b24gZ2VuZXJhdGVfaW50ZXJmYWNlKCkKCglsb2NhbCBzY3JvbGxfeSA9IGNvbnRlbnQgYW5kIGNv
bnRlbnQueQoJbG9jYWwgdGV4dDAgPSBuYXZ0ZXh0IGFuZCBuYXZ0ZXh0OmdldF90ZXh0KCkKCQoJ
Z3VpX3csIGd1aV9oID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpLCBnZXRfZGlzcGxheSgpOmhlaWdo
dCgpCgkKCS0tIHNob3cgcGF0aCB3aGVuIG5vdCBpbiBpbnRlbnRpb24gbW9kZQoJaWYgKG5vdCBp
bnRlbnRpb24pIHRoZW4KCQl3aW5kb3d7dGl0bGUgPSBwd2QoKX0KCWVuZAoJCglndWkgPSBjcmVh
dGVfZ3VpKCkKCQoJLS0gcHJpbnRoKCJnZW5lcmF0ZV9pbnRlcmZhY2UoKSIpCgkKCWxvY2FsIGFk
ZF9oZWlnaHQgPSBpbnRlbnRpb24gYW5kIC0xOSBvciAwCgoJaWYgKG1vZGUgPT0gImxpc3QiKSAg
ICBnZW5lcmF0ZV9pbnRlcmZhY2VfbGlzdCgxNiwgYWRkX2hlaWdodCkKCWlmIChtb2RlID09ICJn
cmlkIikgICAgZ2VuZXJhdGVfaW50ZXJmYWNlX2dyaWQoMTYsIGFkZF9oZWlnaHQpCglpZiAobW9k
ZSA9PSAiZGVza3RvcCIpIGdlbmVyYXRlX2ludGVyZmFjZV9kZXNrdG9wKDAsIGFkZF9oZWlnaHQp
CgkKCWlmIChtb2RlICE9ICJkZXNrdG9wIikgdGhlbgoJCWdlbmVyYXRlX3Rvb2xiYXIoKQoJZW5k
CgkKCWlmIChpbnRlbnRpb24pIGdlbmVyYXRlX2ludGVudGlvbl9wYW5lbCgpCgkKCS0tIHJlc3Rv
cmUgc29tZSBzdGF0ZQoJaWYgKGNvbnRlbnQgYW5kIHNjcm9sbF95KSBjb250ZW50LnkgPSBzY3Jv
bGxfeQoKCWlmIChuYXZ0ZXh0KSBuYXZ0ZXh0OnNldF90ZXh0e3B3ZCgpfQoJCmVuZAoKCgoKCjo6
IGxpc3QubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMjAgMDY6Mjc6
NDIiLG1vZGlmaWVkPSIyMDI1LTA0LTE5IDE5OjIwOjQyIixyZXZpc2lvbj0zNTE1LHN0b3JlZD0i
MjAyMy0yMS0yOSAwOToyMToxOSJdXQotLSBtb2RlOiBsaXN0CmxvY2FsIGl0ZW1faCA9IDEyCmxv
Y2FsIGZ1bmN0aW9uIGNyZWF0ZV9maWxlX2l0ZW0ocGFyZW50LCBmZiwgeCwgeSkKCWlmIChub3Qg
ZmYgb3Igbm90IGZmLmZpbGVuYW1lKSByZXR1cm4KCWxvY2FsIGVsID0gewoJCXggPSB4LCB5ID0g
eSwgd2lkdGg9NDgwLAoJCXdpZHRoX3JlbCA9IDEuMCwgaGVpZ2h0PTEyLAoJCWZpbmZvICAgID0g
IGZmLAoJCWZpbGVuYW1lID0gZmYuZmlsZW5hbWUsCgkJcGFyZW50ID0gcGFyZW50LAoJfQoKCWZ1
bmN0aW9uIGVsOmRyYWcobXNnKQoJCWRyYWdfc2VsZWN0ZWRfZmlsZXMobXNnKQoJZW5kCglmdW5j
dGlvbiBlbDpyZWxlYXNlKG1zZykKCQlkcmFnZ2luZ19maWxlcyA9IG5pbAoJZW5kCgoJLS0gZnJv
bSBncmlkIHZlcnNpb24KCWZ1bmN0aW9uIGVsOnVwZGF0ZShtc2cpCgkJLS0gcmVzZXQgYXV0by1v
cGVuIG1lY2hhbmlzbQoJCWlmIChub3QgZHJhZ2dpbmdfZmlsZXMpIHRoZW4KCQkJc2VsZi5vcGVu
ZWRfd2hpbGVfZHJhZ2dpbmdfZmlsZXMgPSBmYWxzZQoJCQlzZWxmLmhvdmVyX2NvdW50ZXIgPSAw
CgkJCXJldHVybgoJCWVuZAoJCS0tIHRvIGRvOiBob3ZlciBsb2dpYwoJZW5kCgoJCglmdW5jdGlv
biBlbDpkcmF3KCkKCQlpZiAoc2VsZi5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQlyZWN0ZmlsbCgw
LDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMTApCgkJZW5kCgkJCgkJbGluZSgwLHNlbGYu
aGVpZ2h0LTEsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsNikKCgkJcHJpbnQoc2VsZi5maW5m
by5maWxlbmFtZV9wcmludGFibGUsNCwyLDEpCgkJCgkJaWYgKG5vdCBzZWxmLmZpbmZvLmlzX25v
bl9jYXJ0X2ZvbGRlcikgcHJpbnQoc3RyaW5nLmZvcm1hdCgiJTZkIixzZWxmLmZpbmZvLnNpemUp
LDE0MCwyLDEpCgkJCgkJaWYgKHNlbGYuZmluZm8ubWV0YS5tb2RpZmllZCkgcHJpbnQoc2VsZi5m
aW5mby5tZXRhLm1vZGlmaWVkOnN1YigxLDEwKSwgMjAwLCAyLDEpCgkKCQktLSBmb3IgZHJhZ2dp
bmcgZmlsZSBpY29ucwoJCS0tW1sKCQkJc2VsZi5maW5mby54ID0gc2VsZi54ICsgc2VsZi5wYXJl
bnQuc3gKCQkJc2VsZi5maW5mby55ID0gc2VsZi55ICsgc2VsZi5wYXJlbnQuc3kKCQkJbG9jYWwg
bXgsbXkgPSBtb3VzZSgpCgkJCXNlbGYuZmluZm8ueSA9IG15ICsgKHNlbGYuZmluZm8ueSAtIG15
KSAvIDQgLS0gc2NydW5jaCB1cAoJCV1dCgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWlm
IChrZXkoImN0cmwiKSkgdGhlbgoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gbm90IHNlbGYuZmlu
Zm8uc2VsZWN0ZWQKCQllbHNlaWYga2V5InNoaWZ0IiBhbmQgbGFzdF9pbmRleCB0aGVuCgkJCS0t
IHNlbGVjdCByYW5nZQoJCQlsb2NhbCBpMCxpMSA9IGxhc3RfaW5kZXgsIHNlbGYuZmluZm8uaW5k
ZXgKCQkJLS1wcmludGgoInNlbGVjdGluZyByYW5nZSAiLi5wb2R7aTAsaTF9KQoJCQlpZiAoaTAg
PiBpMSkgaTAsaTE9aTEsaTAKCQkJZm9yIGk9aTAsaTEgZG8KCQkJCWZpbmZvW2ZpbGVuYW1lc1tp
XV0uc2VsZWN0ZWQgPSB0cnVlCgkJCWVuZAoJCWVsc2UKCQkJaWYgKG5vdCBzZWxmLmZpbmZvLnNl
bGVjdGVkKSB0aGVuCgkJCQlkZXNlbGVjdF9hbGwoKQoJCQllbmQKCQkJc2VsZi5maW5mby5zZWxl
Y3RlZCA9IHRydWUKCQkJbGFzdF9pbmRleCA9IHNlbGYuZmluZm8uaW5kZXgKCQkJLS0gc2V0CgkJ
CW5hdnRleHQ6c2V0X3RleHR7ZnVsbHBhdGgoZWwuZmlsZW5hbWUpfQoJCWVuZAkKCgkJdXBkYXRl
X2NvbnRleHRfbWVudSgpCgoJCWlmIGludGVudGlvbiA9PSAic2F2ZV9maWxlX2FzIiBvciBpbnRl
bnRpb24gPT0gInNlbGVjdF9maWxlIiBvciBpbnRlbnRpb24gPT0gIm5ld19maWxlIiBvciBpbnRl
bnRpb24gPT0gIm5ld19jYXJ0IiB0aGVuCgkJCS0tIHNldCB0ZXh0CgkJCWludGVudGlvbl90ZXh0
OnNldF90ZXh0KHtlbC5maWxlbmFtZX0pCgkJCW5hdnRleHQ6c2V0X3RleHR7cHdkKCl9CgkJZW5k
CgllbmQKCglmdW5jdGlvbiBlbDp0YXAobXNnKQoJCS0tIHVuc2VsZWN0IGFsbCBidXQgY3VycmVu
dCBpdGVtIChuZWVkIHRvIHByZXNlcnZlIHNlbGVjdGlvbiBvbiBjbGljayBmb3IgZHJhZ2dpbmcg
LyBjb250ZXh0IG1lbnUpCgkJaWYgbm90IGtleSJjdHJsIiBhbmQgbm90IGtleSJzaGlmdCIgYW5k
IG1zZy5sYXN0X21iID09IDEgdGhlbgoJCQlkZXNlbGVjdF9hbGwoKQoJCQlzZWxmLmZpbmZvLnNl
bGVjdGVkID0gdHJ1ZQoJCWVuZAoJZW5kCgoJZnVuY3Rpb24gZWw6ZG91YmxlY2xpY2soKQoJCWNs
aWNrX29uX2ZpbGUoc2VsZi5maWxlbmFtZSkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9u
IGdlbmVyYXRlX2ZlbHNfbGlzdCgpCgktLSBoYW5kbGUgZmlsZSBpdGVtcyBsYXllciBvZiBndWkg
bWFudWFsbHkgc28gY2FuIG9wdGltaXNlCgktLSAoZS5nLiBvbmx5IGRyYXcgLyB1cGRhdGUgdmlz
aWJsZSBpdGVtcykKCQkKCWxvY2FsIHh4LHl5ID0gMCwwCglsb2NhbCBpdGVtX3cgPSA2OAoJLS0g
dG8gZG86IHNob3VsZCBiZSBwYXJlbnQKCWxvY2FsIGl0ZW1zX3ggPSBnZXRfZGlzcGxheSgpOndp
ZHRoKCkgXCBpdGVtX3cKCQoJZmkgPSB7fQoJCglmb3IgaT0xLCNmaWxlbmFtZXMgZG8KCQlhZGQo
ZmksIGNyZWF0ZV9maWxlX2l0ZW0oY29udGVudCwgZmluZm9bZmlsZW5hbWVzW2ldXSwgMCwgKGkt
MSkqaXRlbV9oKSkKCWVuZAplbmQKZnVuY3Rpb24gZ2VuZXJhdGVfaW50ZXJmYWNlX2xpc3QoeTAs
IGFkZF9oZWlnaHQpCgl1cGRhdGVfZmlsZV9pbmZvKHRydWUpCgkKCWxvY2FsIHBvaW50ZXJfZWwg
PSBuaWwKCQoJCgktLSBsb2NhdGlvbiBpcyBpbiB3aW5kb3cgdGl0bGUhCglsb2NhbCBjb250YWlu
ZXIgPSBndWk6YXR0YWNoewoJCXg9MCx5PXkwKzEyLAoJCXdpZHRoX3JlbCA9IDEuMCwKCQloZWln
aHRfcmVsID0gMS4wLAoJCWhlaWdodF9hZGQgPSAtKHkwKzEyKSArIGFkZF9oZWlnaHQsCgkJZHJh
d19kZXBlbmRlbmN5ID0gZmlsZXZpZXdfc3RhdGUKCX0KCglmdW5jdGlvbiBjb250YWluZXI6ZHJh
dygpCgkJcmVjdGZpbGwoMCwwLDEwMDAsc2VsZi5oZWlnaHQsNykKCWVuZAoKCWNvbnRlbnQgPSBj
b250YWluZXI6YXR0YWNoewoJCXg9MCx5PTAsCgkJd2lkdGhfcmVsPTEuMCwKCQloZWlnaHQ9I2Zp
bGVuYW1lcyAqIGl0ZW1faCwKCQljbGlwX3RvX3BhcmVudCA9IHRydWUKCX0KCgktLSBhdHRyaWJ1
dGUgaGVhZGVycwoJLS0gdG8gZG86IGNsaWNrIGZvciBzb3J0aW5nIGJ5IHRoYXQgYXR0cmlidXRl
CgkKCWd1aTphdHRhY2h7CgkJeD0wLHk9eTAsd2lkdGhfcmVsPTEuMCxoZWlnaHQ9MTIsCgkJd2lk
dGggPSAxMDAsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0
aC0xLHNlbGYuaGVpZ2h0LTEsIDYpCgkJCXByaW50KCJmaWxlbmFtZSIsIDQsIDIsIDEzKQoJCQlw
cmludCgic2l6ZSIsIDE1MSwyLDEzKSAtLSByaWdodC1qdXN0aWZpZWQgYmVjYXVlcyB2YWx1ZXMg
YXJlIHJpZ2h0LWp1c3RpZmllZAoJCQlwcmludCgibW9kaWZpZWQiLDIxMSwyLDEzKSAtLSByaWdo
dC1qdXN0aWZpZWQgdG8gbWF0Y2ggc2l6ZTsgdmFsdWVzIGFyZSBhbHdheXMgc2FtZSB3aWR0aCBz
byBmcmVlIHRvIGNob29zZSBqdXN0aWZpY2F0aW9uCgkJZW5kCgl9CgkKCS0tLS0tLS0tCgkKCWZ1
bmN0aW9uIGNvbnRlbnQ6Y2xhbXBfc2Nyb2xsaW5nKCkKCQlsb2NhbCBtYXhfeSA9IG1heCgwLCBj
b250ZW50LmhlaWdodCAtIGNvbnRhaW5lci5oZWlnaHQpCgkJY29udGVudC55ID0gbWlkKDAsIGNv
bnRlbnQueSwgLW1heF95KQoJCWNvbnRlbnQueCA9IG1pbigwLCBjb250ZW50LngpCgllbmQKCWZ1
bmN0aW9uIGNvbnRlbnQ6dXBkYXRlKCkKCgkJLS0gKzIwIHNvIHRoYXQgdGhlcmUgaXMgYmxhbmsg
c3BhY2UgYXQgdGhlIGJvdHRvbTsgc2hvd3MgZW5kIG9mIGxpc3QgYW5kIGNhbiBjbGljayB0byBk
ZXNlbGVjdCBhZnRlciBzZWxlY3RpbmcgYWxsCgkJc2VsZi5oZWlnaHQgPSBtYXgoc2VsZi5wYXJl
bnQuaGVpZ2h0LCAjZmlsZW5hbWVzICogaXRlbV9oICsgMjApIAoJCQoJCWNvbnRlbnQ6Y2xhbXBf
c2Nyb2xsaW5nKCkKCQkKCQktLSB1cGRhdGUgcG9pbnRlciBlbGVtZW50CgkJbG9jYWwgbXgsbXks
bWIgPSBtb3VzZSgpCgkJbG9jYWwgaW5kZXggPSAxICsgKG15IC0gc2VsZi5zeSkgXCBpdGVtX2gK
CQlwb2ludGVyX2VsID0gZmlbZmxyKGluZGV4KV0KCQkKCQktLSBzZXQgY3Vyc29yCgkJd2luZG93
e2N1cnNvciA9IHBvaW50ZXJfZWwgYW5kICJwb2ludGVyIiBvciAxfQoJCQoJZW5kCgktLSAKCQkJ
CglmdW5jdGlvbiBjb250ZW50OmRyYXcoKQoJCQoJCWlmICgjZmkgPT0gMCkgcmV0dXJuCgkKCQls
b2NhbCBtaW5pID0gbWlkKDEsICgtY29udGVudC55ICAgICAgICAgICAgICAgICAgICkgXCBpdGVt
X2ggKyAxLCAjZmkpCgkJbG9jYWwgbWF4aSA9IG1pZCgxLCAoLWNvbnRlbnQueSArIGNvbnRhaW5l
ci5oZWlnaHQpIFwgaXRlbV9oICsgMSwgI2ZpKQoJCWZvciBpPW1pbmksbWF4aSBkbwoJCQkKCQkJ
bG9jYWwgZmYgPSBmaVtpXQoJCQlsb2NhbCBzeCA9IGZmLnggKyBjb250ZW50LnggXCAxICsgY29u
dGFpbmVyLnggCgkJCWxvY2FsIHN5ID0gZmYueSArIGNvbnRlbnQueSBcIDEgKyBjb250YWluZXIu
eSAKCQkKCQkJY2FtZXJhKC1zeCwgLXN5KQoJCQkKCQkJLS0gY2xpcHBpbmcgaGFjazogZG9uJ3Qg
ZHJhdyBvdmVyIHRvb2xiYXIgb3IgY29sdW1uIGhlYWRlcnMgYXQgdG9wCgkJCWNsaXAoc3gsIG1h
eChzeSwgY29udGFpbmVyLnkpLCBmZi53aWR0aCwgZmYuaGVpZ2h0KQoJCQlmZjpkcmF3KCkKCQll
bmQKCQkKCQljbGlwKCkKCWVuZAoJCgktLSBmb3J3YXJkIG1lc3NhZ2VzIChsaXN0IHZpZXcpCgkt
LSB0byBkbzogYWxsb3cgc3Vic2NyaWJlX3RvX2V2ZW50cyBhdCBndWkgZWxlbWVudCBsZXZlbD8K
CQotLVtbCglmdW5jdGlvbiBjb250ZW50OmNsaWNrKC4uLikKCQlwb2ludGVyX2VsOmNsaWNrKC4u
LikKCWVuZApdXQoKCWZ1bmN0aW9uIGNvbnRlbnQ6dGFwKG1zZykKCQlpZiAocG9pbnRlcl9lbCBh
bmQgcG9pbnRlcl9lbC50YXApIHBvaW50ZXJfZWw6dGFwKG1zZykKCWVuZAoKCWZ1bmN0aW9uIGNv
bnRlbnQ6Y2xpY2sobXNnKQoJCWlmIChwb2ludGVyX2VsKSB0aGVuCgkJCXBvaW50ZXJfZWw6Y2xp
Y2sobXNnKQoJCWVsc2UKCQkJaWYgKG5vdCBrZXkiY3RybCIpIGRlc2VsZWN0X2FsbCgpCgkJCXNl
bCA9IHttc2cubXgsIG1zZy5teX0gLS0gcmVsYXRpdmUgdG8gZ3VpIGVsZW1lbnQKCQllbmQKCWVu
ZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6cmVsZWFzZSgpCgkJc2VsID0gbmlsCgkJZHJhZ2dpbmdfZmls
ZXMgPSBuaWwKCWVuZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6ZG91YmxlY2xpY2soLi4uKQoJCXBvaW50
ZXJfZWw6ZG91YmxlY2xpY2soLi4uKQoJZW5kCgoJZnVuY3Rpb24gY29udGVudDpkcmFnKG1zZykK
CQoJCS0tIGRyYWdnaW5nIGEgZmlsZQoJCWlmIChwb2ludGVyX2VsIGFuZCBwb2ludGVyX2VsLmZp
bmZvIGFuZCBwb2ludGVyX2VsLmRyYWcgYW5kCgkJCW5vdCBzZWwpIHRoZW4KCQkJcG9pbnRlcl9l
bDpkcmFnKG1zZykKCQllbmQKCgkJLS0gKG5vIGRyYWcgdG8gc2VsZWN0IGluIGxpc3QgdmlldykK
CWVuZAoJCgktLXVwZGF0ZV9maWxlX2luZm8odHJ1ZSkKCWNvbnRhaW5lcjphdHRhY2hfc2Nyb2xs
YmFyc3thdXRvaGlkZT10cnVlfQoJCmVuZAoKCgoKOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyNS0xMS0yNCAyMDoyMDozMyIsZ2FsYWt0aXNrPXRydWUsbW9kaWZp
ZWQ9IjIwMjUtMTEtMjQgMjA6NDE6MzMiLHJldmlzaW9uPTEzXV0tLWVudigpISEKCi0tW1sKbm90
IHdvcmtpbmc6CglzZWxlY3RfZmlsZQoJZGVza3RvcCAodW5zdXJlIGlmIHdpbGwgZXZlciBiZSBz
dXBwb3J0ZWQpCl1dLS0KCl9lbnY9ZW52KCkKaWYgKF9lbnYuc2FuZGJveD09ImJicyIpIHRoZW4K
CW5vdGlmeSgiVGhpcyBkb2Vzbid0IHJ1biBjb3JyZWN0bHkgd2hlbiBzYW5kYm94ZWQgLSBnb2lu
ZyB0byB6ZXBzIikKZW5kCi0tZmFpbHNhZmUgdG8gZ28gdG8gemVwJ3MgZmlsZW5hdiBmb3IgYW55
dGhpbmcgdW5zdXBwb3J0ZWQKLS16ZXAgYXJnIHRvIGp1c3QgYWx3YXlzIGdvIHRvIHplcHMKaWYg
KG5vdCAoCihfZW52LmFyZ3YgYW5kIF9lbnYuYXJndlsxXT09Ii1kZXNrdG9wIikKb3IgKF9lbnYu
YXJndiBhbmQgX2Vudi5hcmd2WzFdPT0iemVwIikKb3IgKF9lbnYuemVwKQpvciAoX2Vudi5zYW5k
Ym94PT0iYmJzIikKLS1vciB0cnVlCikpIHRoZW4KCV9lbnYuY29ydW5fcHJvZ3JhbT1uaWwKCWNy
ZWF0ZV9wcm9jZXNzKCIvYXBwZGF0YS9nYWxha3Rpc2tGaWxlbmF2L2ZpbGVuYXYucDY0IixfZW52
KQplbHNlCglfZW52LmNvcnVuX3Byb2dyYW09bmlsCgljcmVhdGVfcHJvY2VzcygiL2FwcGRhdGEv
Z2FsYWt0aXNrRmlsZW5hdi96ZXBzZmlsZW5hdi5wNjQiLF9lbnYpCglleGl0KCkKZW5kCjo6IG9w
ZW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMDQgMTI6NDY6MTYi
LG1vZGlmaWVkPSIyMDI1LTA0LTE5IDE5OjIwOjQyIixyZXZpc2lvbj0zMzc3LHN0b3JlZD0iMjAy
My0yMS0yOSAwOToyMToxOSJdXQoKCQoJZnVuY3Rpb24gY2xpY2tfb25fZmlsZShmaWxlbmFtZSwg
YWN0aW9uLCBhcmd2KQoJCQoJCS0tcHJpbnRoKCJvcGVuaW5nOiAiLi50b3N0cihmaWxlbmFtZSkp
CgkJCgkJLS1pZiAobm90IGludGVudGlvbiBhbmQgc3RyaW5nLnN1YihmaWxlbmFtZSwtNCkgPT0g
Ii5sb2MiKSB0aGVuCgoJCWlmIChzdHJpbmcuc3ViKGZpbGVuYW1lLC00KSA9PSAiLmxvYyIpIC0t
IDAuMS4wYzogYWx3YXlzIG9wZW4gYXMgaWYgZm9sZGVyCgkJdGhlbgoJCQlsb2NhbCBkYXQgPSBm
ZXRjaChmaWxlbmFtZSkKCQkJLS0gc3dpdGNoZXJvb255CgkJCS0tIHRvIGRvOiAqKiBsb29wIGRh
bmdlciEgKioKCQkJaWYgKGRhdCBhbmQgZGF0LmxvY2F0aW9uKSB0aGVuCgkJCQlmaWxlbmFtZSA9
IGZ1bGxwYXRoKGRhdC5sb2NhdGlvbikgLS0gZGF0LmxvY2F0aW9uIGNhbiBiZSByZWxhdGl2ZQoJ
CQkJY2xpY2tfb25fZmlsZShmaWxlbmFtZSwgZGF0LmFjdGlvbiwgZGF0LmFyZ3YpCgkJCWVsc2UK
CQkJCW5vdGlmeSgibm90IGEgdmFsaWQgbG9jYXRpb24gZmlsZSIpCgkJCWVuZAoJCWVsc2VpZiBu
b3QgaW50ZW50aW9uIGFuZCAoaXNfY2FydChmaWxlbmFtZSkgb3IgYWN0aW9uID09ICJydW4iKSB0
aGVuCgkJCS0tIGNhcnRyaWRnZSAtLT4gcnVuIGl0IQoJCQkKCQkJY3JlYXRlX3Byb2Nlc3MoZmls
ZW5hbWUsCgkJCQl1bnBvZChhcmd2KQoJCQkpCgkJCgkJZWxzZQoJCQktLSB0byBkbzogY291bGQg
Z3JhYiBmcm9tIGZpbGUgaXRlbQoJCQkKCQkJaWYgKGZzdGF0KGZpbGVuYW1lKSA9PSAiZm9sZGVy
IikgdGhlbgoJCQkJLS0gZGlyZWN0b3J5CgkJCQlpZiAobW9kZSA9PSAiZGVza3RvcCIgb3Iga2V5
KCJzaGlmdCIpKSB0aGVuCgkJCQkJLS0gb3BlbiBpbiBhIHNlcGFyYXRlIHdpbmRvdwoJCQkJCS0t
IHRvIGRvOiBydW4gc2VsZgoJCQkJCWNyZWF0ZV9wcm9jZXNzKCIvc3lzdGVtL2FwcHMvZmlsZW5h
di5wNjQiLAoJCQkJCXsgCgkJCQkJCWFyZ3YgPSB7CgkJCQkJCQlmdWxscGF0aChmaWxlbmFtZSks
IAoJCQkJCQkJZnVsbHBhdGgoZmlsZW5hbWUpCgkJCQkJCX0KCQkJCQl9KQoJCQkJCQoJCQkJZWxz
ZQoJCQkJCWNkKGZpbGVuYW1lKQoJCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQkJZW5kCgkJCQkK
CQkJZWxzZQoJCQkKCQkJCS0tIG9ubHkgc2VsZWN0ZWQgaW50ZW50aW9ucyBnZXQgcHJvY2Vzc2Vk
IGJ5CgkJCQktLSBkb3VibGUgY2xpY2tpbmcgb24gYSBmaWxlLiBmb3IgZXhhbXBsZSwKCQkJCS0t
IHVuZGVyIG5ld19maWxlIChuZXcgdGFiKSBkb3VibGUgY2xpY2tpbmcKCQkJCS0tIHNob3VsZCBz
dGlsbCBtZWFuIGVkaXRpbmcgdGhhdCBmaWxlIGFzIHVzdWFsCgkJCQktLSB1cGRhdGU6IGNvdWxk
bid0IGZpbmQgYW4gaW50ZW50aW9uIHRoYXQgL2lzLwoJCQkJLS0gYXBwcm9wcmlhdGUgaGVyZSEg
LT4gYWx3YXlzIGVkaXQKCgkJCQktLSBwcmludGgoImNsaWNrZWQgb24gZmlsZTsge2ludGVudGlv
biwgb3Blbl93aXRoLCBmdWxscGF0aChmaWxlbmFtZSksIHN0YXQoMzA3KX0iLi5wb2R7aW50ZW50
aW9uLCBlbnYoKS5vcGVuX3dpdGgsIGZ1bGxwYXRoKGZpbGVuYW1lKSwgc3RhdCgzMDcpfSkKCQkJ
CQoJCQkJaWYgKGludGVudGlvbiA9PSAic2F2ZV9maWxlX2FzIiBvciBpbnRlbnRpb24gPT0gInNl
bGVjdF9maWxlIiBvciBpbnRlbnRpb24gPT0gImNvbmZpcm1fZmlsZV9vdmVyd3JpdGUiKSB0aGVu
CgkJCQkJLS0gZmlsZW5hbWUgaW4gdGV4dCBmaWVsZCBzaG91bGQgYWxyZWFkeSBiZSBzZXQKCQkJ
CQlwcm9jZXNzX2ludGVudGlvbigpCgkJCQllbHNlCgkJCQkJLS0gb3BlbiBieSBmaWxlIGV4dGVu
c2lvbgoJCQkJCWNyZWF0ZV9wcm9jZXNzKGVudigpLm9wZW5fd2l0aCBhbmQgZW52KCkub3Blbl93
aXRoIG9yICIvc3lzdGVtL3V0aWwvb3Blbi5sdWEiLAoJCQkJCQl7CgkJCQkJCQlhcmd2ID0ge2Z1
bGxwYXRoKGZpbGVuYW1lKX0sCgkJCQkJCQlmaWxldmlldyA9IHt7bG9jYXRpb249ZnVsbHBhdGgo
ZmlsZW5hbWUpLG1vZGU9IlJXIn19LCAtLSBncmFudCBwZXJtaXNzaW9uIHRvIGFjY2VzcyBpdCAo
aW4gY2FzZSBvcGVuaW5nIHByb2dyYW0gaXMgc2FuZGJveGVkKQoJCQkJCQkJLS1wd2QgPSBwd2Qo
KQoJCQkJCQl9CgkJCQkJKQoJCQkJCQoJCQkJCS0tIDAuMi4waDogY2xvc2UgZmlsZW5hdiBhZnRl
ciAiT3BlbiIgZnJvbSB3cmFuZ2xlciAob3Blbl93aXRoKQoJCQkJCWlmIChlbnYoKS53aW5kb3df
YXR0cmlicyBhbmQgZW52KCkud2luZG93X2F0dHJpYnMuYXV0b2Nsb3NlKSBleGl0KCkgLS0gbW9y
ZSBwYXJ0aWN1bGFyIG1lYW5pbmc7IHNhbWUgcmVzdWx0IGluIHByYWN0aWNlIHRob3VnaC4KCQkJ
CQkKCQkJCWVuZAoJCQkKCQkJZW5kCgkJZW5kCgkJCgllbmQKCgo6OiB0YWJjb21wLmx1YQotLVtb
cG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTUzLTI2IDE5OjUzOjAwIixtb2RpZmllZD0i
MjAyNC0wNC0wMyAwNTozMjozOSIscmV2aXNpb249NTksc3RvcmVkPSIyMDIzLTU5LTA3IDA3OjU5
OjQ0Il1dCi0tW1sKCWZhOiBjcmVhdGUgZ3VpIHdpdGggcmVsYXRpdmUgc2l6ZXMKXV0KLS0gKiog
aW5jcmVkaWJseSBpbmVmZmljaWVudCEgdG8gZG86IG5lZWQgdG8gcmVwbGFjZSB3aXRoIHN0cmlu
ZyBtYXRjaGluZwpmdW5jdGlvbiBmaW5kX2NvbW1vbl9wcmVmaXgoczAsIHMxKQoJaWYgKHR5cGUo
czApIH49ICJzdHJpbmciKSB0aGVuIHJldHVybiBuaWwgZW5kCglpZiAodHlwZShzMSkgfj0gInN0
cmluZyIpIHRoZW4gcmV0dXJuIG5pbCBlbmQKCWlmIChzMCA9PSBzMSkgdGhlbiByZXR1cm4gczAg
ZW5kCglsb2NhbCBsZW4gPSAwCgl3aGlsZShzdWIoczAsMSxsZW4rMSkgPT0gc3ViKHMxLDEsbGVu
KzEpKSBkbwoJCWxlbiA9IGxlbiArIDEKCQktLXByaW50aChsZW4pCgllbmQKCXJldHVybiBzdWIo
czAsMSxsZW4pCmVuZApmdW5jdGlvbiB0YWJfY29tcGxldGVfZmlsZW5hbWUoY21kKQoJaWYgKGNt
ZCA9PSAiIikgdGhlbiByZXR1cm4gY21kIGVuZAoJLS0gZ2V0IHN0cmluZwoJbG9jYWwgYXJncyA9
IHNwbGl0KGNtZCwgIiBcIiIsIGZhbHNlKSAgLS0gYWxzbyBzcGxpdCBvbiAiIHRvIGFsbG93IHRh
Yi1jb21wbGV0aW5nIGZpbGVuYW1lcyBpbnNpZGUgc3RyaW5ncwoJbG9jYWwgcHJlZml4ID0gYXJn
c1sjYXJnc10gb3IgIiIKCS0tIGNvbnN0cnVjdCBwYXRoIHByZWZpeCAgLS0gZXZlcnl0aGluZyAo
Y2Fub25pY2FsIHBhdGgpIGV4Y2VwdCB0aGUgZmlsZW5hbWUKCWxvY2FsIHByZWZpeCA9IGZ1bGxw
YXRoKHByZWZpeCkKCWxvY2FsIHBhdGhzZWcgPSBzcGxpdChwcmVmaXgsIi8iLGZhbHNlKQoJaWYg
KG5vdCBwYXRoc2VnKSB0aGVuIHJldHVybiBjbWQgZW5kCglsb2NhbCBwYXRoX3BhcnQgPSAiIgoJ
Zm9yIGk9MSwjcGF0aHNlZy0xIGRvCgkJcGF0aF9wYXJ0ID0gcGF0aF9wYXJ0IC4uICIvIiAuLiBw
YXRoc2VnW2ldCgllbmQKCWlmIChwYXRoX3BhcnQgPT0gIiIpIHRoZW4gcGF0aF9wYXJ0ID0gIi8i
IGVuZCAtLSBjYW5vbmljYWwgZmlsZW5hbWUgc3BlY2lhbCBjYXNlCglwcmVmaXggPSAocGF0aHNl
ZyBhbmQgcGF0aHNlZ1sjcGF0aHNlZ10pIG9yICIvIgoJLS0gcHJpbnRoKCJAQEAgcGF0aCBwYXJ0
OiAiLi5wYXRoX3BhcnQuLiIgcHdkOiIuLnB3ZCgpKQoJbG9jYWwgZmlsZXMgPSBscyhwYXRoX3Bh
cnQpCglpZiAobm90IGZpbGVzKSByZXR1cm4gY21kCgktLSBmaW5kIG1hdGNoZXMKCWxvY2FsIHNl
Z21lbnQgPSBuaWwKCWxvY2FsIG1hdGNoZXMgPSAwCglsb2NhbCBzaW5nbGVfZmlsZW5hbWUgPSBu
aWwKCglmb3IgaT0xLCNmaWxlcyBkbwoJCS0tcHJpbnRoKHByZWZpeC4uIiA6OiAiLi5maWxlc1tp
XSkKCQlpZiAoc3ViKGZpbGVzW2ldLCAxLCAjcHJlZml4KSA9PSBwcmVmaXgpIHRoZW4KCQkJbWF0
Y2hlcyA9IG1hdGNoZXMgKyAxCgkJCWxvY2FsIGNhbmRpZGF0ZSA9IHN1YihmaWxlc1tpXSwgI3By
ZWZpeCArIDEpIC0tIHJlbWFpbmRlcgoKCQkJLS0gc2V0IHNlZ21lbnQgdG8gc3RhcnRpbmcgc2Vx
dWVuY2UgY29tbW9uIHRvIGNhbmRpZGF0ZSBhbmQgc2VnbWVudAoJCQlzZWdtZW50ID0gc2VnbWVu
dCBhbmQgZmluZF9jb21tb25fcHJlZml4KGNhbmRpZGF0ZSwgc2VnbWVudCkgb3IgY2FuZGlkYXRl
CgkJCXNpbmdsZV9maWxlbmFtZSA9IHBhdGhfcGFydC4uIi8iLi5maWxlc1tpXSAtLSB1c2VkIHdo
ZW4gc2luZ2xlIG1hdGNoIGlzIGZvdW5kCgkJZW5kCgllbmQKCQoJaWYgKHNlZ21lbnQpIHRoZW4K
CQljbWQgPSBjbWQgLi4gc2VnbWVudAoJCS0tY3Vyc29yX3BvcyA9IGN1cnNvcl9wb3MgKyAjc2Vn
bWVudAoJZW5kCgoJaWYgbWF0Y2hlcyA9PSAxIGFuZCBzaW5nbGVfZmlsZW5hbWUgYW5kIGZzdGF0
KHNpbmdsZV9maWxlbmFtZSkgPT0gImZvbGRlciIgdGhlbgoJCWNtZCAuLj0gIi8iCgllbmQKCgkK
CXJldHVybiBjbWQKZW5kCgoKCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9InplcCIsY3Jl
YXRlZD0iMjAyMy0xMS0xNSAwNzoxMTozMCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMTAx
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMGUwZTA3MDcwNzA3MDcwNzA3MDcwNzA3MGUw
ZTAxMDEwZTBlMDcwMTA3MDcwNzA3MDcwNzAxMDcwZTBlMDEwMTBlMGUwNzAxMDcwNzA3MDcwNzA3
MDEwNzBlMGUwMTAxMGUwZTA3MDcwNzA3MDcwNzA3MDcwNzA3MGUwZTAxMDEwZTBlMDcwNzBlMDcw
NzA3MDcwZTA3MDcwZTE3MDEwMTBlMGUwNzA3MDcwZTBlMGUwZTA3MDcwNzE3MTcwMTAxMGUwZTA3
MDcwNzA3MDcwNzA3MDcwNzA3MTcxNzAxMDEwZTBlMGUwZTBlMGUwZTBlMGUwZTE3MTcxNzBlMDEw
MTBlMGUwZTBlMGUwZTBlMGUwZTE3MTcxNzBlMGUwMTAxMGUwZTBlMGUwZTBlMGUwZTE3MTcxNzBl
MGUwZTAxMDEwZTBlMDEwMTAxMDEwMTAxMDEwMTAxMDEwZTBlMDEwMTBlMGUwMTAxMDEwMTA3MDcw
NzA3MDcwMTBlMGUwMTAxMGUwZTAxMDEwMTAxMDcwNzA3MDcwNzAxMGUwZTAxMDEwZTBlMDEwMTAx
MDEwNzA3MDcwNzA3MDEwZTAxMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMCIpLG1v
ZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixub3Rlcz0iKGMpIExleGFsb2ZmbGUgR2FtZXMg
TExQIixydW50aW1lPTIwLHN0b3JlZD0iMjAyNC0wMy0yNCAxNTozNTo1NiIsdGl0bGU9IlBpY290
cm9uIEZpbGUgTmF2aWdhdG9yIix2ZXJzaW9uPSIwLjEuMWQiLHdvcmtzcGFjZXM9e3tsb2NhdGlv
bj0ibWFpbi5sdWEjMzkiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImludGVyZi5sdWEj
NSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ3JpZC5sdWEjMSIsd29ya3NwYWNlX2lu
ZGV4PTF9LHtsb2NhdGlvbj0iZHJvcC5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlv
bj0ib3Blbi5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaW50ZW50aW9uLmx1
YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkZXNrdG9wLmx1YSMxIix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJmaW5mby5sdWEjMjM0Iix3b3Jrc3BhY2VfaW5kZXg9MX0s
e2xvY2F0aW9uPSJsaXN0Lmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngv
MC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfX1dXQo6OiBnZngvLmluZm8ucG9kCi0tW1twb2QsY3Jl
YXRlZD0iMjAyMy0xMS0xNSAwNzoxMTozMCIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6Mzgi
LHN0b3JlZD0iMjAyMy0xMS0xNSAwNzoxMTozMCJdXQo6OiBnZngvMC5nZngKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRJd0lEQTJPak00T2pVMklpeHRiMlJwWm1sbFpEMGlN
akF5TlMwdwpOeTB5T0NBeE5UbzFNVG96TkNJc2NtVjJhWE5wYjI0OU16RTFNQ3h6ZEc5eVpXUTlJ
akl3TWpNdE16UXRNRGtnTVRrNk16UTZOVE1pClhWMXNlalFBZ2dRQUFPbzZBQUR6Rkh0Yk1GMDll
Mkp0Y0Qxd2VIVUFReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0Q0FES2VUMHcKTEhwdmIyMDlP
SDBzTVFEekNnQ1JVQUYzQmdGQUFYY1dBVEFCZHlZQklBRjNOZ0VRQWJjRUFEUVhKbWNLQUMxR1J3
b0FBd1FBTDlFQQpkZ0FjNy1BSlVZQUJMU1lCQUdFdE5oSFdBZ0FCVHdFQTBRRExBRGdnSnoyekFE
VTNMVWNNQUVFWExRY05DQUFnSFhjR0FDQmROeG9BCkkwMDNNQUFQMVFBaGItRUJGcGNXRVFRQUJR
TFlBSU1tZ1JZUkpnRTNNUVlBUVFFQUFSWUlBQzhRMFcwQUhKQVFvVEFCclFFUUFRY0cKQUJBUkNn
Q2Z2UUVBQVFjQkhWRXRFQUFLLXdPZEVSQ3hCd0VRRVpjTkFTQUJuUUZBa1NCNUFCenlCZkFLUVpB
eEhRRUFvUzBSM1JFdApkeTBSSFpjZEJBQlhGeDBuSFFjSUFDR1hIU0FBLXdCTlJ6MFJUUWNOQncw
SFBSSGRBUUFzQWlLQU1TMEJBSkU5RWQxekFJRlhUUkV0Clp6MFJiVkVBc1MwbkRTYzlFUzBIRFFk
OUZnQWhQVmNtQUE4X0Fqd0FCQUFBMUFBUk56QUNQeWNkSndnQUNBUW9BQTVHQWdfSUFETmYKRngw
WEhUY0lBQUVCd2dKbUZ3MEhIUWNORUFBUGhnQkdFeTBPQVFVSUFBQW5CQ0ZITFF3QUtSMEhDQUFQ
aEFCQklEZE5iQUZQTncwbgpEUWdBQXpJSExTZWVBQ1V0SjU0QUQ0Z0FRUkpuLUFFYWJRb0NTUWNO
QngwU0FDVnRKMm9FRDRZQVFSRzNYZ0EwQngxSERBQURsZ0VlCnQ0WUJEM3dBRkE5V0JqRVFEYTBB
RUIydEFCQXRyUUFXUFlFQVJRRlhGamNHQUFKaUJsZ0hGaGNHVndnQUtFWlhmZ1lQc3dBZm53SFIK
QUFIWEVRZTlCd1FBQXY4SDF4RVhoaWNSRjRZWEJoRzNCZ0VBQWJZQklMSHdBMlFBSGI4Q29VQUJo
d0ZBQVFkdEJ3WUFGQUV1QUNCVwpCOGdCdjJjR0FWQUJaZ0ZnY2ZBR2VBQWRmd2h4WUJFdEpvRThC
d1V2OFFFdEFTQllFYmNoMXhFQ0FQOEJCcmNHRWRZUkZoMldJYllSCkFOSHdBUTRISjFNSERWY05C
d3dBTXhkZEZ3b0FEeFFIUHktdzhERUFmNDhBOFFIV0VRYTlCZ1FBQXY4SDFoRVdoeVlSRm9jV0RS
RzIKRFFFQUFiMEJFTUh3QTVRQVRoRUhQd0tjRVFCUkxVWWh4aEhXQWdBQjhBRWZBSVlBVGc4eEFC
MWlFTEVnRVpjUlFBUUVCQUFQOVFRVgotd0FHbHdZQkVBRzJBUkFSbGhFZ3NSQjZBQ3d6SngwWDN3
VS1OeDBYQ0FBSUJDZ0FENFlBQkE5OEFsUXZzUVlFQUFLVjFoRUdGd1pkCkJoY0dDQUF4TmwwbUNn
VVBoQUlpRHpFQXJ3XzBCZzBBQkFCRkZ4WUhGbkFDUmlZSEZqY1lBQzRtTjJFSEQzd0FRbDhIRmlj
V053Z0EKQ0Fla0FDLVJBR1FDVVYtZEVRMnhEUVFBQmdDMEMzTU5weDBSRFpjZDRnUWZJQjBCcGc4
eEFQOFNENjRCZFFfSUFCRmZCeFlYRmtjSQpBQUVSVmdZQVZnWUhGZ2NHRUFBUGhnQkdFeVlPQVFV
SUFBQW9EQ0UzSmd3QUtSWUhDQUFQaEFCQklDZEdiQUZQSndZbkJnZ0FBd0xiCkJDUUhKZ2dBSDNl
SUFFUUNEd3dxQjJZS0FnQ0dBUWtTQUFNZ0FCX0hoZ0JFR3JkNEFnLW5CUXNQZmdOX0FKQUZELVlN
RkFMWEN4OEMKOUF4YXIzY1JRQUZtRVZDQjhBVUpBVTVnQXJFZ0FiY0JCQTRQMVF3Q0JQUU5Id0tK
QUI0UE1RRC0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
Z1ZCdFBUaDlmUT09Cjo6IGdmeC8xLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJ
ekxURXdMVEV4SURBek9qRXpPakF4SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB3Ck5DMHhPU0F4T1Rv
eU1EbzBNaUlzY21WMmFYTnBiMjQ5TVRNeU1WMWRiSG8wQUpvQUFBQXpNUUFBOHhSN1d6QmRQWHRp
YlhBOWNIaDEKQUVNZ0VCQUU4UEFzWm14aFozTTlNQ3h3WVc1ZmVBZ0F6M2s5TUN4NmIyOXRQVGg5
TERFQUtmVUJDQWdFTnpBSEVCY2dCeEFuRUFjdwpCd1FBTDFlUVJ3QXVqMWVRQndBSEFBY2dTUUFP
RHZJQUR6RUEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLVFsQnRQVGg5ZlE9PQo6OiBnZngvZGVsbWUvLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyMy0xMC0xMSAwNzo1NDowNiIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6
NDc6MzgiLHN0b3JlZD0iMjAyMy01NC0xMSAwNzo1NDowNiJdXQo6OiBnZngvZGVsbWUyLy5pbmZv
LnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMDItMTEgMDg6MDI6MjAiLG1vZGlmaWVkPSIyMDI1
LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjMtMDItMTEgMDg6MDI6MjAiXV0KOjogZ2Z4L2hh
Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMDktMTEgMDg6MDk6NDQiLG1vZGlmaWVk
PSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjMtMDktMTEgMDg6MDk6NDQiXV0KOjog
Z2Z4L3p4Yy8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTExIDA3OjQxOjQxIixt
b2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTQxLTExIDA3OjQxOjQx
Il1dCjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTA3IDEwOjExOjU2
Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTAzLTA3IDEwOjEx
OjU2Il1dCjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExU
QXpMVEEzSURFd09qRXhPalUySWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHdOeUF4TURveE1q
b3dNU0lzY21WMmFYTnBiMjQ5TVYxZGJIbzBBR2tBQUFDakNBQUE4Qk43YkdGNVpYSTllMXN3WFQx
N1ltMXcKUFhWelpYSmtZWFJoS0NKcE1UWWlMREUyQXdBdklqQUJBUC0tLV9faElpa3NjR0Z1WDNn
OU1BZ0E4Z1o1UFRBc2MyTmhiR1U5TVN4MAphV3hsWDJnOU1UWUtBRzkzUFRFMmZTeExCUC0tLS04
NFVERTJmWDE5Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTA3IDEw
OjExOjU2Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTAzLTA3
IDEwOjExOjU2Il1dCjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJMExUQXpMVEEzSURFd09qRXhPalUySWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHdOeUF4
TURveE1qb3dNU0lzY21WMmFYTnBiMjQ5TVYxZGJIbzBBQkFCQUFCUkJ3QUE4Q2R3ZUhVQUF5Z0FB
QU1BQkE5QUVBSU8KQUFHZ0FTQUNvQTRBRHhBQURmREtBUUlEQkFVR0J3RVAtNUFJQ1FvTER3d1BE
UThPRHc4UUFQQUFEUThSRHhJUEV3OFVEeFVQRmc4WApFd0R4QVE4WUR4a1BHZzhiRHh3UEhROGVE
eDhVQVBFQUlBOGhEeUlQSXc4a0R5VVBKZzhuRkFEeEFDZ1BLUThxRHlzUExBOHREeTRQCkx4UUE4
UUF3RHpFUE1nOHpEelFQTlE4MkR6Y1VBUDhGT0E4NUR6b1BPdzg4RHowUFBnOC1BUS0tOFA4QkFP
di1KMW9CRUFZUElCQUIKSUFFZ0FmQUFBaEFDREJBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENn
LS1ENEFQOXc4TkFmQUpBUkFHRERBQS16a2Ytd0VBM0wtNApEMEFBRFVELS03RHdjQW9BLS05a0gt
OEJBSmRRLS0tLS14OD0KOjogW2VvY10K
:: bios/apps/gfx.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBj
YW52YXMubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDQtMTEgMDI6MDQ6
MDIiLG1vZGlmaWVkPSIyMDI1LTA3LTEwIDAzOjI1OjUxIixyZXZpc2lvbj01MTMwLHN0b3JlZD0i
MjAyMy0yNC0yOCAwMDoyNDowMCJdXQoKbG9jYWwgZmlsbF9jcHU9MAoKZnVuY3Rpb24gZG9fZmls
bF8wKGJtcCwgeCwgeSwgdGMpCgppZiAoZ2V0KGJtcCx4LHkpICE9IHRjKSByZXR1cm4KaWYgKHgg
PCAwIG9yIHkgPCAwIG9yIHggPj0gd3cgb3IgeSA_PSBoaCkgcmV0dXJuCgpsb2NhbCBsLHI9eCx4
CndoaWxlKGdldChibXAsbCx5KT09dGMgYW5kIGw_PTApIGwtPTEKbCs9MQp3aGlsZShnZXQoYm1w
LHIseSk9PXRjIGFuZCByPHd3KSByKz0xCnItPTEKCmZvciB4eD1sLHIgZG8KCXNldChibXAseHgs
eSxjb2wpCmVuZAoKaWYgKHkgPiAwKSB0aGVuCglsb2NhbCBsYXN0ID0gbmlsCglmb3IgeHg9bCxy
IGRvCgkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4eCx5LTEpID09IHRjCgkJaWYgKHZhbCBhbmQgbm90
IGxhc3QpIHRoZW4KCQkJZG9fZmlsbF8wKGJtcCx4eCx5LTEsdGMpCgkJZW5kCgkJbGFzdCA9IHZh
bAoJZW5kCmVuZAoKaWYgKHkgPCBoaC0xKSB0aGVuCglsb2NhbCBsYXN0ID0gbmlsCglmb3IgeHg9
bCxyIGRvCgkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4eCx5KzEpID09IHRjCgkJaWYgKHZhbCBhbmQg
bm90IGxhc3QpIHRoZW4KCQkJZG9fZmlsbF8wKGJtcCx4eCx5KzEsdGMpCgkJZW5kCgkJbGFzdCA9
IHZhbAoJZW5kCmVuZAoKLS0gI3B1dGFmbGlwaW5pdAotLSB0byBkbzogd2h5IGlzIHRoaXMgY2F1
c2luZyB3bSBmbGlja2VyIHcvIGxvdyB2YWx1ZXMgKDAuMjUpIH4gaG93IGlzIHRoYXQgcG9zc2li
bGU-Ci0tIG9oLi4gaXMganVzdCB0aGUgYXBwIGd1aT8gbmVlZCB0byBtYW51YWxseSBob2xkIGZy
YW1lIGFnYWluIGFmdGVyIGZsaXAuIGJsZWguCi0tW1sKaWYgKHN0YXQoMSkgLSBmaWxsX2NwdSA_
IDIpIHRoZW4KCWZpbGxfY3B1ID0gc3RhdCgxKSBndWk6ZHJhd19hbGwoKSBmbGlwKCkKCXBva2Uo
MHg1NDdjLCAxKSAtLSBrZWVwIGhvbGRpbmcgZnJhbWUKZW5kCl1dCgplbmQKCmZ1bmN0aW9uIGRv
X2ZpbGwoYm1wLCB4LCB5KQpsb2NhbCB0YyA9IGdldChibXAsIHgsIHkpCmlmIChjb2wgPT0gdGMp
IHJldHVybgp3dyxoaCA9IGJtcDphdHRyaWJzKCkKZmlsbF9jcHUgPSAwCnJldHVybiBkb19maWxs
XzAoYm1wLCB4LCB5LCB0YykKZW5kCgpmdW5jdGlvbiBjcmVhdGVfb3V0bGluZShibXAsIHd3LCBo
aCkKCmxvY2FsIG91dCA9IHVzZXJkYXRhKCJ1OCIsIHd3KzIsIGhoKzIpIC0tIDFweCBib3VuZGFy
eQpzZXRfZHJhd190YXJnZXQob3V0KQoKc3NwcihibXAsIDAsIDAsIF8sIF8sMSwgMSwgd3csIGho
KQoKd3cgKz0gMiBoaCArPSAyCgpsb2NhbCBvdXQwID0gb3V0OmNvcHkoKQoKLS1vdXQgPSBvdXQ6
YWRkKG91dCwgb3V0LCBuaWwsIDIpIC0tIHdob2EhCi0tIHNyY19vZmZzZXQsIGRlc3Rfb2Zmc2V0
LCBpdGVtX3dpZHRoLCBzcmNfc3RyaWRlLCBkZXN0X3N0cmlkZSwgbnVtX2l0ZW1zCm91dDphZGQo
b3V0MCwgdHJ1ZSwgd3crMSwgd3crMCwgd3ctMSwgd3csIHd3LCBoaC0yKQpvdXQ6YWRkKG91dDAs
IHRydWUsIHd3KzEsIHd3KzIsIHd3LTEsIHd3LCB3dywgaGgtMikKb3V0OmFkZChvdXQwLCB0cnVl
LCB3dysxLCB3dyowKzEsIHd3LTEsIHd3LCB3dywgaGgtMikKb3V0OmFkZChvdXQwLCB0cnVlLCB3
dysxLCB3dyoyKzEsIHd3LTEsIHd3LCB3dywgaGgtMikKCi0tIGRpc2NvCmZvciB5PTAsaGgtMSBk
bwoJb3V0OmFkZCg4KygoeVwzKSUzKSo4LCB0cnVlLCAwLCB5Knd3LCA0LCAwLCA4LCB3dy84KzEp
CmVuZAoKb3V0OmFkZCg4LCB0cnVlLCAgMCwgMCwgd3cqNCwgd3csIHd3KjgsIGhoLzgrMSkKCnNl
dF9kcmF3X3RhcmdldCgpCnJldHVybiBvdXQKZW5kCgoKCmZ1bmN0aW9uIHVkcmVjdGZpbGwodWQs
IHgwLCB5MCwgeDEseTEsIGNvbCkKaWYgKHR5cGUodWQpIH49ICJ1c2VyZGF0YSIpIHJldHVybgp4
MFw9MSB5MFw9MSB4MVw9MSB5MVw9MQppZiAoeDE8eDApeDAseDE9eDEseDAKaWYgKHkxPHkwKXkw
LHkxPXkxLHkwCgp4MCA9IG1heCgwLCB4MCkKeTAgPSBtYXgoMCwgeTApCgpsb2NhbCB3aWR0aCwg
aGVpZ2h0ID0gKHgxLXgwKSsxLCAoeTEteTApKzEKd2lkdGggPSBtaW4od2lkdGgsIHVkOndpZHRo
KCkteDApCmhlaWdodCA9IG1pbihoZWlnaHQsIHVkOmhlaWdodCgpLXkwKQoKaWYgKHdpZHRoIDwg
MSBvciBoZWlnaHQgPCAxKSByZXR1cm4KCmxvY2FsIHVkdyA9IHVkOndpZHRoKCkKdWQ6Y29weShj
b2wsIHRydWUsIG5pbCwgeDAreTAqdWR3LHdpZHRoLCBuaWwsdWR3LGhlaWdodCkKZW5kCgpmdW5j
dGlvbiBjcmVhdGVfY2FudmFzKGVsKQoKbG9jYWwgd3csaGggPSAxNiwxNgpsb2NhbCBjYW5feDAs
Y2FuX3kwID0gMCwwCmxvY2FsIGRyYWdfeDAsZHJhZ195MCA9IDAsMApsb2NhbCBtdG9vbAoKZnVu
Y3Rpb24gZWw6dXBkYXRlKCkKCgllbC5jdXJzb3IgPSAiY3Jvc3NoYWlyIgoJaWYgKG10b29sID09
ICJwYW4iKSBlbC5jdXJzb3IgPSAiZ3JhYiIKLS0JCWlmIChtdG9vbCA9PSAiZmlsbCIpIGVsLmN1
cnNvciA9IGdldF9zcHIoNTYpIC0tIGNvbW1lbnRlZDsgY2FuJ3QgdXNlIGdldF9zcHIhCglpZiAo
bXRvb2wgPT0gImZpbGwiKSBlbC5jdXJzb3IgPSBpY29ucy5idWNrZXRfY3Vyc29yCgoJCgktLSBz
YWZldHkgW2R1cmluZyBkZXZdCgljaS56b29tID0gY2kuem9vbSBvciAxCgljaS5wYW5feCA9IGNp
LnBhbl94IG9yIDAKCWNpLnBhbl95ID0gY2kucGFuX3kgb3IgMAoJCgl3dyA9IGNibXBfd2lkdGgg
ICogY2kuem9vbQoJaGggPSBjYm1wX2hlaWdodCAqIGNpLnpvb20KCQoJbXRvb2wgPSBjdG9vbAoJ
aWYgKGtleSJzcGFjZSIpIG10b29sID0gInBhbiIKCWlmIChrZXkicyIpIG10b29sID0gInNlbGVj
dCIKCQoJLS0gcGl4ZWwgbG9va2luZyBhdCBpbiBjZW50ZXIKCWxvY2FsIHB4ID0gY2JtcF93aWR0
aC8yICArIGNpLnBhbl94Cglsb2NhbCBweSA9IGNibXBfaGVpZ2h0LzIgKyBjaS5wYW5feQoJCglj
YW5feDAgPSBlbC53aWR0aFwyICAtIHB4ICogY2kuem9vbQoJY2FuX3kwID0gZWwuaGVpZ2h0XDIg
LSBweSAqIGNpLnpvb20KCQplbmQKCmZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCWJhY2t1cF9zdGF0
ZSgpCgkKCWlmIG10b29sID09ICJzZWxlY3QiIHRoZW4KCQktLSBuZWVkcyB0byBoYXBwZW4gZmly
c3QgZm9yIGNhbGN1bGF0aW5nIHgseQoJCWNsZWFyX3NlbGVjdGlvbigpCgllbmQKCQoJbG9jYWwg
eCA9IChtc2cubXggLSBjYW5feDApIFwgY2kuem9vbQoJbG9jYWwgeSA9IChtc2cubXkgLSBjYW5f
eTApIFwgY2kuem9vbQoJbG9jYWwgeHgseXkgPSB4LHkKCWlmIChjaS5sYXllcikgeC09IGNpLmxh
eWVyX3ggeS09IGNpLmxheWVyX3kKCS0tcHJpbnRoKCJjbGljazogIi4ucG9ke3gseX0pCgkKCQoJ
LS0gdGFyZ2UgYml0bWFwOiBkcmF3IHRvIGZsb2F0aW5nIGxheWVyIGlmIGl0IGV4aXN0cwoJbG9j
YWwgdGJtcCA9IGNpLmxheWVyIG9yIGNibXAgCglsb2NhbCB0Ym1wX3dpZHRoLCB0Ym1wX2hlaWdo
dCA9IHRibXA6YXR0cmlicygpCglpZiAodHlwZSh0Ym1wKX49InVzZXJkYXRhIikgdGJtcD1jYm1w
IHByaW50aCgiKiogbm8gdGJtcCEhIikKCQoJZHJhZ194MCAgPSB4ICBkcmFnX3kwICA9IHkKCWNs
aWNrX3gwID0geCAgY2xpY2tfeTAgPSB5IAoJY2xpY2tfeHgwID0geHggIGNsaWNrX3l5MCA9IHl5
CglvcF9ibXAgPSB0Ym1wOmNvcHkoKQoJYmxpdCh0Ym1wLCBvcF9ibXApIC0tIHRvIGRvOiByZW1v
dmUKCQoJCglpZiBtc2cubWIgPT0gMiB0aGVuCgkJLS0gY2FuIHBpY2sgdXAgY29sb3VyIHdpdGgg
YW55IHRvb2wKCQljb2wgPSBnZXQodGJtcCwgeCwgeSkKCWVsc2VpZiBtdG9vbCA9PSAiZmlsbCIg
dGhlbgoJCWRvX2ZpbGwodGJtcCwgeCwgeSkKCWVsc2VpZiBrZXkiY3RybCIgdGhlbgoJCS0tIGFu
eSBvdGhlciB0b29sOiBjdHJsLWNsaWNrIHRvIGRvIHJlcGxhY2UKCQlsb2NhbCBjb2wwID0gZ2V0
KHRibXAsIHgseSkKCQlmb3IgeXk9MCx0Ym1wX2hlaWdodC0xIGRvCgkJCWZvciB4eD0wLHRibXBf
d2lkdGgtMSBkbwoJCQkJaWYgKGdldCh0Ym1wLHh4LHl5KSA9PSBjb2wwKSBzZXQodGJtcCx4eCx5
eSxjb2wpCgkJCWVuZAoJCWVuZAoJZW5kCgkKZW5kCgoKZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkt
LSB0YXJnZSBiaXRtYXA6IGRyYXcgdG8gZmxvYXRpbmcgbGF5ZXIgaWYgaXQgZXhpc3RzCglsb2Nh
bCB0Ym1wID0gY2kubGF5ZXIgb3IgY2JtcCAKCQoJc2V0X2RyYXdfdGFyZ2V0KHRibXApCgkKCWxv
Y2FsIHggPSAobXNnLm14IC0gY2FuX3gwKSBcIGNpLnpvb20KCWxvY2FsIHkgPSAobXNnLm15IC0g
Y2FuX3kwKSBcIGNpLnpvb20KCWxvY2FsIHh4LHl5ID0geCx5CglpZiAoY2kubGF5ZXIpIHRoZW4K
CQlzZXRfZHJhd190YXJnZXQoY2kubGF5ZXIpCgkJeC09IGNpLmxheWVyX3ggeS09IGNpLmxheWVy
X3kKCWVuZAoJCglpZiBtc2cubWIgPT0gMiB0aGVuCgkJLS0gY2FuIHBpY2sgdXAgY29sb3VyIHdp
dGggYW55IHRvb2wKCQljb2wgPSBnZXQodGJtcCwgeCwgeSkKCWVsc2VpZiAobXRvb2wgPT0gInBh
biIpIHRoZW4KCQljaS5wYW5feCAtPSBtc2cuZHggLyBjaS56b29tCgkJY2kucGFuX3kgLT0gbXNn
LmR5IC8gY2kuem9vbQoJZWxzZWlmIG10b29sID09ICJzdGFtcCIgdGhlbgoJCWlmIChsYXN0X3N0
YW1wX2JtcF9zdHIgfj0gZ2V0X2NsaXBib2FyZCgpKSB0aGVuCgkJCWxhc3Rfc3RhbXBfYm1wX3N0
ciA9IGdldF9jbGlwYm9hcmQoKQoJCQlsYXN0X3N0YW1wX2JtcCA9IHVucG9kKGxhc3Rfc3RhbXBf
Ym1wX3N0cikKCQllbmQKCQoJCWxvY2FsIGJtcCA9IGxhc3Rfc3RhbXBfYm1wCgkJaWYgKHR5cGUo
Ym1wKSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJCWJsaXQob3BfYm1wLCB0Ym1wKQoJCQlzZXRfZHJh
d190YXJnZXQodGJtcCkKCQkJbG9jYWwgd3csaGggPSBibXA6YXR0cmlicygpCgkJCS0tIGludmVy
dGVkIHBpY28tOCBiZWhhdmlvdXIhIHRyYW5zcGFyZW5jeSBieSBkZWZhdWx0CgkJCWlmIChrZXki
Y3RybCIpIHJlY3RmaWxsKHgtd3cvMix5LWhoLzIseCt3dy8yLTEseStoaC8yLTEsMCkKCQkJc3By
KGJtcCwgeCAtIHd3LzIsIHkgLSBoaC8yKQoJCQlzZXRfZHJhd190YXJnZXQoKQoJCWVuZAoJCgll
bHNlaWYgKG10b29sID09ICJzZWxlY3QiKSB0aGVuCgkJLS0geHgseXkgLS0gbm90IHJlbGF0aXZl
IHRvIHNlbGVjdGlvbgoJCWNzZWw6Y2xlYXIoKQoJCXNldF9kcmF3X3RhcmdldChjc2VsKQoJCXJl
Y3RmaWxsKGNsaWNrX3h4MCArLjUsIGNsaWNrX3l5MCArLjUsIHh4ICsuNSwgeXkgKy41LCAxKQoJ
CXNldF9kcmF3X3RhcmdldCgpCgkJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZ2VuZXJhdGUKCWVs
c2VpZiAobXRvb2wgPT0gInBlbmNpbCIgb3IgbXRvb2wgPT0gImJydXNoIikgdGhlbgoJCQlsb2Nh
bCBkeCwgZHkgPSB4LWRyYWdfeDAsIHktZHJhZ195MAoJCQlsb2NhbCBzdGVwcyA9IG1heChhYnMo
ZHgpLGFicyhkeSkpICogMgoJCQlkeCAvPSBzdGVwcyBkeSAvPSBzdGVwcwoJCQlsb2NhbCB4eCA9
IGRyYWdfeDAKCQkJbG9jYWwgeXkgPSBkcmFnX3kwCgkJCWlmIChtdG9vbCA9PSAiYnJ1c2giKSB0
aGVuCgkJCQktLSBwcm92aXNpb25hbCBydWxlOgoJCQkJLS0gb25seSB0cmFuc3BhcmVudCB3aGVu
IGRyYXcgY29sb3VyIGlzIG5vdCAwCgkJCQlmaWxscChicnVzaC5wYXQpIHBva2UoMHg1NTBiLGNv
bCA9PSAwIGFuZCAweDAwIG9yIDB4ZmYpCgkJCQlwYWwoNyxjb2wpCgkJCQlsb2NhbCBicnVzaF9z
cHJpdGUgPSBicnVzaF9nZnhbYnJ1c2gud2hpY2hdCgkJCQkKCQkJCWZvciBpPTAsc3RlcHMgZG8K
CQkJCQktLWNpcmNmaWxsKHh4LCB5eSwgYnJ1c2gudGhpY2tuZXNzLCBjb2wpCgkJCQkJCgkJCQkJ
c3ByKGJydXNoX3Nwcml0ZSx4eC0zLHl5LTMpCgkJCQkJeHggKz0gZHgKCQkJCQl5eSArPSBkeQoJ
CQkJZW5kCgkJCQlwYWwoKQoJCQkJZmlsbHAoKSBwYWx0KCkgcG9rZSgweDU1MGIsMHgwMCkKCQkJ
ZWxzZQoJCQkJZm9yIGk9MCxzdGVwcyBkbwoJCQkJCXNldCh0Ym1wLCB4eCwgeXksIGNvbCkKCQkJ
CQl4eCArPSBkeAoJCQkJCXl5ICs9IGR5CgkJCQllbmQKCQkJZW5kCgkJZWxzZWlmIG10b29sID09
ICJjaXJjIiBvciBtdG9vbCA9PSAicmVjdCIgdGhlbgoJCQlibGl0KG9wX2JtcCwgdGJtcCkKCQkJ
bG9jYWwgZnVuYyA9IG10b29sID09ICJyZWN0IiBhbmQKCQkJCShrZXkoImN0cmwiKSBhbmQgcmVj
dGZpbGwgb3IgcmVjdCkgb3IKCQkJCShrZXkoImN0cmwiKSBhbmQgb3ZhbGZpbGwgb3Igb3ZhbCkK
CQkJbG9jYWwgd3csaGggPSB4IC0gY2xpY2tfeDAsIHktY2xpY2tfeTAKCQkJaWYga2V5KCJzaGlm
dCIpIHRoZW4KCQkJCWlmIGFicyh3dyk_YWJzKGhoKSB0aGVuCgkJCQkJaGggPSB3dyBlbHNlIHd3
ID0gaGgKCQkJCWVuZAoJCQllbmQKCQkJZnVuYyhjbGlja194MCArLjUsIGNsaWNrX3kwICsuNSwg
Y2xpY2tfeDAgKy41ICsgd3csIGNsaWNrX3kwICsuNSArIGhoLCBjb2wpCgkJZWxzZWlmIG10b29s
ID09ICJsaW5lIiB0aGVuCgkJCWJsaXQob3BfYm1wLCB0Ym1wKQoJCQlsb2NhbCB4MCx5MD1jbGlj
a194MCArLjUsIGNsaWNrX3kwICsuNQoJCQlsb2NhbCB4MSx5MT14ICsuNSwgeSArLjUKCQkJLS0g
c25hcAoJCQlpZiBrZXkoInNoaWZ0IikgdGhlbgoJCQkJbG9jYWwgZHgsZHkgPSB4MS14MCx5MS15
MAoJCQkJbG9jYWwgbWFnICAgPSBzcXJ0KGR4KmR4K2R5KmR5KQoJCQkJbG9jYWwgYSAgICAgPSBh
dGFuMihkeCxkeSkKCQkJCWEgKz0gMS8zMgoJCQkJYSA9IChhICogMTYpIFwgMQoJCQkJYSAmPSAx
NQoJCQkJaWYgKGElMiA9PSAxKSB0aGVuCgkJCQkJLS0gaXNvbWV0cmljIC0tIHVzZSAyOjEgZ3Jh
ZGllbnQKCQkJCQltYWcgPSBtYXgoYWJzKGR4KSxhYnMoZHkpKSBcIDEKCQkJCQltYWcgPSAobWFn
KzEpICYgfjEKCQkJCQlpZiBhYnMoZHgpID4gYWJzKGR5KSB0aGVuCgkJCQkJCWR4LGR5ID0gc2du
KGR4KSptYWcsc2duKGR5KSptYWcvMgoJCQkJCWVsc2UKCQkJCQkJZHgsZHkgPSBzZ24oZHgpKm1h
Zy8yLHNnbihkeSkqbWFnCgkJCQkJZW5kCgkJCQkJLS0gb25lIHN0ZXAgYmFjayB0byBnZXQgZXZl
biBzdGVwcyAobGluZSgpIGlzIG5vdCBoYWxmIG9wZW4pCgkJCQkJZHggLT0gc2duKGR4KQoJCQkJ
CWR5IC09IHNnbihkeSkKCQkJCQkKCQkJCQl4MSA9IHgwICsgZHgKCQkJCQl5MSA9IHkwICsgZHkK
CQkJCWVsc2UKCQkJCQlhIC89IDE2CgkJCQkJeDEgPSB4MCArIGNvcyhhKSAqIG1hZwoJCQkJCXkx
ID0geTAgKyBzaW4oYSkgKiBtYWcKCQkJCWVuZAoJCQkJCgkJCWVuZAoJCQlsaW5lKHgwLHkwLCB4
MSx5MSwgY29sKQoJCWVuZAoJCQoJCWRyYWdfeDAgPSB4IAoJCWRyYWdfeTAgPSB5CgkJCgkJLS0g
dXBkYXRlIGNibXAgd2l0aCBhbnkgY2hhbmdlcyBkcmF3biB0byBjaS5sYXllcgoJCWlmIChjaS5s
YXllcikgYmxpdChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSkK
CQkKCWVuZAoJCglmdW5jdGlvbiBlbDpyZWxlYXNlKG1zZykKCgkJbG9jYWwgeCA9IChtc2cubXgg
LSBjYW5feDApIFwgY2kuem9vbQoJCWxvY2FsIHkgPSAobXNnLm15IC0gY2FuX3kwKSBcIGNpLnpv
b20KCQkKCQlpZiAobXRvb2wgPT0gInNlbGVjdCIpIHRoZW4KCQkJaWYgKGNsaWNrX3gwID09IHgg
YW5kIGNsaWNrX3kwID09IHkpIHRoZW4KCQkJCS0tIGNhbid0IHNlbGVjdCBzaW5nbGUgcGl4ZWw7
IGRlc2VsZWN0CgkJCQljbGVhcl9zZWxlY3Rpb24oKQoJCQllbHNlCgkJCQktLSBjcmVhdGUgZmxv
YXRpbmcgbGF5ZXIKCQkJCWlmICh4IDwgY2xpY2tfeDApIGNsaWNrX3gwLHggPSB4LGNsaWNrX3gw
CgkJCQlpZiAoeSA8IGNsaWNrX3kwKSBjbGlja195MCx5ID0geSxjbGlja195MAoJCQkJbG9jYWwg
d3cgPSB4IC0gY2xpY2tfeDAgKyAxCgkJCQlsb2NhbCBoaCA9IHkgLSBjbGlja195MCArIDEKCQkJ
CQoJCQkJY2kubGF5ZXIgPSB1c2VyZGF0YSgidTgiLHd3LGhoKQoJCQkJY2kubGF5ZXJfeCA9IGNs
aWNrX3gwCgkJCQljaS5sYXllcl95ID0gY2xpY2tfeTAKCQkJCWNpLmxheWVyMCA9IGNibXA6Y29w
eSgpCgkJCQlzZXRfZHJhd190YXJnZXQoY2kubGF5ZXIwKQoJCQkJcmVjdGZpbGwoY2xpY2tfeDAs
IGNsaWNrX3kwLCBjbGlja194MCArIHd3LTEsIGNsaWNrX3kwICsgaGgtMSwgMCkKCQkJCXNldF9k
cmF3X3RhcmdldCgpCgkJCQlibGl0KGNibXAsY2kubGF5ZXIsY2xpY2tfeDAsIGNsaWNrX3kwLDAs
MCx3dyxoaCkKCQkJZW5kCgkJZW5kCQoJCQoJCXN0b3JlX211bHRpX2JtcCgpCgkJY2kudW5kb19z
dGFjazpjaGVja3BvaW50KCkgLS0gMC4yLjBpOiBleHRyYSBjaGVja3BvaW50IGlzIHNhdmUgLS0g
Y2FuIHNob3cgdW5zYXZlZCBjaGFuZ2VzIGFzdGVyaXNrIGltbWVkaWF0ZWx5CgllbmQKCQoJCglm
dW5jdGlvbiBlbDpkcmF3KG1zZykKCQoJCS0tIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIHVwIHRv
IGRhdGUKCQktLSAobWlnaHQgYmUgb3V0IG9mIHN5bmMgZHVlIHRvIGtleWJvYXJkLXRyaWdnZXJl
ZCBvcGVyYXRpb247IGUuZy4gcm90YXRlKQoJCXNlbGYudXBkYXRlKG1zZykgCgkJCgkJbG9jYWwg
eCA9IChtc2cubXggLSBjYW5feDApIFwgY2kuem9vbQoJCWxvY2FsIHkgPSAobXNnLm15IC0gY2Fu
X3kwKSBcIGNpLnpvb20KCQkKCQktLWZpbGxwKDB4MTI0OCkKCQlmaWxscCgpCgkJcmVjdGZpbGwo
MCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMzIpCgkJZmlsbHAoKQkKCQkKCQlsb2NhbCB4MCx5
MCA9IGNhbl94MCwgY2FuX3kwCgkJbG9jYWwgeDEseTEgPSB4MCArIHd3LCB5MCArIGhoCgkJbG9j
YWwgc2NhbGUgPSBjaS56b29tCgoJCWNvbG9yKDUpCgkJbGluZSh4MC0yLHkwLTEqc2NhbGUtMSx4
MC0yLHkxKzEqc2NhbGUpCgkJbGluZSh4MSsxLHkwLTEqc2NhbGUtMSx4MSsxLHkxKzEqc2NhbGUp
CgkJCgkJbGluZSh4MC0xKnNjYWxlLTEseTAtMix4MSsxKnNjYWxlLHkwLTIpCgkJbGluZSh4MC0x
KnNjYWxlLTEseTErMSx4MSsxKnNjYWxlLHkxKzEpCgkJCgkJcmVjdGZpbGwoeDAtMSx5MC0xLHgw
K3d3LHkwK2hoLDApCgkJc3NwcihjYm1wLCAwLCAwLCBfLCBfLCB4MCx5MCx3dyxoaCkKCQkKCQlp
ZiAoY3NlbCkgdGhlbgoJCQoJCQlsb2NhbCBzZWxfc2NhbGUgPSBtaW4oc2NhbGUsIDEpCgkJCXdo
aWxlIHNlbF9zY2FsZSA8IHNjYWxlIGFuZCAKCQkJCXNlbF9zY2FsZSAqIGNibXA6d2lkdGgoKSA8
IDUxMiBhbmQKCQkJCXNlbF9zY2FsZSAqIGNibXA6aGVpZ2h0KCkgPCA1MTIgZG8KCQkJCXNlbF9z
Y2FsZSArPSAxCgkJCWVuZAoJCQlsb2NhbCBzZWxfd3cgPSBjYm1wOndpZHRoKCkgKiBzZWxfc2Nh
bGUKCQkJbG9jYWwgc2VsX2hoID0gY2JtcDpoZWlnaHQoKSAqIHNlbF9zY2FsZQoJCQoJCQktLSB0
byBkbzogYWxzbyB1cGRhdGUgaGlnaCBiaXRzIGluIGltYWdlIHRvIHByb3RlY3QKCQkJLS0gcGl4
ZWxzIG91dHNpZGUgb2Ygc2VsZWN0aW9uIGZyb20gbW9kaWZpY2F0aW9uCgkJCWlmIChub3QgY3Nl
bF9vdXRsaW5lIG9yIHNlbF93dyB_PSBsYXN0X291dGxpbmVfd3cpIHRoZW4KCQkJCWNzZWxfb3V0
bGluZSA9IGNyZWF0ZV9vdXRsaW5lKGNzZWwsc2VsX3d3LHNlbF9oaCkKCQkJCWxhc3Rfb3V0bGlu
ZV93dyA9IHNlbF93dwoJCQllbmQKCQkJCgkJCS0tc3ByKGNzZWxfb3V0bGluZSx4MCx5MCkKCQkJ
Zm9yIGk9MCw2MyBkbwoJCQkJcGFsdChpLHRydWUpCgkJCWVuZAoJCQlwYWx0KDEsZmFsc2UpIHBh
bHQoMixmYWxzZSkKCQkJCgkJCXBhbCgxLDcpIHBhbCgyLDcpCgkJCQoJCQlsb2NhbCBjYz0odCgp
KjgpJTgKCQkJcGFsKDksICA4ICsgKGNjKzApJTgpCgkJCXBhbCgxNywgOCArIChjYysyKSU4KQoJ
CQlwYWwoMjUsIDggKyAoY2MrNCklOCkKCQkJcGFsKDMzLCA4ICsgKGNjKzYpJTgpCgkJCQoJCQkK
CQkJZmlsbHAoMHhjOTM2OTM2YzM2Yzk2YzkzID4_ICgoKHRpbWUoKSoxNSlcMSklNCkqMTYpCgkJ
CQoJCQktLSB0byBkbzogZml4IG1hdGNoaW5nCgkJCWxvY2FsIHFxID0gMQoJCQlpZiAoc2VsX3Nj
YWxlIDwgc2NhbGUpIHFxID0gMgoJCQkKCQkJLS1xcSA9IHNjYWxlIC8gc2VsX3NjYWxlCgkJCS0t
cGFsKCkgZmlsbHAoKQoJCQlzc3ByKGNzZWxfb3V0bGluZSwgMCwgMCwgXywgXywgCgkJCQl4MC1x
cSwgeTAtcXEsIHd3K3FxKjIsIGhoK3FxKjIpCgkJCQoJCWVuZAoJCQoJCS0tcHJpbnQocG9ke3Nl
bF9zY2FsZSx4MCx5MCx3dyxoaH0sMiwyLDcpCgkJcGFsKCkgZmlsbHAoKQoJCQoJCXByaW50KHN0
cmluZy5mb3JtYXQoIlwwMTRcIzAgJTNkICUzZCAiLHgseSksIDEyLCAgc2VsZi5oZWlnaHQtMTQs
IDYpCgkJCgkJCgkJCgkJLS1wcmludChwb2R7Y2kucGFuX3gsIGNpLnBhbl95LCBjaS56b29tfSwy
LDIsNykKCWVuZAoJCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCQoJCWNpLnpvb20gKz0g
bXNnLndoZWVsX3kKCQktLXNjYWxlICo9IChtc2cud2hlZWxfeSA8IDApIGFuZCAwLjUgb3IgMi4w
CgkJCgkJIC0tIHRvIGRvOiBjYW4gc2NhbGUgMC41IGZvciBsYXJnZSBpbWFnZXM-CgkJCgkJbG9j
YWwgbWluX3NjYWxlID0gMS4wCgkJbG9jYWwgbWF4X3NjYWxlID0gMTYuMAoJCQoJCS0tIGNhbiB6
b29tIG91dCBmdXJ0aGVyIHdoZW4gd291bGRuJ3QgZml0IG90aGVyd2lzZQoJCWlmIChjYm1wOndp
ZHRoKCkgID49IHNlbGYud2lkdGggKSBtaW5fc2NhbGUgPSAwLjUKCQlpZiAoY2JtcDpoZWlnaHQo
KSA_PSBzZWxmLmhlaWdodCkgbWluX3NjYWxlID0gMC41CQkKCQkKCQljaS56b29tID0gbWlkKG1p
bl9zY2FsZSwgY2kuem9vbSwgbWF4X3NjYWxlKQoJCWlmIChjaS56b29tID49IDEpIGNpLnpvb20g
XD0gMQoJZW5kCgkKCXJldHVybiBlbAoKZW5kCgoKOjogZHJhdy5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMiAwMzoyNjoyMCIsbW9kaWZpZWQ9IjIwMjUtMDctMTAg
MDM6MjU6NTEiLHJldmlzaW9uPTM5OTEsc3RvcmVkPSIyMDIzLTI0LTI4IDAwOjI0OjAwIl1dCmZ1
bmN0aW9uIF9kcmF3KCkKCQoJY2xzKDUpCgkKCS0tIG9wZXJhdGlvbnMgZHVyaW5nIF91cGRhdGUg
Y2FuIHJlcXVlc3QgYQoJLS0gZ3VpIHVwZGF0ZSBiZWZvcmUgaXQgaXMgbmV4dCBkcmF3IChhdm9p
ZCBmbGlja2VyKQoJaWYgKHJlZnJlc2hfZ3VpKSB0aGVuCgkJZ2VuZXJhdGVfZ3VpKCkKCQktLSBn
dWk6ZHJhd19hbGwoKSBleHBlY3RzIDp1cGRhdGVfYWxsKCkgY2FsbGVkIGZpcnN0IG9uIGN1cnJl
bnQgc3RhdGUgb2YgZ3VpCgkJZ3VpOnVwZGF0ZV9hbGwoKQoJCXJlZnJlc2hfZ3VpID0gZmFsc2UK
CWVuZAoJCQoJZ3VpOmRyYXdfYWxsKCkKCQoJLS0gY3VzdG9tIGRpc3BsYXkgcGFsZXR0ZQoJLS0g
YXQgZW5kLi4gc29tZXRoaW5nIGluIDpkcmF3X2FsbCgpIHByb2JhYmx5IGNhbGxzIHBhbCgpCglw
b2tlNCgweDUwMDArMzIqNCwgMHgyMDIwMjAyMCkKCQoJaWYgKGN1c3RvbV9wYWxldHRlKSB0aGVu
CgkJcG9rZTQoMHg1MDAwLCBnZXQoY3VzdG9tX3BhbGV0dGUpKQoJZW5kCgkKZW5kCgoKOjogZ3Vp
Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTA1LTExIDAyOjA1OjE2Iixt
b2RpZmllZD0iMjAyNS0wOS0wOSAwMjowNzoyNiIscmV2aXNpb249NDg5NCxzdG9yZWQ9IjIwMjMt
MjQtMjggMDA6MjQ6MDAiXV0KLS1bWwoKCXNob3VsZCBvbmx5IG5lZWQ6CglwYWxldHRlICAtLSAg
d2l0aCB0YWIgdG8gc2hvdyBvcGVyYXRpb25zIChvciBvdGhlciBwYWxldHRlIHN0eWxlcykKCXRv
b2xzCgl0b29sIGF0dHJpYnV0ZXMgLy8gYnJ1c2ggc2l6ZSwgZmlsbCBwYXR0ZXJuCgluYXZpZ2F0
b3IKCgl0aGUgcGFsZXR0ZSBhbmQgbmF2aWdhdG9yIGNhbiAvZnJhbWUvIHRoZSB0b29scyArIGF0
dHJpYnV0ZXMJCgpdXQoKc2hvd19wYW5lID0gdHJ1ZQoKIC0tIHVwZGF0ZSBsYXlvdXQgd2l0aG91
dCBuZWVkaW5nIHRvIHJlZ2VuZXJhdGUgZ3VpCiAtLSB0byBkbzogY291bGQgYWxzbyB1c2UgdGhp
cyBmb3IgaGFuZGxpbmcgY2hhbmdlcyBpbiBkaXNwbGF5IHNpemUKIGZ1bmN0aW9uIHVwZGF0ZV9n
dWlfbGF5b3V0KCkKIAlpZiAobm90IHNpZGViYXIgb3Igbm90IGNhbnZhc19lbCkgcmV0dXJuCiAJ
CiAJeHQgPSBzaG93X3BhbmUgYW5kIDMzNiBvciA0ODAKIAlzaWRlYmFyX3ggPSBzaWRlYmFyX3gg
b3Igc2lkZWJhci54CiAJc2lkZWJhcl94ID0gKHNpZGViYXJfeCAqIDMgKyB4dCkgLyA0CiAJCglp
ZiAoc2lkZWJhcl94ID4geHQpIHRoZW4KCQlzaWRlYmFyX3ggPSBtYXgoeHQsIHNpZGViYXJfeCAt
IDgpCgllbHNlCgkJc2lkZWJhcl94ID0gbWluKHh0LCBzaWRlYmFyX3ggKyA4KQoJZW5kCgkKCS0t
ICEhIGluc3RhbnQgY2hhbmdlIC0tIG1heWJlIGJldHRlciAoc3RpbGwgZ2V0IHRvb2xiYXIgdHJh
bnNpdGlvbiEpCglzaWRlYmFyX3ggPSB4dAoKIAlzaWRlYmFyLnggPSBzaWRlYmFyX3ggXCAxCiAJ
c2lkZWJhci5oZWlnaHQgPSBnZXRfZGlzcGxheSgpOmhlaWdodCgpCiAKCWNhbnZhc19lbC53aWR0
aCA9IHNpZGViYXJfeCBcIDEKCWNhbnZhc19lbC5oZWlnaHQgPSBnZXRfZGlzcGxheSgpOmhlaWdo
dCgpCgkKCWlmIChpbXBvcnRlcl9mcmFtZSkgaW1wb3J0ZXJfZnJhbWUueCA9IGNhbnZhc19lbC53
aWR0aC8yLTcwCiAKCS0tIHNlbmQgYSBtZXNzYWdlIHRvIHdtIGFza2luZyB0byB1bmRvY2sgLyBk
b2NrIHRvb2xiYXIKCWlmIHNob3dfcGFuZSB_PSBsYXN0X3Nob3dfcGFuZSB0aGVuCQoJCS0tc2Vu
ZF9tZXNzYWdlKDMsIHtldmVudD0iZG9ja190b29sYmFyIiwgc3RhdGUgPSBzaG93X3BhbmV9KQoJ
ZW5kCglsYXN0X3Nob3dfcGFuZSA9IHNob3dfcGFuZQogZW5kCiAKCmZ1bmN0aW9uIGdlbmVyYXRl
X2d1aSgpCgoJZ3VpID0gY3JlYXRlX2d1aSgpCgkKCWlmIChtb2RhbF90b29sID09ICJpbXBvcnRl
ciIpIHRoZW4KCQktLSByZXVzZSBjYW52YXMgdG8gZ2V0IGZvcm1hdHRpbmcKCQljYW52YXNfZWwg
PSBjcmVhdGVfaW1wb3J0ZXIoe3g9MCx5PTAsCgkJd2lkdGg9MzM2LGhlaWdodF9yZWw9MS4wfSwg
Z3VpKQoJCXdpbmRvd3tjYXB0dXJlX2VzY2FwZXMgPSB0cnVlfQoJZWxzZQoJCWNhbnZhc19lbCA9
IGd1aTphdHRhY2goY3JlYXRlX2NhbnZhc3t4PTAseT0wLAoJCXdpZHRoPTMzNixoZWlnaHRfcmVs
PTEuMH0pCgllbmQKCglzaWRlYmFyID0gZ3VpOmF0dGFjaHt4PTQ4MC0xNDQseT0wLHdpZHRoPTE1
MCxoZWlnaHQ9MjUwfQoJCgktLSBhIGxpdHRsZSBzcGFjZSBhYm92ZSBwYWxldHRlIGZvciB0YWJz
IChvcGVyYXRpb24pCglsb2NhbCBwYWxfZWwgPSBzaWRlYmFyOmF0dGFjaChjcmVhdGVfcGFsZXR0
ZXt4PTgseT0xNix3aWR0aD0xMjgsaGVpZ2h0PTMyfSkKCglzaWRlYmFyOmF0dGFjaChjcmVhdGVf
cGFsX3RhYnN7eD0xMTIseT02LHdpZHRoPTQ4LGhlaWdodD05fSkKCXNpZGViYXI6YXR0YWNoKGNy
ZWF0ZV9wYWxfcHJldmlld3t4PTcseT00LHdpZHRoPTMwLGhlaWdodD05fSkKLS1bWwoJc2lkZWJh
cjphdHRhY2h7CgkJeD0xMjgseT04LHdpZHRoPTgsaGVpZ2h0PTYsCgkJZHJhdz1mdW5jdGlvbigp
IAoJCQktLWZvciB5PTAsMyBkbyBmb3IgeD0wLDcgZG8KCQkJLS0JcHNldCh4LHkseCt5KjgpIGVu
ZCBlbmQKCQkJcmVjdGZpbGwoMCwwLDcsMyw2KSAKCQllbmQsCgkJY2xpY2s9ZnVuY3Rpb24oKSBw
YWxfc3dhdGNoIF5ePSAxIHJlZnJlc2hfZ3VpPTEgZW5kCgl9Cl1dCQoJCQoJLS1zaWRlYmFyOmF0
dGFjaChjcmVhdGVfaXRlbV9pbmZve3g9OCx5PTY0LHdpZHRoPTEyOCxoZWlnaHQ9MjB9KQoKCXNp
ZGViYXI6YXR0YWNoKGNyZWF0ZV9pdGVtX2luZm97eD04LHk9OTYsd2lkdGg9MTI4LGhlaWdodD0y
NH0pCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfYmFua190YWJze3g9OCsxMjgtNDgrMSx5PTExNi05
LHdpZHRoPTQ4LGhlaWdodD05fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9uYXZ7eD04LHk9MTE2
LHdpZHRoPTEyOCxoZWlnaHQ9MTI4fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9yYW1fd2lkZ2V0
e3g9ODgseT0yNTAsd2lkdGg9NjAsaGVpZ2h0PTEwfSkKCgktLS0tIHRvb2xzIC0tLS0KCQoJbG9j
YWwgdG9vbHMgPSB7CgkJInBlbmNpbCIsImJydXNoIiwibGluZSIsInJlY3QiLCAiY2lyYyIsCgkJ
ImZpbGwiLCAic3RhbXAiLCAic2VsZWN0IiwgInBhbiIKCQktLSJlcmFzZXIiLAoJCS0tInNtdWRn
ZSIsCgkJLS0ic3dlZXAiLCJ0ZXh0Iiwic2NyYW1ibGUiCgl9CgkKCWxvY2FsIHd3PTEyCglsb2Nh
bCB5eT1wYWxfZWwueSArIHBhbF9lbC5oZWlnaHQgKyA0Cglmb3IgaT0wLCN0b29scy0xIGRvCglz
aWRlYmFyOmF0dGFjaChjcmVhdGVfdG9vbF9idXR0b24odG9vbHNbaSsxXSwgCgkJMTArKGkld3cp
KjE0LCB5eSsoaVx3dykqMTQpKQoJZW5kCgkKCS0tLS0gY29sb3VyIC8gZmlsbCBwYXR0ZXJuIHBy
ZXZpZXcgLS0tLS0KCi0tIG9ubHkgc2hvdyB3aGVuIHRvb2xzIHRoYXQgdXNlIGZpbGwgcGF0dGVy
biBpcyBzZWxlY3RlZAotLSAobGluZSBhbmQgc2hhcGUgZGlzYWJsZWQgZm9yIG5vdykKaWYgKCh7
YnJ1c2g9MSx4bGluZT0xLHhzaGFwZT0xfSlbY3Rvb2xdKSB0aGVuIAoKCXl5Kz0xNgoJc2lkZWJh
cjphdHRhY2goe3g9OCx5PXl5LHdpZHRoPTI0LGhlaWdodD0yNCwKCQlkcmF3PWZ1bmN0aW9uKHNl
bGYpCgkJCWNsaXAoKQoJCQlyZWN0ZmlsbCgtMSwtMSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0LDAp
CgkJCWZpbGxwKGJydXNoLnBhdCkKCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhl
aWdodC0xLGNvbCkKCQkJZmlsbHAoKQoJCWVuZAoJfSkKCQoJLS0gYnJ1c2hlcwoJCglsb2NhbCB4
eCA9IDM2CgkKCQoJZm9yIGk9MCw3IGRvCgkJc2lkZWJhcjphdHRhY2goY3JlYXRlX2JydXNoX2J1
dHRvbihpKzEsIHh4ICsoaSV3dykqMTIsIHl5KSkKCWVuZAoJCgktLSAweDgwODUKCS0tIGZpbGwg
cGF0dGVybnMKCQoJbG9jYWwgcGF0ID0ge1swXT0KCQkweDAwMDAsMHg1MGEwLDB4NWE1YSwweDUw
YTB_MHhmZmZmLAkKCQkweDM2YzksMHg5YzYzLDB4MTI0OH4weGZmZmYsMHg4NDIxfjB4ZmZmZiwK
CgkJMHgwMDAwLCAweDgwYjksIDB4ODEzZCwKCQkweDdlOTksIDB4ODFkYiwgMHg3ZDdkLAoJCTB4
ODI3MiwgMHg4MzRmCgl9Cgl5eSArPSAxNAoJZm9yIGk9MCw3IGRvCgkJCXNpZGViYXI6YXR0YWNo
KHt4ID0geHggKyBpKjEyLCB5ID0geXksIHdpZHRoPTExLGhlaWdodD0xMCwKCQkJCXBhdCA9IHBh
dFtpXSwKCQkJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJCQljbGlwKCkKCQkJCQktLXBva2UoMHg1
NTBiLDB4ZmYpCgkJCQkJcmVjdGZpbGwoLTEsLTEsc2VsZi53aWR0aCxzZWxmLmhlaWdodCwwKQoJ
CQkKCQkJCQlmaWxscChzZWxmLnBhdCkKCQkJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNl
bGYuaGVpZ2h0LTEsCgkJCQkJCXNlbGYucGF0PT1icnVzaC5wYXQgYW5kIDcgb3IgNSkKCQkJCQlm
aWxscCgpCgkJCQllbmQsCgkJCQljbGljayA9IGZ1bmN0aW9uKHNlbGYpCgkJCQkJYnJ1c2gucGF0
ID0gc2VsZi5wYXQKCQkJCWVuZAoJCQl9KQoJZW5kCmVuZCAtLSBicnVzaCBlbGVtZW50cwoKCXVw
ZGF0ZV9ndWlfbGF5b3V0KCkKCmVuZAoKdG9vbF9nZng9ewpwZW5jaWw9IltnZnhdMDgwODAwMDA3
MDAwMDAwNzc3MDAwMDc3Nzc3MDA3Nzc3NzAwNzA3NzcwMDA3MDA3MDAwMDc3NzAwMDAwMDAwMDAw
MDBbL2dmeF0iLApicnVzaD0iW2dmeF0wODA4MDAwMDA3NzAwMDAwNzcwMDAwMDc3MDAwMDAwNzAw
MDAwNzcwMDAwMDA3NzAwMDAwNzcwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCmxpbmU9IltnZnhdMDgw
ODAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDAw
MDAwMDAwMDBbL2dmeF0iLApzZWxlY3Q9IltnZnhdMDgwODc3MDcwNzcwNzAwMDAwNzAwMDAwMDAw
MDcwMDAwMDcwMDAwMDAwMDA3MDAwMDA3MDc3MDcwNzcwMDAwMDAwMDBbL2dmeF0iLApyZWN0PSJb
Z2Z4XTA4MDg3Nzc3Nzc3MDcwMDAwMDcwNzAwMDAwNzA3MDAwMDA3MDcwMDAwMDcwNzAwMDAwNzA3
Nzc3Nzc3MDAwMDAwMDAwWy9nZnhdIiwKY2lyYz11bnBvZCgiYjY0OmJIbzBBQ0FBQUFBaUFBQUE4
d1Z3ZUhVQVF5QUlDQVFRSnpBSElBY1FCMEFIQUFRQWNCQUhJQWN3SjZBPSIpLApwYW49IltnZnhd
MDgwODAwNzA3MDAwMDA3MDcwNzAwMDcwNzA3MDAwNzc3NzcwNzA3Nzc3NzAwNzc3Nzc3MDAwNzc3
NzAwMDAwMDAwMDBbL2dmeF0iLApmaWxsPSJbZ2Z4XTA4MDgwMDAwNzAwMDAwMDAwNzAwMDAwMDAw
NzAwNzc3Nzc3NzcwNzc3NzcwNzAwNzc3MDA3MDAwNzAwMDAwMDAwMDAwWy9nZnhdIiwKc3RhbXA9
IltnZnhdMDgwODAwNzc3MDAwMDA3NzcwMDAwMDc3NzAwMDAwNzc3MDAwNzc3Nzc3NzA3MDAwMDA3
MDc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLApzbXVkZ2U9IltnZnhdMDgwODAwNzAwMDAwMDA3MDAw
MDAwMDcwNzA3MDAwNzc3NzcwNzA3Nzc3NzAwNzc3Nzc3MDAwNzc3NzAwMDAwMDAwMDBbL2dmeF0i
LApzd2VlcD0iW2dmeF0wODA4MDAwMDcwMDAwMDAwNzAwMDAwMDA3MDAwMDAwNzAwMDAwMDA3MDAw
MDc3Nzc3NzcwNzA3MDcwNzAwMDAwMDAwMFsvZ2Z4XSIsCnRleHQ9IltnZnhdMDgwODc3Nzc3Nzcw
NzcwMDc3NzA3Nzc3MDc3MDc3MDAwNzcwNzA3NzA3NzA3NzAwNzA3MDc3Nzc3NzcwMDAwMDAwMDBb
L2dmeF0iLApzY3JhbWJsZT0iW2dmeF0wODA4MDcwMDA3MDAwNzAwMDcwMDc3Nzc3NzcwNzA3Nzcw
NzA3Nzc3Nzc3MDA3MDAwNzAwNzcwMDA3NzAwMDAwMDAwMFsvZ2Z4XSIsCmVyYXNlcj0iW2dmeF0w
ODA4MDAwNzcwMDAwMDc3NzcwMDA3Nzc3NzcwNzA3Nzc3NzA3MDA3NzcwMDA3MDA3MDAwMDA3NzAw
MDAwMDAwMDAwMFsvZ2Z4XSIsCn0KCmJydXNoX2dmeD17CnVzZXJkYXRhIltnZnhdMDgwODAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDBbL2dmeF0iLAp1c2VyZGF0YSJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3
NzAwMDAwMDc3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKdXNlcmRhdGEiW2dm
eF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAwMDA3NzcwMDAwMDA3MDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCnVzZXJkYXRhIltnZnhdMDgwODAwMDAwMDAwMDAwMDAwMDAw
MDA3NzAwMDAwNzc3NzAwMDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLAp1
c2VyZGF0YSJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDc3MDAwMDA3Nzc3MDAwNzc3Nzc3MDA3Nzc3Nzcw
MDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwWy9nZnhdIiwKdXNlcmRhdGEiW2dmeF0wODA4MDA3Nzc3
MDAwNzc3Nzc3MDc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3MDc3Nzc3NzAwMDc3Nzcw
MFsvZ2Z4XSIsCi0tW1twb2QscG9kX3R5cGU9ImltYWdlIl1ddW5wb2QoImI2NDpiSG8wQUE4QUFB
QU9BQUFBNEhCNGRRQkRJQWdJQlBBSlItQVMiKSwKLS1bW3BvZCxwb2RfdHlwZT0iaW1hZ2UiXV11
bnBvZCgiYjY0OmJIbzBBQm9BQUFBWUFBQUE4QWx3ZUhVQVF5QUlDQVJRQjFBWFFCZEFGMEFYUUJk
QUY5QT0iKSwKdXNlcmRhdGEiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDc3NzcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCnVzZXJkYXRhIltnZnhd
MDgwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAw
MDAwMDAwMDAwMDBbL2dmeF0iCn0KCgpmdW5jdGlvbiBjcmVhdGVfYnJ1c2hfYnV0dG9uKHdoaWNo
LCB4LCB5KQoJbG9jYWwgZWw9IHsKCQl3aGljaCA9IHdoaWNoLCB4ID0geCwgeSA9IHksIHdpZHRo
PTEyLCBoZWlnaHQgPSAxMiwKCQljdXJzb3I9InBvaW50ZXIiCQoJfQoJCgllbC5nZnggPSBicnVz
aF9nZnhbd2hpY2hdCgkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCXJlY3RmaWxsKDAsMSxzZWxmLndp
ZHRoLTIsc2VsZi5oZWlnaHQtMiwwKQoJCXBhbCg3LCBzZWxmLndoaWNoID09IGJydXNoLndoaWNo
IGFuZCA3IG9yIDEzKQoJCXNwcihzZWxmLmdmeCwyLDIpCgkJcGFsKDcsNykKCWVuZAoJCglmdW5j
dGlvbiBlbDp0YXAoKQoJCWJydXNoLndoaWNoID0gc2VsZi53aGljaAoJCWJydXNoLnRoaWNrbmVz
cyA9IHNlbGYud2hpY2gtMQoJCWJydXNoLnNwcml0ZSA9IGVsLmdmeAoJZW5kCgkKCXJldHVybiBl
bAplbmQKCgpmdW5jdGlvbiBjcmVhdGVfdG9vbF9idXR0b24od2hpY2gsIHgsIHkpCglsb2NhbCBl
bD0ge3doaWNoID0gd2hpY2gsIHggPSB4LCB5ID0geSwgd2lkdGg9MTIsIGhlaWdodCA9IDEyLGN1
cnNvcj0icG9pbnRlciJ9CgkKCWlmIHR5cGUodG9vbF9nZnhbd2hpY2hdKSA9PSAidXNlcmRhdGEi
IHRoZW4KCQllbC5nZnggPSB0b29sX2dmeFt3aGljaF0KCWVsc2UKCQllbC5nZnggPSB1c2VyZGF0
YSh0b29sX2dmeFt3aGljaF0pCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhdygpCgktLVtbCgkJbGlu
ZSgxLDAsOSwwLDEzKQoJCXJlY3RmaWxsKDAsMSwxMCw5LDEzKQoJCWxpbmUoMSwxMCw5LDEwLDEz
KQoJXV0KCQlwYWwoNywgd2hpY2ggPT0gY3Rvb2wgYW5kIDcgb3IgMTMpCgkJc3ByKHNlbGYuZ2Z4
LDIsMikKCQlwYWwoNyw3KQoJZW5kCgkKCWZ1bmN0aW9uIGVsOnRhcCgpCgkJY3Rvb2wgPSBzZWxm
LndoaWNoCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoKCXJldHVybiBlbAplbmQKCgpmdW5j
dGlvbiBjcmVhdGVfcmFtX3dpZGdldChlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCS0tIDAuMi4w
aTogY2hhbmdlZCB0byAxMk1CIGFzIG5vbWluYWwgc2FmZSBhbW91bnQgb2YgbWVtb3J5IHRvIHVz
ZQoJCS0tIG5lZWQgc3BhY2UgZm9yIHdyYW5nbGVyL3N0b3JlIHNhdmluZyBjb2RlICsgdW5kbyBz
dGFjayBldGMKCQlwcmludChzdHJpbmcuZm9ybWF0KCJcMDE0JTIuMmZtYiAoJTAyZCUlKSIsc3Rh
dCgwKS8weDEwMDAwMCxzdGF0KDApXDEyNTgyOSksMCwwLAoJCQlzdGF0KDApID4gMTEwMDAwMDAg
YW5kIDE0IG9yIDIxKSAtLSB3YXJuIHdoZW4gY2xvc2UgdG8gY2FwYWNpdHkKCWVuZAoJcmV0dXJu
IGVsCmVuZAoKCjo6IGltcG9ydC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
NS0wNy0wOCAwMTo1NToxMiIsbW9kaWZpZWQ9IjIwMjUtMDctMjYgMDk6NDY6MTUiLHJldmlzaW9u
PTM0MV1dCi0tW1sKCXNwcml0ZXNoZWV0IGltcG9ydGVyIGZvciB0d28gY29tbW9uIHdvcmtmbG93
czoKCQoJMS4gdXNlIGV4dGVybmFsIHNwcml0ZSBlZGl0b3IKCQkvLyByZXBlYXRlZCB1c2UgLS0g
YXV0aG9yIG1pZ2h0IG5vdCB3YW50IHRvIHdyaXRlIHRoZWlyIG93biBpbXBvcnRlcgoJCS8vIHNo
b3VsZCByZW1lbWJlciB0aGUgbGFzdCBwYXJhbWV0ZXJzIHVzZWQgW2ZvciB0aGF0IGltYWdlIHNo
YXBlXQoKCTIuIGdyYWIgZGF0YSBmcm9tIGEgUElDTy04IGNhcnRyaWRnZQoJCS8vIHVzdWFsbHkg
anVzdCBvbmNlIChvdGhlcndpc2UgY2FuIHBhc3RlIGluZGl2aWR1YWwgW2dmeF0gaXRlbXMpCgkJ
CgljYW4gc2xpY2UgYW5kIGRpY2Ugb3Igc2VsZWN0IGl0ZW1zIGFuZCBjb3B5IC8gcGFzdGUKCQoJ
ZWl0aGVyIHdheSwgbmVlZCB0byBrbm93OiBpdGVtX3dpZHRoLCBpdGVtX2hlaWdodCBpbiBwaXhl
bHMKCQoJCl1dCgpsb2NhbCBzbGljZV90ID0gMAoKZnVuY3Rpb24gY3JlYXRlX2ltcG9ydGVyKGVs
LCBwYXJlbnQpCgoJZWwgPSBwYXJlbnQ6YXR0YWNoKGVsKQoJCgktLSBmb3JjZSByZWFzb25hYmxl
IHZhbHVlcwoJaWYgKGltcG9ydF9ibXApIHRoZW4KCQlpbXBvcnRfb2Zmc2V0ID0gaW1wb3J0X29m
ZnNldCBvciAwCgkJaW1wb3J0X3RyaW0gPSBpbXBvcnRfdHJpbSBvciAwCgkJaW1wb3J0X3RpbGVf
dyA9IG1pZCg0LGltcG9ydF90aWxlX3cgb3IgOCw1MTIpCgkJaW1wb3J0X3RpbGVfaCA9IG1pZCg0
LGltcG9ydF90aWxlX2ggb3IgOCw1MTIpCgllbmQKCQoJaWYgKGltcG9ydF9ibXApIHRoZW4KCQoJ
CWxvY2FsIGN4ID0gZWwud2lkdGgvMgoJCQoJCS0tIGZyYW1lCgkJbG9jYWwgZnJhbWUgPSBlbDph
dHRhY2h7CgkJCXggPSBjeC03MCwgeSA9IDIwNCwKCQkJd2lkdGggPSAxNDAsIGhlaWdodD0gNDQs
CgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmKQoJCQkJcnJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLHNl
bGYuaGVpZ2h0LDIsMSkKCQkJZW5kCgkJfQoJCQoJCWltcG9ydGVyX2ZyYW1lID0gZnJhbWUKCQoJ
CWZyYW1lOmF0dGFjaF9idXR0b24oewoJCQl4ID0gMjAsIHkgPSAyNywKCQkJd2lkdGggPSAxMDAs
CgkJCWJvcmRlciA9IDB4MDEwMSwKCQkJbGFiZWwgPSAiU2xpY2UgYW5kIERpY2UiLAoJCQljbGlj
ayA9IHNsaWNlX2FuZF9kaWNlLAoJCQlob3ZlciA9IGZ1bmN0aW9uKHNlbGYsbXNnKSBzbGljZV90
ID0gdGltZSgpIGVuZCwKCQkJY3Vyc29yPQotLVtbcG9kX3R5cGU9ImdmeCJdXXVucG9kKCJiNjQ6
YkhvMEFFNEFBQUJNQUFBQThEMXdlSFVBUXlBU0RBUkJ3QUUzSVpBQkJ5RW5RVUFCQnhFWEVUY0JR
QUVIQVJjUkJ5RUhFVEFCSnhFSE1TY3hBQUVIRVFkQlZ3RVFBUmRSQnhFbkFTQVJKeUVIVVVBaE53
SEFRZkFIIikKCQl9KQoJCQoJCS0tIAoJCQoJCWZyYW1lOmF0dGFjaF9maWVsZHsKCQkJeD01OCx5
PTYsd2lkdGg9MTYsaGVpZ2h0PTcsCgkJCWdldD1mdW5jdGlvbigpIHJldHVybiBpbXBvcnRfdGls
ZV93IGVuZCwKCQkJc2V0PWZ1bmN0aW9uKHNlbGYsdmFsKSBpbXBvcnRfdGlsZV93ID0gdG9udW0o
dmFsKSBvciBpbXBvcnRfdGlsZV93IGVuZCwKCQkJbGFiZWw9IlwwMTR0aWxlIHdpZHRoOiAiLAoJ
CQlwcmludF9wcmVmaXg9IlwwMTQiCgkJfQoJCWZyYW1lOmF0dGFjaF9maWVsZHsKCQkJeD0xMTYs
eT02LHdpZHRoPTE2LGhlaWdodD03LAoJCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gaW1wb3J0X3Rp
bGVfaCBlbmQsCgkJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgaW1wb3J0X3RpbGVfaCA9IHRvbnVt
KHZhbCkgb3IgaW1wb3J0X3RpbGVfaCBlbmQsCgkJCWxhYmVsPSJcMDE0aGVpZ2h0OiAiLAoJCQlw
cmludF9wcmVmaXg9IlwwMTQiCgkJfQoJCQoJCWZyYW1lOmF0dGFjaF9maWVsZHsKCQkJeD02Nix5
PTE2LHdpZHRoPTE2LGhlaWdodD03LAoJCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gaW1wb3J0X29m
ZnNldCBlbmQsCgkJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgaW1wb3J0X29mZnNldCA9IHRvbnVt
KHZhbCkgb3IgaW1wb3J0X29mZnNldCBlbmQsCgkJCWxhYmVsPSJcMDE0c3ByaXRlIGluZGV4OiAi
LAoJCQlwcmludF9wcmVmaXg9IlwwMTQiCgkJfQoKCQlmcmFtZTphdHRhY2hfZmllbGR7CgkJCXg9
MTE2LHk9MTYsd2lkdGg9MTYsaGVpZ2h0PTcsCgkJCWdldD1mdW5jdGlvbigpIHJldHVybiBpbXBv
cnRfdHJpbSBlbmQsCgkJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgaW1wb3J0X3RyaW0gPSBtYXgo
MCx0b251bSh2YWwpIG9yIGltcG9ydF90cmltKSBlbmQsCgkJCWxhYmVsPSJcMDE0dHJpbTogIiwK
CQkJcHJpbnRfcHJlZml4PSJcMDE0IgoJCX0KCgllbmQKCglsb2NhbCBtYXJnaW4gPSAyCglmdW5j
dGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsMTAwMCwxMDAwLDMyKQoJCQoJCW1hcmdpbl90
YXJnZXQgPSAoc2xpY2VfdCA_IHRpbWUoKS0wLjEyNSkgYW5kIDQuNSBvciAyLjUKCQltYXJnaW5f
ZiA9IG1hcmdpbl9mIG9yIDEuMAoJCW1hcmdpbl9mID0gbWFyZ2luX2YgKiAwLjggKyBtYXJnaW5f
dGFyZ2V0ICogMC4yCgkJCgkJbG9jYWwgY3gsIGN5ID0gZWwud2lkdGgvMiwgZWwuaGVpZ2h0LzIg
LSAoaW1wb3J0X2JtcCBhbmQgMjAgb3IgMCkKCQkKCQlpZiAoaW1wb3J0X2JtcCkgdGhlbgoJCQkK
CQkJbG9jYWwgdGlsZXNfeCA9IGltcG9ydF9ibXA6d2lkdGgoKSBcIGltcG9ydF90aWxlX3cKCQkJ
bG9jYWwgdGlsZXNfeSA9IGltcG9ydF9ibXA6aGVpZ2h0KCkgXCBpbXBvcnRfdGlsZV9oCgkJCQoJ
CQlsb2NhbCBtYXJnaW4gPSBtYXJnaW5fZgoJCQlsb2NhbCB3dyA9IGltcG9ydF9ibXA6d2lkdGgo
KSArIG1hcmdpbiAqICh0aWxlc194LTEpCgkJCWxvY2FsIGhoID0gaW1wb3J0X2JtcDpoZWlnaHQo
KSArIG1hcmdpbiAqICh0aWxlc195LTEpCgkJCQoJCQlsb2NhbCB4MCx5MCA9IGN4LXd3LzIrMC41
LCBtYXgoMiwgY3ktaGgvMikrMC41CgkJCWxvY2FsIHgxLHkxID0geDArd3csIHkwK2hoCgkJCQoJ
CQlmb3IgeT0wLHRpbGVzX3ktMSBkbwoJCQkJZm9yIHg9MCx0aWxlc194LTEgZG8KCQkJCQlibGl0
KGltcG9ydF9ibXAsIG5pbCwKCQkJCQkJeCAqIGltcG9ydF90aWxlX3csIAoJCQkJCQl5ICogaW1w
b3J0X3RpbGVfaCwKCQkJCQkJeDAgKyB4ICogKGltcG9ydF90aWxlX3cgKyBtYXJnaW4pLAoJCQkJ
CQl5MCArIHkgKiAoaW1wb3J0X3RpbGVfaCArIG1hcmdpbiksCgkJCQkJCWltcG9ydF90aWxlX3cg
LSBtYXgoMCxpbXBvcnRfdHJpbSksCgkJCQkJCWltcG9ydF90aWxlX2ggLSBtYXgoMCxpbXBvcnRf
dHJpbSkKCQkJCQkpCgkJCQkJCQoJCQkJZW5kCgkJCWVuZAoJCQkKCQotLQkJCXJlY3RmaWxsKHgw
LHkwLHgxLHkxLDApCi0tCQkJc3ByKGltcG9ydF9ibXAsIHgwLCB5MCkKCQkJCgkJCS0tcmVjdCh4
MC0xNix5MC0xNix4MSsxNix5MSsxNiwxOCkKCQkJCgkJZWxzZQoJCQlmaWxscCgweDVhNWEpCgkJ
CWxvY2FsIHgwLHkwID0gY3ggLSA2MCwgY3kgLSA0MAoJCQlsb2NhbCB4MSx5MSA9IGN4ICsgNjAs
IGN5ICsgNDAKCQkJcmVjdCh4MCx5MCx4MSx5MSw3KQoJCQlmaWxscCgpCgkJCQoJCQlzdHI9ImRy
b3AgLnBuZyAvIC5wOCIKLS0JCQlzdHI9ImRyYWcgJiBkcm9wIHBuZyIKCQkJdyA9IHByaW50KHN0
ciwwLC0xMDApCgkJCXByaW50KHN0cixjeCAtIHcvMiwgY3ktNCwgNikKCQkJcHJpbnQoIlwwMTQo
b3IgcGFzdGUpIiwgY3ggLSAxNixjeSs4LDEzKQoJCWVuZAoJCQoJZW5kCglyZXR1cm4gZWwKCQpl
bmQKCgotLVtbCnRlc3Q6CltnZnhdMDgwODAwMDAwMDAwMGYwMDBmMDAwZmZmZmZmMDBmMWZmZjEw
MGVmZmZmZTAwMDIyMjAwMDAwODg4MDAwMDBmMGYwMDBbL2dmeF0KXV0KZnVuY3Rpb24gcGFzdGVf
c3ByaXRlc2hlZXQoKQoJbG9jYWwgYm1wCglsb2NhbCBzdHIgPSBnZXRfY2xpcGJvYXJkKCkKCWlm
IChzdHI6c3ViKDEsNSkgPT0gIltnZnhdIikgdGhlbgoJCWJtcCA9IHVzZXJkYXRhKHN0cikKCQlp
bXBvcnRfdGlsZV93ID0gaW1wb3J0X3RpbGVfdyBvciA4CgkJaW1wb3J0X3RpbGVfaCA9IGltcG9y
dF90aWxlX2ggb3IgOAoJZWxzZQoJCWJtcCA9IHVucG9kKHN0cikKCQlpbXBvcnRfdGlsZV93ID0g
aW1wb3J0X3RpbGVfdyBvciAxNgoJCWltcG9ydF90aWxlX2ggPSBpbXBvcnRfdGlsZV9oIG9yIDE2
CgllbmQKCQoJaWYgKGJtcCkgdGhlbgoJCWltcG9ydF9ibXAgPSBibXAKCQlyZWZyZXNoX2d1aSA9
dHJ1ZQoJZWxzZQoJCW5vdGlmeSgibm8gaW1hZ2UgZm91bmQgaW4gY2xpcGJvYXJkIikJCgllbmQK
CQoJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAoKCmZ1bmN0aW9uIHNsaWNlX2FuZF9kaWNlKCkKCglp
ZiAobm90IGltcG9ydF9ibXApIHJldHVybgoJCglsb2NhbCBsaXN0ID0ge30KCglsb2NhbCB0dyx0
aCA9IHRvbnVtKGltcG9ydF90aWxlX3cpIG9yIDgsIHRvbnVtKGltcG9ydF90aWxlX2gpIG9yIDgK
CWxvY2FsIHRpbGVzX3cgPSBpbXBvcnRfYm1wOndpZHRoKCkgXCB0dwoJbG9jYWwgdGlsZXNfaCA9
IGltcG9ydF9ibXA6aGVpZ2h0KCkgXCB0aAoJCglsb2NhbCBxID0gbWF4KGltcG9ydF90cmltLDAp
Cglmb3IgcGFzcz0wLDEgZG8KCQlmb3IgeT0wLHRpbGVzX2gtMSBkbwoJCQlmb3IgeD0wLHRpbGVz
X3ctMSBkbwoJCQkJbG9jYWwgaWR4ID0gaW1wb3J0X29mZnNldCArIHggKyB5ICogdGlsZXNfdwoJ
CQkJaWYgKGlkeCA_PSAwIGFuZCBpZHggPCAyNTYpIHRoZW4KCQkJCQlpZiAocGFzcyA9PSAwKSB0
aGVuCgkJCQkJCWFkZChsaXN0LGlkeCkKCQkJCQllbHNlCgkJCQkJCWxvY2FsIGJtcDEgPSB1c2Vy
ZGF0YSgidTgiLCB0dy1xLCB0aC1xKQoJCQkJCQlibGl0KGltcG9ydF9ibXAsIGJtcDEsIHgqdHcs
IHkqdGgsIDAsIDAsIHR3LXEsIHRoLXEpCgkJCQkJCWl0ZW1baWR4XS5ibXAgPSBibXAxCgkJCQkJ
CWl0ZW1baWR4XS5mbGFncyA9IDAKCQkJCQllbmQKCQkJCWVuZAoJCQllbmQKCQllbmQKCQktLSBo
YXZlIGxpc3Qgb2Ygc3ByaXRlcyB0aGF0IHdpbGwgYmUgd3JpdHRlbiwgYnV0IGhhdmVuJ3QKCQkt
LSB5ZXQgbW9kaWZpZWQgdGhlbSAtPiBzZXQgY2hlY2twb2ludCBvbiBlYWNoIG9uZSBzbyB0aGF0
IAoJCS0tIGN0cmwteiB3aWxsIHVuZG8gYWxsIChvbmx5IHN1cHBvcnRzIHNpbmdsZSB1bmRvKQoJ
CWlmIChwYXNzID09IDApIG11bHRpX29wKGxpc3QsIHRydWUpCgllbmQKCQoJCglyZWZyZXNoX2d1
aSA9IHRydWUKZW5kCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIw
MjMtMDQtMTEgMDI6MDQ6NTQiLG1vZGlmaWVkPSIyMDI1LTEwLTEwIDA0OjI3OjQ5Iixwcm9nPSJi
YnM6Ly9zdHJhd2JlcnJ5X3NyYy5wNjQiLHJldmlzaW9uPTUwNDQsc3RvcmVkPSIyMDIzLTI0LTI4
IDAwOjI0OjAwIix4c3RpY2tlcnM9e31dXQotLVtbCglnZng5OiBtdWx0aS1lZGl0IHRoYXQgaGFz
IG93biBlcGhlbWVyYWwgdW5kbyBzdGFjawoJCQkobGF0ZXI6IGNvdWxkIGludmFsaWRhdGUgb25s
eSBvbmNlIGRvIGEgbm9uLW11bHRpX2VkaXQgY2hlY2twb2ludCkKXV0KCmluY2x1ZGUgImRyYXcu
bHVhIgppbmNsdWRlICJ1cGRhdGUubHVhIgppbmNsdWRlICJndWkubHVhIgppbmNsdWRlICJjYW52
YXMubHVhIgppbmNsdWRlICJwYWwubHVhIgppbmNsdWRlICJuYXYubHVhIgppbmNsdWRlICJ1bmRv
Lmx1YSIKaW5jbHVkZSAiaW1wb3J0Lmx1YSIKaW5jbHVkZSAicDgubHVhIgoKY2JtcCxjYm1wX3dp
ZHRoLGNibXBfaGVpZ2h0LGNzZWwgPSBuaWwsbmlsLG5pbAoKLS1tb2RhbF90b29sID0gICJpbXBv
cnRlciIgLS0gdGVzdAoKZnVuY3Rpb24gZGlzbWlzc19tb2RhbF90b29sKCkKCWlmIChtb2RhbF90
b29sKSB0aGVuCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJbW9kYWxfdG9vbCA9IG5pbCAKCWVuZAoJ
d2luZG93e2NhcHR1cmVfZXNjYXBlcyA9IGZhbHNlfQplbmQKLS1bWwoJc2VsZWN0aW9uIGxheWVy
IHN0YXRlIGlzIG5vdCBzYXZlZApdXQpmdW5jdGlvbiBzYXZlX3dvcmtpbmdfZmlsZSgpCgktLXBy
aW50aCgiQEAgW2dmeF0gc2F2aW5nIHdvcmtpbmcgZmlsZSIpCglsb2NhbCBvdXRwdXQgPSB7fQoJ
Zm9yIGk9MCwjaXRlbSBkbwoJCWxvY2FsIGlpPWl0ZW1baV0KCQlvdXRwdXRbaV0gPSB7CgkJCWJt
cCA9IGlpLmJtcCwKCQkJZmxhZ3MgPSBpaS5mbGFncywKCQkJcGFuX3ggPSBpaS5wYW5feCwKCQkJ
cGFuX3kgPSBpaS5wYW5feSwKCQkJem9vbSA9IGlpLnpvb20sCgkJCWV4dHJhID0gaWkuZXh0cmEK
CQl9CgllbmQKCXJldHVybiBvdXRwdXQKZW5kCgpmdW5jdGlvbiBsb2FkX3dvcmtpbmdfZmlsZShp
dGVtXzEpCgoJaXRlbV8xID0gaXRlbV8xIG9yIHt9CgoJCWl0ZW0gPSB7fQoJCWZvciBpPTAsMjU1
IGRvCgkJCXNyYyA9IGl0ZW1fMVtpXSBvciB7fQoJCQlpdGVtW2ldID0gewoJCQkJYm1wICAgPSBz
cmMuYm1wIG9yIHVzZXJkYXRhKCJ1OCIsMTYsMTYpLAoJCQkJc2VsICAgPSBzcmMuc2VsIG9yIHVz
ZXJkYXRhKCJ1OCIsMTYsMTYpLAoJCQkJZmxhZ3MgPSBzcmMuZmxhZ3Mgb3IgMCwKCQkJCWV4dHJh
ID0gc3JjLmV4dHJhIG9yIG5pbCwgLS0gdGV4dC4gbWF5YmUgIm5vdGVzIj8KCQkJCXBhbl94ID0g
c3JjLnBhbl94IG9yIDAsCgkJCQlwYW5feSA9IHNyYy5wYW5feSBvciAwLAoJCQkJem9vbSA9IHNy
Yy56b29tIG9yIDgKCQkJfQoJCQkKCQkJaWYgKGk9PTAgYW5kIG5vdCBzcmMuYm1wKSB0aGVuCgkJ
CQktLSB4CgkJCQlpdGVtW2ldLmJtcDpzZXQoNiw2LDcsMCwwLDcpCgkJCQlpdGVtW2ldLmJtcDpz
ZXQoNiw3LDAsNyw3LDApCgkJCQlpdGVtW2ldLmJtcDpzZXQoNiw4LDAsNyw3LDApCgkJCQlpdGVt
W2ldLmJtcDpzZXQoNiw5LDcsMCwwLDcpCgkJCWVuZAoJCQkKCQkJYWRkX3VuZG9fc3RhY2soaXRl
bVtpXSkKCQkJCgkJCS0tcHJpbnRoKCJsb2FkZWQgaXRlbSAiLi5pLi4iICBibXAgd2lkdGg6Ii4u
aXRlbVtpXS5ibXA6d2lkdGgoKSkKCQllbmQJCgkJCglzZXRfY3VycmVudF9pdGVtKDApCgkKZW5k
CgpmdW5jdGlvbiBfaW5pdCgpCgotLQlwb2tlKDB4NDAwMCxnZXQoZmV0Y2giL3N5c3RlbS9mb250
cy9wOC5mb250IikpCgkKCXdpbmRvd3sKCQl0YWJiZWQgPSB0cnVlLAoJCWljb24gPSB1c2VyZGF0
YSJbZ2Z4XTA4MDg3NzcwMDc3Nzc3NzAwNzc3Nzc3MDA3Nzc3Nzc3Nzc3NzcwNzc3NzA3NzA3Nzc3
MDc3Nzc3Nzc3NzAwMDAwMDAwWy9nZnhdIgoJfQoJCglta2RpcigiL3JhbS9jYXJ0L2dmeCIpCgkK
CXdyYW5nbGVfd29ya2luZ19maWxlKAoJCXNhdmVfd29ya2luZ19maWxlLAoJCWxvYWRfd29ya2lu
Z19maWxlLAoJCSIvcmFtL2NhcnQvZ2Z4LzAuZ2Z4IiwgLS0gZGVmYXVsdAoJCW5pbCxuaWwsCgkJ
ZnVuY3Rpb24oKQoJCQktLSB1bnNhdmVkIGNoYW5nZXMgKG1pZ2h0KSBleGlzdCB3aGVuIHVuZG8g
c3RhY2sgcG9zaXRpb24gY2hhbmdlcwoJCQlyZXR1cm4gY2kgYW5kIGNpLnVuZG9fc3RhY2sgYW5k
ICNjaS51bmRvX3N0YWNrLnVuZG9fc3RhY2sKCQllbmQKCSkKCQoJbWVudWl0ZW17CgkJaWQgPSAi
aW1wb3J0X3Nwcml0ZXNoZWV0IiwKCQlsYWJlbCA9ICJcXjo3NzU1NzcwMDc3NTU3NzAwIEltcG9y
dCBTcHJpdGVzaGVldCIsCgkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQltb2RhbF90b29sID0gImlt
cG9ydGVyIgoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCX0KCglzZXRfY3VycmVudF9pdGVt
KDEpCglzZXRfY3VycmVudF9iYW5rKDApCgkKCS0tIHJlZ2lvbiBvZiBzZWxlY3RlZCBzcHJpdGVz
CglyZWdpb249ewoJCXg9MSx5PTAsdz0xLGg9MSwKCQl4MD0xLHkwPTAKCX0KCQoJaXRlbTAsaXRl
bTEsaXRlbTIgPSAxLDEsMQoKCWdlbmVyYXRlX2d1aSgpCgkKCWNvbCA9IDcKCWN0b29sID0gInBl
bmNpbCIKCQoJYnJ1c2ggPSB7CgkJc3BhY2luZz0xLAoJCXRoaWNrbmVzcz0yLAoJCXdoaWNoPTMs
CgkJcGF0PTB4MAoJfQoJCglyZWZyZXNoX2d1aSA9IHRydWUKCQplbmQKCmZ1bmN0aW9uIHNldF9j
dXJyZW50X2JhbmsoaSkKCS0tcHJpbnRoKCJzZXR0aW5nIGJhbms6ICIuLmkpCgljdXJyZW50X2Jh
bmsgPSBpCmVuZAoKZnVuY3Rpb24gc2V0X25laWdoYm91cnNfdmlldyhpLCBkaSkKCWlmIChub3Qg
aSkgcmV0dXJuCglpZiAoaSA8IDAgb3IgaSA_IDI1NSkgcmV0dXJuCglsb2NhbCBiID0gaXRlbVtp
XS5ibXAKCWlmIChiIGFuZCBiOndpZHRoKCkgPT0gY2JtcF93aWR0aCBhbmQgYjpoZWlnaHQoKSA9
PSBjYm1wX2hlaWdodCkgdGhlbgoJCWl0ZW1baV0ucGFuX3ggPSBjaS5wYW5feAoJCWl0ZW1baV0u
cGFuX3kgPSBjaS5wYW5feQoJCWl0ZW1baV0uem9vbSAgPSBjaS56b29tCgkJc2V0X25laWdoYm91
cnNfdmlldyhpICsgZGksIGRpKQoJZW5kCmVuZAoKZnVuY3Rpb24gc3RvcmVfbXVsdGlfYm1wKGNy
ZWF0ZV9jaGVja3BvaW50KQoJaWYgKGNyZWF0ZV9jaGVja3BvaW50ID09IG5pbCkgY3JlYXRlX2No
ZWNrcG9pbnQgPSB0cnVlCglpZiAobm90IG11bHRpX2VkaXQpIHJldHVybiAKCWxvY2FsIGl0ZW13
ID0gaXRlbVtyZWdpb24ueSo4K3JlZ2lvbi54XS5ibXA6d2lkdGgoKQoJbG9jYWwgaXRlbWggPSBp
dGVtW3JlZ2lvbi55KjgrcmVnaW9uLnhdLmJtcDpoZWlnaHQoKQoJZm9yIHk9MCxyZWdpb24uaC0x
IGRvCgkJZm9yIHg9MCxyZWdpb24udy0xIGRvCgkJCWxvY2FsIGlpID0gaXRlbVsoeSArIHJlZ2lv
bi55KSo4ICsgKHgrIHJlZ2lvbi54KV0KCQkJaWYgKGlpKSB0aGVuCgkJCQlpaS51bmRvX3N0YWNr
OmNoZWNrcG9pbnQoKSAtLSBjYW4gcmV3aW5kIHRoZXNlIGNoYW5nZXMgcGVyIHRpbGUgaWYgbmVl
ZGVkCgkJCQlibGl0KGNibXAsaWkuYm1wLHgqaXRlbXcseSppdGVtaCwwLDApCgkJCWVuZAoJCWVu
ZAoJZW5kCmVuZAoKZnVuY3Rpb24gc2V0X2N1cnJlbnRfaXRlbShpLCBzaG93X2luX25hdmlnYXRv
cikKCgktLXN0b3JlX211bHRpX2JtcCgpIC0tIGluIGNhc2UgdGhlcmUgaXMgb25lCgoJaSA9IChp
IG9yIGN1cnJlbnRfaXRlbSlcMQoJaWYgKG5vdCBpdGVtW2ldKSByZXR1cm4gLS0gb3V0IG9mIHJh
bmdlCgkKCWlmIChjdXJyZW50X2l0ZW0pIHRoZW4KCQlzZXRfbmVpZ2hib3Vyc192aWV3KGN1cnJl
bnRfaXRlbSsxLDEpCgkJc2V0X25laWdoYm91cnNfdmlldyhjdXJyZW50X2l0ZW0tMSwtMSkKCWVu
ZAoJCgljdXJyZW50X2l0ZW0gPSBpCgljaSA9IGl0ZW1bY3VycmVudF9pdGVtXQoKCWNibXAgPSBp
dGVtW2N1cnJlbnRfaXRlbV0uYm1wCgljYm1wX3dpZHRoLCBjYm1wX2hlaWdodCA9IGNibXA6d2lk
dGgoKSwgY2JtcDpoZWlnaHQoKQoKCWlmIG5vdCBpdGVtW2N1cnJlbnRfaXRlbV0uc2VsIG9yCgkJ
aXRlbVtjdXJyZW50X2l0ZW1dLnNlbDp3aWR0aCgpIH49IGNibXBfd2lkdGggb3IKCQlpdGVtW2N1
cnJlbnRfaXRlbV0uc2VsOmhlaWdodCgpIH49IGNibXBfaGVpZ2h0Cgl0aGVuCgkJaXRlbVtjdXJy
ZW50X2l0ZW1dLnNlbCA9IHVzZXJkYXRhKCJ1OCIsY2JtcF93aWR0aCwgY2JtcF9oZWlnaHQpCgll
bmQKCQoJY3NlbCA9IGl0ZW1bY3VycmVudF9pdGVtXS5zZWwKCWNzZWxfb3V0bGluZSA9IGl0ZW1b
Y3VycmVudF9pdGVtXS5zZWxfb3V0bGluZQoJCgktLSBzaW5nbGUtaXRlbSByZWdpb24gbW92ZXMg
d2l0aCBjdXJyZW50X2l0ZW0KCWlmIChub3QgcmVnaW9uIG9yIChyZWdpb24udz09MSBhbmQgcmVn
aW9uLmg9PTEpKSB0aGVuCgkJbG9jYWwgcnggPSBjdXJyZW50X2l0ZW0gJSA4CgkJbG9jYWwgcnkg
PSBjdXJyZW50X2l0ZW0gXCA4CgkJcmVnaW9uPXt4PXJ4LHk9cnkseDA9cngseTA9cnksdz0xLGg9
MX0KCWVuZAoKCWlmIChzaG93X2luX25hdmlnYXRvcikgdGhlbgoJCWN1cnJlbnRfYmFuayA9IGN1
cnJlbnRfaXRlbSBcIDY0CgllbmQKCQoKCS0tIGVwaGVtZXJhbCBjYm1wIGFuZCBzZWxlY3Rpb24g
d2hlbiByYW5nZSBpcyBub3QgMXgxCgktLSBhbmQgaXRlbXMgaW4gcmVnaW9uIGFyZSBzYW1lIHNp
emUKCW11bHRpX2VkaXQgPSBmYWxzZQoJCglpZiAocmVnaW9uLncgPiAxIG9yIHJlZ2lvbi5oID4g
MSkgdGhlbgoJCW11bHRpX2VkaXQgPSB0cnVlCgkJbG9jYWwgaW5kZXg9Z2V0X3JlZ2lvbl9pbmRl
eGVzKHJlZ2lvbikKCQlmb3IgaT0xLCNpbmRleCBkbwoJCQlpZihpdGVtW2luZGV4W2ldXS5ibXA6
d2lkdGgoKSAgfj0gY2JtcF93aWR0aCkgIG11bHRpX2VkaXQgPSBmYWxzZQoJCQlpZihpdGVtW2lu
ZGV4W2ldXS5ibXA6aGVpZ2h0KCkgfj0gY2JtcF9oZWlnaHQpIG11bHRpX2VkaXQgPSBmYWxzZQoJ
CWVuZAoJZW5kCgkKCWlmIChtdWx0aV9lZGl0KSB0aGVuCgkJbG9jYWwgaXRlbXcgPSBjYm1wX3dp
ZHRoCgkJbG9jYWwgaXRlbWggPSBjYm1wX2hlaWdodAoJCQoJCWNibXAgPSB1c2VyZGF0YSgidTgi
LGl0ZW13ICogcmVnaW9uLncsIGl0ZW1oICogcmVnaW9uLmgpCgkJZm9yIHk9MCxyZWdpb24uaC0x
IGRvCgkJCWZvciB4PTAscmVnaW9uLnctMSBkbwoJCQkJbG9jYWwgaWkgPSBpdGVtWyh5ICsgcmVn
aW9uLnkpKjggKyAoeCsgcmVnaW9uLngpXQoJCQkJaWYgKGlpKSBibGl0KGlpLmJtcCxjYm1wLDAs
MCx4Kml0ZW13LHkqaXRlbWgpCgkJCWVuZAoJCWVuZAoJCWNibXBfd2lkdGgsIGNibXBfaGVpZ2h0
ID0gY2JtcDp3aWR0aCgpLCBjYm1wOmhlaWdodCgpCgoJCWNzZWwgPSB1c2VyZGF0YSgidTgiLGNi
bXBfd2lkdGgsIGNibXBfaGVpZ2h0KQoJCWNzZWxfb3V0bGluZSA9IG5pbAoJCQoJCW11bHRpX2l0
ZW0gPSB7CgkJCXpvb20gPSBpdGVtW2N1cnJlbnRfaXRlbV0uem9vbSoyIC8gcmVnaW9uLncsCgkJ
CWJtcCA9IGNibXAKCQl9CgkJYWRkX3VuZG9fc3RhY2sobXVsdGlfaXRlbSkKCQljaSA9IG11bHRp
X2l0ZW0KCWVuZAoJCgktLSBnZW5lcmF0ZV9ndWkoKQoJLS0gcmVmcmVzaF9ndWkgPSB0cnVlCmVu
ZAoKb25fZXZlbnQoImxvc3RfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQltYXBfZ2Z4X3N0YXRl
ID0gbWFwX2dmeF9zdGF0ZSBvciBmZXRjaCIvcmFtL3NoYXJlZC9tYXBfZ2Z4LnBvZCIgb3Ige30K
CQltYXBfZ2Z4X3N0YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4ID0gY3VycmVudF9pdGVtCgkJbWFw
X2dmeF9zdGF0ZS5yZWdpb24gPSByZWdpb24gLS0gMC4yLjBkCgkJbWFwX2dmeF9zdGF0ZS5nZnhf
cHJvY19pZCA9IHBpZCgpCgkJc3RvcmUoIi9yYW0vc2hhcmVkL21hcF9nZngucG9kIiwgbWFwX2dm
eF9zdGF0ZSkKCWVuZAopCgpvbl9ldmVudCgiZ2FpbmVkX2ZvY3VzIiwKCWZ1bmN0aW9uKCkKCQlt
YXBfZ2Z4X3N0YXRlID0gZmV0Y2giL3JhbS9zaGFyZWQvbWFwX2dmeC5wb2QiCgkJaWYgKG1hcF9n
Znhfc3RhdGUgYW5kIHB3ZigpKSB0aGVuCgkJCS0tIG9ubHkgaWYgdGhlIHNlbGVjdGVkIHNwcml0
ZSBiYW5rIG51bWJlciBtYXRjaGVzIGN1cnJlbnQgZmlsZSwgc2V0IGN1cnJlbnQgaXRlbSBhbmQg
cmVnaW9uCgoJCQlsb2NhbCBudW0gPSB0b251bShwd2YoKTpiYXNlbmFtZSgpOnN1YigxLDIpKSBv
ciB0b251bShwd2YoKTpiYXNlbmFtZSgpOnN1YigxLDEpKQoJCQlpZiAobnVtIGFuZCBudW0gPT0g
bWFwX2dmeF9zdGF0ZS5jdXJyZW50X3Nwcml0ZV9pbmRleCBcIDI1NikgdGhlbgoJCQkJc2V0X2N1
cnJlbnRfaXRlbShtYXBfZ2Z4X3N0YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4ICUgMjU2LCB0cnVl
KQoJCQkJcmVnaW9uID0gbWFwX2dmeF9zdGF0ZS5yZWdpb24gb3IgcmVnaW9uCgkJCWVuZAoJCWVu
ZAoJZW5kCikKCm9uX2V2ZW50KCJzZXRfcGFsZXR0ZSIsCglmdW5jdGlvbihtc2cpCgkJaWYgKHR5
cGUobXNnLnBhbGV0dGUpID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJbG9jYWwgdywgaCwgdHlwZSA9
IG1zZy5wYWxldHRlOmF0dHJpYnMoKQoJCQlpZiAodyA9PSA2NCBhbmQgdHlwZSA9PSAiaTMyIikg
dGhlbgoJCQkJY3VzdG9tX3BhbGV0dGUgPSBtc2cucGFsZXR0ZQoJCQllbmQKCQllbmQKCWVuZAop
CgotLVtbCgkKXV0KZnVuY3Rpb24gY29sb3VyX2ZpdChibXAsIHBhbDApCgoJbG9jYWwgY29scyA9
IHBhbDA6d2lkdGgoKQoJbG9jYWwgcGFsMSA9IHt9CgkKCWZvciBpPTAsY29scy0xIGRvCgkJbG9j
YWwgciA9IChwYWwwOmdldChpKSA_PiAxNikgJiAweGZmCgkJbG9jYWwgZyA9IChwYWwwOmdldChp
KSA_PiAgOCkgJiAweGZmCgkJbG9jYWwgYiA9IChwYWwwOmdldChpKSA_PiAgMCkgJiAweGZmCgkJ
CgkJbG9jYWwgYmVzdF9kaXN0LCBiZXN0X2NvbCA9IDEwMDAwMDAwMCwgMAoJCWZvciBpPTAsNjMg
ZG8KCQkJbG9jYWwgcjEgPSBwZWVrKDB4NTAwMCtpKjQrMikKCQkJbG9jYWwgZzEgPSBwZWVrKDB4
NTAwMCtpKjQrMSkKCQkJbG9jYWwgYjEgPSBwZWVrKDB4NTAwMCtpKjQrMCkKCQkJbG9jYWwgZGlz
dCA9IChyMS1yKV4yICsgKGcxLWcpXjIgKyAoYjEtYileMgoJCQlpZiAoZGlzdCA8IGJlc3RfZGlz
dCkgYmVzdF9jb2wgPSBpIGJlc3RfZGlzdCA9IGRpc3QKCQllbmQKCQkKCQlwYWwxW2ldID0gYmVz
dF9jb2wKCWVuZAoJCgktLSBzZXQgZHJhdyBwYWwgYW5kIGRyYXcgb24gdG8gc2VsZgoJcGFsdCgw
KSAtLSBubyB0cmFuc3BhcmVuY3kKCXBhbChwYWwxKQoJCglzZXRfZHJhd190YXJnZXQoYm1wKQoJ
c3ByKGJtcCkKCXNldF9kcmF3X3RhcmdldCgpCgkKCXJldHVybiBibXAKZW5kCgoKb25fZXZlbnQo
ImRyb3BfaXRlbXMiLGZ1bmN0aW9uKG1zZykKCgktLSBzaW5nbGUgZmlsZSBmb3Igbm93Cglsb2Nh
bCBkcm9wcGVkX2l0ZW0gPSBtc2cuaXRlbXNbMV0KCWlmIGRyb3BwZWRfaXRlbSBhbmQgZHJvcHBl
ZF9pdGVtLnBvZF90eXBlID09ICJmaWxlX3JlZmVyZW5jZSIgYW5kIAoJCXR5cGUoZHJvcHBlZF9p
dGVtLmZ1bGxwYXRoKSA9PSAic3RyaW5nIgoJCWFuZCAKCQkoZHJvcHBlZF9pdGVtLmZ1bGxwYXRo
OmV4dCgpID09ICJwbmciIG9yCgkJZHJvcHBlZF9pdGVtLmZ1bGxwYXRoOmV4dCgpID09ICJwOC5w
bmciIG9yCgkJZHJvcHBlZF9pdGVtLmZ1bGxwYXRoOmV4dCgpID09ICJwOCIpCgl0aGVuCgkJCgkJ
bG9jYWwgZyA9IGZldGNoKGRyb3BwZWRfaXRlbS5mdWxscGF0aCkKCgkJaWYgKGRyb3BwZWRfaXRl
bS5mdWxscGF0aDpleHQoKSA9PSAicDgiKSB0aGVuCgkJCWcgPSBleHRyYWN0X3A4X3Nwcml0ZXNo
ZWV0KGRyb3BwZWRfaXRlbS5mdWxscGF0aCkKCQkJaW1wb3J0X3RpbGVfdyA9IDgKCQkJaW1wb3J0
X3RpbGVfaCA9IDgKCQllbmQKCgkJaWYgKGRyb3BwZWRfaXRlbS5mdWxscGF0aDpleHQoKSA9PSAi
cDgucG5nIikgdGhlbgoJCQlnID0gZGVjb2RlX3Nwcml0ZXNoZWV0KGV4dHJhY3Rfcm9tKGZldGNo
KGRyb3BwZWRfaXRlbS5mdWxscGF0aCx7YXJnYj10cnVlfSkpKQoJCQlpbXBvcnRfdGlsZV93ID0g
OAoJCQlpbXBvcnRfdGlsZV9oID0gOAoJCWVuZAoKCQlpZiAodHlwZShnKSA9PSAidXNlcmRhdGEi
KSB0aGVuCgkJCgkJCWlmIChtb2RhbF90b29sID09ICJpbXBvcnRlciIpIHRoZW4KCQkJCWltcG9y
dF9ibXAgPSBnCgkJCQlpbXBvcnRfdGlsZV93ID0gaW1wb3J0X3RpbGVfdyBvciAxNgoJCQkJaW1w
b3J0X3RpbGVfaCA9IGltcG9ydF90aWxlX2ggb3IgMTYKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJ
CQllbHNlCgkJCQliYWNrdXBfc3RhdGUoKQoJCQkJaXRlbVtjdXJyZW50X2l0ZW1dLmJtcCA9IGcK
CQkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtKQoJCQkJY2xlYXJfc2VsZWN0aW9uKCkK
CQkJZW5kCgkJZW5kCgkJCgkJLS1bWwoJCWlmICh0eXBlKGcpID09ICJ1c2VyZGF0YSIpIHRoZW4K
CQkJCgkJCWxvY2FsIGJtcCwgcGFsMSA9IGc6Y29udmVydCgidTgiLCB0cnVlKQoJCQliYWNrdXBf
c3RhdGUoKQoJCQlpdGVtW2N1cnJlbnRfaXRlbV0uYm1wID0gY29sb3VyX2ZpdChibXAsIHBhbDEp
CgkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtKQoJCQljbGVhcl9zZWxlY3Rpb24oKQoJ
CWVuZAoJCV1dCgllbHNlCgkJbm90aWZ5KCJjb3VsZCBub3QgbG9hZCBkcm9wcGVkIGZpbGUiKQoJ
ZW5kCgkKCQplbmQpCgoKCgo6OiBuYXYubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9
IjIwMjMtMTAtMTEgMDI6MTg6NDgiLG1vZGlmaWVkPSIyMDI1LTA3LTExIDA1OjAwOjMwIixyZXZp
c2lvbj01NjExLHN0b3JlZD0iMjAyMy0yNC0yOCAwMDoyNDowMCJdXQotLVtbCgluYXZpZ2F0ZSBz
cHJpdGUgYmFuawoJKyB0b3AtbGV2ZWwgb3BlcmF0aW9ucyAocmVzaXplIGJpdG1hcCkKCSsgc2Vs
ZWN0IHJlZ2lvbgoJCgl0YWIgdG8gdG9nZ2xlIHBhbmUgKGFuZCBkb2NrL3VuZG9jayB0b29sYmFy
ISkKXV0KCmljb25zPQp7CgktLSBub3RlcwoJIltnZnhdMDgwODc3Nzc3NzAwNzc3Nzc3MDA3MDAw
MDcwMDc3Nzc3NzAwNzAwMDA3MDA3Nzc3NzcwMDA3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLAoJCgkt
LSBzY2FsZQoJIltnZnhdMDgwODcwNzA3MDcwMDAwMDAwMDA3MDAwMDA3MDAwMDAwMDAwNzc3MDAw
NzA3NzcwMDAwMDc3NzA3MDcwMDAwMDAwMDBbL2dmeF0iLAoJCgktLSB1bmxvY2ssIGxvY2sKCSJb
Z2Z4XTA4MDgwMDc3NzAwMDA3MDAwNzAwMDcwMDAwMDAwNzc3NzcwMDA3NzA3NzAwMDc3Nzc3MDAw
MDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKCSJbZ2Z4XTA4MDgwMDAwMDAwMDAwNzc3MDAwMDcwMDA3
MDAwNzc3NzcwMDA3NzA3NzAwMDc3Nzc3MDAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKCglidWNr
ZXRfY3Vyc29yPXVucG9kKCJiNjQ6YkhvMEFFOEFBQUJQQUFBQThnQndlSFVBUXlBVkZRVFFBZkFE
QVFjRkFQQXI0RUVIQWNBQlp3R2dBUWNCUndHd0FRY1JKd0hBQVFjQkFBRUhBZEFCQndFUUFkQUJJ
QUhnQVFjZ0J3SGdBU0FCOEFFQkJ3SHdBd0h3alE9PSIpLAoJCn0KCmZ1bmN0aW9uIG1ha2VfdG9n
Z2xlX2J1dHRvbihlbCkKCglsb2NhbCBlbCA9IGVsIG9yIHt9CgllbC53aWR0aCA9IGVsLndpZHRo
IG9yIDcKCWVsLmhlaWdodCA9IGVsLmhlaWdodCBvciA3CgllbC5zZXQgPSBlbC5zZXQgb3IgZnVu
Y3Rpb24oKSBlbmQKCWVsLmdldCA9IGVsLmdldCBvciBmdW5jdGlvbigpIGVuZAoJZWwuY3Vyc29y
PSJwb2ludGVyIgoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlsb2NhbCBiID0gZWwuYm1wMAoJCWlm
IChzZWxmLmdldCgpIGFuZCBlbC5ibXAxKSBiID0gZWwuYm1wMQoJCWxvY2FsIGNvbCA9IHNlbGYu
Z2V0KCkgYW5kIDcgb3IgMTMKCQlwYWwoNyxjb2wpCgkJc3ByKGIsIDAsIDApCgkJcGFsKCkKCWVu
ZAoJCglmdW5jdGlvbiBlbDpjbGljaygpCgkJZWwuc2V0KG5vdCBlbC5nZXQoKSkKCWVuZAoJCgly
ZXR1cm4gZWwKZW5kCgoKLS0gdG8gZG86IGxvY2sgYXNwZWN0IGJ1dHRvbiAKLS0gKG9ubHkgbmVl
ZCB0byBjaGFuZ2Ugd2lkdGggdG8gZ28gZnJvbSAxMng4IC0_IDI0eDE2KQpmdW5jdGlvbiByZXNp
emVfaXRlbShpbmRleCwgd2lkdGgsIGhlaWdodCkKCS0tIG5vdGU6IHVzZXJkYXRhIG9ubHkgdGFr
ZXMgbnVtYmVycyBmb3Igc2l6ZXMsIG5vdCBzdHJpbmdzICghKQoKCWlmICh3aWR0aCkgd2lkdGg9
dG9udW0od2lkdGgpCglpZiAoaGVpZ2h0KSBoZWlnaHQ9dG9udW0oaGVpZ2h0KQoJCgktLWl0ZW1b
aW5kZXhdLnVuZG9fc3RhdGU6Y2hlY2twb2ludCgpCgkKCWxvY2FsIHd3ID0gaXRlbVtpbmRleF0u
Ym1wOndpZHRoKCkKCWxvY2FsIGhoID0gaXRlbVtpbmRleF0uYm1wOmhlaWdodCgpCglsb2NhbCBh
c3BlY3QgPSB3dyAvIGhoCgoJbG9jYWwgd3cgPSB0b251bSh3aWR0aCkgb3Igd3cKCWxvY2FsIGho
ID0gdG9udW0oaGVpZ2h0KSBvciBoaAoJCglpZiAobG9ja19hc3BlY3QpIHRoZW4KCQlpZiAobm90
IHdpZHRoKSAgd2lkdGggID0gaGggKiBhc3BlY3QKCQlpZiAobm90IGhlaWdodCkgaGVpZ2h0ID0g
d3cgLyBhc3BlY3QKCWVsc2UKCQl3aWR0aCA9IHdpZHRoIG9yIHd3CgkJaGVpZ2h0ID0gaGVpZ2h0
IG9yIGhoCgllbmQKCQoJLS1wcmludGgoIndpZHRoOiIuLnRvc3RyKHdpZHRoKS4uIiAgaGVpZ2h0
OiIuLnRvc3RyKGhlaWdodCkpCgktLXByaW50aCgidHlwZSh3aWR0aCk6Ii4udHlwZSh3aWR0aCku
LiIgIHR5cGUoaGVpZ2h0KToiLi50eXBlKGhlaWdodCkpCgoJaWYgKHdpZHRoIDwgMSBvciB3aWR0
aCA_IDgxOTIgb3IKCQloZWlnaHQgPCAxIG9yIGhlaWdodCA_IDgxOTIgb3IKCQl3aWR0aCAqIGhl
aWdodCA_IDEwMjQqMTAyNCkgdGhlbgoJCS0tIHRvIGRvOiBlcnJvciAiYmFkIHNpemUiIG9yICJ0
b28gYmlnIgoJCXJldHVybgoJZW5kCgkJCglsb2NhbCBvbGQgPSBpdGVtW2luZGV4XS5ibXAKCWxv
Y2FsIG5ldyA9IHVzZXJkYXRhKCJ1OCIsIHdpZHRoLCBoZWlnaHQpCgkKCWJsaXQob2xkLCBuZXcs
IDAsMCwgCgkJbmV3OndpZHRoKClcMiAtIG9sZDp3aWR0aCgpXDIsCgkJbmV3OmhlaWdodCgpXDIg
LSBvbGQ6aGVpZ2h0KClcMgoJKQoJCglpdGVtW2luZGV4XS5ibXAgPSBuZXcKZW5kCgoKZnVuY3Rp
b24gY3JlYXRlX2l0ZW1faW5mbyhlbCkKCgllbCA9IGd1aTpuZXcoZWwpCgoJZnVuY3Rpb24gZWw6
ZHJhdygpCgkJLS1yZWN0KDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIDEzKQoJZW5k
CgkKCS0tIHByZXZpZXcgdGh1bWIKCWVsOmF0dGFjaHsKCQl4PTAseT0wLHdpZHRoPTE2LGhlaWdo
dD0xNiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCXJlY3RmaWxsKDAsMCwyMywyMywwKQoJCQls
b2NhbCBiPSBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wCgkJCXNwcihiLHNlbGYud2lkdGgvMiAtIGI6
d2lkdGgoKS8yLCBzZWxmLmhlaWdodC8yLWI6aGVpZ2h0KCkvMikKCQllbmQKCX0KCQoJbG9jYWwg
eHgwID0gMjAKCWxvY2FsIHl5ICA9IDAKCS0tIGluZGV4CgllbDphdHRhY2h7CgkJeD14eDAseT15
eSx3aWR0aD0xNSxoZWlnaHQ9NywKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGI9IGl0
ZW1bY3VycmVudF9pdGVtXS5ibXAKCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhl
aWdodC0xLDApCgkJCXByaW50KHN0cmluZy5mb3JtYXQoIlwwMTQlMDNkIixjdXJyZW50X2l0ZW0p
LDIsMSw3KQoJCWVuZAoJfQoJCglsb2NhbCB4eCA9IHh4MCArIDE4CgkKCS0tIHdpZHRoCgllbDph
dHRhY2hfZmllbGR7CgkJeD14eCx5PXl5LHdpZHRoPTE1LGhlaWdodD03LAoJCWdldD1mdW5jdGlv
bigpIHJldHVybiBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wOndpZHRoKCkgZW5kLAoJCXNldD1mdW5j
dGlvbihzZWxmLHZhbCkgCgkJCWZvciBpbmRleCBpbiBhbGwobXVsdGlfb3AoZ2V0X3JlZ2lvbl9p
bmRleGVzKHJlZ2lvbiksdHJ1ZSkpIGRvCgkJCQlyZXNpemVfaXRlbShpbmRleCwgdmFsLCBuaWwp
CgkJCWVuZAoJCQktLXJlc2l6ZV9pdGVtKGN1cnJlbnRfaXRlbSwgdmFsLCBuaWwpCgkJCXNldF9j
dXJyZW50X2l0ZW0oKSByZWZyZXNoX2d1aSA9IHRydWUgLS0gdXBkYXRlCgkJZW5kLAoJCWxhYmVs
PSIiLAoJCXByaW50X3ByZWZpeD0iXDAxNCIKCX0KCQoJLS0gdG9nZ2xlIGxvY2sKCWVsOmF0dGFj
aChtYWtlX3RvZ2dsZV9idXR0b257CgkJeD14eCsxNix5PTAsCgkJYm1wMD11c2VyZGF0YShpY29u
c1szXSksCgkJYm1wMT11c2VyZGF0YShpY29uc1s0XSksCgkJc2V0PWZ1bmN0aW9uKHZhbCkgbG9j
a19hc3BlY3QgPSB2YWwgZW5kLAoJCWdldD1mdW5jdGlvbigpIHJldHVybiBsb2NrX2FzcGVjdCBl
bmQsCgl9KQoJCgktLSBoZWlnaHQKCWVsOmF0dGFjaF9maWVsZHsKCQl4PXh4KzI0LHk9eXksd2lk
dGg9MTUsaGVpZ2h0PTcsCgkJZ2V0PWZ1bmN0aW9uKCkgcmV0dXJuIGl0ZW1bY3VycmVudF9pdGVt
XS5ibXA6aGVpZ2h0KCkgZW5kLAoJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgCgkJCWZvciBpbmRl
eCBpbiBhbGwobXVsdGlfb3AoZ2V0X3JlZ2lvbl9pbmRleGVzKHJlZ2lvbiksdHJ1ZSkpIGRvCgkJ
CQlyZXNpemVfaXRlbShpbmRleCwgbmlsLCB2YWwpCgkJCWVuZAoJCQktLXJlc2l6ZV9pdGVtKGN1
cnJlbnRfaXRlbSwgbmlsLCB2YWwpCgkJCXNldF9jdXJyZW50X2l0ZW0oKSByZWZyZXNoX2d1aSA9
IHRydWUgLS0gdXBkYXRlCgkJZW5kLAoJCWxhYmVsPSIiLAoJCXByaW50X3ByZWZpeD0iXDAxNCIK
CX0JCgkKCS0tIHNwcml0ZSBmbGFncwoJZm9yIGk9MCw3IGRvCgkJZWw6YXR0YWNoewoJCWN1cnNv
cj0icG9pbnRlciIsCgkJLS14PXh4MCtpKjcsCgkJeD04MStpKjYsCgkJeT0wLAoJCXdpZHRoPTUs
aGVpZ2h0PTksCgkJaW5kZXg9aSwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGNvbDAg
PSAxCgkJCWxvY2FsIGNvbDEgPSAxMwoJCQlpZiAoaXRlbVtjdXJyZW50X2l0ZW1dLmZsYWdzICYg
KDE8PHNlbGYuaW5kZXgpKSA_IDAgdGhlbgoJCQkJY29sMCA9IDggKyBzZWxmLmluZGV4CgkJCQlj
b2wxID0gNwoJCQllbmQKCQkJY2lyY2ZpbGwoMiwyLDIsY29sMCkKCQkJY2lyYygyLDIsMiwwKQoJ
CWVuZCwKCQkKCQljbGljayA9IGZ1bmN0aW9uKHNlbGYpCgkJCWJhY2t1cF9zdGF0ZSgpCgkJCWxv
Y2FsIGJpdCA9ICgxPDxzZWxmLmluZGV4KQoJCQlsb2NhbCBzdGF0ZTEgPSAoaXRlbVtjdXJyZW50
X2l0ZW1dLmZsYWdzICYgYml0KSBeXiBiaXQKCQkJCgkJCS0taXRlbVtjdXJyZW50X2l0ZW1dLmZs
YWdzIF5ePSAoMTw8c2VsZi5pbmRleCkKCQkJCgkJCWZvciBpbmRleCBpbiBhbGwobXVsdGlfb3Ao
Z2V0X3JlZ2lvbl9pbmRleGVzKHJlZ2lvbiksdHJ1ZSkpIGRvCgkJCQlpdGVtW2luZGV4XS5mbGFn
cyA9IChpdGVtW2luZGV4XS5mbGFncyAmIH5iaXQpIHwgc3RhdGUxCgkJCWVuZAoJCWVuZCwKCX0K
CWVuZAoJCgktLSBlZGl0IGV4dHJhLiBsYXRlciEKCS0tW1sKCWVsOmF0dGFjaChtYWtlX3RvZ2ds
ZV9idXR0b257CgkJeD0yMCx5PTksCgkJYm1wMD11c2VyZGF0YShpY29uc1sxXSkKCX0pCgldXQoJ
CgktLSBzdHJldGNoOyBkb24ndCBuZWVkCgktLVtbCgllbDphdHRhY2gobWFrZV90b2dnbGVfYnV0
dG9uewoJCXg9NTQseT05LAoJCWJtcDA9dXNlcmRhdGEoaWNvbnNbMl0pCgl9KQkKCV1dCgoJcmV0
dXJuIGVsCmVuZAoKCmZ1bmN0aW9uIGNyZWF0ZV9iYW5rX3RhYnMoZWwpCgoJZWwgPSBndWk6bmV3
KGVsKQoKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCS0tcmVjdCgwLDAsc2VsZi53aWR0aC0xLCBzZWxm
LmhlaWdodC0xLCAxMykKCWVuZAoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCB5X29mZnMgPSBpID09
IGN1cnJlbnRfYmFuayBhbmQgMCBvciAxCgkJbG9jYWwgdGFiID0gZWw6YXR0YWNoKHsKCQkJeD1p
KjEyLHk9eV9vZmZzLHdpZHRoPTExLGhlaWdodD1lbC5oZWlnaHQgLSB5X29mZnMsCgkJCWluZGV4
PWksCgkJCWN1cnNvcj0icG9pbnRlciIsCgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmKQoJCQkJbG9j
YWwgc2VsID0gY3VycmVudF9iYW5rID09IHNlbGYuaW5kZXgKCQkJCXJlY3RmaWxsKDAsMCxzZWxm
LndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIHNlbCBhbmQgNyBvciA2KQoJCQkJcHNldCgwLDAsNSkK
CQkJCWxpbmUoMCwxLDEsMCw1KQoJCQkJbGluZSgwLDIsMiwwLDUpCgkJCQkKCQkJCXBzZXQoc2Vs
Zi53aWR0aC0xLDAsNSkKCQkJCQoJCQkJbGluZSgwLHNlbGYuaGVpZ2h0LTEsc2VsZi53aWR0aC0x
LHNlbGYuaGVpZ2h0LTEsMTMpCgkJCQlwcmludCgiXDAxNCIuLnNlbGYuaW5kZXgsNSwxLDEzKQoJ
CQllbmQsCgkJCWNsaWNrID0gZnVuY3Rpb24oc2VsZikKCQkJCXNldF9jdXJyZW50X2Jhbmsoc2Vs
Zi5pbmRleCkKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQkJCgkJfSkKCWVuZAoJCgoJ
CglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVfbmF2KGVsKQoKCWZ1bmN0aW9uIGVsOmRy
YXcoKQoJCWNsaXAoKQoJCXJlY3RmaWxsKC0xLC0xLHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0LCAw
KQoJCQoJCWZvciB5PTAsNyBkbwoJCQlmb3IgeD0wLDcgZG8KCQkJCWxvY2FsIHNjYWxlID0gMQoJ
CQkJbG9jYWwgaWkgPSB4ICsgeSo4ICsgY3VycmVudF9iYW5rKjY0CgkJCQlsb2NhbCBibXAgPSBp
dGVtW2lpXS5ibXAKCQkJCWxvY2FsIHd3LGhoID0gYm1wOndpZHRoKCksIGJtcDpoZWlnaHQoKQoJ
CQkJLS0gdG8gZG86IHRoaXMgbWFrZXMgdmVyeSB0aGluIGJtcHMgaW52aXNpYmxlIGluIHByZXZp
ZXcKCQkJCXNjYWxlID0gMTYgLyBtYXgod3csaGgpCgkJCQlpZiAoc2NhbGUgPj0gMSkgdGhlbgoJ
CQkJCXNjYWxlID0gc2NhbGUgXCAxCgkJCQllbHNlaWYgKHNjYWxlID49IDAuNjY2KSB0aGVuCgkJ
CQkJc2NhbGUgPSAxIC0tIHVwIHRvIDI0eDI0LCBzdGlsbCBzaG93IHBpeGVsIGZvciBwaXhlbAoJ
CQkJZW5kCgkJCQljbGlwKHNlbGYuc3ggKyB4KjE2LCBzZWxmLnN5ICsgeSoxNiwgMTYsMTYpCgkJ
CQlzc3ByKGJtcCwKCQkJCQkwLDAsbmlsLG5pbCwKCQkJCQl4KjE2ICsgOCAtIHd3ICogc2NhbGUv
MiwKCQkJCQl5KjE2ICsgOCAtIGhoICogc2NhbGUvMiwKCQkJCQl3dypzY2FsZSwgaGgqc2NhbGUp
CgkJCWVuZAoJCWVuZAoJCQoJCS0tIHJlZ2lvbgoJCWxvY2FsIHh4ID0gcmVnaW9uLnggKiAxNgoJ
CWxvY2FsIHl5ID0gKHJlZ2lvbi55IC0gY3VycmVudF9iYW5rKjgpICogMTYKCQlsb2NhbCB3dyA9
IHJlZ2lvbi53ICogMTYKCQlsb2NhbCBoaCA9IHJlZ2lvbi5oICogMTYKCQljbGlwKGVsLnN4LTIs
ZWwuc3ktMixlbC53aWR0aCs0LGVsLmhlaWdodCs0KQoJCXJlY3QoeHgtMix5eS0yLCB4eCt3dysx
LCB5eStoaCsxLCAwKQoJCXJlY3QoeHgtMSx5eS0xLCB4eCt3dyswLCB5eStoaCswLCA3KQoJCQoJ
CS0tW1sKCQlpZiAoY3VycmVudF9iYW5rID09IGN1cnJlbnRfaXRlbVw2NCkgdGhlbgoJCQkKCQkJ
bG9jYWwgaWkgPSAoY3VycmVudF9pdGVtIC0gY3VycmVudF9iYW5rKjY0KQoJCQlsb2NhbCB4eCA9
IChpaSAlIDgpICogMTYKCQkJbG9jYWwgeXkgPSAoaWkgXCA4KSAqIDE2CgkKCQkJY2xpcCgpCgkJ
CQoJCQlyZWN0KHh4LTIseXktMix4eCsxNyx5eSsxNywwKQoJCQlyZWN0KHh4LTEseXktMSx4eCsx
Nix5eSsxNiw3KQoJCWVuZAoJCV1dCgkJCgllbmQKCQoKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJ
CWxvY2FsIHJ4ID0gbXNnLm14ICogOCBcIHNlbGYud2lkdGgKCQlsb2NhbCByeSA9IG1zZy5teSAq
IDggXCBzZWxmLmhlaWdodCArIChjdXJyZW50X2JhbmsqOCkKCQlsb2NhbCBpID0gcnggKyByeSAq
IDgKCQkKCQlpZiBrZXkic2hpZnQiIHRoZW4KCQkJLS0gZXh0ZW5kIHJlZ2lvbgoJCQlyeDA9bWlu
KHJ4LCByZWdpb24ueDApCgkJCXJ5MD1taW4ocnksIHJlZ2lvbi55MCkKCQkJcmVnaW9uID0gewoJ
CQkJeD1yeDAsIHk9cnkwLAoJCQkJdz1tYXgocngscmVnaW9uLngwKS1yeDArMSwKCQkJCWg9bWF4
KHJ5LHJlZ2lvbi55MCktcnkwKzEsCgkJCQl4MD1yZWdpb24ueDAsIHkwPXJlZ2lvbi55MAoJCQl9
CgkJZWxzZQkKCQkJcmVnaW9uPXsKCQkJCXg9cngsIHk9cnksIHc9MSwgaD0xLCB4MD1yZWdpb24u
eDAsIHkwPXJlZ2lvbi55MAoJCQl9CgkJZW5kCgkJCgkJc2V0X2N1cnJlbnRfaXRlbShpKQoJCS0t
cHJpbnRoKCJzZXR0aW5nIGl0ZW06ICIuLmkpCgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2sobXNn
KQoJCS0tIHJlc2V0IHJlZ2lvbiBldmVuIGlmIHNoaWZ0LWNsaWNraW5nIChwOCBiZWhhdmlvdXIp
CgkJbG9jYWwgcnggPSBtc2cubXggKiA4IFwgc2VsZi53aWR0aAoJCWxvY2FsIHJ5ID0gbXNnLm15
ICogOCBcIHNlbGYuaGVpZ2h0ICsgKGN1cnJlbnRfYmFuayo4KQoJCXJlZ2lvbj17CXg9cngsIHk9
cnksIHc9MSwgaD0xLCB4MD1yeCwgeTA9cnkgfQoJCWRpc21pc3NfbW9kYWxfdG9vbCgpCgllbmQK
CQoJcmV0dXJuIGVsCmVuZAoKCjo6IHA4Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVk
PSIyMDI1LTA3LTI2IDA5OjQ3OjUxIixtb2RpZmllZD0iMjAyNS0wNy0yNiAwOTo0Nzo1MSIscmV2
aXNpb249MF1dCgpmdW5jdGlvbiBleHRyYWN0X3A4X3Nwcml0ZXNoZWV0KGZuKQoJbG9jYWwgc3Ry
ID0gZmV0Y2goZm4pCglpZiAodHlwZShzdHIpIH49ICJzdHJpbmciKSByZXR1cm4KCWxvY2FsIGxp
bmVzID0gc3BsaXQoc3RyLCJcbiIsZmFsc2UpCglpZiAobGluZXNbMV0gfj0gInBpY28tOCBjYXJ0
cmlkZ2UgLy8gaHR0cDovL3d3dy5waWNvLTguY29tIikgcmV0dXJuIG5pbAoJZm9yIGk9MSwjbGlu
ZXMtMSBkbwoJCWlmIChsaW5lc1tpXSA9PSAiX19nZnhfXyIpIHRoZW4KCQkJbG9jYWwgYm1wID0g
dXNlcmRhdGEoInU4IiwxMjgsMTI4KQoJCQlsb2NhbCByb3cgPSAwCgkJCWZvciBqPWkrMSwjbGlu
ZXMgZG8KCQkJCWxvY2FsIGRhdCA9IGxpbmVzW2pdCgkJCQlmb3IgeD0wLDEyNyBkbwoJCQkJCWJt
cDpzZXQoeCxyb3csdG9udW0oIjB4Ii4uKGRhdFt4KzFdIG9yIDApKSkKCQkJCWVuZAoJCQkJcm93
ICs9IDEKCQkJZW5kCgkJCXJldHVybiBibXAKCQllbmQKCWVuZAoJcmV0dXJuIG5pbAplbmQKCgpm
dW5jdGlvbiBleHRyYWN0X3JvbSh1ZCkKCglsb2NhbCBkOCA9IHVkOmNvcHkoKQoJZDg6bXV0YXRl
KCJ1OCIpCgkKCWxvY2FsIG91dCA9IHVzZXJkYXRhKCJ1OCIsIDB4ODAyMCkKCQoJLS0gdG8gZG86
IGNvdWxkIGJlIGZhc3RlciB3aXRoIGZhbmN5IHVzZXJkYXRhIG9wcwoJZm9yIGk9MCwgMHg4MDFm
IGRvCgkJb3V0W2ldID0KCQkJKChkOFtpKjQrMF0gJiAweDMpIDw8IDApIHwKCQkJKChkOFtpKjQr
MV0gJiAweDMpIDw8IDIpIHwKCQkJKChkOFtpKjQrMl0gJiAweDMpIDw8IDQpIHwKCQkJKChkOFtp
KjQrM10gJiAweDMpIDw8IDYpCgllbmQKCglyZXR1cm4gb3V0CgplbmQKCmZ1bmN0aW9uIGRlY29k
ZV9zcHJpdGVzaGVldChyb20pCglsb2NhbCBvdXQgPSB1c2VyZGF0YSgidTgiLDEyOCwxMjgpCglm
b3IgaT0wLDE2MzgzIGRvCgkJb3V0W2ldID0gKHJvbVtpXDJdID4_ICgoaSUyKSo0KSkmMHhmCgll
bmQKCXJldHVybiBvdXQKZW5kCjo6IHBhbC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRl
ZD0iMjAyMy0wNS0xMSAwMjowNTowMSIsbW9kaWZpZWQ9IjIwMjUtMDctMDggMDI6NDc6MTMiLHJl
dmlzaW9uPTI2NjAsc3RvcmVkPSIyMDIzLTExLTI4IDAzOjExOjE5Il1dCmxvY2FsIHBjb2xzID0g
e1swXT0KCTAsMTksMywyNywgIDExLDI2LDEwLDIzLAoJMSwxNywxMiwyOCwgMTgsMTYsMTMsMjks
CgkyLDMwLDE0LDMxLCAyNCw4LDI1LDksCgkyMCw0LDIxLDE1LCA1LDIyLDYsNywKfQoKcGNvbHNf
Y29udGludW91cyA9IHtbMF0gPQoJMCwyMCw0LDMxLDE1LDgsMjQsMiwKCTIxLDUsMjIsNiw3LDIz
LDE0LDMwLAoJMSwxNiwxNywxMiwyOCwyOSwxMywxOCwKCTE5LDMsMjcsMTEsMjYsMTAsOSwyNSwK
fQoKcGNvbHNfaWRlbnRpdHkgPSB7WzBdID0KCTAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIs
MTMsMTQsMTUsCgkxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwz
MQp9CgpmdW5jdGlvbiBzd2l0Y2hfY29sKGRpbmRleCkKCWlmIChwYWxfc3dhdGNoPT0xKSBkaW5k
ZXgqPTIKCWxvY2FsIGluZGV4ID0gLTEKCWZvciBpPTAsNjMgZG8KCQlpZiAocGNvbHNbaV0gPT0g
Y29sKSBpbmRleCA9IGkKCWVuZAoJaWYgKGluZGV4Pj0wKSBjb2wgPSBwY29sc1soaW5kZXgrZGlu
ZGV4KSU2NF0KZW5kCgpmdW5jdGlvbiBjcmVhdGVfcGFsX3ByZXZpZXcoZWwpCgllbCA9IGd1aTpu
ZXcoZWwpCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsMTYsOCwwKQoJCXJlY3Rm
aWxsKDEsMSwxNSw3LGNvbCkKCQlwcmludCgiXDAxNCIuLmNvbCwyMCwyLDYpCgllbmQKCXJldHVy
biBlbAplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9wYWxfdGFicyhlbCkKCgllbCA9IGd1aTpuZXcoZWwp
CgoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJLS1yZWN0KDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVp
Z2h0LTEsIDEzKQoJZW5kCgkKCWxvY2FsIHN3YXRjaF9uYW1lPXtbMF09Il4iLCJeIn0KCQoJZm9y
IGk9MCwxIGRvCgkJbG9jYWwgeV9vZmZzID0gaSA9PSBwYWxfc3dhdGNoIGFuZCAwIG9yIDEKCQls
b2NhbCB0YWIgPSBlbDphdHRhY2goewoJCQl4PWkqMTIseT15X29mZnMsd2lkdGg9MTEsaGVpZ2h0
PWVsLmhlaWdodCAtIHlfb2ZmcywKCQkJaW5kZXg9aSwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYp
CgkJCQlsb2NhbCBzZWwgPSBwYWxfc3dhdGNoID09IHNlbGYuaW5kZXgKCQkJCXJlY3RmaWxsKDAs
MCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIHNlbCBhbmQgNiBvciAxMykKCQkJCXBzZXQo
MCwwLDUpCgkJCQlsaW5lKDAsMSwxLDAsNSkKCQkJCWxpbmUoMCwyLDIsMCw1KQoJCQkJCgkJCQlw
c2V0KHNlbGYud2lkdGgtMSwwLDUpCgkJCQkKCQkJCWxpbmUoMCxzZWxmLmhlaWdodC0xLHNlbGYu
d2lkdGgtMSxzZWxmLmhlaWdodC0xLDEzKQoJCQkJcHJpbnQoc3dhdGNoX25hbWVbc2VsZi5pbmRl
eF0sNSwxLDUpCgkJCQkKCQkJZW5kLAoJCQkKCQkJY2xpY2sgPSBmdW5jdGlvbihzZWxmKQoJCQkJ
cGFsX3N3YXRjaCA9IHNlbGYuaW5kZXgKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQkJ
CgkJfSkKCWVuZAoJCgoJCglyZXR1cm4gZWwKZW5kCgoKCi0tZm9yIGk9MCw2MyBkbyBwY29sc1tp
XT1pIGVuZAoKLS1bWwpwY29sc1syMl0scGNvbHNbMjFdPXBjb2xzWzIxXSxwY29sc1syMl0KcGNv
bHNbMTZdLHBjb2xzWzE3XSxwY29sc1sxOF0gPSBwY29sc1sxOF0sIHBjb2xzWzE2XSxwY29sc1sx
N10KXV0KCnBhbF9zd2F0Y2ggPSAxCgpmdW5jdGlvbiBjcmVhdGVfcGFsZXR0ZShlbCkKCgktLSBp
ZGVudGl0eQoJZm9yIGk9MCw2MyBkbyBwY29sc1tpXSA9IGkgZW5kCgkKCWlmIHBhbF9zd2F0Y2gg
PT0gMSB0aGVuCgkJZm9yIGk9MCw2MyBkbyAKCQkJcGNvbHNbaV0gPSBwY29sc19jb250aW51b3Vz
W2lcMl0gb3IgMCAKCQllbmQKCWVuZAoJCgktLSB0byBkbzogYWRhcHRpdmUKCWxvY2FsIGVwciA9
IDE2Cglsb2NhbCB3dyA9IGVsLndpZHRoIC8gZXByCglsb2NhbCBoaCA9IGVsLmhlaWdodCAvIDQK
CQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJY2xpcCgpCgkJCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lk
dGgsIHNlbGYuaGVpZ2h0LCAwKQoJCXJlY3RmaWxsKC0xLC0xLHNlbGYud2lkdGgsIHNlbGYuaGVp
Z2h0LCAwKQoJCQoJCWZvciB5PTAsNjRcZXByLTEgZG8KCQkJZm9yIHg9ZXByLTEsMCwtMSBkbwoJ
CQkJcmVjdGZpbGwoeCAqIHd3LCB5ICogaGgsIHggKiB3dyArIHd3LTEsIHkgKiBoaCArIGhoLTEs
IAoJCQkJcGNvbHNbeCArIHkqZXByXSkKCQkJCWlmIChwY29sc1t4ICsgeSplcHJdID09IGNvbCkg
dGhlbgoJCQkJCWxvY2FsIHh4ID0geCAqIHd3CgkJCQkJbG9jYWwgeXkgPSB5ICogaGgKCQkJCQlp
ZiAocGFsX3N3YXRjaCA9PSAwIG9yIHglMiA9PSAwKSB0aGVuCgkJCQkJCXJlY3QoeHgrMCx5eSsw
LHh4K3d3KigxK3BhbF9zd2F0Y2gpLTEseXkraGgtMSw3KQoJCQkJCQlyZWN0KHh4KzEseXkrMSx4
eCt3dyooMStwYWxfc3dhdGNoKS0yLHl5K2hoLTIsMCkKCQkJCQllbmQKCQkJCWVuZAoJCQllbmQK
CQllbmQKCQkKCQkKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlsb2NhbCB4eCA9IG1z
Zy5teCBcIHd3CgkJbG9jYWwgeXkgPSBtc2cubXkgXCBoaAoJCWNvbCA9IHBjb2xzW3h4ICsgeXkg
KiBlcHJdIG9yIDAKCWVuZAoJCgkKCXJldHVybiBlbAplbmQKCgoKCgoKCgoKCjo6IHVuZG8ubHVh
Ci0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMTQgMDM6Mjk6MjciLG1vZGlm
aWVkPSIyMDI1LTA5LTA5IDAxOjA2OjMzIixyZXZpc2lvbj0zMjExLHN0b3JlZD0iMjAyMy0yNC0y
OCAwMDoyNDowMCJdXQoKLS0gZXZlcnkgY2hlY2twb2ludCBoYXMgYSBncm91cCBpZCBhdHRhY2hl
ZCB0byBpdCAocGFyYW1ldGVyIHRvIDpjaGVja3BvaW50KCkpCi0tPiBncm91cCBjYW4gYmUgaWRl
bnRpZmllZCBhcyBzdWNoCgpsb2NhbCB1bmRvX2lkID0gMQoKbG9jYWwgZ3JvdXBfb3BfaXRlbXMg
PSBuaWwKCmxvY2FsIGZ1bmN0aW9uIHVuZG9fc2F2ZV9zdGF0ZShpaSkKCS0tIGRvbid0IHN0b3Jl
IG5pbHMsIHRvIHByZXNlcnZlIG9yZGVyCglyZXR1cm4gewoJCQoJCWlpLmZsYWdzLAoJCWlpLmJt
cDpjb3B5KCksCgkJaWkuc2VsIGFuZCBpaS5zZWw6Y29weSgpLAoJCWlpLmxheWVyMCBhbmQgaWku
bGF5ZXIwOmNvcHkoKSwKCQlpaS5sYXllciBhbmQgaWkubGF5ZXI6Y29weSgpLAoJCWlpLmxheWVy
X3ggb3IgMCwKCQlpaS5sYXllcl95IG9yIDAsCgkJaWkucGFuX3gsCgkJaWkucGFuX3ksCgkJaWku
em9vbQoJfQplbmQKCmxvY2FsIGZ1bmN0aW9uIHVuZG9fbG9hZF9zdGF0ZShzLCBpaSkKCglpaS5m
bGFncyA9IHNbMV0KCWlpLmJtcCA9ICAgc1syXQoJaWkuc2VsID0gICBzWzNdIG9yIG5pbAoJaWku
bGF5ZXIwID0gc1s0XSBvciBuaWwKCWlpLmxheWVyID0gc1s1XSBvciBuaWwKCWlpLmxheWVyX3gg
PSBzWzZdCglpaS5sYXllcl95ID0gc1s3XQoJaWkucGFuX3ggPSBzWzhdCglpaS5wYW5feSA9IHNb
OV0KCWlpLnpvb20gPSBzWzEwXQoJCmVuZAoKZnVuY3Rpb24gYmFja3VwX3N0YXRlKCkKCWxvY2Fs
IHR0MCA9IHN0YXQoMSkKCQoJY2kudW5kb19zdGFjazpjaGVja3BvaW50KCkKCgkJLS0gdW5kbyBu
byBsb25nZXIgYXBwbGllcyB0byBhIGdyb3VwIG9mIGl0ZW1zCglncm91cF9vcF9pdGVtcyA9IG5p
bAoKZW5kCgoKZnVuY3Rpb24gdW5kbygpCglpZiAobXVsdGlfZWRpdCkgdGhlbgoJCS0tIHJhbmdl
CgkJbG9jYWwgcmVzID0gY2kudW5kb19zdGFjazp1bmRvKCkKCQktLSBzdG9yZSBjaGFuZ2VzIGJh
Y2sgdG8gaW5kaXZpZHVhbCBzcHJpdGVzCgkJLS0gdG8gZG86IGNvdWxkIGRvIHNvbWV0aGluZyB3
aXRoIHRoZSBpbmRpdmlkdWFsIHN0YWNrcyBoZXJlLCAKCQktLSBidXQgZWFzeSB0byBwcm9kdWNl
IHVuZXhwZWN0ZWQgYmVoYXZpb3VyIQoJCXN0b3JlX211bHRpX2JtcCgpCgkJCgllbHNlaWYgKGdy
b3VwX29wX2l0ZW1zKSB0aGVuCgkJLS0gdW5kbyBvbiBlYWNoIGl0ZW0gaW4gZ3JvdXAKCQlub3Rp
ZnkoInVuZG9pbmcgIi4uI2dyb3VwX29wX2l0ZW1zLi4iIGl0ZW1zIikKCQlmb3IgaT0xLCNncm91
cF9vcF9pdGVtcyBkbwoJCQlsb2NhbCBpaSA9IGl0ZW1bZ3JvdXBfb3BfaXRlbXNbaV1dCgkJCWlm
IChpaSkgaWkudW5kb19zdGFjazp1bmRvKCkKCQllbmQKCQktLSBjYW4gb25seSBkbyBhIHNpbmds
ZSB1bmRvIGFuZCBubyByZWRvcyBvbiBncm91cCBvcGVyYXRpb25zCgkJZ3JvdXBfb3BfaXRlbXMg
PSBuaWwKCWVsc2UKCQktLSBzaW5nbGUgdW5kbyBvbiBjdXJyZW50IGl0ZW06IGFsd2F5cyBhbGxv
dwoJCWNpLnVuZG9fc3RhY2s6dW5kbygpCgllbmQKZW5kCgpmdW5jdGlvbiByZWRvKCkKCglpZiAo
bXVsdGlfZWRpdCkgdGhlbgoJCWNpLnVuZG9fc3RhY2s6cmVkbygpCgkJc3RvcmVfbXVsdGlfYm1w
KCkKCWVsc2UKCQljaS51bmRvX3N0YWNrOnJlZG8oKQoJZW5kCgkKZW5kCgpmdW5jdGlvbiBhZGRf
dW5kb19zdGFjayhpaSkKCS0tIDAuMi4waTogdXNlIGZvcm1hdCAweDgxICh3YXMgMHgxMSkgLS0g
ZmFzdGVyIHRvIGRpZmYgYW5kIHVzZXMgbGVzcyBtZW1vcnkKCS0tIHBhdGNoIHNpemVzIG5vdCBt
dWNoIChvciBhbnkpIGxhcmdlcgoJaWkudW5kb19zdGFjayA9IGNyZWF0ZV91bmRvX3N0YWNrKHVu
ZG9fc2F2ZV9zdGF0ZSwgdW5kb19sb2FkX3N0YXRlLCAweDgxLCBpaSkKZW5kCgotLSBvcGVyYXRl
IG9uIG11bHRpcGxlIGl0ZW1zCi0tIChoYXJkIHRvIG1lcmdlIHdpdGggbG9naWMgZm9yIG9wZXJh
dGluZyBvbiByZWdpb24gLS0gaGFzIGRpZmZlcmVudCByZXF1aXJlbWVudHMpCgpmdW5jdGlvbiBt
dWx0aV9vcChpbmRleGVzLCBkb19jaGVja3BvaW50KQoJZ3JvdXBfb3BfaXRlbXMgPSB1bnBvZChw
b2QoaW5kZXhlcykpCglpZiAoZG9fY2hlY2twb2ludCkgdGhlbgoJCWZvciBpIGluIGFsbChncm91
cF9vcF9pdGVtcykgZG8KCQkJaXRlbVtpXS51bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQoJCWVuZAoJ
ZW5kCglpZiAoI2luZGV4ZXMgPT0gMSkgZ3JvdXBfb3BfaXRlbXMgPSBuaWwgLS0gbm90IGEgZ3Jv
dXAgb3AKCXJldHVybiBpbmRleGVzCmVuZAoKCjo6IHVwZGF0ZS5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMCAwNzo0NToyNiIsbW9kaWZpZWQ9IjIwMjUtMTAtMTUg
MjE6MDQ6MjgiLHJldmlzaW9uPTQ4NDksc3RvcmVkPSIyMDIzLTI0LTI4IDAwOjI0OjAwIl1dCgkK
CWZ1bmN0aW9uIGdldF9zZWxlY3RlZF9yZWN0KCkKCQlsb2NhbCB4MCx5MCA9IDEwMDAwLCAxMDAw
MAoJCWxvY2FsIHgxLHkxID0gMCwwCgkJbG9jYWwgdWQ9dXNlcmRhdGEoInU4IixjYm1wX3dpZHRo
LDEpCgoJCWZvciB5ID0gMCwgY2JtcF9oZWlnaHQtMSBkbwoJCQktLSBmYXN0IHRlc3QgZm9yIG5v
bi1lbXB0eSByb3cKCQkJYmxpdChjc2VsLHVkLDAseSwwLDAsY2JtcF93aWR0aCwxKQoJCQl1ZDpi
b3IodWQsdHJ1ZSwgMCwwLDEsIDEsMCxjYm1wX3dpZHRoKQoJCQlpZiAodWRbMF0_MCkgdGhlbgoJ
CQkJZm9yIHggPSAwLCBjYm1wX3dpZHRoLTEgZG8KCQkJCQlpZiAoZ2V0KGNzZWwsIHgsIHkpID4g
MCkgdGhlbgoJCQkJCQl4MCA9IG1pbih4MCwgeCkgeTAgPSBtaW4oeTAsIHkpCgkJCQkJCXgxID0g
bWF4KHgxLCB4KSB5MSA9IG1heCh5MSwgeSkKCQkJCQllbmQgCgkJCQllbmQKCQkJZW5kCgkJZW5k
CgkJaWYgKHgwID09IDEwMDAwKSB4MCx5MCx4MSx5MSA9IDAsIDAsIGNibXBfd2lkdGgtMSwgY2Jt
cF9oZWlnaHQtMQoJCQotLQkJcHJpbnRoKHBvZHt4MCwgeTAsIHgxLXgwKzEsIHkxLXkwKzF9KQoJ
CXJldHVybiB4MCwgeTAsIHgxLXgwKzEsIHkxLXkwKzEKCWVuZAoJCgkKCWZ1bmN0aW9uIGNvcHlf
c2VsZWN0ZWRfcmVjdCgpCgkJbG9jYWwgeDAsIHkwLCB3dywgaGggPSBnZXRfc2VsZWN0ZWRfcmVj
dCgpCgkJbG9jYWwgb3V0ID0gdXNlcmRhdGEoInU4Iiwgd3csIGhoKQoJCS0tcHJpbnRoKHBvZHt4
MCx5MCwgd3csaGh9KQoJCWJsaXQoY2JtcCwgb3V0LCB4MCwgeTAsIDAsIDApCgkJcmV0dXJuIG91
dAoJZW5kCgkKCQoJZnVuY3Rpb24gcm90YXRlX3NlbGVjdGlvbihkeCwgZHkpCgkJbG9jYWwgeCx5
ID0gMCwgMAoJCWxvY2FsIGJtcDIgPSBjYm1wOmNvcHkoKQoJCWxvY2FsIHcsaCA9IGJtcDI6YXR0
cmlicygpCgkJc2V0X2RyYXdfdGFyZ2V0KGNibXApCgkJCgkJY2xpcCh4LHksdyxoKQoJCXJlY3Rm
aWxsKHgseSx4K3ctMSx5K2gtMSwwKQoJCWZvciB5eT0tMSwxIGRvCgkJCWZvciB4eD0tMSwxIGRv
CgkJCQlzcHIoYm1wMixkeCt4K3h4KncsZHkreSt5eSpoKQoJCQllbmQKCQllbmQKCQkJCQoJCWNs
aXAoKQoJCXNldF9kcmF3X3RhcmdldCgpCgllbmQKCQoJZnVuY3Rpb24gbW92ZV9zZWxlY3Rpb24o
ZHgsIGR5KQoJCQoJCWlmIChub3QgY2kubGF5ZXIpIHJldHVybiByb3RhdGVfc2VsZWN0aW9uKGR4
LCBkeSkKCQkKCQlibGl0KGNpLmxheWVyMCwgY2JtcCkKCQljaS5sYXllcl94ICs9IGR4CgkJY2ku
bGF5ZXJfeSArPSBkeQoJCWJsaXQoY2kubGF5ZXIsIGNibXAsIDAsIDAsIGNpLmxheWVyX3gsIGNp
LmxheWVyX3kpCgkJCgkJLS0gbmV3IHNlbGVjdGlvbgoJCWNzZWw6Y2xlYXIoKQoJCWxvY2FsIHd3
LCBoaCA9IGNpLmxheWVyOmF0dHJpYnMoKQoJCXNldF9kcmF3X3RhcmdldChjc2VsKQoJCXJlY3Rm
aWxsKGNpLmxheWVyX3gsIGNpLmxheWVyX3ksIGNpLmxheWVyX3ggKyB3dy0xLCBjaS5sYXllcl95
ICsgaGgtMSwgMSkKCQljc2VsX291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQoJCXNldF9kcmF3
X3RhcmdldCgpCgllbmQKCQoJIAoJZnVuY3Rpb24gY2xlYXJfc2VsZWN0aW9uKCkKCQlpZiAoY3Nl
bCkgY3NlbDpjbGVhcigpCgkJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZnJlc2gKCQljaS5sYXll
ciwgY2kuYmFjayA9IG5pbCwgbmlsIC0tIHdoYXQgaXMgY2kuYmFjaz8gdG8gZG86IGRlbGV0ZSBp
ZiBub3QgdXNlZAoJZW5kCgkKCWZ1bmN0aW9uIHNlbGVjdF9hbGwoKQoJCWJhY2t1cF9zdGF0ZSgp
CgkJY3NlbDpjb3B5KDEsdHJ1ZSkKCQljc2VsX291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQkK
CQlsb2NhbCB3dyxoaCA9IGNibXBfd2lkdGgsY2JtcF9oZWlnaHQKCQljaS5sYXllciA9IHVzZXJk
YXRhKCJ1OCIsd3csaGgpCgkJY2kubGF5ZXJfeCA9IDAKCQljaS5sYXllcl95ID0gMAoJCWNpLmxh
eWVyMCA9IGNibXA6Y29weSgpCgkJYmxpdChjYm1wLGNpLmxheWVyKQoJZW5kCgkKCQoJZnVuY3Rp
b24gbW9kaWZ5X3NlbGVjdGlvbihvcCkKCQoJCWJhY2t1cF9zdGF0ZSgpCgkJCgkJbG9jYWwgdGJt
cCA9IGNpLmxheWVyIG9yIGNibXAKCQlsb2NhbCBvcmlnID0gdGJtcDpjb3B5KCkKCQkKCQlpZiAo
b3AgPT0gImZsaXBfeCIpIHRoZW4KCQkJZm9yIHg9MCwgdGJtcDp3aWR0aCgpLTEgZG8KCQkJCWJs
aXQob3JpZyx0Ym1wLHgsMCx0Ym1wOndpZHRoKCktMS14LDAsMSx0Ym1wOmhlaWdodCgpKQoJCQll
bmQKCQllbmQKCQkKCQlpZiAob3AgPT0gImZsaXBfeSIpIHRoZW4KCQkJZm9yIHk9MCwgdGJtcDpo
ZWlnaHQoKS0xIGRvCgkJCQlibGl0KG9yaWcsdGJtcCwwLHksMCx0Ym1wOmhlaWdodCgpLTEteSx0
Ym1wOndpZHRoKCksMSkKCQkJZW5kCgkJZW5kCgkJCgkJaWYgKG9wID09ICJyb3RhdGUiKSB0aGVu
CgkJCS0tIHRyaWNreTogaXRlbSwgc2VjdGlvbiBuZWVkIHRvIGNoYW5nZSBkaW1lbnNpb25zCgkJ
CQoJCQl0Ym1wID0gdGJtcDp0cmFuc3Bvc2UoKQoJCQlvcmlnID0gdGJtcDpjb3B5KCkKCQkJLS0g
dmVydGljYWwgZmxpcCB0byBjb21wbGV0ZSByb3RhdGlvbgoJCQlmb3IgeT0wLCB0Ym1wOmhlaWdo
dCgpLTEgZG8KCQkJCWJsaXQob3JpZyx0Ym1wLDAseSwwLHRibXA6aGVpZ2h0KCktMS15LHRibXA6
d2lkdGgoKSwxKQoJCQllbmQKCQkJCgkJCWlmIChjaS5sYXllcikgdGhlbgoJCQkJY2kubGF5ZXIg
PSB0Ym1wCgkJCQktLSB1cGRhdGUgZmxvYXRpbmcgbGF5ZXIgLyBzZWxlY3Rpb24sIGFuZCBjZW50
ZXIKCQkJCW1vdmVfc2VsZWN0aW9uKAoJCQkJCSh0Ym1wOmhlaWdodCgpLXRibXA6d2lkdGgoKSkv
MiwKCQkJCQkodGJtcDp3aWR0aCgpLXRibXA6aGVpZ2h0KCkpLzIKCQkJCSkKCQkJZWxzZQoJCQkJ
aWYgKGNibXA6d2lkdGgoKSB_PSBjYm1wOmhlaWdodCgpKSB0aGVuCgkJCQkJLS0gbm90IHN1cHBv
cnRlZCBieSBtdWx0aV9lZGl0CgkJCQkJaXRlbVtjdXJyZW50X2l0ZW1dLmJtcCA9IHRibXAKCQkJ
CQljYm1wID0gaXRlbVtjdXJyZW50X2l0ZW1dLmJtcAoJCQkJCWNibXBfd2lkdGgsIGNibXBfaGVp
Z2h0ID0gY2JtcDp3aWR0aCgpLCBjYm1wOmhlaWdodCgpCgkJCQllbHNlCgkJCQkJYmxpdCh0Ym1w
LGNibXApCgkJCQllbmQKCQkJZW5kCgoJCWVuZAoJCQoJCQoJCS0tIGxheWVyIG9ubHkgLS0gZG9u
J3QgY2xlYXIgd2hvbGUgbWFwIHdpdGggZGVsCgkJaWYgKGNpLmxheWVyIGFuZCBvcCA9PSAiY2xl
YXIiKSB0aGVuCgkJCWNpLmxheWVyOmNsZWFyKCkKCQllbmQKCQkKCQktLSB1cGRhdGUgY2hhbmdl
cwoJCWlmIChjaS5sYXllcikgYmxpdChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwg
Y2kubGF5ZXJfeSkKCQkJCQoJCWlmIChtdWx0aV9lZGl0KSB0aGVuCgkJCXN0b3JlX211bHRpX2Jt
cCgpCgkJZWxzZQoJCQktLSBuZWVkZWQgZm9yIHJvdGF0ZTsgbWlnaHQgY2hhbmdlIHNpemUKCQkJ
c2V0X2N1cnJlbnRfaXRlbShjdXJyZW50X2l0ZW0sIHRydWUpCgkJZW5kCgkJCgllbmQKCQoJZnVu
Y3Rpb24gZ2V0X3JlZ2lvbl9pbmRleGVzKHIpCgkJbG9jYWwgb3V0PXt9CgkJZm9yIHkgPSByLnks
ci55K3IuaC0xIGRvCgkJCWZvciB4ID0gci54LHIueCtyLnctMSBkbwoJCQkJaWYgKHg_PTAgYW5k
IHg8OCBhbmQgeT49MCBhbmQgeTwzMikgdGhlbgoJCQkJCWFkZChvdXQsIHgreSo4KQoJCQkJZW5k
CgkJCWVuZAoJCWVuZAoJCXJldHVybiBvdXQKCWVuZAoKCWZ1bmN0aW9uIGdhdGhlcl9zcHJpdGVz
KHIpCgkJbG9jYWwgb3V0PXt9CgkJCgkJZm9yIGluZGV4IGluIGFsbChnZXRfcmVnaW9uX2luZGV4
ZXMocikpIGRvCgkJCWxvY2FsIGlpID0gaXRlbVtpbmRleF0KCQkJYWRkKG91dCwgewoJCQkJYm1w
ID0gaWkuYm1wLAoJCQkJZmxhZ3MgPSBpaS5mbGFncywKCQkJCXBhbl94ID0gaWkucGFuX3gsCgkJ
CQlwYW5feSA9IGlpLnBhbl95LAoJCQkJem9vbSA9IGlpLnpvb20KCQkJfSkKCQllbmQKCQkKCQly
ZXR1cm4gb3V0CgllbmQKCQoJLS0gcmV0dXJuIGEgbGlzdCBvZiBpdGVtIGluZGV4ZXMgZm9yIGl0
ZW1zIHRoYXQgd2VyZSBtb2RpZmllZAoJZnVuY3Rpb24gcGFzdGVfc3ByaXRlX2NvbGxlY3Rpb24o
ZGF0LCByZWdpb25fdywgZG9fYmlnKQoJCWxvY2FsIHh4PTAKCQlsb2NhbCB5eT0wCgkJbG9jYWwg
b3V0ID0ge30KCQlmb3IgaT0xLCNkYXQgZG8KCQkJLS0gdGFyZ2V0CgkJCWxvY2FsIHR4PXJlZ2lv
bi54ICsgeHgKCQkJbG9jYWwgdHk9cmVnaW9uLnkgKyB5eQoJCQkKCQkJaWYgKHR4Pj0wIGFuZCB0
eDw4IGFuZCB0eT49MCBhbmQgdHk8MzIpIHRoZW4KCQkJCWxvY2FsIGluZGV4PXR4K3R5KjgKCQkJ
CWxvY2FsIHNyYz1kYXRbaV0gCgkJCQlpdGVtW2luZGV4XS51bmRvX3N0YWNrOmNoZWNrcG9pbnQo
KQoJCQkJCgkJCQlpdGVtW2luZGV4XS5ibXAgPSBzcmMuYm1wIG9yIHVzZXJkYXRhKCJ1OCIsMTYs
MTYpCgkJCQlpdGVtW2luZGV4XS5mbGFncyA9IHNyYy5mbGFncyBvciAwCgkJCQlpdGVtW2luZGV4
XS5wYW5feCA9IHNyYy5wYW5feCBvciAwCgkJCQlpdGVtW2luZGV4XS5wYW5feSA9IHNyYy5wYW5f
eSBvciAwCgkJCQlpdGVtW2luZGV4XS56b29tICA9IHNyYy56b29tIG9yIDgKCQkJCWl0ZW1baW5k
ZXhdLmV4dHJhID0gc3JjLmV4dHJhCgkJCQkKCQkJCWlmIGRvX2JpZyB0aGVuCgkJCQkJbG9jYWwg
Ym1wMSA9IGl0ZW1baW5kZXhdLmJtcAoJCQkJCWxvY2FsIHcsaCA9IGJtcDE6YXR0cmlicygpCgkJ
CQkJbG9jYWwgYm1wMiA9IHVzZXJkYXRhKCJ1OCIsdyoyLGgqMikKCQkJCQlmb3IgeT0wLGgqMi0x
IGRvCgkJCQkJCWZvciB4PTAsdyoyLTEgZG8KCQkJCQkJCWJtcDI6c2V0KHgseSxnZXQoYm1wMSx4
LzIseS8yKSkKCQkJCQkJZW5kCgkJCQkJZW5kCgkJCQkJaXRlbVtpbmRleF0uYm1wID0gYm1wMgoJ
CQkJZW5kCgkJCQkKCQkJCWFkZChvdXQsaW5kZXgpCgkJCWVuZAoJCgkJCS0tIGFkdmFuY2UgcmVs
YXRpdmUgcG9zaXRpb24KCQkJeHgrPTEKCQkJaWYgKHh4ID49IHJlZ2lvbl93KSB0aGVuCgkJCQl4
eD0wIHl5Kz0xCgkJCWVuZAoJCWVuZAoJCXJldHVybiBvdXQKCWVuZAoJCgkKZnVuY3Rpb24gX3Vw
ZGF0ZSgpCgoJLS1bWwoJCS0tIHVzZSB1cGRhdGVfZ3VpX2xheW91dCBpbnN0ZWFkCgkJaWYgKGdl
dF9kaXNwbGF5KCk6aGVpZ2h0KCkgIT0gbGFzdF9kaXNwbGF5X2hlaWdodCkgcmVmcmVzaF9ndWkg
PSB0cnVlCgkJbGFzdF9kaXNwbGF5X2hlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKCV1d
CQoJCglpZiAocmVmcmVzaF9ndWkpIHRoZW4KCQlnZW5lcmF0ZV9ndWkoKQoJCXJlZnJlc2hfZ3Vp
ID0gZmFsc2UKCWVuZAoJCiAJZ3VpOnVwZGF0ZV9hbGwoKQogCXVwZGF0ZV9ndWlfbGF5b3V0KCkK
IAlzZXRfZHJhd190YXJnZXQoKQogCi0tCWlmIChtb2RhbF90b29sKSByZXR1cm4KIAlpZiAoa2V5
cCJlc2NhcGUiKSBkaXNtaXNzX21vZGFsX3Rvb2woKQogCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLQogCWlmIChndWk6Z2V0X2tleWJvYXJkX2ZvY3VzX2VsZW1lbnQo
KSkgcmV0dXJuCiAJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAJ
CiAJaWYga2V5cCgidGFiIikgdGhlbgoJCXNob3dfcGFuZSA9IG5vdCBzaG93X3BhbmUKCWVsc2Vp
ZiBrZXlwKCJlbnRlciIpIHRoZW4KCQljbGVhcl9zZWxlY3Rpb24oKQoJZW5kCgkKCWxvY2FsIG1h
ZyA9IChrZXkoImN0cmwiKSBvciBrZXkoInNoaWZ0IikpIGFuZCA4IG9yIDEKCQoJLS0gbW92ZV9z
ZWxlY3Rpb24gdXNlZCBlbHNld2hlcmUgLS0gbmVlZCB0byBkbyBiYWNrdXAgYW5kIHN0b3JlX211
bHRpX2JtcCBoZXJlCglpZiAoa2V5cCgibGVmdCIpKSAgYmFja3VwX3N0YXRlKCkgbW92ZV9zZWxl
Y3Rpb24oLW1hZywgMCkgc3RvcmVfbXVsdGlfYm1wKCkKCWlmIChrZXlwKCJyaWdodCIpKSBiYWNr
dXBfc3RhdGUoKSBtb3ZlX3NlbGVjdGlvbiggbWFnLCAwKSBzdG9yZV9tdWx0aV9ibXAoKQoJaWYg
KGtleXAoInVwIikpICAgIGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCAwLC1tYWcpIHN0
b3JlX211bHRpX2JtcCgpCglpZiAoa2V5cCgiZG93biIpKSAgYmFja3VwX3N0YXRlKCkgbW92ZV9z
ZWxlY3Rpb24oIDAsIG1hZykgc3RvcmVfbXVsdGlfYm1wKCkKCQoJaWYgKG5vdCBrZXkiY3RybCIp
IHRoZW4KCQoJCWlmIChrZXlwKCJmIikpIG1vZGlmeV9zZWxlY3Rpb24oImZsaXBfeCIpCgkJaWYg
KGtleXAoInYiKSkgbW9kaWZ5X3NlbGVjdGlvbigiZmxpcF95IikKCQlpZiAoa2V5cCgiciIpKSB0
aGVuCgkJCWlmIChtdWx0aV9lZGl0IGFuZCBjYm1wOndpZHRoKCkgfj0gY2JtcDpoZWlnaHQoKSkg
dGhlbgoJCQkJbm90aWZ5KCJjYW4gbm90IHJvdGF0ZSBhIG5vbi1zcXVhcmUgcmVnaW9uIG9mIHRp
bGVzIikKCQkJZWxzZQoJCQkJbW9kaWZ5X3NlbGVjdGlvbigicm90YXRlIikKCQkJZW5kCQkJCgkJ
ZW5kCgkJCgkJaWYgKGtleXAoImRlbCIpIG9yIGtleXAoImJhY2tzcGFjZSIpKSBtb2RpZnlfc2Vs
ZWN0aW9uKCJjbGVhciIpCgkJCgkJLS0gbmF2aWdhdGUKCQktLSB0byBkbzogcmVnaW9uIG1vdmVz
IHdpdGggdGhlc2Uga2V5cz8KCQlsb2NhbCBtYWcgPSBrZXkoInNoaWZ0IikgYW5kIDggb3IgMQoJ
CWlmIChrZXlwKCItIikpIHJlZ2lvbi53LHJlZ2lvbi5oPTEsMSBzZXRfY3VycmVudF9pdGVtKGN1
cnJlbnRfaXRlbSAtIG1hZywgdHJ1ZSkgCgkJaWYgKGtleXAoIisiKSkgcmVnaW9uLncscmVnaW9u
Lmg9MSwxIHNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtICsgbWFnLCB0cnVlKQoJCQoJCS0t
IHN3aXRjaCBjb2xvdXIKCQlpZiAoa2V5cCgiMSIpKSBzd2l0Y2hfY29sKC0xKQoJCWlmIChrZXlw
KCIyIikpIHN3aXRjaF9jb2woIDEpCgkJCgllbmQgLS0gbm8gY3RybAoJCiAJLS0gY3RybCAtLQog
CQogCWlmIChrZXkoImN0cmwiKSkgdGhlbgoJIAoJIAlpZiBrZXlwKCJjIikgb3Iga2V5cCgieCIp
IHRoZW4KCSAJCWxvY2FsIGZsYWdzID0gaXRlbVtjdXJyZW50X2l0ZW1dLmZsYWdzCgkgCQlpZiAo
ZmxhZ3MgPT0gMCkgZmxhZ3MgPSBuaWwgLS0gZG9uJ3QgbmVlZCB0byBzdG9yZSBhbnl3aGVyZQoJ
IAkJCgkgCQljb3BpZWRfc3RyID0ga2V5cCgieCIpIGFuZCAiY3V0ICIgb3IgImNvcGllZCAiCgkg
CQkKCSAJCWlmIHJlZ2lvbi53ID09IDEgYW5kIHJlZ2lvbi5oID09IDEgdGhlbgoJCSAJCXNldF9j
bGlwYm9hcmQoCgkJIAkJCXBvZChjb3B5X3NlbGVjdGVkX3JlY3QoKSwKCQkgCQkJCTcsIHtwb2Rf
dHlwZT0iZ2Z4IixmbGFncz1mbGFnc30KCQkgCQkpKQoJCSAJCWxvY2FsIF8sXyx3dyxoaCA9IGdl
dF9zZWxlY3RlZF9yZWN0KCkKCQkgCQlpZiAod3cgPT0gY2JtcF93aWR0aCBhbmQgaGggPT0gY2Jt
cF9oZWlnaHQpIHRoZW4KCQkgCQkJbm90aWZ5KGNvcGllZF9zdHIuLiJzcHJpdGUiKQoJCSAJCWVs
c2UKCQkgCQkJbm90aWZ5KGNvcGllZF9zdHIuLnd3Li4iIHggIi4uaGguLiIgcGl4ZWxzIikKCQkg
CQllbmQKCQkgCQkKCQkgCQlpZiBrZXlwKCJ4IikgdGhlbgoJCQkJCWJhY2t1cF9zdGF0ZSgpCgkJ
CQkJc2V0X2RyYXdfdGFyZ2V0KGNibXApCgkJCQkJbG9jYWwgeCx5LHcsaCA9IGdldF9zZWxlY3Rl
ZF9yZWN0KCkKCQkJCQlyZWN0ZmlsbCh4LHkseCt3LTEseStoLTEsMCkKCQkJCQlzZXRfZHJhd190
YXJnZXQoKQoJCQkJZW5kCgkJIAkJCgkgCQllbHNlCgkgCQkJLS0gbXVsdGktY29weQoJIAkJCQoJ
IAkJCWxvY2FsIGxpc3QgPSBnYXRoZXJfc3ByaXRlcyhyZWdpb24pCgkgCQkJCgkgCQkJCgkgCQkJ
c2V0X2NsaXBib2FyZCgKCSAJCQkJcG9kKGdhdGhlcl9zcHJpdGVzKHJlZ2lvbiksCgkgCQkJCQk3
LCB7cG9kX3R5cGU9ImdmeCIscmVnaW9uX3c9cmVnaW9uLnd9CgkgCQkJKSkJCgkgCQkJCgkgCQkJ
aWYgKGtleXAieCIpIHRoZW4KCQkgCQkJbXVsdGlfb3AobGlzdCkKCQkgCQkJZm9yIGk9MSwjbGlz
dCBkbwotLQkJIAkJCQlwcmludGgoIml0ZW0gIi4uaS4uIjogIi4udG9zdHIobGlzdFtpXSkpCgkJ
IAkJCQlsaXN0W2ldLmJtcDpjb3B5KDAsdHJ1ZSkKCQkgCQkJZW5kCgkJIAkJCXNldF9jdXJyZW50
X2l0ZW0oY3VycmVudF9pdGVtKQoJIAkJCWVuZAoJIAkJCQoJIAkJCW5vdGlmeShjb3BpZWRfc3Ry
Li4ocmVnaW9uLncqcmVnaW9uLmgpLi4iIHNwcml0ZXMiKQoJIAkJZW5kCgkgCQkKCQkJCgkJZW5k
CgkJCgkJaWYga2V5cCgidiIpIGFuZCBtb2RhbF90b29sID09ICJpbXBvcnRlciIgdGhlbgoJCQlw
YXN0ZV9zcHJpdGVzaGVldCgpCgkJZWxzZWlmIGtleXAoInYiKSBvciBrZXlwKCJiIikgdGhlbgoJ
CQlsb2NhbCBjdCA9IGdldF9jbGlwYm9hcmQoKQoJCQlsb2NhbCBibXAxID0gbmlsCgkJCWxvY2Fs
IG1ldGEgPSBuaWwKCQkJaWYgKHN1YihjdCwxLDUpID09ICJbZ2Z4XSIpIHRoZW4KCQkJCWJtcDEg
PSB1c2VyZGF0YShjdCkKCQkJZWxzZQoJCQkJYm1wMSwgbWV0YSA9IHVucG9kKGN0KQoJCQllbmQK
CQkJaWYgKHR5cGUoYm1wMSkgPT0gInVzZXJkYXRhIikgdGhlbgoJCQkKCQkJCS0tIHBhc3RlIGJp
ZwoJCQkJaWYgKGtleXAiYiIpIHRoZW4KCQkJCQlsb2NhbCB3LGggPSBibXAxOmF0dHJpYnMoKQoJ
CQkJCWxvY2FsIGJtcDIgPSB1c2VyZGF0YSgidTgiLHcqMixoKjIpCgkJCQkJZm9yIHk9MCxoKjIt
MSBkbwoJCQkJCQlmb3IgeD0wLHcqMi0xIGRvCgkJCQkJCQlibXAyOnNldCh4LHksZ2V0KGJtcDEs
eC8yLHkvMikpCgkJCQkJCWVuZAoJCQkJCWVuZAoJCQkJCWJtcDEgPSBibXAyCgkJCQllbmQKCQkJ
CQoJCQkJYmFja3VwX3N0YXRlKCkKCQkJCWl0ZW1bY3VycmVudF9pdGVtXS5ibXAgPSBibXAxCgkJ
CQlpdGVtW2N1cnJlbnRfaXRlbV0uZmxhZ3MgPSBtZXRhIGFuZCBtZXRhLmZsYWdzIG9yIDAKCQkJ
CXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtLCB0cnVlKQoJCQllbHNlaWYgKHR5cGUoYm1w
MSkgPT0gInRhYmxlIiBhbmQgbWV0YSBhbmQgbWV0YS5yZWdpb25fdykgdGhlbgoJCQkJLS0gbXVs
dGlwYXN0ZQoJCQkJbXVsdGlfb3AoCgkJCQkJcGFzdGVfc3ByaXRlX2NvbGxlY3Rpb24oYm1wMSwg
bWV0YS5yZWdpb25fdywga2V5cCJiIikKCQkJCSkKCQkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVu
dF9pdGVtLCB0cnVlKQoJCQkJbm90aWZ5KCJwYXN0ZWQgIi4uI2JtcDEuLiIgc3ByaXRlcyIpCgkJ
CWVsc2UKCQkJCW5vdGlmeSgiY291bGQgbm90IGZpbmQgZ2Z4IHRvIHBhc3RlIikKCQkJZW5kCgkJ
ZW5kCgkJCgkJaWYga2V5cCgieiIpIHRoZW4KCQkJdW5kbygpCgkJCWlmIG11bHRpX2VkaXQgYW5k
IG5vdCBncm91cF9vcF9pdGVtcyB0aGVuCgkJCQktLSBkb24ndCB3YW50IHRvIHNldCBjdXJyZW50
IGl0ZW0gLyB3aWxsIGNsb2JiZXIgc3RhdGUKCQkJCS0tIGp1c3QgcmV3aXJlIGNibXAgaW5zdGFk
LiBjYW4gYXNzdW1lIGlzIHNhbWUgc2l6ZQoJCQkJY2JtcCA9IGNpLmJtcCAtLSBzZXQgYnkgdW5k
byBzdGFjayBsb2FkIGZ1bmN0aW9uCgkJCQlzdG9yZV9tdWx0aV9ibXAoZmFsc2UpIC0tIG5vIGNo
ZWNrcG9pbnQhCgkJCWVsc2UKCQkJCS0tIHJlZnJlc2ggY2FudmFzZSBibXAKCQkJCS0tIChtaWdo
dCBoYXZlIGNoYW5nZWQgc2l6ZSkKCQkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtKQoJ
CQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJCWVuZAoJCWVuZAoJCQoJCWlmIGtleXAoInkiKSB0aGVu
CgkJCXJlZG8oKQoJCQlpZiBtdWx0aV9lZGl0IHRoZW4KCQkJCWNibXAgPSBjaS5ibXAgLS0gY2Fu
IGFzc3VtZSBpcyBzYW1lIHNpemU7IGRvbid0IHdhbnQgdG8gcmVmcmVzaCBndWkKCQkJCXN0b3Jl
X211bHRpX2JtcChmYWxzZSkgLS0gbm8gY2hlY2twb2ludCEKCQkJZWxzZQoJCQkJc2V0X2N1cnJl
bnRfaXRlbShjdXJyZW50X2l0ZW0pCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZW5kCgkJZW5k
CgkJCgkJaWYga2V5cCgiYSIpIHRoZW4KCQkJc2VsZWN0X2FsbCgpCgkJZW5kCgkJCgkKCWVuZCAt
LSBjdHJsCgoJaWYgKGtleXAoKSkgY2kudW5kb19zdGFjazpjaGVja3BvaW50KCkgLS0gc2hvdyB1
bnNhdmVkIGNoYW5nZXMgYXN0ZXJpc2sgaW1tZWRpYXRlbHkKCgkKIGVuZAoKCjo6IC5pbmZvLnBv
ZAotLVtbcG9kLGF1dGhvcj0ibGV4YWxvZmZsZSIsY3JlYXRlZD0iMjAyMy0xMC0xOSAxMjo1MDo1
MCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAw
MDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBkMGQwZDBkMGQw
ZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3
MGQwZDA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwZDA3MDcwZDBkMDcwNzBkMGQwZDA3MDEwMTA3MGQw
ZDBkMDcwNzBkMGQwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MDcwNzA3MDcwZDBkMGQwNzAx
MDEwNzBkMGQwZDA3MGQwNzA3MGQwNzBkMGQwZDA3MDEwMTA3MGQwZDBkMDcwNzA3MDcwNzA3MGQw
ZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQwZDBkMGQwZDBk
MGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDEwNjA2MDYw
NjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAw
MDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9
IjIwMjUtMTItMTQgMDA6NDc6MzgiLG5vdGVzPSIiLHJ1bnRpbWU9MjEsc3RvcmVkPSIyMDI0LTAz
LTIyIDExOjQzOjEyIix0aXRsZT0iUGljb3Ryb24gUGl4ZWxzIix2ZXJzaW9uPSIwLjEuMWUiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTYiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249ImRyYXcubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InVwZGF0ZS5s
dWEjMjI4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWkubHVhIzI1MyIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iY2FudmFzLmx1YSM0MjciLHdvcmtzcGFjZV9pbmRleD0x
fSx7bG9jYXRpb249Im5hdi5sdWEjMTQxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ1
bmRvLmx1YSM5MSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaW1wb3J0Lmx1YSMxNDci
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InA4Lmx1YSMxMSIsd29ya3NwYWNlX2luZGV4
PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJt
YXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfX1dXQo6OiBbZW9jXQo=
:: bios/apps/map.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBj
YW52YXMubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDQtMTEgMDI6MDQ6
MDIiLG1vZGlmaWVkPSIyMDI1LTA3LTEwIDAzOjI2OjEyIixyZXZpc2lvbj00NDYwXV0KCmxvY2Fs
IGZpbGxfY3B1PTAKCmZ1bmN0aW9uIGRvX2ZpbGxfMChibXAsIHgsIHksIHRjKQoJaWYgKGdldChi
bXAseCx5KSAhPSB0YykgcmV0dXJuCglpZiAoeCA8IDAgb3IgeSA8IDAgb3IgeCA_PSB3dyBvciB5
ID49IGhoKSByZXR1cm4KCWxvY2FsIGwscj14LHgKCXdoaWxlKGdldChibXAsbCx5KT09dGMgYW5k
IGw_PTApIGwtPTEKCWwrPTEKCXdoaWxlKGdldChibXAscix5KT09dGMgYW5kIHI8d3cpIHIrPTEK
CXItPTEKCQoJZm9yIHh4PWwsciBkbwoJCXNldChibXAseHgseSxjb2wpCQoJZW5kCgkKCWlmICh5
ID4gMCkgdGhlbgoJCWxvY2FsIGxhc3QgPSBuaWwKCQlmb3IgeHg9bCxyIGRvCgkJCWxvY2FsIHZh
bCA9IGdldChibXAseHgseS0xKSA9PSB0YwoJCQlpZiAodmFsIGFuZCBub3QgbGFzdCkgdGhlbgoJ
CQkJZG9fZmlsbF8wKGJtcCx4eCx5LTEsdGMpCgkJCWVuZAoJCQlsYXN0ID0gdmFsCgkJZW5kCgll
bmQKCQoJaWYgKHkgPCBoaC0xKSB0aGVuCgkJbG9jYWwgbGFzdCA9IG5pbAoJCWZvciB4eD1sLHIg
ZG8KCQkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4eCx5KzEpID09IHRjCgkJCWlmICh2YWwgYW5kIG5v
dCBsYXN0KSB0aGVuCgkJCQlkb19maWxsXzAoYm1wLHh4LHkrMSx0YykKCQkJZW5kCgkJCWxhc3Qg
PSB2YWwKCQllbmQKCWVuZAoJCgktLSAjcHV0YWZsaXBpbml0CgktLSB0byBkbzogd2h5IGlzIHRo
aXMgY2F1c2luZyB3bSBmbGlja2VyIHcvIGxvdyB2YWx1ZXMgKDAuMjUpIH4gaG93IGlzIHRoYXQg
cG9zc2libGU-CgktLSBvaC4uIGlzIGp1c3QgdGhlIGFwcCBndWk-IG5lZWQgdG8gbWFudWFsbHkg
aG9sZCBmcmFtZSBhZ2FpbiBhZnRlciBmbGlwLiBibGVoLgoJLS1bWwoJaWYgKHN0YXQoMSkgLSBm
aWxsX2NwdSA_IDIpIHRoZW4KCQlmaWxsX2NwdSA9IHN0YXQoMSkgZ3VpOmRyYXdfYWxsKCkgZmxp
cCgpCgkJcG9rZSgweDU0N2MsIDEpIC0tIGtlZXAgaG9sZGluZyBmcmFtZQoJZW5kCgldXQplbmQK
CmZ1bmN0aW9uIGRvX2ZpbGwoYm1wLCB4LCB5KQoJbG9jYWwgdGMgPSBnZXQoYm1wLCB4LCB5KQoJ
aWYgKGNvbCA9PSB0YykgcmV0dXJuCgl3dyxoaCA9IGJtcDp3aWR0aCgpLCBibXA6aGVpZ2h0KCkK
CWZpbGxfY3B1ID0gMAoJcmV0dXJuIGRvX2ZpbGxfMChibXAsIHgsIHksIHRjKQplbmQKCi0tIHVz
ZSBwYW4gb2YgY3VycmVudCBpdGVtCi0tIHRvIGRvOiBnbG9iYWwgcGFuL3NjYWxlIG1vZGU-Cmxv
Y2FsIG1saW5lID0gdXNlcmRhdGEoImkxNiIsIDQwOTYsIDEpCgpmdW5jdGlvbiBkcmF3X2xheWVy
KGVsLCBpaSwgcGFuX3gsIHBhbl95LCBzY2FsZSkKCglsb2NhbCBsYm1wID0gaWkuYm1wCglpZiAo
bm90IGxibXApIHJldHVybgoJaWYgKGlpLmhpZGRlbikgcmV0dXJuCgkKCWxvY2FsIHRpbGVfdyA9
IGlpLnRpbGVfdyBvciAxNgoJbG9jYWwgdGlsZV9oID0gaWkudGlsZV9oIG9yIDE2CgkKCWxvY2Fs
IHRpbGVfd3cgPSB0aWxlX3cgKiBzY2FsZQoJbG9jYWwgdGlsZV9oaCA9IHRpbGVfaCAqIHNjYWxl
CgoJLS0gcGl4ZWwgbG9va2luZyBhdCBpbiBjZW50ZXIKCWxvY2FsIHd3ID0gKGxibXA6d2lkdGgo
KSAqIHRpbGVfdykKCWxvY2FsIGhoID0gKGxibXA6aGVpZ2h0KCkgKiB0aWxlX2gpCglsb2NhbCBw
eCA9IHd3IC8yICArIHBhbl94Cglsb2NhbCBweSA9IGhoIC8yICsgcGFuX3kKCQoJbG9jYWwgeDAg
PSBlbC53aWR0aFwyICAtIHB4ICogc2NhbGUKCWxvY2FsIHkwID0gZWwuaGVpZ2h0XDIgLSBweSAq
IHNjYWxlCgkKCQkKCWxvY2FsIHgxLHkxID0geDAgKyB3dyAqIHNjYWxlLCB5MCArIGhoICogc2Nh
bGUKCQoJCgktLSB1c2UgZm9yIGRyYXdpbmcgZ3JpZCBsaW5lcwoJbG9jYWwgbWluX3ggPSBtaWQo
MCwgKDAgLSB4MCkgXCB0aWxlX3d3IC0gMSwgbGJtcDp3aWR0aCgpLTEpCglsb2NhbCBtaW5feSA9
IG1pZCgwLCAoMCAtIHkwKSBcIHRpbGVfaGggLSAxLCBsYm1wOmhlaWdodCgpLTEpCglsb2NhbCBt
YXhfeCA9IG1pZCgwLCBtaW5feCArIChlbC53aWR0aCBcIHRpbGVfd3cpICsgMiwgbGJtcDp3aWR0
aCgpLTEpCglsb2NhbCBtYXhfeSA9IG1pZCgwLCBtaW5feSArIChlbC5oZWlnaHQgXCB0aWxlX2ho
KSArIDIsIGxibXA6aGVpZ2h0KCktMSkKCgoJaWYgKHRydWUpIHRoZW4KCQoJCW1hcChsYm1wLDAs
MCx4MCx5MCxuaWwsbmlsLDAsIHRpbGVfd3csIHRpbGVfaGgpCgoJLS0gdGxpbmUKCS0tcHJpbnRo
KChtYXhfeC1taW5feCkqKG1heF95LW1pbl95KSkKCS0taWYgKChtYXhfeC1taW5feCkqKG1heF95
LW1pbl95KSA_IDIwMDApIHRoZW4KCWVsc2VpZiAoZmFsc2UpIHRoZW4gLS0gdGVzdGluZyB0bGlu
ZTNkCgkJCgkJbG9jYWwgbGFzdF9teWkgPSAtMTAwMDAKCQlmb3IgeT0wLCBlbC5oZWlnaHQtMSBk
bwoJCQktLSB3aGVyZSBpbiBtYXA-CgkJCWxvY2FsIG15ID0gKHkgLSB5MCkgLyB0aWxlX2hoCgkJ
CWlmIChteSA_PTAgYW5kIG15IDwgbGJtcDpoZWlnaHQoKSkgdGhlbgoJCQkJaWYgbGFzdF9teWkg
fj0gbXlcMSB0aGVuCgkJCQkJbGFzdF9teWkgPSBteVwxCgkJCQkJLS0gaWYgKGxhc3RfbXlpPj0w
IGFuZCBsYXN0X215aTxsYm1wOmhlaWdodCgpKSAKCQkJCQlpZiAodHJ1ZSkgLS0gc2hvdWxkIGJl
IGNsaXBwZWQhCgkJCQkJdGhlbgoJCQkJCQlibGl0KGxibXAsbWxpbmUsMCxsYXN0X215aSwwLDAs
bGJtcDp3aWR0aCgpLDEpIC0tIGNvcHkgbGluZQoJCQkJCWVuZAoJCQkJZW5kCgkJCQl0bGluZTNk
KG1saW5lLHgwLHkseDArd3cqc2NhbGUseSwgICAwLG15JTEsbGJtcDp3aWR0aCgpLG15JTEpCgkJ
CWVuZAoJCWVuZAoKCWVuZAoKCS0tIGdyaWQgbGluZXMgb24gY3VycmVudCBncmlkICh0byBkbzog
dGludGVkKQoJLS0gZG9uJ3QgZHJhdyB3aGVuIHByZXNzaW5nIHNwYWNlIGluIHRleHQgZWRpdG9y
CglpZiAoa2V5KCJzcGFjZSIpIGFuZCBpaSA9PSBjaSBhbmQgbm90IGd1aTpnZXRfa2V5Ym9hcmRf
Zm9jdXNfZWxlbWVudCgpKSB0aGVuCgkJZmlsbHAoKSBwYWwoKQoJCS0tZmlsbHAoMHhmZjAwKQoJ
CWZvciB4PW1pbl94KnRpbGVfd3csbWF4X3gqdGlsZV93dyx0aWxlX3d3IGRvCgkJCWxpbmUoeDAr
eCx5MCx4MCt4LHkxLTEsMHgwMjAxKQoJCWVuZAoJCgkJLS1maWxscCgweDY2NjYpCgkJZm9yIHk9
bWluX3kqdGlsZV9oaCxtYXhfeSp0aWxlX2hoLHRpbGVfaGggZG8KCQkJbGluZSh4MCx5MCt5LHgx
LTEseTAreSwweDAyMDEpCgkJZW5kCgkJCgkJZmlsbHAoKQoJZW5kIAoJCmVuZAoKCmZ1bmN0aW9u
IGNyZWF0ZV9vdXRsaW5lKGJtcCwgd3csIGhoKQoKCS0tcHJpbnRoKCJjcmVhdGluZyBvdXRsaW5l
OiAiLi5wb2R7d3csaGh9KQoKCWxvY2FsIG91dCA9IHVzZXJkYXRhKCJ1OCIsIHd3KzIsIGhoKzIp
IC0tIDFweCBib3VuZGFyeQoJc2V0X2RyYXdfdGFyZ2V0KG91dCkKCQoJc3NwcihibXAsIDAsIDAs
IF8sIF8sMSwgMSwgd3csIGhoKQoJCgl3dyArPSAyIGhoICs9IDIKCQoJbG9jYWwgb3V0MCA9IG91
dDpjb3B5KCkKCQoJLS1vdXQgPSBvdXQ6YWRkKG91dCwgb3V0LCBuaWwsIDIpIC0tIHdob2EhCgkt
LSBzcmNfb2Zmc2V0LCBkZXN0X29mZnNldCwgaXRlbV93aWR0aCwgc3JjX3N0cmlkZSwgZGVzdF9z
dHJpZGUsIG51bV9pdGVtcwoJb3V0OmFkZChvdXQwLCB0cnVlLCB3dysxLCB3dyswLCB3dy0xLCB3
dywgd3csIGhoLTIpCglvdXQ6YWRkKG91dDAsIHRydWUsIHd3KzEsIHd3KzIsIHd3LTEsIHd3LCB3
dywgaGgtMikKCW91dDphZGQob3V0MCwgdHJ1ZSwgd3crMSwgd3cqMCsxLCB3dy0xLCB3dywgd3cs
IGhoLTIpCglvdXQ6YWRkKG91dDAsIHRydWUsIHd3KzEsIHd3KjIrMSwgd3ctMSwgd3csIHd3LCBo
aC0yKQoJCgktLSBkaXNjbwoJZm9yIHk9MCxoaC0xIGRvCgkJb3V0OmFkZCg4KygoeVwzKSUzKSo4
LCB0cnVlLCAwLCB5Knd3LCA0LCAwLCA4LCB3dy84KzEpCgllbmQKCQoJb3V0OmFkZCg4LCB0cnVl
LCAgMCwgMCwgd3cqNCwgd3csIHd3KjgsIGhoLzgrMSkKCQoJc2V0X2RyYXdfdGFyZ2V0KCkKCXJl
dHVybiBvdXQKZW5kCgoKZnVuY3Rpb24gdWRyZWN0ZmlsbCh1ZCwgeDAsIHkwLCB4MSx5MSwgY29s
KQoJaWYgKHR5cGUodWQpIH49ICJ1c2VyZGF0YSIpIHJldHVybgoJeDBcPTEgeTBcPTEgeDFcPTEg
eTFcPTEKCWlmICh4MTx4MCl4MCx4MT14MSx4MAoJaWYgKHkxPHkwKXkwLHkxPXkxLHkwCgkKCXgw
ID0gbWF4KDAsIHgwKQoJeTAgPSBtYXgoMCwgeTApCgoJbG9jYWwgd2lkdGgsIGhlaWdodCA9ICh4
MS14MCkrMSwgKHkxLXkwKSsxCgl3aWR0aCA9IG1pbih3aWR0aCwgdWQ6d2lkdGgoKS14MCkKCWhl
aWdodCA9IG1pbihoZWlnaHQsIHVkOmhlaWdodCgpLXkwKQoJCglpZiAod2lkdGggPCAxIG9yIGhl
aWdodCA8IDEpIHJldHVybgoJCglsb2NhbCB1ZHcgPSB1ZDp3aWR0aCgpCgl1ZDpjb3B5KGNvbCwg
dHJ1ZSwgbmlsLCB4MCt5MCp1ZHcsd2lkdGgsIG5pbCx1ZHcsaGVpZ2h0KQplbmQKCgpmdW5jdGlv
biBjcmVhdGVfY2FudmFzKGVsKQoJbG9jYWwgd3csaGggPSAxNiwxNgoJbG9jYWwgY2FuX3gwLCBj
YW5feTAgPSAwLDAKCWxvY2FsIGRyYWdfeDAsZHJhZ195MCA9IDAsMAoJbG9jYWwgY2xpY2tfeCxj
bGlja195ID0gMCwwCgkKCWZ1bmN0aW9uIGVsOnVwZGF0ZShtc2cpCgkKCQllbC5jdXJzb3IgPSAi
Y3Jvc3NoYWlyIgoJCWlmIChtdG9vbCA9PSAicGFuIikgZWwuY3Vyc29yID0gImdyYWIiCgkJaWYg
KG10b29sID09ICJmaWxsIikgZWwuY3Vyc29yID0gaWNvbnMuYnVja2V0X2N1cnNvcgoKCQktLSBz
YWZldHkgW2R1cmluZyBkZXZdCgkJY2kuem9vbSA9IGl0ZW1bMV0uem9vbSBvciAxCgkJY2kucGFu
X3ggPSBpdGVtWzFdLnBhbl94IG9yIDAKCQljaS5wYW5feSA9IGl0ZW1bMV0ucGFuX3kgb3IgMAoJ
CQoJCS0tIHRlbXBvcmFyeTogc2V0IGxheWVyIHRvIHNpemUgb2Ygc3ByaXRlIDAKCQktLSAobGF0
ZXI6IGFsbG93IHBlci1sYXllciB0aWxlIHNpemUpCgkJbG9jYWwgc3ByMCA9IGdldF9zcHIoMCkK
CQlpZiAoc3ByMCkgY2kudGlsZV93LCBjaS50aWxlX2ggPSBzcHIwOndpZHRoKCksIHNwcjA6aGVp
Z2h0KCkKCQkKCgkJdGlsZV93ID0gY2kudGlsZV93CgkJdGlsZV9oID0gY2kudGlsZV9oCgkJd3cg
PSBjYm1wX3dpZHRoICAqIGNpLnpvb20gKiB0aWxlX3cKCQloaCA9IGNibXBfaGVpZ2h0ICogY2ku
em9vbSAqIHRpbGVfaAoKCQltdG9vbCA9IGN0b29sCgkJaWYgKGtleSJzcGFjZSIpIG10b29sID0g
InBhbiIKCQlpZiAoa2V5InMiKSBtdG9vbCA9IG1zZy5tYiBhbmQgbXNnLm1iID4gMSBhbmQgInBp
Y2siIG9yICJzZWxlY3QiCi0tCQlpZiAoY3Rvb2w9PSJzdGFtcCIgYW5kIG1zZy5tYj4xKSBtdG9v
bCA9ICJzZWxlY3QiIC0tIHRvIGRvOiB3b3VsZCBiZSBuaWNlCgkJCgkJLS0gcGl4ZWwgbG9va2lu
ZyBhdCBpbiBjZW50ZXIKCQlsb2NhbCBweCA9IChjYm1wX3dpZHRoICogdGlsZV93KSAvMiAgKyBj
aS5wYW5feAoJCWxvY2FsIHB5ID0gKGNibXBfaGVpZ2h0ICogdGlsZV9oKSAvMiArIGNpLnBhbl95
CgkJCgkJY2FuX3gwID0gZWwud2lkdGhcMiAgLSBweCAqIGNpLnpvb20KCQljYW5feTAgPSBlbC5o
ZWlnaHRcMiAtIHB5ICogY2kuem9vbQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCQkK
CQliYWNrdXBfc3RhdGUoKQoKCQlpZiBtdG9vbCA9PSAic2VsZWN0IiBvciBtdG9vbCA9PSAicGlj
ayIgdGhlbgoJCQktLSBuZWVkcyB0byBoYXBwZW4gZmlyc3QgZm9yIGNhbGN1bGF0aW5nIHgseQoJ
CQljbGVhcl9zZWxlY3Rpb24oKQoJCWVuZAoKCQlsb2NhbCB4ID0gKG1zZy5teCAtIGNhbl94MCkg
XCAoY2kuem9vbSAqIHRpbGVfdykKCQlsb2NhbCB5ID0gKG1zZy5teSAtIGNhbl95MCkgXCAoY2ku
em9vbSAqIHRpbGVfaCkKCQlsb2NhbCB4eCx5eSA9IHgseQoJCQoJCWNsaWNrX3gsIGNsaWNrX3kg
PSB4LHkKCQkKCQlpZiAoY2kubGF5ZXIpIHgtPSBjaS5sYXllcl94IHktPSBjaS5sYXllcl95CgoJ
CS0tIHRhcmdlIGJpdG1hcDogZHJhdyB0byBmbG9hdGluZyBsYXllciBpZiBpdCBleGlzdHMKCQls
b2NhbCB0Ym1wID0gY2kubGF5ZXIgb3IgY2JtcCAKCQlsb2NhbCB0Ym1wX3dpZHRoLCB0Ym1wX2hl
aWdodCA9IHRibXA6YXR0cmlicygpCgkJaWYgKHR5cGUodGJtcCl_PSJ1c2VyZGF0YSIpIHRibXA9
Y2JtcCBwcmludGgoIioqIG5vIHRibXAhISIpCgoJCWRyYWdfeDAgID0geCAgZHJhZ195MCAgPSB5
CgkJY2xpY2tfeDAgPSB4ICBjbGlja195MCA9IHkgCgkJY2xpY2tfeHgwID0geHggIGNsaWNrX3l5
MCA9IHl5CgkJb3BfYm1wID0gdGJtcDpjb3B5KCkKCQlibGl0KHRibXAsIG9wX2JtcCkgLS0gdG8g
ZG86IHJlbW92ZQoJCQoJCWlmIG10b29sID09ICJmaWxsIiBhbmQgbm90IGtleSJzcGFjZSIgYW5k
IG1zZy5tYiA9PSAxIHRoZW4KCQkJZG9fZmlsbCh0Ym1wLCB4LCB5KQoJCWVuZAoJCS0tW1sKCQlp
ZiAobXRvb2wgPT0gInBpY2siKSB0aGVuCgkJCS0tIDF4MSBzZWxlY3Rpb24gKGR1cGUpCgkJCQoJ
CQljaS5sYXllciA9IHVzZXJkYXRhKCJpMTYiLDEsMSkKCQkJY2kubGF5ZXJfeCA9IHh4CgkJCWNp
LmxheWVyX3kgPSB5eQoJCQljaS5sYXllcjAgPSBjYm1wOmNvcHkoKQoJCQljaS5sYXllcjA6c2V0
KHh4LHl5LDApIC0tIGN1dCBvdXQKCQkJLS0gY29weSBmcm9tIG1hcCB0byBmbG9hdGluZyBsYXll
cgoJCQlibGl0KGNibXAsY2kubGF5ZXIseHgseXksMCwwLDEsMSkKCQllbmQKCQldXQoJCS0tIHJl
cGxhY2UKCQlpZiAobXRvb2wgPT0gInBlbmNpbCIgYW5kIGtleSJjdHJsIikgdGhlbgoJCQlsb2Nh
bCBjb2wwID0gZ2V0KHRibXAsIHgseSkKCQkJZm9yIHl5PTAsdGJtcF9oZWlnaHQtMSBkbwoJCQkJ
Zm9yIHh4PTAsdGJtcF93aWR0aC0xIGRvCgkJCQkJaWYgKGdldCh0Ym1wLHh4LHl5KSA9PSBjb2ww
KSBzZXQodGJtcCx4eCx5eSxjb2wpCgkJCQllbmQKCQkJZW5kCgkJZW5kCgkJCgkJCgllbmQKCQoJ
CglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCgkJbG9jYWwgdGJtcCA9IGNpLmxheWVyIG9yIGNibXAg
CgkJCgkJLS0gc2V0X2RyYXdfdGFyZ2V0KGNibXApCgkJCgkJbG9jYWwgeCA9IChtc2cubXggLSBj
YW5feDApIFwgKGNpLnpvb20gKiB0aWxlX3cpCgkJbG9jYWwgeSA9IChtc2cubXkgLSBjYW5feTAp
IFwgKGNpLnpvb20gKiB0aWxlX2gpCgkJbG9jYWwgZHJhd190YXJnZXQgPSBjaS5ibXAKCQlsb2Nh
bCB4eCx5eSA9IHgseQoJCWlmIChjaS5sYXllcikgdGhlbgoJCQktLSBzZXRfZHJhd190YXJnZXQo
Y2kubGF5ZXIpCgkJCWRyYXdfdGFyZ2V0ID0gY2kubGF5ZXIKCQkJeC09IGNpLmxheWVyX3ggeS09
IGNpLmxheWVyX3kKCQllbmQKCQkKCQlpZiAobXRvb2wgPT0gInBhbiIgb3Iga2V5InNwYWNlIikg
dGhlbgoJCQktLWNpLnBhbl94IC09IG1zZy5keCAvIGNpLnpvb20KCQkJLS1jaS5wYW5feSAtPSBt
c2cuZHkgLyBjaS56b29tCgkJCWl0ZW1bMV0ucGFuX3ggLT0gbXNnLmR4IC8gY2kuem9vbQoJCQlp
dGVtWzFdLnBhbl95IC09IG1zZy5keSAvIGNpLnpvb20KCQkJCgkJZWxzZWlmIChtdG9vbCA9PSAi
c2VsZWN0IikgdGhlbgoJCQktLSB4eCx5eSAtLSBub3QgcmVsYXRpdmUgdG8gc2VsZWN0aW9uCgkJ
CXNldF9kcmF3X3RhcmdldChjc2VsKQoJCQlyZWN0ZmlsbCgwLDAsMTAyNCwxMDI0LDApCgkJCXJl
Y3RmaWxsKGNsaWNrX3h4MCArLjUsIGNsaWNrX3l5MCArLjUsIHh4ICsuNSwgeXkgKy41LCAxKQoJ
CQljc2VsX291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQoJCWVsc2VpZiAobXRvb2wgPT0gInBp
Y2siKSB0aGVuCgkJCS0tIDF4MSBzZWxlY3Rpb24gKGR1cGUpCgkJCQoJCQljaS5sYXllciA9IHVz
ZXJkYXRhKCJpMTYiLDEsMSkKCQkJY2kubGF5ZXJfeCA9IHh4CgkJCWNpLmxheWVyX3kgPSB5eQoJ
CQljaS5sYXllcjAgPSBjYm1wOmNvcHkoKQoJCQljaS5sYXllcjA6c2V0KHh4LHl5LDApIC0tIGN1
dCBvdXQKCQkJLS0gY29weSBmcm9tIG1hcCB0byBmbG9hdGluZyBsYXllcgoJCQlibGl0KGNibXAs
Y2kubGF5ZXIseHgseXksMCwwLDEsMSkKCQllbHNlaWYgKG1zZy5tYiA9PSAyKSB0aGVuCgkJCS0t
IGFueXRoaW5nIGFmdGVyIHRoaXM6IG1iMiBtZWFucyBwaWNrIHVwIHRpbGUKCQkJY29sID0gZ2V0
KHRibXAsIHgsIHkpCgkJCS0tIHJlZ2lvbiBvZiBzZWxlY3RlZCBzcHJpdGVzCgkJCXJlZ2lvbj17
CgkJCQl4PWNvbCU4LHk9KGNvbCUyNTYpXDgsdz0xLGg9MSwKCQkJCXgwPWNvbCU4LHkwPShjb2wl
MjU2KVw4LAoJCQkJYmFuayA9IChjb2wgXCAyNTYpICUgMzIgLS0gJTMyIHRvIGRpc2NhcmQgZmxp
cCBiaXRzCgkJCX0KCQllbHNlaWYgKG10b29sID09ICJwZW5jaWwiIG9yIG10b29sID09ICJlcmFz
ZXIiKSB0aGVuCgkJCWlmIChtc2cubWIgPT0gMSkgdGhlbgoJCQkKCQkJCS0tIHRpbGUgcmVnaW9u
IGJ5IHNuYXBwaW5nIHgseSB0byB0b3AgbGVmdCBvZiB3d3hoaCBncm91cAoJCQkJbG9jYWwgcmVn
aW9uX3cxID0gKGNvbCYweDIwMDA_MCkgYW5kIHJlZ2lvbi5oIG9yIHJlZ2lvbi53CgkJCQlsb2Nh
bCByZWdpb25faDEgPSAoY29sJjB4MjAwMD4wKSBhbmQgcmVnaW9uLncgb3IgcmVnaW9uLmgKCQkJ
CQoJCQkJeCAtPSAoeHgtY2xpY2tfeCklcmVnaW9uX3cxCgkJCQl5IC09ICh5eS1jbGlja195KSVy
ZWdpb25faDEKCQkKCQkJCWxvY2FsIGR4LCBkeSA9IHgtZHJhZ194MCwgeS1kcmFnX3kwCgkJCQls
b2NhbCBzdGVwcyA9IG1heChhYnMoZHgpLGFicyhkeSkpCgkJCQlkeCAvPSBzdGVwcyBkeSAvPSBz
dGVwcwoJCQkJbG9jYWwgeHggPSBkcmFnX3gwCgkJCQlsb2NhbCB5eSA9IGRyYWdfeTAKCQkJCQoJ
CQkJLS0gc3RlcHMgb25seSByZWxldmFudCBmb3IgMXgxIHRpbGUKCQkJCWlmIChyZWdpb24udyA_
IDEgb3IgcmVnaW9uLmggPiAxKSBzdGVwcyA9IDAgCgkJCQkKCQkJCWZvciBpPTAsc3RlcHMgZG8K
CQkJCQlmb3IgdGlsZXk9MCxyZWdpb24uaC0xIGRvCgkJCQkJCWZvciB0aWxleD0wLHJlZ2lvbi53
LTEgZG8KCQkJCQkJCWxvY2FsIHR4PXRpbGV4CgkJCQkJCQlsb2NhbCB0eT10aWxleQoJCQkJCQkJ
bG9jYWwgdHc9cmVnaW9uLncKCQkJCQkJCWxvY2FsIHRoPXJlZ2lvbi5oCgkJCQkJCQkKCQkJCQkJ
CWlmKGNvbCAmIDB4MjAwMCA_IDApIHR4LHR5LHR3LHRoPXR5LHR4LHRoLHR3CgkJCQkJCQlpZihj
b2wgJiAweDQwMDAgPiAwKSB0eD0odHctMSktdHgKCQkJCQkJCWlmKGNvbCAmIDB4ODAwMCA_IDAp
IHR5PSh0aC0xKS10eQoJCQkJCQkJLS0gMC4yLjBlIHdhcyBiYW5rICogNjQgLS0gYmFuayBtZWFu
cyBmaWxlLCBub3QgYmFua19wYWdlISA_XzwKCQkJCQkJCWxvY2FsIGNvbDEgPSByZWdpb24uYmFu
ayAqIDI1NiArIHJlZ2lvbi54ICsgcmVnaW9uLnkgKiA4CgkJCQkJCQljb2wxICs9IHRpbGV4ICsg
dGlsZXkgKiA4CgkJCQkJCQljb2wxIHw9IGNvbCAmIDB4ZTAwMCAtLSBzZXQgZmxpcCBiaXRzCgkJ
CQkJCQktLXByaW50aCgic2V0dGluZyAiLi50b3N0cihjb2wxLDEpLi4iICBmcm9tIGNvbDogIi4u
dG9zdHIoY29sLDEpKQoJCQkJCQkJc2V0KHRibXAsIHh4K3R4LCB5eSt0eSwgY29sMSkKCQkJCQkJ
ZW5kCgkJCQkJZW5kCgkJCQkJCgkJCQkJeHggKz0gZHgKCQkJCQl5eSArPSBkeQoJCQkJZW5kCgkJ
CQoJCQllbmQKCQllbHNlaWYgbXRvb2wgPT0gInJlY3QiIHRoZW4KCQkJYmxpdChvcF9ibXAsIHRi
bXApCgkJCXVkcmVjdGZpbGwodGJtcCwgY2xpY2tfeDAgKy41LCBjbGlja195MCArLjUsIHggKy41
LCB5ICsuNSwgY29sKQoJCWVsc2VpZiBtdG9vbCA9PSAic3RhbXAiIHRoZW4KCQkJaWYgKGxhc3Rf
c3RhbXBfYm1wX3N0ciB_PSBnZXRfY2xpcGJvYXJkKCkpIHRoZW4KCQkJCWxhc3Rfc3RhbXBfYm1w
X3N0ciA9IGdldF9jbGlwYm9hcmQoKQoJCQkJbGFzdF9zdGFtcF9ibXAgPSB1bnBvZChsYXN0X3N0
YW1wX2JtcF9zdHIpCgkJCWVuZAoJCQoJCQlsb2NhbCBibXAgPSBsYXN0X3N0YW1wX2JtcAoJCQlp
ZiAodHlwZShibXApID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJCWJsaXQob3BfYm1wLCB0Ym1wKQoJ
CQkJbG9jYWwgd3csaGggPSBibXA6YXR0cmlicygpCgkJCQlibGl0KGJtcCwgdGJtcCwgMCwgMCwg
eCwgeSkgLS0gdGxjIG1vcmUgY29tbW9uOyB0byBkbzogb3B0aW9uCgkJCQktLWJsaXQoYm1wLCB0
Ym1wLCAwLCAwLCB4IC0gd3cvMiArICh3dyYxKS8yLCB5IC0gaGgvMiArIChoaCYxKS8yKQoJCQkJ
CgkJCWVuZAoJCQkKCQllbHNlaWYgbXRvb2wgPT0gImxpbmUiIHRoZW4KCQkJYmxpdChvcF9ibXAs
IHRibXApCgkJCS0tbGluZShjbGlja194MCArLjUsIGNsaWNrX3kwICsuNSwgeCArLjUsIHkgKy41
LCBjb2wpIC0tIHRvIGRvIC0tIGRyYXcgbGluZSBvbiB0Ym1wCgkJZW5kCgkJCgkJZHJhZ194MCA9
IHggCgkJZHJhZ195MCA9IHkKCQkKCQktLSB1cGRhdGUgY2JtcCB3aXRoIGFueSBjaGFuZ2VzIGRy
YXduIHRvIGNpLmxheWVyCgkJaWYgKGNpLmxheWVyKSBibGl0KGNpLmxheWVyLCBjYm1wLCAwLCAw
LCBjaS5sYXllcl94LCBjaS5sYXllcl95KQoJCQoJZW5kCgoJZnVuY3Rpb24gZWw6cmVsZWFzZSht
c2cpCgkJCgkJbG9jYWwgeCA9IChtc2cubXggLSBjYW5feDApIFwgKGNpLnpvb20gKiB0aWxlX3cp
CgkJbG9jYWwgeSA9IChtc2cubXkgLSBjYW5feTApIFwgKGNpLnpvb20gKiB0aWxlX2gpCgkJCgkJ
aWYgKG10b29sID09ICJzZWxlY3QiKSB0aGVuCgkJCWlmIChjbGlja194MCA9PSB4IGFuZCBjbGlj
a195MCA9PSB5KSB0aGVuCgkJCQktLSBjYW4ndCBzZWxlY3Qgc2luZ2xlIHRpbGUgdW5sZXNzIGhv
bGQgZm9yIGEgaGFsZiBhIHNlY29uZAoJCQkJLS0gZGVzZWxlY3QKCQkJCWNsZWFyX3NlbGVjdGlv
bigpCgkJCWVsc2UKCQkJCS0tIGNyZWF0ZSBmbG9hdGluZyBsYXllcgoJCQkJaWYgKHggPCBjbGlj
a194MCkgY2xpY2tfeDAseCA9IHgsY2xpY2tfeDAKCQkJCWlmICh5IDwgY2xpY2tfeTApIGNsaWNr
X3kwLHkgPSB5LGNsaWNrX3kwCgkJCQlsb2NhbCB3dyA9IHggLSBjbGlja194MCArIDEKCQkJCWxv
Y2FsIGhoID0geSAtIGNsaWNrX3kwICsgMQoJCQkJCgkJCQljaS5sYXllciA9IHVzZXJkYXRhKCJp
MTYiLHd3LGhoKQoJCQkJY2kubGF5ZXJfeCA9IGNsaWNrX3gwCgkJCQljaS5sYXllcl95ID0gY2xp
Y2tfeTAKCQkJCQoJCQkJLS0gY29weSBvZiB0aGUgaW1hZ2UgCgkJCQljaS5sYXllcjAgPSBjYm1w
OmNvcHkoKQoJCQkJLS0gLi4gd2l0aCB0aGF0IGFyZWEgY3V0IG91dAoJCQkJdWRyZWN0ZmlsbChj
aS5sYXllcjAsIGNsaWNrX3gwLCBjbGlja195MCwgY2xpY2tfeDAgKyB3dy0xLCBjbGlja195MCAr
IGhoLTEsIDApCgoJCQkJLS0gY29weSBmcm9tIG1hcCB0byBmbG9hdGluZyBsYXllcgoJCQkJYmxp
dChjYm1wLGNpLmxheWVyLGNsaWNrX3gwLCBjbGlja195MCwwLDAsd3csaGgpCgkJCWVuZAoJCWVu
ZAkKCQljbGlja194MCwgY2xpY2tfeTAgPSBuaWwgLS0gZG9uJ3QgZHJhdyBhIHNlbGVjdGlvbiBp
biBwcm9ncmVzcwoJCQoJCWl0ZW1bY3VycmVudF9pdGVtXS51bmRvX3N0YWNrOmNoZWNrcG9pbnQo
KSAtLSBzaG93IHVuY2hhbmdlZCBjaGFuZ2VzIGFzdGVyaXNrIGltbWVkYXRlbHkKCWVuZAoJCglm
dW5jdGlvbiBlbDpkcmF3KG1zZykKCQkKCQlsb2NhbCB4ID0gKG1zZy5teCAtIGNhbl94MCkgXCAo
Y2kuem9vbSAqIHRpbGVfdykKCQlsb2NhbCB5ID0gKG1zZy5teSAtIGNhbl95MCkgXCAoY2kuem9v
bSAqIHRpbGVfaCkKCQkKCQlsb2NhbCBzY2FsZSA9IGNpLnpvb20KCQlsb2NhbCB0aWxlX3d3ID0g
dGlsZV93ICogc2NhbGUKCQlsb2NhbCB0aWxlX2hoID0gdGlsZV9oICogc2NhbGUKCQkKCQkKCQlm
aWxscCgweDkzNmMpCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMSkKCQlm
aWxscCgpCgkJcmVjdGZpbGwoY2FuX3gwLTEsY2FuX3kwLTEsY2FuX3gwK3d3LGNhbl95MCtoaCww
KQoJCXJlY3QgICAoY2FuX3gwLTIsY2FuX3kwLTIsY2FuX3gwK3d3KzEsY2FuX3kwK2hoKzEsNikK
CQkKCQktLSBkcmF3IGJvdHRvbSB0byB0b3AKCQlmb3IgaT0jaXRlbSwxLC0xIGRvCgkJCWRyYXdf
bGF5ZXIoZWwsIGl0ZW1baV0sIGl0ZW1bMV0ucGFuX3gsIGl0ZW1bMV0ucGFuX3ksIGl0ZW1bMV0u
em9vbSkKCQllbmQKCQkKCQlmaWxscCgpCgoKCQktLS0tLS0tLS0tIGRyYXcgc2VsZWN0aW9uCgoJ
CWlmIChmYWxzZSkgdGhlbgotLQkJaWYgKGNzZWwpIHRoZW4KCQkKCQkJbG9jYWwgc2VsX3NjYWxl
ID0gbWluKHNjYWxlLCAwLjUpCgoJCQl3aGlsZSBzZWxfc2NhbGUgPCBzY2FsZSBhbmQgCgkJCQlz
ZWxfc2NhbGUgKiBjYm1wOndpZHRoKCkgKiB0aWxlX3cgPCAxMjggYW5kCgkJCQlzZWxfc2NhbGUg
KiBjYm1wOmhlaWdodCgpICogdGlsZV9oIDwgMTI4IGRvCgkJCQlzZWxfc2NhbGUgKz0gMQoJCQll
bmQKCQkJbG9jYWwgc2VsX3d3ID0gY2JtcDp3aWR0aCgpICogdGlsZV93ICogc2VsX3NjYWxlCgkJ
CWxvY2FsIHNlbF9oaCA9IGNibXA6aGVpZ2h0KCkgKiB0aWxlX2ggKiBzZWxfc2NhbGUKCQkKCQkJ
LS0gdG8gZG86IGFsc28gdXBkYXRlIGhpZ2ggYml0cyBpbiBpbWFnZSB0byBwcm90ZWN0CgkJCS0t
IHBpeGVscyBvdXRzaWRlIG9mIHNlbGVjdGlvbiBmcm9tIG1vZGlmaWNhdGlvbgotLVtbCgkJCWlm
IChub3QgY3NlbF9vdXRsaW5lIG9yIHNlbF93dyB_PSBsYXN0X291dGxpbmVfd3cpIHRoZW4KCQkJ
CWNzZWxfb3V0bGluZSA9IGNyZWF0ZV9vdXRsaW5lKGNzZWwsIHNlbF93dywgc2VsX2hoKQoJCQkJ
bGFzdF9vdXRsaW5lX3d3ID0gc2VsX3d3CgkJCWVuZApdXQoJCQoJCQktLXNwcihjc2VsX291dGxp
bmUsY2FuX3gwLGNhbl95MCkKCQkJZm9yIGk9MCw2MyBkbwoJCQkJcGFsdChpLHRydWUpCgkJCWVu
ZAoJCQlwYWx0KDEsZmFsc2UpIHBhbHQoMixmYWxzZSkKCQkJCgkJCXBhbCgxLDcpIHBhbCgyLDcp
CgkJCQoJCQlsb2NhbCBjYz0odCgpKjgpJTgKCQkJcGFsKDksICA4ICsgKGNjKzApJTgpCgkJCXBh
bCgxNywgOCArIChjYysyKSU4KQoJCQlwYWwoMjUsIDggKyAoY2MrNCklOCkKCQkJcGFsKDMzLCA4
ICsgKGNjKzYpJTgpCgkJCQoJCQkKCQkJZmlsbHAoMHhjOTM2OTM2YzM2Yzk2YzkzID4_ICgoKHRp
bWUoKSoxNSlcMSklNCkqMTYpCgkJCQoJCQktLSB0byBkbzogZml4IG1hdGNoaW5nCgkJCWxvY2Fs
IHFxID0gMQoJCQlpZiAoc2VsX3NjYWxlIDwgc2NhbGUpIHFxID0gMgoJCQkKCQkJLS1xcSA9IHNj
YWxlIC8gc2VsX3NjYWxlCgkJCS0tcGFsKCkgZmlsbHAoKQoKCQkJcGFsKCkKCgkJCQotLQkJCXNz
cHIoY3NlbF9vdXRsaW5lLCAwLCAwLCBfLCBfLCBjYW5feDAtcXEsIGNhbl95MC1xcSwgd3crcXEq
MiwgaGgrcXEqMikKCQoJCWVuZAoKCQlwYWwoKQoJCWZpbGxwKDB4YzkzNjkzNmMzNmM5NmM5MyA_
PiAoKCh0aW1lKCkqMTUpXDEpJTQpKjE2KQoKCQlpZiAoY2kubGF5ZXIgYW5kIGNpLmxheWVyX3gp
IHRoZW4KCQkJbG9jYWwgc3gwID0gY2FuX3gwICsgZmxyKGNpLmxheWVyX3gpICogdGlsZV93ICog
c2NhbGUKCQkJbG9jYWwgc3kwID0gY2FuX3kwICsgZmxyKGNpLmxheWVyX3kpICogdGlsZV9oICog
c2NhbGUKCQkJbG9jYWwgc3gxID0gc3gwICsgY2kubGF5ZXI6d2lkdGgoKSAqIHRpbGVfdyAqIHNj
YWxlCgkJCWxvY2FsIHN5MSA9IHN5MCArIGNpLmxheWVyOmhlaWdodCgpICogdGlsZV9oICogc2Nh
bGUKCgkJCXJlY3Qoc3gwLTEsc3kwLTEsc3gxLHN5MSwweDA3MDEpCgoJCWVsc2VpZiAoY2xpY2tf
eDAgYW5kIG10b29sID09ICJzZWxlY3QiIGFuZCBtc2cubWIgPT0gMSkgdGhlbgoJCQoJCQktLSBz
ZWxlY3Rpb24gaW4gcHJvZ3Jlc3MKCQkJbG9jYWwgbXgwID0gY2xpY2tfeDAKCQkJbG9jYWwgbXkw
ID0gY2xpY2tfeTAKCQkJbG9jYWwgbXgxID0geAoJCQlsb2NhbCBteTEgPSB5CgkJCWlmIChteDAg
PiBteDEpIG14MCxteDEgPSBteDEsbXgwCgkJCWlmIChteTAgPiBteTEpIG15MCxteTEgPSBteTEs
bXkwCgkJCQoJCQlsb2NhbCBzeDAgPSBjYW5feDAgKyBteDAgKiB0aWxlX3cgKiBzY2FsZQoJCQls
b2NhbCBzeTAgPSBjYW5feTAgKyBteTAgKiB0aWxlX2ggKiBzY2FsZQoJCQlsb2NhbCBzeDEgPSBj
YW5feDAgKyAobXgxKzEpICogdGlsZV93ICogc2NhbGUKCQkJbG9jYWwgc3kxID0gY2FuX3kwICsg
KG15MSsxKSAqIHRpbGVfaCAqIHNjYWxlCgoJCQlyZWN0KHN4MC0xLHN5MC0xLHN4MSxzeTEsMHgw
NzAxKQoKCQllbmQKCgkJZmlsbHAoKSBwYWwoKQoJCQoJCS0tIGR1cGU6IHVwZGF0ZSBsYXN0X3N0
YW1wX2JtcF9zdHI7IG5lZWQgZm9yIGRyYXdpbmcgcHJldmlldyB3aWR0aCwgaGVpZ2h0CgkJaWYg
KG10b29sID09ICJzdGFtcCIgYW5kIGxhc3Rfc3RhbXBfYm1wX3N0ciB_PSBnZXRfY2xpcGJvYXJk
KCkpIHRoZW4KCQkJbGFzdF9zdGFtcF9ibXBfc3RyID0gZ2V0X2NsaXBib2FyZCgpCgkJCWxhc3Rf
c3RhbXBfYm1wID0gdW5wb2QobGFzdF9zdGFtcF9ibXBfc3RyKQoJCWVuZAoJCQoJCS0tIGRyYXcg
dGlsZSByZWdpb24KCQlpZiBtdG9vbCA9PSAicGVuY2lsIiBvciAobXRvb2wgPT0gInN0YW1wIiBh
bmQgbGFzdF9zdGFtcF9ibXApICB0aGVuCgkJCWxvY2FsIHd3ID0gbXRvb2wgPT0gInBlbmNpbCIg
YW5kIHJlZ2lvbi53IG9yIGxhc3Rfc3RhbXBfYm1wOndpZHRoKCkKCQkJbG9jYWwgaGggPSBtdG9v
bCA9PSAicGVuY2lsIiBhbmQgcmVnaW9uLmggb3IgbGFzdF9zdGFtcF9ibXA6aGVpZ2h0KCkKCQkJ
CgkJCWlmIChtdG9vbCA9PSAicGVuY2lsIiBhbmQgY29sJjB4MjAwMD4wKSB0aGVuCgkJCQl3dyxo
aD1oaCx3dwoJCQllbmQKCQkJCgkJCWxvY2FsIHN4MCA9IGNhbl94MCArIHggKiB0aWxlX3cgKiBz
Y2FsZQoJCQlsb2NhbCBzeTAgPSBjYW5feTAgKyB5ICogdGlsZV9oICogc2NhbGUKCQkJbG9jYWwg
c3gxID0gY2FuX3gwICsgKHgrd3cpICogdGlsZV93ICogc2NhbGUKCQkJbG9jYWwgc3kxID0gY2Fu
X3kwICsgKHkraGgpICogdGlsZV9oICogc2NhbGUKCgkJCS0tIGRyYXcgcHJldmlldyB3aGVuIG1v
dXNlIG5vdCBoZWxkCgkJCWlmIChtc2cubWIgPT0gMCkgcmVjdChzeDAtMSxzeTAtMSxzeDEsc3kx
LDB4MDgwNykKCQllbmQKCgkJcHJpbnQoc3RyaW5nLmZvcm1hdCgiXCMwICUzZCAlM2QgIix4LHkp
LCAxMiwgIHNlbGYuaGVpZ2h0LTE0LCA2KQoJCQoJCS0tcHJpbnQoc3RhdCgxKSwxMCwxMCw3KQoK
LS0JCWlmIChjaS5sYXllcikgcHJpbnQoImxheWVyOiAiLi5wb2R7Y2kubGF5ZXJfeCxjaS5sYXll
cl95LGNpLmxheWVyOmF0dHJpYnMoKX0sIDIwLCAyMCw3KSAtLSB0byBkbzogZHJhdyBzZWxlY3Rp
b24uIGNyZWF0ZV9vdXRsaW5lIG9uIGRlbWFuZCBldGMKLS0JCXByaW50KCJtdG9vbDogIi4ubXRv
b2wsMjAsMzAsNykKCWVuZAoJCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCQoJCWxvY2Fs
IGlpID0gaXRlbVsxXSAtLSBnbG9iYWwgem9vbSBmb3Igbm93CgkJaWYgKGlpLnpvb20gPD0gMSkg
dGhlbgoJCQlpZiAobXNnLndoZWVsX3kgPCAwKSBpaS56b29tIC89IDIKCQkJaWYgKG1zZy53aGVl
bF95ID4gMCkgaWkuem9vbSAqPSAyCgkJZWxzZQoJCQlpaS56b29tICs9IG1zZy53aGVlbF95CgkJ
ZW5kCgkJCgkJbG9jYWwgbWluX3NjYWxlID0gMC4yNQoJCWxvY2FsIG1heF9zY2FsZSA9IDE2IC0t
IHdhcyA0CgkJCgkJLS0gY2FuIHpvb20gb3V0IGZ1cnRoZXIgd2hlbiB3b3VsZG4ndCBmaXQgb3Ro
ZXJ3aXNlCgkJLS0gaWYgKGNibXA6d2lkdGgoKSAgPj0gc2VsZi53aWR0aCApIG1pbl9zY2FsZSA9
IDAuNQoJCS0tIGlmIChjYm1wOmhlaWdodCgpID49IHNlbGYuaGVpZ2h0KSBtaW5fc2NhbGUgPSAw
LjUJCQoJCQoJCWlpLnpvb20gPSBtaWQobWluX3NjYWxlLCBpaS56b29tLCBtYXhfc2NhbGUpCgkJ
aWYgKGlpLnpvb20gPj0gMSkgaWkuem9vbSBcPSAxCgllbmQKCQoJCglyZXR1cm4gZWwKZW5kCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiBkcmF3Lmx1YQotLVtbcG9kX2Zv
cm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTEyIDAzOjI2OjIwIixtb2RpZmllZD0iMjAyNS0w
Ny0xMCAwMzoyNjoxMiIscmV2aXNpb249MzIyNF1dCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg1KQoJ
LS0gb3BlcmF0aW9ucyBkdXJpbmcgX3VwZGF0ZSBjYW4gcmVxdWVzdCBhCgktLSBndWkgdXBkYXRl
IGJlZm9yZSBpdCBpcyBuZXh0IGRyYXcgKGF2b2lkIGZsaWNrZXIpCglpZiAocmVmcmVzaF9ndWkp
IHRoZW4KCQlnZW5lcmF0ZV9ndWkoKQoJCS0tIGd1aTpkcmF3X2FsbCgpIGV4cGVjdHMgOnVwZGF0
ZV9hbGwoKSBjYWxsZWQgZmlyc3Qgb24gY3VycmVudCBzdGF0ZSBvZiBndWkKCQlndWk6dXBkYXRl
X2FsbCgpCgkJcmVmcmVzaF9ndWkgPSBmYWxzZQoJZW5kCgkJCglmaWxscCgpIHBhbCgpCglndWk6
ZHJhd19hbGwoKQoJCgktLSBkYXJrIGdyYXkKCXBva2U0KDB4NTAwMCszMio0LCAweDIwMjAyMDIw
KQoJCglpZiAoY3VzdG9tX3BhbGV0dGUpIHRoZW4KCQlwb2tlNCgweDUwMDAsIGdldChjdXN0b21f
cGFsZXR0ZSkpCgllbmQKCQplbmQKCgo6OiBndWkubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNy
ZWF0ZWQ9IjIwMjMtMDUtMTEgMDI6MDU6MTYiLG1vZGlmaWVkPSIyMDI1LTA5LTA5IDAyOjA4OjU1
IixyZXZpc2lvbj00MDY3XV0KCnNob3dfcGFuZSA9IHRydWUKCgoKIC0tIHVwZGF0ZSBsYXlvdXQg
d2l0aG91dCBuZWVkaW5nIHRvIHJlZ2VuZXJhdGUgZ3VpCiAtLSB0byBkbzogY291bGQgYWxzbyB1
c2UgdGhpcyBmb3IgaGFuZGxpbmcgY2hhbmdlcyBpbiBkaXNwbGF5IHNpemUKIGZ1bmN0aW9uIHVw
ZGF0ZV9ndWlfbGF5b3V0KCkKIAlpZiAobm90IHNpZGViYXIgb3Igbm90IGNhbnZhc19lbCkgcmV0
dXJuCiAJCiAJeHQgPSBzaG93X3BhbmUgYW5kIDMzNiBvciA0ODAKIAlzaWRlYmFyX3ggPSBzaWRl
YmFyX3ggb3Igc2lkZWJhci54CiAJc2lkZWJhcl94ID0gKHNpZGViYXJfeCAqIDMgKyB4dCkgLyA0
CiAJCglpZiAoc2lkZWJhcl94ID4geHQpIHRoZW4KCQlzaWRlYmFyX3ggPSBtYXgoeHQsIHNpZGVi
YXJfeCAtIDgpCgllbHNlCgkJc2lkZWJhcl94ID0gbWluKHh0LCBzaWRlYmFyX3ggKyA4KQoJZW5k
CgkKCS0tICEhIGluc3RhbnQgY2hhbmdlIC0tIG1heWJlIGJldHRlciAoc3RpbGwgZ2V0IHRvb2xi
YXIgdHJhbnNpdGlvbiEpCglzaWRlYmFyX3ggPSB4dAoKIAlzaWRlYmFyLnggPSBzaWRlYmFyX3gg
XCAxCiAJc2lkZWJhci5oZWlnaHQgPSBnZXRfZGlzcGxheSgpOmhlaWdodCgpCiAKCWNhbnZhc19l
bC53aWR0aCA9IHNpZGViYXJfeCBcIDEKCWNhbnZhc19lbC5oZWlnaHQgPSBnZXRfZGlzcGxheSgp
OmhlaWdodCgpCiAKCS0tIHNlbmQgYSBtZXNzYWdlIHRvIHdtIGFza2luZyB0byB1bmRvY2sgLyBk
b2NrIHRvb2xiYXIKCWlmIHNob3dfcGFuZSB_PSBsYXN0X3Nob3dfcGFuZSB0aGVuCQoJCS0tc2Vu
ZF9tZXNzYWdlKDMsIHtldmVudD0iZG9ja190b29sYmFyIiwgc3RhdGUgPSBzaG93X3BhbmV9KQoJ
ZW5kCglsYXN0X3Nob3dfcGFuZSA9IHNob3dfcGFuZQogZW5kCiAKCmZ1bmN0aW9uIGdlbmVyYXRl
X2d1aSgpCgkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCgktLSByZW1vdmUgdGVtcG9yYXJ5IGl0ZW1z
IGF0dGFjaGVkIG9uIGRlbWFuZAoJbGF5ZXJfbmFtZV9lZGl0b3IgPSBuaWwKCWZpZWxkX2VkaXRv
ciA9IG5pbAoJCglpZiAobm90IHNob3dfcGFuZSkgdGhlbgoJCWd1aTphdHRhY2goY3JlYXRlX2Nh
bnZhc3t4PTAseT0wLHdpZHRoPTQ4MCxoZWlnaHRfcmVsPTEuMH0pCgkJcmV0dXJuCgllbmQKCQoJ
Y2FudmFzX2VsID0gZ3VpOmF0dGFjaChjcmVhdGVfY2FudmFze3g9MCx5PTAsd2lkdGg9MzM2LGhl
aWdodD0yNjF9KQoJCglzaWRlYmFyID0gZ3VpOmF0dGFjaHt4PTQ4MC0xNDQseT0wLHdpZHRoPTE1
MCxoZWlnaHQ9MjUwfQoJCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfbGF5ZXJfaW5mb3t4PTgseT01
LHdpZHRoPTEyOCxoZWlnaHQ9MjR9KQoJc2lkZWJhcjphdHRhY2goY3JlYXRlX2xheWVyX25hdnt4
PTgseT0xNix3aWR0aD0xMjgsaGVpZ2h0PTU1fSkKCQoJLS0gYSBsaXR0bGUgc3BhY2UgYWJvdmUg
cGFsZXR0ZSBmb3IgdGFicyAob3BlcmF0aW9uKQoJLS1sb2NhbCBwYWxfZWwgPSBzaWRlYmFyOmF0
dGFjaChjcmVhdGVfcGFsZXR0ZXt4PTgseT0xNCx3aWR0aD0xMjgsaGVpZ2h0PTMyfSkKCQkKCS0t
c2lkZWJhcjphdHRhY2goY3JlYXRlX2l0ZW1faW5mb3t4PTgseT02NCx3aWR0aD0xMjgsaGVpZ2h0
PTIwfSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9pdGVtX2luZm97eD04LHk9OTYsd2lkdGg9MTI4
LGhlaWdodD0yNH0pCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfYmFua190YWJze3g9OCsxMjgtNDgr
MSx5PTExNi05LHdpZHRoPTQ4LGhlaWdodD05fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9uYXZ7
eD04LHk9MTE2LHdpZHRoPTEyOCxoZWlnaHQ9MTI4fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9y
YW1fd2lkZ2V0e3g9ODgseT0yNTAsd2lkdGg9NjAsaGVpZ2h0PTEwfSkKCgkKCS0tLS0gdG9vbHMg
LS0tLQoJCgktLSAqKiB0byBkbzogdG9vbCBzaG91bGQgZGVwZW5kIG9uIGxheWVyIHR5cGUuCgkt
LSAqKiBlLmcuIGVudGl0eSBwaWNrZXIgd2hlbiBsYXllciBpcyBlbnRpdGllcyBtb2RlCgkKCWxv
Y2FsIHRvb2xzID0gewoJCSJwZW5jaWwiLCAicmVjdCIsImZpbGwiLCJzdGFtcCIsInNlbGVjdCIs
InBpY2siLCJwYW4iCgl9CgkKCWxvY2FsIHd3PTEyCglsb2NhbCB5eT03NSAtLSBnZnggaXMgNTAK
CWZvciBpPTAsI3Rvb2xzLTEgZG8KCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV90b29sX2J1dHRvbih0
b29sc1tpKzFdLCAKCQkxMCsoaSV3dykqMTQsIHl5KyhpXHd3KSoxNCkpCgllbmQKCQoJCgkKCXVw
ZGF0ZV9ndWlfbGF5b3V0KCkKCgplbmQKbG9jYWwgdG9vbF9nZng9ewpwZW5jaWw9IltnZnhdMDgw
ODAwMDA3MDAwMDAwNzc3MDAwMDc3Nzc3MDA3Nzc3NzAwNzA3NzcwMDA3MDA3MDAwMDc3NzAwMDAw
MDAwMDAwMDBbL2dmeF0iLApicnVzaD0iW2dmeF0wODA4MDAwMDA3NzAwMDAwNzcwMDAwMDc3MDAw
MDAwNzAwMDAwNzcwMDAwMDA3NzAwMDAwNzcwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCmxpbmU9Iltn
ZnhdMDgwODAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcw
MDAwMDAwMDAwMDAwMDBbL2dmeF0iLAotLXJlY3Q9IltnZnhdMDgwODc3Nzc3NzcwNzAwMDAwNzA3
MDAwMDA3MDcwMDAwMDcwNzAwMDAwNzA3MDAwMDA3MDc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLApy
ZWN0PSAtLSBhbHdheSBmaWxsZWQgaW4gbWFwIGVkaXRvcgotLVtbcG9kLHBvZF90eXBlPSJpbWFn
ZSJdXXVucG9kKCJiNjQ6YkhvMEFCUUFBQUFYQUFBQXMzQjRkUUJESUFnSUJHY0FBZ0JRQUdjQVo0
QT0iKSwKcGljaz0KLS1bW3BvZCxwb2RfdHlwZT0iaW1hZ2UiXV11bnBvZCgiYjY0OmJIbzBBQmdB
QUFBV0FBQUE4QWR3ZUhVQVF5QUlDQVFnQjJBSHNCY2dGN0FIWUFldyIpLApzZWxlY3Q9IltnZnhd
MDgwODc3MDcwNzcwNzAwMDAwNzAwMDAwMDAwMDcwMDAwMDcwMDAwMDAwMDA3MDAwMDA3MDc3MDcw
NzcwMDAwMDAwMDBbL2dmeF0iLApzaGFwZT0iW2dmeF0wODA4Nzc3Nzc3NzA3MDAwMDA3MDcwMDAw
MDcwNzAwMDAwNzA3MDAwMDA3MDcwMDAwMDcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIsCnBhbj0i
W2dmeF0wODA4MDA3MDcwMDAwMDcwNzA3MDAwNzA3MDcwMDA3Nzc3NzA3MDc3Nzc3MDA3Nzc3Nzcw
MDA3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIsCmZpbGw9IltnZnhdMDgwODAwMDA3MDAwMDAwMDA3MDAw
MDAwMDA3MDA3Nzc3Nzc3NzA3Nzc3NzA3MDA3NzcwMDcwMDA3MDAwMDAwMDAwMDBbL2dmeF0iLApz
dGFtcD0iW2dmeF0wODA4MDA3NzcwMDAwMDc3NzAwMDAwNzc3MDAwMDA3NzcwMDA3Nzc3Nzc3MDcw
MDAwMDcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIsCnNtdWRnZT0iW2dmeF0wODA4MDA3MDAwMDAw
MDcwMDAwMDAwNzA3MDcwMDA3Nzc3NzA3MDc3Nzc3MDA3Nzc3NzcwMDA3Nzc3MDAwMDAwMDAwMFsv
Z2Z4XSIsCnN3ZWVwPSJbZ2Z4XTA4MDgwMDAwNzAwMDAwMDA3MDAwMDAwMDcwMDAwMDA3MDAwMDAw
MDcwMDAwNzc3Nzc3NzA3MDcwNzA3MDAwMDAwMDAwWy9nZnhdIiwKdGV4dD0iW2dmeF0wODA4Nzc3
Nzc3NzA3NzAwNzc3MDc3NzcwNzcwNzcwMDA3NzA3MDc3MDc3MDc3MDA3MDcwNzc3Nzc3NzAwMDAw
MDAwMFsvZ2Z4XSIsCnNjcmFtYmxlPSJbZ2Z4XTA4MDgwNzAwMDcwMDA3MDAwNzAwNzc3Nzc3NzA3
MDc3NzA3MDc3Nzc3NzcwMDcwMDA3MDA3NzAwMDc3MDAwMDAwMDAwWy9nZnhdIiwKZXJhc2VyPSJb
Z2Z4XTA4MDgwMDA3NzAwMDAwNzc3NzAwMDc3Nzc3NzA3MDc3Nzc3MDcwMDc3NzAwMDcwMDcwMDAw
MDc3MDAwMDAwMDAwMDAwWy9nZnhdIiwKfQpsb2NhbCBicnVzaF9nZng9ewoiW2dmeF0wODA4MDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMFsvZ2Z4XSIsCiJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3NzAwMDAw
MDc3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKIltnZnhdMDgwODAwMDAwMDAw
MDAwMDAwMDAwMDA3MDAwMDAwNzc3MDAwMDAwNzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBb
L2dmeF0iLAoiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDc3MDAwMDA3Nzc3MDAwMDc3Nzcw
MDAwMDc3MDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCiJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDc3
MDAwMDA3Nzc3MDAwNzc3Nzc3MDA3Nzc3NzcwMDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwWy9nZnhd
IiwKIltnZnhdMDgwODAwNzc3NzAwMDc3Nzc3NzA3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3
Nzc3NzA3Nzc3NzcwMDA3Nzc3MDBbL2dmeF0iLAoiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDc3NzcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCiJb
Z2Z4XTA4MDgwMDAwMDAwMDAwMDAwMDAwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAw
NzAwMDAwMDAwMDAwMDAwWy9nZnhdIgp9CmZ1bmN0aW9uIGNyZWF0ZV9icnVzaF9idXR0b24od2hp
Y2gsIHgsIHkpCglsb2NhbCBlbD0ge3doaWNoID0gd2hpY2gsIHggPSB4LCB5ID0geSwgd2lkdGg9
MTIsIGhlaWdodCA9IDEyfQoJCgllbC5nZnggPSB1c2VyZGF0YShicnVzaF9nZnhbd2hpY2hdKQoJ
CglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDEsc2VsZi53aWR0aC0yLHNlbGYuaGVp
Z2h0LTIsMCkKCQlwYWwoNywgc2VsZi53aGljaCA9PSBicnVzaC53aGljaCBhbmQgNyBvciAxMykK
CQlzcHIoc2VsZi5nZngsMiwyKQoJCXBhbCg3LDcpCgllbmQKCQoJZnVuY3Rpb24gZWw6dGFwKCkK
CQlicnVzaC53aGljaCA9IHNlbGYud2hpY2gKCQlicnVzaC50aGlja25lc3MgPSBzZWxmLndoaWNo
LTEKCWVuZAoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGNyZWF0ZV90b29sX2J1dHRvbih3aGlj
aCwgeCwgeSkKCWxvY2FsIGVsPSB7d2hpY2ggPSB3aGljaCwgeCA9IHgsIHkgPSB5LCB3aWR0aD0x
MiwgaGVpZ2h0ID0gMTJ9CgkKCWVsLmdmeCA9IHRvb2xfZ2Z4W3doaWNoXQoJaWYgKHR5cGUoZWwu
Z2Z4KT09InN0cmluZyIpIGVsLmdmeCA9IHVzZXJkYXRhKHRvb2xfZ2Z4W3doaWNoXSkKCQoJZnVu
Y3Rpb24gZWw6ZHJhdygpCgktLVtbCgkJbGluZSgxLDAsOSwwLDEzKQoJCXJlY3RmaWxsKDAsMSwx
MCw5LDEzKQoJCWxpbmUoMSwxMCw5LDEwLDEzKQoJXV0KCQlwYWwoNywgd2hpY2ggPT0gY3Rvb2wg
YW5kIDcgb3IgMTMpCgkJc3ByKHNlbGYuZ2Z4LDIsMikKCQlwYWwoNyw3KQoJZW5kCgkKCWZ1bmN0
aW9uIGVsOnRhcCgpCgkJY3Rvb2wgPSBzZWxmLndoaWNoCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgll
bmQKCQoJcmV0dXJuIGVsCmVuZAoKLS0gZnJvbSBnZngucDY0CmZ1bmN0aW9uIGNyZWF0ZV9yYW1f
d2lkZ2V0KGVsKQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJLS0gMC4yLjBpOiBjaGFuZ2VkIHRvIDEy
TUIgYXMgbm9taW5hbCBzYWZlIGFtb3VudCBvZiBtZW1vcnkgdG8gdXNlCgkJLS0gbmVlZCBzcGFj
ZSBmb3Igd3JhbmdsZXIvc3RvcmUgc2F2aW5nIGNvZGUgKyB1bmRvIHN0YWNrIGV0YwoJCXByaW50
KHN0cmluZy5mb3JtYXQoIiUyLjJmbWIgKCUwMmQlJSkiLHN0YXQoMCkvMHgxMDAwMDAsc3RhdCgw
KVwxMjU4MjkpLDAsMCwKCQkJc3RhdCgwKSA_IDExMDAwMDAwIGFuZCAxNCBvciAyMSkgLS0gd2Fy
biB3aGVuIG1vcmUgdGhhbiA3Lzh0aHMgb2YgY2FwYWNpdHkKCWVuZAoJcmV0dXJuIGVsCmVuZAoK
OjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wNC0xMSAwMjow
NDo1NCIsbW9kaWZpZWQ9IjIwMjUtMDctMTAgMDM6MjY6MTIiLHJldmlzaW9uPTQxMjddXQotLVtb
CglQaWNvdHJvbiBNYXAgRWRpdG9yCl1dCmluY2x1ZGUgImRyYXcubHVhIgppbmNsdWRlICJ1cGRh
dGUubHVhIgppbmNsdWRlICJndWkubHVhIgppbmNsdWRlICJjYW52YXMubHVhIgppbmNsdWRlICJu
YXYubHVhIgppbmNsdWRlICJ1bmRvLmx1YSIKLS0gZGVsZXRlbWUKY2JtcCxjYm1wX3dpZHRoLGNi
bXBfaGVpZ2h0ID0gbmlsLG5pbCxuaWwKCi0tIHRvIGRvOiB1bmlmeSB3aXRoIGxvYWRfd29ya2lu
Z19maWxlCmZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X21hcHMoKQoJLS0gZGVmYXVsdCBtYXBzCgli
bXAgPSB7fQoJaXRlbSA9IHt9Cglmb3IgaT0xLDEgZG8KCQlpdGVtW2ldID0gewoJCQlibXAgICA9
IHVzZXJkYXRhKCJ1MTYiLDMyLDMyKSwKCQkJbmFtZSA9IG5pbCwgLS0ibGF5ZXIgIi4uaSwgLS0g
bGF0ZXI6IGN1c3RvbSBuYW1lcyBmb3IgbGF5ZXJzCgkJCWV4dHJhID0gbmlsLCAtLSB0ZXh0LiBt
YXliZSAibm90ZXMiPwoJCQlwYW5feCA9IDAsCgkJCXBhbl95ID0gMCwKCQkJc2NhbGUgPSAxLAoJ
CQl0aWxlX3cgPSAxNiwKCQkJdGlsZV9oID0gMTYKCQl9CgkJYWRkX3VuZG9fc3RhY2soaXRlbVtp
XSkKCWVuZAplbmQKCmZ1bmN0aW9uIHNhdmVfd29ya2luZ19maWxlKCkKCWxvY2FsIG91dHB1dCA9
IHt9Cglmb3IgaT0xLCNpdGVtIGRvCgkJbG9jYWwgaWk9aXRlbVtpXQoJCW91dHB1dFtpXSA9IHsK
CQkJbmFtZSA9IGlpLm5hbWUsCgkJCWJtcCA9IGlpLmJtcCwKCQkJcGFuX3ggPSBpaS5wYW5feCwK
CQkJcGFuX3kgPSBpaS5wYW5feSwKCQkJem9vbSA9IGlpLnpvb20sCgkJCXRpbGVfdyA9IGlpLnRp
bGVfdywKCQkJdGlsZV9oID0gaWkudGlsZV9oLAoJCQloaWRkZW4gPSBpaS5oaWRkZW4KCQl9Cgll
bmQKCQoJcmV0dXJuIG91dHB1dAplbmQKCmZ1bmN0aW9uIGxvYWRfd29ya2luZ19maWxlKGl0ZW1f
MSkKCQoJaXRlbV8xID0gdHlwZShpdGVtXzEpID09ICJ0YWJsZSIgYW5kIGl0ZW1fMSBvciB7fQoJ
CgktLSBkZXYgbGVnYWN5OiB6ZXJvLWJhc2VkIGxheWVyIGNvbGxlY3Rpb24KCWlmIChub3QgaXRl
bV8xWzFdIGFuZCBpdGVtXzFbMF0pIHRoZW4KCQlpdGVtXzEgPSB7aXRlbV8xWzBdfQoJZW5kCglp
dGVtID0ge30KCglmb3IgaT0xLCNpdGVtXzEgZG8KCQlpZiAodHlwZShpdGVtXzEubGF5ZXIpPT0i
dGFibGUiKSBpdGVtXzEgPSBpdGVtXzEubGF5ZXIgLS0gbGVnYWN5CgkJaXRlbVtpXSA9IGl0ZW1f
MVtpXSBvciB7fQoJCQoJCWxvY2FsIGl0bSA9IGl0ZW1baV0KCgkJaXRtLmJtcCAgID0gaXRtLmJt
cCBvciB1c2VyZGF0YSgiaTE2IiwxNiwxNikKCQlpdG0uc2VsICAgPSBpdG0uc2VsIG9yIHVzZXJk
YXRhKCJ1OCIsIDE2LDE2KQoJCWl0bS5uYW1lICA9IGl0bS5uYW1lIG9yIG5pbAoJCWl0bS5leHRy
YSA9IGl0bS5leHRyYSBvciBuaWwgLS0gdGV4dC4gbWF5YmUgIm5vdGVzIj8KCQlpdG0ucGFuX3gg
PSBpdG0ucGFuX3ggb3IgMAoJCWl0bS5wYW5feSA9IGl0bS5wYW5feSBvciAwCgkJaXRtLnpvb20g
ID0gaXRtLnpvb20gb3IgMQoJCWl0bS50aWxlX3cgPSBpdG0udGlsZV93IG9yIDE2CgkJaXRtLnRp
bGVfaCA9IGl0bS50aWxlX2ggb3IgMTYKCQlpdG0uaGlkZGVuID0gaXRtLmhpZGRlbiBvciBmYWxz
ZQoJCWFkZF91bmRvX3N0YWNrKGl0ZW1baV0pCgllbmQJCgkKCXNldF9jdXJyZW50X2l0ZW0oMSkK
CQoJLS0gcmVnaW9uIG9mIHNlbGVjdGVkIHNwcml0ZXMKCXJlZ2lvbj17CgkJeD0xLHk9MCx3PTEs
aD0xLAoJCXgwPTEseTA9MAoJfQoJCmVuZAoKLS1bWwoJbG9hZCBldmVyeXRoaW5nIGluIC9yYW0v
Y2FydC9nZngKCXRvIGRvOiBwZXIgYmFuayBpbnZhbGlkYXRpb24KCXRvIGRvOiBnZnggZmlsZXMg
cmVsYXRpdmUgdG8gbWFwIGZpbGU-CgkJLS0gbWlnaHQgd2FudCB0byBtYWtlIG1hcHMgb3V0c2lk
ZSBvZiBjYXJ0IGNvbnRleHQKXV0KZnVuY3Rpb24gbG9hZF9zcHJpdGViYW5rcygpCi0tCXByaW50
aCgiIC0tIGxvYWRfc3ByaXRlYmFua3MoKSAtLSIpCglnZnhfbHMgPSBscygiL3JhbS9jYXJ0L2dm
eCIpCglnZnhfZmlsZSA9IHt9Cglmb3IgaT0xLCNnZnhfbHMgZG8KCQlsb2NhbCBmbiA9IGdmeF9s
c1tpXQoJCWxvY2FsIG51bSA9IHRvbnVtKHN0cmluZy5zdWIoZm4sMSwyKSkgb3IgdG9udW0oc3Ry
aW5nLnN1YihmbiwxLDEpKQoJCQoJCWZuID0gIi9yYW0vY2FydC9nZngvIi4uZm4gCi0tCQlwcmlu
dGgoImxvYWRpbmcgIi4uZm4pCgkJaWYgKG51bSkgdGhlbgoJCQlnZnhfZmlsZVtudW1dID0gZm4K
CQkJbG9jYWwgZ2Z4X2RhdCA9IGZldGNoKGZuKQoJCQlpZiAodHlwZShnZnhfZGF0ID09ICJ0YWJs
ZSIpIGFuZCBnZnhfZGF0WzBdIGFuZCBnZnhfZGF0WzBdLmJtcCkgdGhlbgoJCQkJZm9yIGk9MCwj
Z2Z4X2RhdCBkbwoJCQkJCXNldF9zcHIobnVtICogMjU2ICsgaSwgZ2Z4X2RhdFtpXS5ibXApCgkJ
CQllbmQKCQkJZW5kCgkJZW5kCgllbmQKZW5kCgpjb2wgPSAxIC0tIHNwcml0ZSBpbmRleAoKZnVu
Y3Rpb24gX2luaXQoKQoJCglwb2tlKDB4NDAwMCxnZXQoZmV0Y2giL3N5c3RlbS9mb250cy9wOC5m
b250IikpCgktLXBva2UoMHg0MDAyLDYpIC0tIHRvIGRvOiBzaG91bGQgYmUgYXR0cmlidXRlIG9m
IHA4LmZvbnQKCQoJLS0gZGVmYXVsdCBmaWxlbmFtZSBpcyBkdW1teSBmb3Igbm93CgktLSBub3Rl
OiBzYXZlZCBpbnNpZGUgc2VsZiAoZ2Z4LnA2NCkgd2hlbiBsb2FkZWQgYXMgY3Byb2oKCS0tY3Jl
YXRlX2RlZmF1bHRfYmFuaygpCgl3aW5kb3d7CgkJdGFiYmVkID0gdHJ1ZSwKCQlpY29uID0gdXNl
cmRhdGEiW2dmeF0wODA4MDAwMDA3Nzc3Nzc3MDc3Nzc3NzcwNzc3Nzc3NzAwMDA3Nzc3Nzc3MDc3
Nzc3NzcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIKCX0KCQkKCW1rZGlyKCIvcmFtL2NhcnQvbWFw
IikKCQoJd3JhbmdsZV93b3JraW5nX2ZpbGUoCgkJc2F2ZV93b3JraW5nX2ZpbGUsCgkJbG9hZF93
b3JraW5nX2ZpbGUsCgkJIi9yYW0vY2FydC9tYXAvMC5tYXAiLCAtLSBkZWZhdWx0CgkJbmlsLG5p
bCwKCQlmdW5jdGlvbigpCgkJCS0tIHVuc2F2ZWQgY2hhbmdlcyAobWlnaHQpIGV4aXN0IHdoZW4g
dW5kbyBzdGFjayBwb3NpdGlvbiBvZiBjdXJyZW50IGxheWVyIGNoYW5nZXMKCQkJcmV0dXJuIGNp
IGFuZCBjaS51bmRvX3N0YWNrIGFuZCAjY2kudW5kb19zdGFjay51bmRvX3N0YWNrCgkJZW5kCgoJ
KQoKCWxvYWRfc3ByaXRlYmFua3MoKQoJCgljb2wgPSAxIC0tIHNwcml0ZSBpbmRleAoJCglzZXRf
Y3VycmVudF9pdGVtKDEpCglzZXRfY3VycmVudF9iYW5rKDApCglzZXRfY3VycmVudF9iYW5rX3Bh
Z2UoMCkKCQoJZ2VuZXJhdGVfZ3VpKCkKCQoJY3Rvb2wgPSAicGVuY2lsIgoJbXRvb2wgPSBjdG9v
bAoJaWYgKGtleSJzIikgbXRvb2wgPSAic2VsZWN0IgoJCglicnVzaCA9IHsKCQlzcGFjaW5nPTEs
CgkJdGhpY2tuZXNzPTIsCgkJd2hpY2g9MywKCQlwYXQ9MHgwCgl9CgkKCXJlZnJlc2hfZ3VpID0g
dHJ1ZQoJCmVuZApmdW5jdGlvbiBzZXRfY3VycmVudF9iYW5rX3BhZ2UoaSkKCS0tcHJpbnRoKCJz
ZXR0aW5nIGJhbmsgcGFnZTogIi4uaSkKCWN1cnJlbnRfYmFua19wYWdlID0gaQplbmQKZnVuY3Rp
b24gc2V0X2N1cnJlbnRfYmFuayhpLCBkaSkKCglpID0gaSBvciBjdXJyZW50X2JhbmsKCQoKCWlm
IChkaSkgdGhlbgoJCQoJCWxvY2FsIGkwID0gaQoJCWkgKz0gZGkKCQlpZiAobm90IGdmeF9maWxl
W2ldKSB0aGVuCgkJCWkgPSAoaSArIGRpKSAlIDMyCgkJCXdoaWxlIChub3QgZ2Z4X2ZpbGVbaV0g
YW5kIGkgfj0gaTApIGRvCgkJCQlpID0gKGkgKyBkaSkgJSAzMgoJCQllbmQKCQllbmQKCWVuZAoJ
CgljdXJyZW50X2JhbmsgPSBpCgktLXByaW50aCgic2V0X2N1cnJlbnRfYmFuayAiLi5pKQoKCXJl
ZnJlc2hfZ3VpID0gdHJ1ZQplbmQKZnVuY3Rpb24gc2V0X2N1cnJlbnRfaXRlbShpKQoKCS0tIHRv
IGRvOiByZW1vdmUKCWlmICgjaXRlbSA9PSAwKSB0aGVuCgkJY3JlYXRlX2RlZmF1bHRfbWFwcygp
CgllbmQKCglhc3NlcnQoI2l0ZW0gPiAwKQoJaSA9IGkgb3IgY3VycmVudF9pdGVtCglpID0gbWlk
KDEsIGksICNpdGVtKQoJLS1wcmludGgoInNldHRpbmcgaXRlbTogIi4uaSkKCWN1cnJlbnRfaXRl
bSA9IGZscihpKSAgLS0gd2FudCBpdCB0byBiZSBhbiBpbnRlZ2VyCgljaSA9IGl0ZW1bY3VycmVu
dF9pdGVtXQoJY2JtcCA9IGl0ZW1bY3VycmVudF9pdGVtXS5ibXAKCWNibXBfd2lkdGgsIGNibXBf
aGVpZ2h0ID0gY2JtcDp3aWR0aCgpLCBjYm1wOmhlaWdodCgpCgoJLS0gc2VsZWN0aW9uCglpZiBu
b3QgaXRlbVtjdXJyZW50X2l0ZW1dLnNlbCBvcgoJCWl0ZW1bY3VycmVudF9pdGVtXS5zZWw6d2lk
dGgoKSAgfj0gY2JtcF93aWR0aCBvcgoJCWl0ZW1bY3VycmVudF9pdGVtXS5zZWw6aGVpZ2h0KCkg
fj0gY2JtcF9oZWlnaHQKCXRoZW4KCQlpdGVtW2N1cnJlbnRfaXRlbV0uc2VsID0gdXNlcmRhdGEo
InU4IiwgY2JtcF93aWR0aCwgY2JtcF9oZWlnaHQpCgllbmQKCQoJY3NlbCA9IGl0ZW1bY3VycmVu
dF9pdGVtXS5zZWwKCWNzZWxfb3V0bGluZSA9IGl0ZW1bY3VycmVudF9pdGVtXS5zZWxfb3V0bGlu
ZQoJCgktLSB0byBkbzogc2luZ2xlLWl0ZW0gcmVnaW9uIG1vdmVzIHdpdGggY3VycmVudF9pdGVt
Ci0tCWlmIChub3QgcmVnaW9uIG9yIChyZWdpb24udz09MSBhbmQgcmVnaW9uLmg9PTEpKSB0aGVu
Ci0tCQlsb2NhbCByeCA9IGNvbCAlIDgKLS0JCWxvY2FsIHJ5ID0gY29sIFwgOAotLQkJcmVnaW9u
PXt4PXJ4LHk9cnkseDA9cngseTA9cnksdz0xLGg9MX0KLS0JZW5kCmVuZAoKb25fZXZlbnQoImxv
c3RfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQltYXBfZ2Z4X3N0YXRlID0gbWFwX2dmeF9zdGF0
ZSBvciBmZXRjaCIvcmFtL3NoYXJlZC9tYXBfZ2Z4LnBvZCIgb3Ige30KCQltYXBfZ2Z4X3N0YXRl
LmN1cnJlbnRfc3ByaXRlX2luZGV4ID0gY29sCgkJbWFwX2dmeF9zdGF0ZS5yZWdpb24gPSByZWdp
b24gLS0gMC4yLjBkCgkJbWFwX2dmeF9zdGF0ZS5tYXBfcHJvY19pZCA9IHBpZCgpCgkJc3RvcmUo
Ii9yYW0vc2hhcmVkL21hcF9nZngucG9kIiwgbWFwX2dmeF9zdGF0ZSkKCWVuZAopCm9uX2V2ZW50
KCJnYWluZWRfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQktLXByaW50aCgiQEAgW21hcF0gcmVs
b2FkaW5nIHNwcml0ZWJhbmtzIG9uIGdhaW5pbmcgZm9jdXMiKQoJCWxvYWRfc3ByaXRlYmFua3Mo
KQoKCQktLSB0ZW1wb3Jhcnk6IHNldCB0aWxlIHNpemVzIHRvIHNwcml0ZTAKCQlsb2NhbCBzcHIw
ID0gZ2V0X3NwcigwKQoJCWlmIChzcHIwKSB0aGVuCgkJCWZvciBpPTEsI2l0ZW0gZG8KCQkJCWl0
ZW1baV0udGlsZV93LCBpdGVtW2ldLnRpbGVfaCA9IHNwcjA6d2lkdGgoKSwgc3ByMDpoZWlnaHQo
KQoJCQllbmQKCQllbmQKCgkJCgkJbWFwX2dmeF9zdGF0ZSA9IGZldGNoIi9yYW0vc2hhcmVkL21h
cF9nZngucG9kIgoJCWlmIChtYXBfZ2Z4X3N0YXRlKSB0aGVuCi0tCQkJcHJpbnRoKCJtYXBfZ2Z4
LnBvZCBvbiBmb2N1czogIi4ucG9kKG1hcF9nZnhfc3RhdGUpKQoJCQljb2wgPSBtYXBfZ2Z4X3N0
YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4CgkJCXNwcml0ZV9iYW5rID0gY29sIFwgMjU2CgkJCXNw
cml0ZV9iYW5rX3BhZ2UgPSAoY29sJTI1NikgXCA2NAoJCQlpZiAobWFwX2dmeF9zdGF0ZS5yZWdp
b24pIHRoZW4KCQkJCXJlZ2lvbiA9IG1hcF9nZnhfc3RhdGUucmVnaW9uCgkJCQlyZWdpb24uYmFu
ayA9IGNvbCBcIDI1NgoJCQllbmQKCQllbmQKCgllbmQKKQoKb25fZXZlbnQoInNldF9wYWxldHRl
IiwKCWZ1bmN0aW9uKG1zZykKCQlpZiAodHlwZShtc2cucGFsZXR0ZSkgPT0gInVzZXJkYXRhIikg
dGhlbgoJCQlsb2NhbCB3LCBoLCB0eXBlID0gbXNnLnBhbGV0dGU6YXR0cmlicygpCgkJCWlmICh3
ID09IDY0IGFuZCB0eXBlID09ICJpMzIiKSB0aGVuCgkJCQljdXN0b21fcGFsZXR0ZSA9IG1zZy5w
YWxldHRlCgkJCWVuZAoJCWVuZAoJZW5kCikKCgoKOjogbmF2Lmx1YQotLVtbcG9kX2Zvcm1hdD0i
cmF3IixjcmVhdGVkPSIyMDIzLTEwLTExIDAyOjE4OjQ4Iixtb2RpZmllZD0iMjAyNS0wNy0xMCAw
MzoyNjoxMiIscmV2aXNpb249NDk2OV1dCi0tW1sKCW5hdmlnYXRlIHNwcml0ZSBiYW5rCgkKCXRv
IGRvOiBwaW4gdGFicyBmcm9tIG11bHRpcGxlIHNwcml0ZSBiYW5rcyBhdCBvbmNlCgkoYnV0IDQg
dGFicyBvbiB0aGUgcmlnaHQgIjAiLi4iMyIgYXJlIGFsd2F5cyBmcm9tIHNlbGVjdGVkIC5nZngg
ZmlsZSkKCl1dCmljb25zID0KewoJLS0gbm90ZXMKCSJbZ2Z4XTA4MDg3Nzc3NzcwMDc3Nzc3NzAw
NzAwMDA3MDA3Nzc3NzcwMDcwMDAwNzAwNzc3Nzc3MDAwNzc3Nzc3MDAwMDAwMDAwWy9nZnhdIiwK
CQoJLS0gc2NhbGUKCSJbZ2Z4XTA4MDg3MDcwNzA3MDAwMDAwMDAwNzAwMDAwNzAwMDAwMDAwMDc3
NzAwMDcwNzc3MDAwMDA3NzcwNzA3MDAwMDAwMDAwWy9nZnhdIiwKCQoJLS0gdW5sb2NrLCBsb2Nr
Cglsb2NrMD0iW2dmeF0wODA4MDA3NzcwMDAwNzAwMDcwMDA3MDAwMDAwMDc3Nzc3MDAwNzcwNzcw
MDA3Nzc3NzAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCglsb2NrMT0iW2dmeF0wODA4MDAwMDAw
MDAwMDc3NzAwMDA3MDAwNzAwMDc3Nzc3MDAwNzcwNzcwMDA3Nzc3NzAwMDAwMDAwMDAwMDAwMDAw
MFsvZ2Z4XSIsCgoJaGlkZGVuMD11bnBvZCgiYjY0OmJIbzBBQjhBQUFBaEFBQUE4d053ZUhVQVF5
QUlDQVNRSnpBSEFBY0FCeEFDQUlBQUJ3QUhNQ2Z3QXc9PSIpLAoJaGlkZGVuMT11bnBvZCgiYjY0
OmJIbzBBQThBQUFBT0FBQUE0SEI0ZFFCRElBZ0lCUEFJWi1BUiIpLAoJCglidWNrZXRfY3Vyc29y
PXVucG9kKCJiNjQ6YkhvMEFFOEFBQUJQQUFBQThnQndlSFVBUXlBVkZRVFFBZkFEQVFjRkFQQXI0
RUVIQWNBQlp3R2dBUWNCUndHd0FRY1JKd0hBQVFjQkFBRUhBZEFCQndFUUFkQUJJQUhnQVFjZ0J3
SGdBU0FCOEFFQkJ3SHdBd0h3alE9PSIpLAoJYWRkX2xheWVyPXVucG9kKCJiNjQ6YkhvMEFDQUFB
QUFoQUFBQTRYQjRkUUJESUFnSUJHMEFMUWN0QkFEZ0RVY05BQzBITFFBdEJ5MEFiWUE9IiksCglk
ZWxfbGF5ZXI9dW5wb2QoImI2NDpiSG8wQUNnQUFBQXJBQUFBOHdWd2VIVUFReUFJQ0FRTlJ3MEFa
d0FIRFNjTkJ3WUFRQ2NOSndBV0FJQU5CdzBIRFFjTmdBPT0iKSwKCgllZGl0ID0gdW5wb2QoImI2
NDpiSG8wQUJrQUFBQVhBQUFBOEFod2VIVUFReUFJQ0FTd0IxQW5NQ2N3QndBSFFCZndCUT09Iiks
CgkKCWxheWVyX3VwID0gdW5wb2QoImI2NDpiSG8wQUJZQUFBQVVBQUFBOEFWd2VIVUFReUFJQ0FU
d0F3ZFFKekJIUUFmd0JBPT0iKSwKCWxheWVyX2Rvd24gPSB1bnBvZCgiYjY0OmJIbzBBQllBQUFB
VUFBQUE4QVZ3ZUhVQVF5QUlDQVR3QXdkQVJ6QW5VQWZ3QkE9PSIpLAoJCn0KCmZ1bmN0aW9uIG1h
a2VfdG9nZ2xlX2J1dHRvbihlbCkKCWxvY2FsIGVsID0gZWwgb3Ige30KCWVsLndpZHRoID0gZWwu
d2lkdGggb3IgNwoJZWwuaGVpZ2h0ID0gZWwuaGVpZ2h0IG9yIDcKCWVsLnNldCA9IGVsLnNldCBv
ciBmdW5jdGlvbigpIGVuZAoJZWwuZ2V0ID0gZWwuZ2V0IG9yIGZ1bmN0aW9uKCkgZW5kCgkKCWVs
LmN1cnNvciA9ICJwb2ludGVyIgoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlsb2NhbCBiID0gZWwu
Ym1wMAoJCWlmIChzZWxmLmdldCgpIGFuZCBlbC5ibXAxKSBiID0gZWwuYm1wMQoJCWxvY2FsIGNv
bCA9IHNlbGYuZ2V0KCkgYW5kIDcgb3IgMTMKCQlwYWwoNyxjb2wpCgkJc3ByKGIsIDAsIDApCgkJ
cGFsKCkKCWVuZAoJCglmdW5jdGlvbiBlbDpjbGljaygpCgkJZWwuc2V0KG5vdCBlbC5nZXQoKSkK
CWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKCmZ1bmN0aW9uIG1ha2Vfb3BlcmF0aW9uX2J1dHRvbihl
bCkKCWxvY2FsIGVsID0gZWwgb3Ige30KCWVsLndpZHRoID0gZWwud2lkdGggb3IgNwoJZWwuaGVp
Z2h0ID0gZWwuaGVpZ2h0IG9yIDcKCQoJZWwuY3Vyc29yID0gInBvaW50ZXIiCgkKCWZ1bmN0aW9u
IGVsOmRyYXcoKQoJCWxvY2FsIGIgPSBlbC5ibXAwCgkJbG9jYWwgY29sID0gNwoJCXBhbCg3LGNv
bCkKCQlzcHIoYiwgMCwgMCkKCQlwYWwoKQoJZW5kCgkKCXJldHVybiBlbAplbmQKCgotLSAob25s
eSBuZWVkIHRvIGNoYW5nZSB3aWR0aCB0byBnbyBmcm9tIDEyeDggLT4gMjR4MTYpCmZ1bmN0aW9u
IHJlc2l6ZV9tYXAoaW5kZXgsIHdpZHRoLCBoZWlnaHQpCgktLSBub3RlOiB1c2VyZGF0YSBvbmx5
IHRha2VzIG51bWJlcnMgZm9yIHNpemVzLCBub3Qgc3RyaW5ncyAoISkKCWlmICh3aWR0aCkgd2lk
dGg9dG9udW0od2lkdGgpCglpZiAoaGVpZ2h0KSBoZWlnaHQ9dG9udW0oaGVpZ2h0KQoJCglsb2Nh
bCB3dyA9IGl0ZW1baW5kZXhdLmJtcDp3aWR0aCgpCglsb2NhbCBoaCA9IGl0ZW1baW5kZXhdLmJt
cDpoZWlnaHQoKQoJbG9jYWwgYXNwZWN0ID0gd3cgLyBoaAoJbG9jYWwgd3cgPSB0b251bSh3aWR0
aCkgb3Igd3cKCWxvY2FsIGhoID0gdG9udW0oaGVpZ2h0KSBvciBoaAoJCglpZiAobG9ja19hc3Bl
Y3QpIHRoZW4KCQlpZiAobm90IHdpZHRoKSAgd2lkdGggID0gaGggKiBhc3BlY3QKCQlpZiAobm90
IGhlaWdodCkgaGVpZ2h0ID0gd3cgLyBhc3BlY3QKCWVsc2UKCQl3aWR0aCA9IHdpZHRoIG9yIHd3
CgkJaGVpZ2h0ID0gaGVpZ2h0IG9yIGhoCgllbmQKCQoJaWYgKHdpZHRoIDwgMSBvciB3aWR0aCA_
IDgxOTIgb3IKCQloZWlnaHQgPCAxIG9yIGhlaWdodCA_IDgxOTIgb3IKCQl3aWR0aCAqIGhlaWdo
dCA_IDEwMjQqMTAyNCkgdGhlbgoJCS0tIHRvIGRvOiBlcnJvciAiYmFkIHNpemUiIG9yICJ0b28g
YmlnIgoJCXJldHVybgoJZW5kCgkJCglsb2NhbCBvbGQgPSBpdGVtW2luZGV4XS5ibXAKCWxvY2Fs
IG5ldyA9IHVzZXJkYXRhKCJ1MTYiLCB3aWR0aCwgaGVpZ2h0KQoJCglibGl0KG9sZCwgbmV3LCAw
LDAsIAoJCW5ldzp3aWR0aCgpXDIgLSBvbGQ6d2lkdGgoKVwyLAoJCW5ldzpoZWlnaHQoKVwyIC0g
b2xkOmhlaWdodCgpXDIKCSkKCQoJaXRlbVtpbmRleF0uYm1wID0gbmV3CgkKCXJlZnJlc2hfZ3Vp
ID0gdHJ1ZQoJc2V0X2N1cnJlbnRfaXRlbSgpCmVuZAoKZnVuY3Rpb24gbW92ZV9sYXllcihpbmRl
eCwgZGluZGV4KQoJbG9jYWwgaTEgPSBpbmRleCArIGRpbmRleAoJaWYgKGkxIDwgMSBvciBpMSA_
ICNpdGVtKSByZXR1cm4KCWl0ZW1baTFdLGl0ZW1baW5kZXhdID0gaXRlbVtpbmRleF0saXRlbVtp
MV0KCWlmIChjdXJyZW50X2l0ZW0gPT0gaTEpIHRoZW4KCQlzZXRfY3VycmVudF9pdGVtKGluZGV4
KQoJZWxzZWlmIGN1cnJlbnRfaXRlbSA9PSBpbmRleCB0aGVuCgkJc2V0X2N1cnJlbnRfaXRlbShp
MSkKCWVuZAoJCglyZWZyZXNoX2d1aSA9IHRydWUKZW5kCgoKLS0gbm90ZTogbm9ybWFsbHkgb25s
eSBuZWVkIDwgfjQgbGF5ZXJzLCBzbwotLSBzY3JvbGxiYXIgd291bGQgYmUgbm9ybWFsbHkgbm90
IG5lZWRlZAotLSBwbGFjZWhvbGRlci4gd2lsbCBoYXZlOiBsYXllciBuYW1lLCB2aXNpYmxlLCBb
cGFyZW50IC8gdHJlZSBzdHJ1Y3R1cmVdCi0tICoqIGVhY2ggbGF5ZXIgaGFzIGEgdHlwZSB0aGF0
IGluZmx1ZW5jZXMgdWkgKioKZnVuY3Rpb24gY3JlYXRlX2xheWVyX25hdihlbCkKCglsb2NhbCBp
dGVtX2ggPSA4CgkKCWVsID0gZ3VpOm5ldyhlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCXJlY3Rm
aWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwwKQoJCWxvY2FsIHl5ID0gMgoJCWZv
ciBpPTEsI2l0ZW0gZG8KCQkJbG9jYWwgc2VsZWN0ZWQgPSBpID09IGN1cnJlbnRfaXRlbQoJCQls
YWJlbCA9IGl0ZW1baV0ubmFtZSBvciAiW2xheWVyICIuLmkuLiJdIgoJCQlpZiAoc2VsZWN0ZWQg
YW5kIG5vdCBsYXllcl9uYW1lX2VkaXRvcikgcmVjdGZpbGwoNCx5eSxzZWxmLndpZHRoLTUseXkr
NiwxMikKCQkJCgkJCWNsaXAoZWwuc3gsZWwuc3ksNSs3MiwxMDAwKQoJCQlwcmludChsYWJlbCw1
LHl5KzEsIGkgPT0gMCBhbmQgNyBvciA2KQoJCQljbGlwKCkKCQkJc3ByKGl0ZW1baV0uaGlkZGVu
IGFuZCBpY29ucy5oaWRkZW4xIG9yIGljb25zLmhpZGRlbjAsc2VsZi53aWR0aC0xNCx5eSkKCQkJ
c3ByKGljb25zLmVkaXQsc2VsZi53aWR0aC0yNix5eSkKCQkJcGFsKDcsMTMpCgkJCXNwcihpY29u
cy5sYXllcl91cCxzZWxmLndpZHRoLTM4LHl5KQoJCQlzcHIoaWNvbnMubGF5ZXJfZG93bixzZWxm
LndpZHRoLTQ4LHl5KQoJCQlwYWwoNyw3KQoJCQkKCQkJeXkgKz0gaXRlbV9oCgkJZW5kCgkJCgll
bmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2sobXNnKQoJCWlmIChsYXllcl9uYW1lX2VkaXRvcikgcmVm
cmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJZnVuY3Rpb24gZWw6ZG91YmxldGFwKG1zZykKCQktLSBz
YW1lIGFzIHRhcCBvbiBlZGl0IGJ1dHRvbgoJCW1zZy5teCA9IHNlbGYud2lkdGgtMjkKCQllbDp0
YXAobXNnKQoJZW5kCgkKCQoJZnVuY3Rpb24gZWw6dGFwKG1zZykKCQlsb2NhbCBpbmRleCA9IDEg
KyAobXNnLm15IC0gMikgXCBpdGVtX2gKCQlpbmRleCA9IG1pZCgxLCBpbmRleCwgI2l0ZW0pCgkJ
aWYgKG1zZy5teCA_IHNlbGYud2lkdGggLSAxOCkgdGhlbgoJCQlpdGVtW2luZGV4XS5oaWRkZW4g
PSBub3QgaXRlbVtpbmRleF0uaGlkZGVuCgkJZWxzZWlmIChtc2cubXggPiBzZWxmLndpZHRoIC0g
MzApIHRoZW4KCQkJcmVhZHRleHQodHJ1ZSkgLS0gY2xlYXIgaW5wdXQgYnVmZmVyICh0byBkbzpz
aG91bGQgYXR0YWNoX3RleHRfZWRpdG9yIGRvIHRoYXQ-KQoJCQlsYXllcl9uYW1lX2VkaXRvciA9
IGVsOmF0dGFjaF90ZXh0X2VkaXRvcnsKCQkJCXg9MiwgeT0gMCsgKGluZGV4LTEpKml0ZW1faCwg
d2lkdGg9NzQsIGhlaWdodD0gOSwgCgkJCQlibG9ja19zY3JvbGxpbmcgPSB0cnVlLCBtYXhfbGlu
ZXMgPSAxLAoJCQkJa2V5X2NhbGxiYWNrID0gewoJCQkJCWVudGVyID0gZnVuY3Rpb24gKCkgCgkJ
CQkJCWl0ZW1baW5kZXhdLm5hbWUgPSBsYXllcl9uYW1lX2VkaXRvcjpnZXRfdGV4dCgpWzFdCgkJ
CQkJCWxheWVyX25hbWVfZWRpdG9yID0gbmlsCgkJCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQkJ
CWVuZAoJCQkJfSwKCQkJCS0tIGJsb2NrIG1vdXNlIG1lc3NhZ2VzIGZyb20gc2VsZWN0aW5nIG90
aGVyIGxheWVycwoJCQkJY2xpY2sgPSBmdW5jdGlvbigpIHJldHVybiB0cnVlIGVuZCwKCQkJCXRh
cCA9IGZ1bmN0aW9uKCkgcmV0dXJuIHRydWUgZW5kCgkJCX0KCQkJbGF5ZXJfbmFtZV9lZGl0b3I6
c2V0X3RleHQoeyhpdGVtW2luZGV4XS5uYW1lIG9yICIiKX0pCgkJCWxheWVyX25hbWVfZWRpdG9y
OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoJCQlsYXllcl9uYW1lX2VkaXRvcjpzZXRfY3Vyc29y
KDEwMDAsMSkKCQkJd2luZG93e2NhcHR1cmVfZXNjYXBlcyA9IHRydWV9CgkJCQoJCWVsc2VpZiAo
bXNnLm14ID4gc2VsZi53aWR0aCAtIDQyKSB0aGVuCgkJCW1vdmVfbGF5ZXIoaW5kZXgsIC0xKQoJ
CWVsc2VpZiAobXNnLm14ID4gc2VsZi53aWR0aCAtIDUyKSB0aGVuCgkJCW1vdmVfbGF5ZXIoaW5k
ZXgsIDEpCgkJZWxzZQoJCQlzZXRfY3VycmVudF9pdGVtKGluZGV4KQoJCWVuZAoJZW5kCgoJcmV0
dXJuIGVsCmVuZAoKZnVuY3Rpb24gY3JlYXRlX2xheWVyX2luZm8oZWwpCgllbCA9IGd1aTpuZXco
ZWwpCgkKCWxvY2FsIHh4ID0gMjAgKyAyNAoJbG9jYWwgeXkgPSAwCgkKCS0tIG1hcCB3aWR0aAoJ
ZWw6YXR0YWNoX2ZpZWxkCgl7CgkJeD14eCx5PXl5LHdpZHRoPTIwLGhlaWdodD03LAoJCWdldD1m
dW5jdGlvbigpIHJldHVybiBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wOndpZHRoKCkgZW5kLAoJCXNl
dD1mdW5jdGlvbihzZWxmLHZhbCkKCQkJYmFja3VwX3N0YXRlKCkKCQkJcmVzaXplX21hcChjdXJy
ZW50X2l0ZW0sIHZhbCwgbmlsKQoJCWVuZCwKCQlsYWJlbD0ibGF5ZXIgc2l6ZToiCgl9CgkKCS0t
IHRvZ2dsZSBhc3BlY3QgbG9jawoJZWw6YXR0YWNoKG1ha2VfdG9nZ2xlX2J1dHRvbnsKCQl4PXh4
KzIxLHk9MCwKCQlibXAwPXVzZXJkYXRhKGljb25zLmxvY2swKSwKCQlibXAxPXVzZXJkYXRhKGlj
b25zLmxvY2sxKSwKCQlzZXQ9ZnVuY3Rpb24odmFsKSBsb2NrX2FzcGVjdCA9IHZhbCBlbmQsCgkJ
Z2V0PWZ1bmN0aW9uKCkgcmV0dXJuIGxvY2tfYXNwZWN0IGVuZCwKCX0pCgkKCS0tIG1hcCBoZWln
aHQKCWVsOmF0dGFjaF9maWVsZHsKCQl4PXh4KzI5LHk9eXksd2lkdGg9MjAsaGVpZ2h0PTcsCgkJ
Z2V0PWZ1bmN0aW9uKCkgcmV0dXJuIGl0ZW1bY3VycmVudF9pdGVtXS5ibXA6aGVpZ2h0KCkgZW5k
LAoJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgCgkJCWJhY2t1cF9zdGF0ZSgpCgkJCXJlc2l6ZV9t
YXAoY3VycmVudF9pdGVtLCBuaWwsIHZhbCkKCQllbmQsCgkJbGFiZWw9IiIKCX0KCQoJLS0gYWRk
IGxheWVyCgllbDphdHRhY2gobWFrZV9vcGVyYXRpb25fYnV0dG9uewoJCXg9eHgrNjAseT0wLAoJ
CWJtcDA9aWNvbnMuYWRkX2xheWVyLAoJCXRhcD1mdW5jdGlvbigpCgkJCWlmICgjaXRlbSA_PSA2
KSB0aGVuCgkJCQlub3RpZnkoIm1heGltdW06IDYgbGF5ZXJzIikKCQkJCXJldHVybgoJCQllbmQK
CQkJYmFja3VwX2xheWVycygpCgkJCS0tcHJpbnRoKHBvZChpdGVtW2N1cnJlbnRfaXRlbV0uYm1w
KSkKCQkJbG9jYWwgbmV3X2l0ZW0gPSB7fQoJCQlmb3Igayx2IGluIHBhaXJzKGNpKSBkbwoJCQkJ
bmV3X2l0ZW1ba10gPSB1bnBvZChwb2QodikpCgkJCWVuZAoJCQlhZGRfdW5kb19zdGFjayhuZXdf
aXRlbSkKCQkJbmV3X2l0ZW0ubmFtZSA9IG5pbAoJCQluZXdfaXRlbS5ibXA6Y2xlYXIoKQoJCQkK
CQkJYWRkKGl0ZW0sIG5ld19pdGVtLCBjdXJyZW50X2l0ZW0rMSkKCQkJcmVmcmVzaF9ndWkgPSB0
cnVlCgkJZW5kCgl9KQoJCgktLSBkZWxldGUgbGF5ZXIKCWVsOmF0dGFjaChtYWtlX29wZXJhdGlv
bl9idXR0b257CgkJeD14eCs3Mix5PTAsCgkJYm1wMD1pY29ucy5kZWxfbGF5ZXIsCgkJdGFwPWZ1
bmN0aW9uKCkKCQkJaWYgKCNpdGVtID4gMSkgdGhlbgoJCQkJYmFja3VwX2xheWVycygpCgkJCQlk
ZWxpKGl0ZW0sIGN1cnJlbnRfaXRlbSkKCQkJCXNldF9jdXJyZW50X2l0ZW0oKQoJCQllbHNlCgkJ
CQlub3RpZnkoIm11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGF5ZXIiKQoJCQllbmQKCQllbmQKCX0p
CgkJCglyZXR1cm4gZWwJCmVuZAoKbG9jYWwgbWFwMXgxID0gdXNlcmRhdGEoImkxNiIsMSwxKQoK
CmZ1bmN0aW9uIGNyZWF0ZV9pdGVtX2luZm8oZWwpCgllbCA9IGd1aTpuZXcoZWwpCglmdW5jdGlv
biBlbDpkcmF3KCkKCQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgMTMp
CgllbmQKCQoJLS0gcHJldmlldyB0aHVtYgoJZWw6YXR0YWNoewoJCXg9MCx5PTAsd2lkdGg9MTYs
aGVpZ2h0PTE2LAoJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJcmVjdGZpbGwoMCwwLDIzLDIzLDAp
CgkJCWxvY2FsIGIgPSBnZXRfc3ByKGNvbCYweDFmZmYpCgkJCW1hcDF4MVswXSA9IGNvbAoJCQlp
ZiBub3QgYiB0aGVuCgkJCQlwcmludCgiPyIsMSwxLDUpCgkJCWVsc2VpZiAoY29sICYgMHgyMDAw
KSA_IDAgb3IgdHJ1ZSB0aGVuCgkJCQktLSBwbGFjZWhvbGRlciB0aHVtYiB0aGF0IGNhbiBoYW5k
bGUgcm90YXRpb24gCgkJCQktLSAoYnV0IHN0cmV0Y2hlcyB3aGVuIHchPWgpCgkJCQltYXAobWFw
MXgxLDAsMCwKCQkJCQlzZWxmLndpZHRoLzIgLSBiOndpZHRoKCkvMiwgCgkJCQkJc2VsZi5oZWln
aHQvMi1iOmhlaWdodCgpLzIsCgkJCQkJMSwxLDAsYjp3aWR0aCgpLGI6aGVpZ2h0KCkKCQkJCSkK
CQkJZWxzZQoJCQkJLS0gY2VudGVyZWQsIG5vdCBzdHJldGNoZWQKCQkJCXNwcihiLHNlbGYud2lk
dGgvMiAtIGI6d2lkdGgoKS8yLCBzZWxmLmhlaWdodC8yLWI6aGVpZ2h0KCkvMiwKCQkJCQljb2wm
MHg0MDAwID4gMCwgY29sJjB4ODAwMCA_IDAKCQkJCSkKCQkJZW5kCgkJZW5kLAoJCXRhcD1mdW5j
dGlvbihzZWxmKQoJCQljdXJyZW50X2JhbmsgPSBjb2xcMjU2CgkJCWN1cnJlbnRfYmFua19wYWdl
ID0gKGNvbCYweGZmKVw2NAoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCX0KCQoJbG9jYWwg
eHgwID0gMjAKCWxvY2FsIHl5ICA9IDAKCWxvY2FsIGhleF9tb2RlID0gdHJ1ZQoJCQoJLS0gaW5k
ZXggKGlzIDE2LWJpdCBpbmRleCBpbiBtYXAgZWRpdG9yKQoJLS0gdG8gZG86IHRvZ2dsZSBoZXgg
bW9kZSAvIGRlY2ltYWwgbW9kZQoJZWw6YXR0YWNoewoJCXg9eHgwLHk9eXksd2lkdGg9MjcsaGVp
Z2h0PTcsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQlsb2NhbCBiPSBpdGVtW2N1cnJlbnRfaXRl
bV0uYm1wCgkJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwxMykKCQkJ
bG9jYWwgc3RyID0gaGV4X21vZGUgYW5kCgkJCQlzdHJpbmcuZm9ybWF0KCIwWCUwNHgiLGNvbCAm
IDB4ZmZmZikgb3IKCQkJCXN0cmluZy5mb3JtYXQoIiVkIixjb2wgJiAweDFmZmYpIC0tIGRlY2lt
YWw6IGhpZGUgb3JpZW50YXRpb24gYml0cwoJCQlwcmludChzdHIsc2VsZi53aWR0aC0xLSNzdHIq
NCwxLDcpCgkJZW5kLAoJCXRhcD1mdW5jdGlvbihzZWxmKQoJCQloZXhfbW9kZSA9IG5vdCBoZXhf
bW9kZQoJCWVuZAoJfQoJCgktLSBiYW5rIHNlbGVjdGlvbiBwbGFjZWhvbGRlcgoJLS0gY2xpY2sg
dG8gY2hvb3NlIGZpbGUKCS0tIG1heWJlIHBpbiBwYWdlcyAvIGZpbGVzPyAKCS0tIChjcmVhdGUg
cHJpbWFyeSBzZXQgb2YgdGFicywgd2hlcmUgcGFnZXMgYXJlIHNlY29uZGFyeSkKCWVsOmF0dGFj
aHsKCQl4PXh4MCArIDUyLHk9eXksd2lkdGg9NDgsaGVpZ2h0PTcsCgkJZHJhdz1mdW5jdGlvbihz
ZWxmKQoJCQlsb2NhbCBiPSBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wCgkJCXJlY3RmaWxsKDAsMCxz
ZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwxKQoJCQkKCQkJbG9jYWwgZ2Z4X2ZuID0gZ2Z4X2Zp
bGVbY3VycmVudF9iYW5rXSBvciAiPz8iCgkJCQoJCQlwcmludChzdHJpbmcuZm9ybWF0KGdmeF9m
bjpiYXNlbmFtZSgpLGNvbCksMiwxLDEzKQoJCQkKCQllbmQKCX0KCQoJZWw6YXR0YWNoe3g9eHgw
ICsgNDIseT15eSx3aWR0aD04LGhlaWdodD03LGN1cnNvcj0icG9pbnRlciIsCgkJZHJhdz1mdW5j
dGlvbihzZWxmKQoJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMTMp
IHByaW50KCI8IiwyLDEsNykKCQllbmQsCgkJdGFwPWZ1bmN0aW9uKHNlbGYpIHNldF9jdXJyZW50
X2JhbmsobmlsLCAtMSkgZW5kCgl9CgkKCWVsOmF0dGFjaHt4PXh4MCArIDEwMSx5PXl5LHdpZHRo
PTgsaGVpZ2h0PTcsY3Vyc29yPSJwb2ludGVyIiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCXJl
Y3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwxMykgcHJpbnQoIj4iLDIsMSw3
KQoJCWVuZCwKCQl0YXA9ZnVuY3Rpb24oc2VsZikgc2V0X2N1cnJlbnRfYmFuayhuaWwsIDEpIGVu
ZAoJfQoJCglyZXR1cm4gZWwKZW5kCgkKZnVuY3Rpb24gY3JlYXRlX2JhbmtfdGFicyhlbCkKCWVs
ID0gZ3VpOm5ldyhlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCS0tcmVjdCgwLDAsc2VsZi53aWR0
aC0xLCBzZWxmLmhlaWdodC0xLCAxMykKCWVuZAoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCB5X29m
ZnMgPSBpID09IGN1cnJlbnRfYmFua19wYWdlIGFuZCAwIG9yIDEKCQlsb2NhbCB0YWIgPSBlbDph
dHRhY2goewoJCQl4PWkqMTIseT15X29mZnMsd2lkdGg9MTEsaGVpZ2h0PWVsLmhlaWdodCAtIHlf
b2ZmcywKCQkJaW5kZXg9aSwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJCQlsb2NhbCBzZWwg
PSBjdXJyZW50X2JhbmtfcGFnZSA9PSBzZWxmLmluZGV4CgkJCQlyZWN0ZmlsbCgwLDAsc2VsZi53
aWR0aC0xLCBzZWxmLmhlaWdodC0xLCBzZWwgYW5kIDcgb3IgNikKCQkJCXBzZXQoMCwwLDUpCgkJ
CQlsaW5lKDAsMSwxLDAsNSkKCQkJCWxpbmUoMCwyLDIsMCw1KQoJCQkJCgkJCQlwc2V0KHNlbGYu
d2lkdGgtMSwwLDUpCgkJCQkKCQkJCWxpbmUoMCxzZWxmLmhlaWdodC0xLHNlbGYud2lkdGgtMSxz
ZWxmLmhlaWdodC0xLDEzKQoJCQkJcHJpbnQoc2VsZi5pbmRleCw1LDEsMTMpCgkJCWVuZCwKCQkJ
Y2xpY2sgPSBmdW5jdGlvbihzZWxmKQoJCQkJc2V0X2N1cnJlbnRfYmFua19wYWdlKHNlbGYuaW5k
ZXgsIDEpCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZW5kCgkJCQoJCX0pCgllbmQKCQoJcmV0
dXJuIGVsCmVuZAoKZnVuY3Rpb24gY3JlYXRlX25hdihlbCkKCglmdW5jdGlvbiBlbDpkcmF3KCkK
CQljbGlwKCkKCQlyZWN0ZmlsbCgtMSwtMSxzZWxmLndpZHRoLCBzZWxmLmhlaWdodCwgMCkKCgkJ
Zm9yIHk9MCw3IGRvCgkJCWZvciB4PTAsNyBkbwoJCQkJbG9jYWwgc2NhbGUgPSAxCgkJCQlsb2Nh
bCBibXAgPSBnZXRfc3ByKHggKyB5KjggKyBjdXJyZW50X2JhbmtfcGFnZSo2NCArIGN1cnJlbnRf
YmFuayoyNTYpCgkJCQlpZiAoYm1wKSB0aGVuCgkJCQkJbG9jYWwgd3csaGggPSBibXA6d2lkdGgo
KSwgYm1wOmhlaWdodCgpCgkJCQkJLS0gdG8gZG86IHRoaXMgbWFrZXMgdmVyeSB0aGluIGJtcHMg
aW52aXNpYmxlIGluIHByZXZpZXcKCQkJCQlzY2FsZSA9IDE2IC8gbWF4KHd3LGhoKQoJCQkJCWlm
IChzY2FsZSA_PSAxKSB0aGVuCgkJCQkJCXNjYWxlID0gc2NhbGUgXCAxCgkJCQkJZWxzZWlmIChz
Y2FsZSA_PSAwLjY2NikgdGhlbgoJCQkJCQlzY2FsZSA9IDEgLS0gdXAgdG8gMjR4MjQsIHN0aWxs
IHNob3cgcGl4ZWwgZm9yIHBpeGVsCgkJCQkJZW5kCgkJCQkJY2xpcChzZWxmLnN4ICsgeCoxNiwg
c2VsZi5zeSArIHkqMTYsIDE2LDE2KQoJCQkJCXNzcHIoYm1wLAoJCQkJCQkwLDAsbmlsLG5pbCwK
CQkJCQkJeCoxNiArIDggLSB3dyAqIHNjYWxlLzIsCgkJCQkJCXkqMTYgKyA4IC0gaGggKiBzY2Fs
ZS8yLAoJCQkJCQl3dypzY2FsZSwgaGgqc2NhbGUpCgkJCQllbmQKCQkJZW5kCgkJZW5kCgkJCgkJ
LS0gMC4yLjBkOiBkcmF3IHJlZ2lvbiB3aGVuIHZpZXdpbmcgc2FtZSBiYW5rCgoJCWlmIChyZWdp
b24gYW5kIHJlZ2lvbi5iYW5rID09IGN1cnJlbnRfYmFuaykgdGhlbgoJCQlsb2NhbCB4eCA9IHJl
Z2lvbi54ICogMTYKCQkJbG9jYWwgeXkgPSAocmVnaW9uLnkgLSBjdXJyZW50X2JhbmtfcGFnZSo4
KSAqIDE2CgkJCWxvY2FsIHd3ID0gcmVnaW9uLncgKiAxNgoJCQlsb2NhbCBoaCA9IHJlZ2lvbi5o
ICogMTYKCQkJY2xpcChlbC5zeC0yLGVsLnN5LTIsZWwud2lkdGgrNCxlbC5oZWlnaHQrNCkKCQkJ
cmVjdCh4eC0yLHl5LTIsIHh4K3d3KzEsIHl5K2hoKzEsIDApCgkJCXJlY3QoeHgtMSx5eS0xLCB4
eCt3dyswLCB5eStoaCswLCA3KQoJCWVuZAoJCQoJCS0tW1sKCQlsb2NhbCByY29sID0gY29sICYg
MHgxZmZmIC0tIHdpdGggb3JpZW50YXRpb24gYml0cyBzdHJpcHBlZAoJCWlmIChjdXJyZW50X2Jh
bmsgPT0gcmNvbFwyNTYgYW5kIGN1cnJlbnRfYmFua19wYWdlID09IChyY29sJjB4ZmYpXDY0KSB0
aGVuCgkJCQoJCQlsb2NhbCBpaSA9IChyY29sIC0gY3VycmVudF9iYW5rX3BhZ2UqNjQpICYgMHhm
ZgoJCQlsb2NhbCB4eCA9IChpaSAlIDgpICogMTYKCQkJbG9jYWwgeXkgPSAoaWkgXCA4KSAqIDE2
CgkKCQkJY2xpcCgpCgkJCQoJCQlyZWN0KHh4LTIseXktMix4eCsxNyx5eSsxNywwKQoJCQlyZWN0
KHh4LTEseXktMSx4eCsxNix5eSsxNiw3KQoJCWVuZAoJCV1dCgkJCgllbmQKCQoJLS0gc2VsZWN0
IHNwcml0ZQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgcnggPSBtaWQoMCxtc2cubXgg
KiA4IFwgc2VsZi53aWR0aCw3KQoJCWxvY2FsIHJ5ID0gbWlkKDAsbXNnLm15ICogOCBcIHNlbGYu
aGVpZ2h0LCA3KSArIGN1cnJlbnRfYmFua19wYWdlKjgKCQlsb2NhbCBpID0gcnggKyByeSAqIDgK
CQljb2wgPSBpICsgY3VycmVudF9iYW5rKjI1NgoJCQoJCWlmIGtleSJzaGlmdCIgdGhlbgoJCQkt
LSBleHRlbmQgcmVnaW9uCgkJCQoJCQlyeDA9bWluKHJ4LCByZWdpb24ueDApCgkJCXJ5MD1taW4o
cnksIHJlZ2lvbi55MCkKCQkJcmVnaW9uID0gewoJCQkJeD1yeDAsIHk9cnkwLAoJCQkJdz1tYXgo
cngscmVnaW9uLngwKS1yeDArMSwKCQkJCWg9bWF4KHJ5LHJlZ2lvbi55MCktcnkwKzEsCgkJCQl4
MD1yZWdpb24ueDAsIHkwPXJlZ2lvbi55MCwKCQkJCWJhbmsgPSByZWdpb24uYmFuawoJCQl9Ci0t
CQkJcHJpbnRoKCJzZXQgcmVnaW9uIG9uIGRyYWc6ICIuLnBvZChyZWdpb24pKQoJCWVsc2UJCgkJ
CXJlZ2lvbj17CgkJCQl4PXJ4LCB5PXJ5LCB3PTEsIGg9MSwgeDA9cmVnaW9uLngwLCB5MD1yZWdp
b24ueTAsCgkJCQliYW5rID0gcmVnaW9uLmJhbmsKCQkJfQoJCWVuZAoJCQoJZW5kCgkKCWZ1bmN0
aW9uIGVsOmNsaWNrKG1zZykKCQktLSByZXNldCByZWdpb24gZXZlbiBpZiBzaGlmdC1jbGlja2lu
ZyAocDggYmVoYXZpb3VyKQoJCWxvY2FsIHJ4ID0gbXNnLm14ICogOCBcIHNlbGYud2lkdGgKCQls
b2NhbCByeSA9IG1zZy5teSAqIDggXCBzZWxmLmhlaWdodCArIChjdXJyZW50X2JhbmtfcGFnZSo4
KQoJCXJlZ2lvbj17CQoJCQl4PXJ4LCB5PXJ5LCB3PTEsIGg9MSwgeDA9cngsIHkwPXJ5LAoJCQli
YW5rID0gY3VycmVudF9iYW5rCgkJfQotLQkJcHJpbnRoKCJzZXQgcmVnaW9uIG9uIGNsaWNrOiAi
Li5wb2QocmVnaW9uKSkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKCjo6IHBhbC5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wNS0xMSAwMjowNTowMSIsbW9kaWZpZWQ9IjIw
MjQtMDMtMDYgMDU6Mzc6MTYiLHJldmlzaW9uPTU2OCxzdG9yZWQ9IjIwMjMtMTEtMjggMDM6MTE6
MTkiXV0KbG9jYWwgcGNvbHMgPSB7WzBdPQoJMCwxOSwzLDI3LCAgMTEsMjYsMTAsMjMsCgkxLDE3
LDEyLDI4LCAxOCwxNiwxMywyOSwKCTIsMzAsMTQsMzEsIDI0LDgsMjUsOSwKCTIwLDQsMjEsMTUs
IDUsMjIsNiw3LAp9CgpwY29sc19jb250aW51b3VzID0ge1swXSA9CgkwLDIwLDQsMzEsMTUsOCwy
NCwyLAoJMjEsNSwyMiw2LDcsMjMsMTQsMzAsCgkxLDE2LDE3LDEyLDI4LDI5LDEzLDE4LAoJMTks
MywyNywxMSwyNiwxMCw5LDI1LAp9CgpwY29sc19pZGVudGl0eSA9IHtbMF0gPQoJMCwxLDIsMyw0
LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwKCTE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0
LDI1LDI2LDI3LDI4LDI5LDMwLDMxCn0KCgoKZnVuY3Rpb24gY3JlYXRlX3BhbF90YWJzKGVsKQoK
CWVsID0gZ3VpOm5ldyhlbCkKCglmdW5jdGlvbiBlbDpkcmF3KCkKCQktLXJlY3QoMCwwLHNlbGYu
d2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgMTMpCgllbmQKCQoJbG9jYWwgc3dhdGNoX25hbWU9e1sw
XT0iXiIsIl4ifQoJCglmb3IgaT0wLDEgZG8KCQlsb2NhbCB5X29mZnMgPSBpID09IHBhbF9zd2F0
Y2ggYW5kIDAgb3IgMQoJCWxvY2FsIHRhYiA9IGVsOmF0dGFjaCh7CgkJCXg9aSoxMix5PXlfb2Zm
cyx3aWR0aD0xMSxoZWlnaHQ9ZWwuaGVpZ2h0IC0geV9vZmZzLAoJCQlpbmRleD1pLAoJCQlkcmF3
ID0gZnVuY3Rpb24oc2VsZikKCQkJCWxvY2FsIHNlbCA9IHBhbF9zd2F0Y2ggPT0gc2VsZi5pbmRl
eAoJCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgc2VsIGFuZCA2
IG9yIDEzKQoJCQkJcHNldCgwLDAsNSkKCQkJCWxpbmUoMCwxLDEsMCw1KQoJCQkJbGluZSgwLDIs
MiwwLDUpCgkJCQkKCQkJCXBzZXQoc2VsZi53aWR0aC0xLDAsNSkKCQkJCQoJCQkJbGluZSgwLHNl
bGYuaGVpZ2h0LTEsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMTMpCgkJCQlwcmludChzd2F0
Y2hfbmFtZVtzZWxmLmluZGV4XSw1LDEsNSkKCQkJCQoJCQllbmQsCgkJCQoJCQljbGljayA9IGZ1
bmN0aW9uKHNlbGYpCgkJCQlwYWxfc3dhdGNoID0gc2VsZi5pbmRleAoJCQkJcmVmcmVzaF9ndWkg
PSB0cnVlCgkJCWVuZAoJCQkKCQl9KQoJZW5kCgkKCgkKCXJldHVybiBlbAplbmQKCgoKLS1mb3Ig
aT0wLDYzIGRvIHBjb2xzW2ldPWkgZW5kCgotLVtbCnBjb2xzWzIyXSxwY29sc1syMV09cGNvbHNb
MjFdLHBjb2xzWzIyXQpwY29sc1sxNl0scGNvbHNbMTddLHBjb2xzWzE4XSA9IHBjb2xzWzE4XSwg
cGNvbHNbMTZdLHBjb2xzWzE3XQpdXQoKcGFsX3N3YXRjaCA9IDEKCmZ1bmN0aW9uIGNyZWF0ZV9w
YWxldHRlKGVsKQoKCS0tIGlkZW50aXR5Cglmb3IgaT0wLDYzIGRvIHBjb2xzW2ldID0gaSBlbmQK
CQoJaWYgcGFsX3N3YXRjaCA9PSAxIHRoZW4KCQlmb3IgaT0wLDYzIGRvIAoJCQlwY29sc1tpXSA9
IHBjb2xzX2NvbnRpbnVvdXNbaVwyXSBvciAwIAoJCWVuZAoJZW5kCgkKCS0tIHRvIGRvOiBhZGFw
dGl2ZQoJbG9jYWwgZXByID0gMTYKCWxvY2FsIHd3ID0gZWwud2lkdGggLyBlcHIKCWxvY2FsIGho
ID0gZWwuaGVpZ2h0IC8gNAoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQljbGlwKCkKCQkKCQlyZWN0
ZmlsbCgwLDAsc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQsIDApCgkJcmVjdGZpbGwoLTEsLTEsc2Vs
Zi53aWR0aCwgc2VsZi5oZWlnaHQsIDApCgkJCgkJZm9yIHk9MCw2NFxlcHItMSBkbwoJCQlmb3Ig
eD1lcHItMSwwLC0xIGRvCgkJCQlyZWN0ZmlsbCh4ICogd3csIHkgKiBoaCwgeCAqIHd3ICsgd3ct
MSwgeSAqIGhoICsgaGgtMSwgCgkJCQlwY29sc1t4ICsgeSplcHJdKQoJCQkJaWYgKHBjb2xzW3gg
KyB5KmVwcl0gPT0gY29sKSB0aGVuCgkJCQkJbG9jYWwgeHggPSB4ICogd3cKCQkJCQlsb2NhbCB5
eSA9IHkgKiBoaAoJCQkJCWlmIChwYWxfc3dhdGNoID09IDAgb3IgeCUyID09IDApIHRoZW4KCQkJ
CQkJcmVjdCh4eCswLHl5KzAseHgrd3cqKDErcGFsX3N3YXRjaCktMSx5eStoaC0xLDcpCgkJCQkJ
CXJlY3QoeHgrMSx5eSsxLHh4K3d3KigxK3BhbF9zd2F0Y2gpLTIseXkraGgtMiwwKQoJCQkJCWVu
ZAoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJCQoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRyYWcobXNn
KQoJCWxvY2FsIHh4ID0gbXNnLm14IFwgd3cKCQlsb2NhbCB5eSA9IG1zZy5teSBcIGhoCgkJY29s
ID0gcGNvbHNbeHggKyB5eSAqIGVwcl0gb3IgMAoJZW5kCgkKCQoJcmV0dXJuIGVsCmVuZAoKCgoK
CgoKCgoKCjo6IHVuZG8ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAt
MTQgMDM6Mjk6MjciLG1vZGlmaWVkPSIyMDI1LTA5LTA4IDIxOjM4OjE2IixyZXZpc2lvbj0zMDM3
XV0KbG9jYWwgbGF5ZXJzX3NuYXBzaG90ID0gbmlsCmxvY2FsIGxheWVyX29wID0gZmFsc2UgLS0g
bmV4dCB0aGluZyB0byB1bmRvIGlzIGEgbGF5ZXIgb3BlcmF0aW9uCgpmdW5jdGlvbiBhZGRfdW5k
b19zdGFjayhpaSkKCS0tIGZvcm1hdCAweDgxOiBybGUgKHdhcyAweDExKQoJLS0gMHgxMSBpcyBn
b29kIGZvciBnZW5lYXRpbmcgc21hbGxlciBwYXRjaGVzLCBidXQgcXVpY2tseSBjb25zdW1lcyBt
ZW1vcnkKCS0tIHRvIHN0b3JlIHN0YXRlIGZvciBsYXJnZSBtYXBzIHdpdGggbXVsdGlwbGUgbGF5
ZXJzLgoJaWkudW5kb19zdGFjayA9IGNyZWF0ZV91bmRvX3N0YWNrKHVuZG9fc2F2ZV9zdGF0ZSwg
dW5kb19sb2FkX3N0YXRlLCAweDgxLCBpaSkKZW5kCmZ1bmN0aW9uIHVuZG9fc2F2ZV9zdGF0ZShp
aSkKCXJldHVybiB7CgkJaWkuYm1wOmNvcHkoKSwKCQlpaS5zZWwgYW5kIGlpLnNlbDpjb3B5KCks
CgkJaWkubGF5ZXIwIGFuZCBpaS5sYXllcjA6Y29weSgpLAoJCWlpLmxheWVyIGFuZCBpaS5sYXll
cjpjb3B5KCksCgkJaWkubGF5ZXJfeCBvciAwLAoJCWlpLmxheWVyX3kgb3IgMCwKCQlpaS5wYW5f
eCwKCQlpaS5wYW5feSwKCQlpaS56b29tCgl9CmVuZApmdW5jdGlvbiB1bmRvX2xvYWRfc3RhdGUo
cywgaWkpCglpaS5ibXAgPSBzWzFdIG9yIHVzZXJkYXRhKCJ1OCIsMTYsMTYpCglpaS5zZWwgPSAg
IHNbMl0gb3IgbmlsCglpaS5sYXllcjAgPSBzWzNdIG9yIG5pbAoJaWkubGF5ZXIgPSBzWzRdIG9y
IG5pbAoJaWkubGF5ZXJfeCA9IHNbNV0KCWlpLmxheWVyX3kgPSBzWzZdCglpaS5wYW5feCA9IHNb
N10gb3IgMAoJaWkucGFuX3kgPSBzWzhdIG9yIDAKCWlpLnpvb20gPSBzWzldIG9yIDEKZW5kCgpm
dW5jdGlvbiBiYWNrdXBfc3RhdGUoKQoJbG9jYWwgaWkgPSBpdGVtW2N1cnJlbnRfaXRlbV0KCWxv
Y2FsIHR0MCA9IHN0YXQoMSkKCQoJaWkudW5kb19zdGFjazpjaGVja3BvaW50KCkKCi0tCXByaW50
aChzdHJpbmcuZm9ybWF0KCIlMy4zZiIsc3RhdCgxKS10dDApLi4iIC8vIHBhdGNoIHNpemU6Ii4u
Ci0tCQkjKGlpLnVuZG9fc3RhY2sudW5kb19zdGFja1sjaWkudW5kb19zdGFjay51bmRvX3N0YWNr
XSkpCgoJLS0gaW52YWxpZGF0ZSBhbnkgbGF5ZXIgb3AuIGNhbiByZWxlYXNlIGxheWVycyBzbmFw
c2hvdCB0b28KCS0tICh0aGV5IGNvdWxkIGJlIHRoZSBzYW1lIHRoaW5nKQoJbGF5ZXJfb3AgPSBm
YWxzZQoJbGF5ZXJzX3NuYXBzaG90ID0gbmlsCgkKZW5kCmZ1bmN0aW9uIHVuZG8oKQoJaWYgKGxh
eWVyX29wIGFuZCBsYXllcnNfc25hcHNob3QpIHRoZW4KCQktLSB1bmRvIGRlbGV0ZSBvciBhZGQg
bGF5ZXIKCQlsYXllcl9vcCA9IGZhbHNlIC0tIGNhbiBvbmx5IHVuZG8gbGF5ZXIgb3BlcmF0aW9u
IG9uY2UKCQlpdGVtID0gbGF5ZXJzX3NuYXBzaG90CgkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJc2V0
X2N1cnJlbnRfaXRlbSgpCgllbHNlCgkJLS0gcmVndWxhciB1bmRvIG9uIGEgc2luZ2xlIGxheWVy
CgkJbG9jYWwgaWkgPSBpdGVtW2N1cnJlbnRfaXRlbV0KCQlpaS51bmRvX3N0YWNrOnVuZG8oKQoJ
ZW5kCmVuZApmdW5jdGlvbiByZWRvKCkKCWxvY2FsIGlpID0gaXRlbVtjdXJyZW50X2l0ZW1dCglp
aS51bmRvX3N0YWNrOnJlZG8oKQplbmQKCgoKZnVuY3Rpb24gYmFja3VwX2xheWVycygpCglsYXll
cnNfc25hcHNob3QgPSB7fQoJZm9yIGk9MSwjaXRlbSBkbwoJCWFkZChsYXllcnNfc25hcHNob3Qs
IGl0ZW1baV0pCgllbmQKCWxheWVyX29wID0gdHJ1ZQplbmQKCjo6IHVwZGF0ZS5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMCAwNzo0NToyNiIsbW9kaWZpZWQ9IjIw
MjUtMDctMTMgMDE6Mjg6MDkiLHJldmlzaW9uPTM4MDNdXQoKLS0gdXBkYXRlIGxheW91dCB3aXRo
b3V0IG5lZWRpbmcgdG8gcmVnZW5lcmF0ZSBndWkKIC0tIHRvIGRvOiBjb3VsZCBhbHNvIHVzZSB0
aGlzIGZvciBoYW5kbGluZyBjaGFuZ2VzIGluIGRpc3BsYXkgc2l6ZQogZnVuY3Rpb24gdXBkYXRl
X2d1aV9sYXlvdXQoKQogCWlmIChub3Qgc2lkZWJhciBvciBub3QgY2FudmFzX2VsKSByZXR1cm4K
IAkKIAl4dCA9IHNob3dfcGFuZSBhbmQgMzM2IG9yIDQ4MAogCXNpZGViYXJfeCA9IHNpZGViYXJf
eCBvciBzaWRlYmFyLngKIAlzaWRlYmFyX3ggPSAoc2lkZWJhcl94ICogMyArIHh0KSAvIDQKIAkK
CWlmIChzaWRlYmFyX3ggPiB4dCkgdGhlbgoJCXNpZGViYXJfeCA9IG1heCh4dCwgc2lkZWJhcl94
IC0gOCkKCWVsc2UKCQlzaWRlYmFyX3ggPSBtaW4oeHQsIHNpZGViYXJfeCArIDgpCgllbmQKCQoJ
LS0gISEgaW5zdGFudCBjaGFuZ2UgLS0gbWF5YmUgYmV0dGVyIChzdGlsbCBnZXQgdG9vbGJhciB0
cmFuc2l0aW9uISkKCXNpZGViYXJfeCA9IHh0CgogCXNpZGViYXIueCA9IHNpZGViYXJfeCBcIDEK
IAlzaWRlYmFyLmhlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKIAoJY2FudmFzX2VsLndp
ZHRoID0gc2lkZWJhcl94IFwgMQoJY2FudmFzX2VsLmhlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVp
Z2h0KCkKIAoJLS0gc2VuZCBhIG1lc3NhZ2UgdG8gd20gYXNraW5nIHRvIHVuZG9jayAvIGRvY2sg
dG9vbGJhcgoJaWYgc2hvd19wYW5lIH49IGxhc3Rfc2hvd19wYW5lIHRoZW4JCgkJLS1zZW5kX21l
c3NhZ2UoMywge2V2ZW50PSJkb2NrX3Rvb2xiYXIiLCBzdGF0ZSA9IHNob3dfcGFuZX0pCgllbmQK
CWxhc3Rfc2hvd19wYW5lID0gc2hvd19wYW5lCiBlbmQKCgpmdW5jdGlvbiBnZXRfc2VsZWN0ZWRf
cmVnaW9uKCkKCWxvY2FsIHgwLHkwID0gMTAwMDAsIDEwMDAwCglsb2NhbCB4MSx5MSA9IDAsMAoJ
Zm9yIHkgPSAwLCBjYm1wX2hlaWdodC0xIGRvCgkJZm9yIHggPSAwLCBjYm1wX3dpZHRoLTEgZG8K
CQkJaWYgKGdldChjc2VsLCB4LCB5KSA_IDApIHRoZW4KCQkJCXgwID0gbWluKHgwLCB4KSB5MCA9
IG1pbih5MCwgeSkKCQkJCXgxID0gbWF4KHgxLCB4KSB5MSA9IG1heCh5MSwgeSkKCQkJZW5kIAoJ
CWVuZAoJZW5kCglpZiAoeDAgPT0gMTAwMDApIHgwLHkwLHgxLHkxID0gMCwgMCwgY2JtcF93aWR0
aC0xLCBjYm1wX2hlaWdodC0xCgkKCXJldHVybiB4MCwgeTAsIHgxLXgwKzEsIHkxLXkwKzEKZW5k
CgoKZnVuY3Rpb24gY29weV9zZWxlY3RlZF9yZWdpb24oKQoJbG9jYWwgeDAsIHkwLCB3dywgaGgg
PSBnZXRfc2VsZWN0ZWRfcmVnaW9uKCkKCWxvY2FsIG91dCA9IHVzZXJkYXRhKCJpMTYiLCB3dywg
aGgpCgktLXByaW50aChwb2R7eDAseTAsIHd3LGhofSkKCWJsaXQoY2JtcCwgb3V0LCB4MCwgeTAs
IDAsIDApCglyZXR1cm4gb3V0CmVuZAoKCmZ1bmN0aW9uIG1vdmVfc2VsZWN0aW9uKGR4LCBkeSkK
CQoJaWYgKG5vdCBjaS5sYXllcikgdGhlbgoJCS0tIGp1c3QgcGFuIChsb3VpcyBpbnN0aW5jdGl2
ZWx5IHRyaWVkIHRoaXMpCgkJaXRlbVsxXS5wYW5feCArPSBkeCAqIGl0ZW1bMV0uem9vbSAqIDQK
CQlpdGVtWzFdLnBhbl95ICs9IGR5ICogaXRlbVsxXS56b29tICogNAoJCXJldHVybgoJZW5kCgkK
CWJsaXQoY2kubGF5ZXIwLCBjYm1wKQoJY2kubGF5ZXJfeCArPSBkeAoJY2kubGF5ZXJfeSArPSBk
eQoJYmxpdChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSkKCQoJ
LS0gbmV3IHNlbGVjdGlvbgoJY3NlbDpjbGVhcigpCglsb2NhbCB3dywgaGggPSBjaS5sYXllcjph
dHRyaWJzKCkKCQoJc2V0X2RyYXdfdGFyZ2V0KGNzZWwpCglyZWN0ZmlsbChjaS5sYXllcl94LCBj
aS5sYXllcl95LCBjaS5sYXllcl94ICsgd3ctMSwgY2kubGF5ZXJfeSArIGhoLTEsIDEpCgljc2Vs
X291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQoJc2V0X2RyYXdfdGFyZ2V0KCkKZW5kCgogCmZ1
bmN0aW9uIGNsZWFyX3NlbGVjdGlvbigpCgliYWNrdXBfc3RhdGUoKQoJaWYgKGNzZWwpIGNzZWw6
Y2xlYXIoKQoJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZnJlc2gKCWNpLmxheWVyLCBjaS5iYWNr
ID0gbmlsLCBuaWwKZW5kCgpmdW5jdGlvbiBzZWxlY3RfYWxsKCkKCWJhY2t1cF9zdGF0ZSgpCglj
c2VsOmNvcHkoMSx0cnVlKQoJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZ2VuZXJhdGUJCglsb2Nh
bCB3dyxoaCA9IGNibXBfd2lkdGgsY2JtcF9oZWlnaHQKCWNpLmxheWVyID0gdXNlcmRhdGEoImkx
NiIsd3csaGgpCgljaS5sYXllcl94ID0gMAoJY2kubGF5ZXJfeSA9IDAKCWNpLmxheWVyMCA9IGNi
bXA6Y29weSgpCgoJLS0gc2FtZSBhcyBzZWxlY3QgdG9vbCAtLSBjdXQgb3V0IGFyZWEgdGhhdCB3
aWxsIG1vdmUgKGFsbCBvZiBpdCkKCWNpLmxheWVyMDpjbGVhcigpIAoJCgoJYmxpdChjYm1wLGNp
LmxheWVyKQoJCmVuZAoKZnVuY3Rpb24gbW9kaWZ5X3NlbGVjdGlvbihvcCkKCWJhY2t1cF9zdGF0
ZSgpCgkKCWxvY2FsIHRibXAgPSBjaS5sYXllciBvciBjYm1wCglsb2NhbCBvcmlnID0gdGJtcDpj
b3B5KCkKCQoJaWYgKG9wID09ICJmbGlwX3giKSB0aGVuCgkJZm9yIHg9MCwgdGJtcDp3aWR0aCgp
LTEgZG8KCQkJYmxpdChvcmlnLHRibXAseCwwLHRibXA6d2lkdGgoKS0xLXgsMCwxLHRibXA6aGVp
Z2h0KCkpCgkJZW5kCgkJdGJtcDpieG9yKDB4NDAwMCwgdHJ1ZSkKCWVuZAoJCglpZiAob3AgPT0g
ImZsaXBfeSIpIHRoZW4KCQlmb3IgeT0wLCB0Ym1wOmhlaWdodCgpLTEgZG8KCQkJYmxpdChvcmln
LHRibXAsMCx5LDAsdGJtcDpoZWlnaHQoKS0xLXksdGJtcDp3aWR0aCgpLDEpCgkJZW5kCgkJdGJt
cDpieG9yKDB4ODAwMCwgdHJ1ZSkKCWVuZAoJCgktLSByb3RhdGUgKHVzZSBkaWFnb25hbCBmbGlw
IGJpdCkKCWlmIChvcCA9PSAicm90YXRlIikgdGhlbgoJCS0tIGNsb2Nrd2lzZQoJCWxvY2FsIHJv
dF9jY3c9e1swXT0wYjEwMSwwYjEwMCwwYjAwMSwwYjAwMCwgIDBiMTExLDBiMTEwLDBiMDExLDBi
MDEwfQkKCQktLWNsb2Nrd2lzZSAobm90IHVzZWQsIGJ1dCBpbmNsdWRlZCBoZXJlIGZvciBsYXRl
ciBjYXVzZSBhIHBhaW4gdG8gZGVyaXZlKQoJCWxvY2FsIHJvdF9jdz17WzBdPTBiMDExLDBiMDEw
LDBiMTExLDBiMTEwLCAgMGIwMDEsMGIwMDAsMGIxMDEsMGIxMDB9CgkJCgkJY2kubGF5ZXIgPSBj
aS5sYXllcjp0cmFuc3Bvc2UoKSAtLSBzd2l0Y2ggZGltZW5zaW9ucyAoaWdub3JlIGNvbnRlbnQp
CgkJdGJtcCA9IGNpLmxheWVyCgoJCWZvciB5PTAsdGJtcDpoZWlnaHQoKS0xIGRvCgkJCWZvciB4
PTAsdGJtcDp3aWR0aCgpLTEgZG8KCQkJCWxvY2FsIHZhbDAgPSBvcmlnOmdldCgob3JpZzp3aWR0
aCgpLTEpLXkseCkgLS0gY2N3CgkJCQlsb2NhbCB2YWwxID0gcm90X2Njd1sodmFsMCA_PiAxMykg
JiAweDddIDw8IDEzCgkJCQl0Ym1wOnNldCh4LHksKHZhbDAgJiAweDFmZmYpIHwgdmFsMSkKCQkJ
ZW5kCgkJZW5kCgkJCgkJLS0gY3JlYXRlIGZsb2F0aW5nIGxheWVyIGFuZCBjZW50ZXIKCQktLSAv
MiAtLSBsYXllcl94LCBsYXllcl95IGNhbiBiZSBub24taW50ZWdlciB0byBwcmVzZXJ2ZSBjZW50
ZXIKCQltb3ZlX3NlbGVjdGlvbigKCQkJKHRibXA6aGVpZ2h0KCktdGJtcDp3aWR0aCgpKS8yLAoJ
CQkodGJtcDp3aWR0aCgpLXRibXA6aGVpZ2h0KCkpLzIKCQkpCgoJCS0tIHRlc3Q6IHJhdyBkaWFn
b25hbCBmbGlwCgkJLS0gdGJtcDpieG9yKDB4MjAwMCwgdHJ1ZSkKCWVuZAoJCgktLSBsYXllciBv
bmx5IC0tIGRvbid0IGNsZWFyIHdob2xlIG1hcCB3aXRoIGRlbAoJaWYgKGNpLmxheWVyIGFuZCBv
cCA9PSAiY2xlYXIiKSB0aGVuCgkJY2kubGF5ZXI6Y2xlYXIoKQoJZW5kCgkKCS0tIHVwZGF0ZSBj
aGFuZ2VzCglpZiAoY2kubGF5ZXIpIGJsaXQoY2kubGF5ZXIsIGNibXAsIDAsIDAsIGNpLmxheWVy
X3gsIGNpLmxheWVyX3kpCmVuZAoKCgogCiBmdW5jdGlvbiBfdXBkYXRlKCkKCgktLSB3YW50IHRv
IGtub3cgaWYgZWRpdGluZyB0ZXh0IGF0IHN0YXJ0IG9mIGZyYW1lLCBzbwoJLS0gdGhhdCBjYW4g
aWdub3JlIGVudGVyIGtleXByZXNzIChlcmYpIC0tIG1lc3NlZCB1cCBjaGVja3BvaW50aW5nCgls
b2NhbCBrZmNlMCA9IGd1aTpnZXRfa2V5Ym9hcmRfZm9jdXNfZWxlbWVudCgpCiAKIAlndWk6dXBk
YXRlX2FsbCgpCgl1cGRhdGVfZ3VpX2xheW91dCgpCiAJc2V0X2RyYXdfdGFyZ2V0KCkKIAkKIAkt
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tCiAKIAlpZiAoa2V5cCgiZXNjYXBlIikpIHRoZW4KIAkJLS0gZ2V0IHJpZCBvZiBhdHRhY2gt
b24tZGVtYW5kIGVsZW1lbnRzCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJd2luZG93e2NhcHR1cmVf
ZXNjYXBlcyA9IGZhbHNlfQkKIAllbmQKIAkKICAJLS0gbGF5ZXIgbmFtZSBlZGl0b3IgKG9yIHNv
bWV0aGluZyBlbHNlKSBoYXMvaGFkIGtiZCBmb2N1cyAtPiBpZ25vcmUgb3RoZXIgaW5wdXQKIAlp
ZiAoZ3VpOmdldF9rZXlib2FyZF9mb2N1c19lbGVtZW50KCkgb3Iga2ZjZTApIHJldHVybgoJLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LQogCQoJaWYga2V5cCgidGFiIikgdGhlbgoJCXNob3dfcGFuZSA9IG5vdCBzaG93X3BhbmUKCQly
ZWZyZXNoX2d1aT10cnVlCgllbHNlaWYga2V5cCgiZW50ZXIiKSB0aGVuCgkJY2xlYXJfc2VsZWN0
aW9uKCkKCWVuZAoJCglsb2NhbCBtYWcgPSBrZXkoImN0cmwiKSBhbmQgOCBvciAxCglpZiAoY2ku
bGF5ZXIpIHRoZW4gLS0gc29tZXRoaW5nIHNlbGVjdGVkCgkJaWYgKGtleXAoImxlZnQiKSkgIGJh
Y2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKC1tYWcsIDApCgkJaWYgKGtleXAoInJpZ2h0Iikp
IGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCBtYWcsIDApCgkJaWYgKGtleXAoInVwIikp
ICAgIGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCAwLC1tYWcpCgkJaWYgKGtleXAoImRv
d24iKSkgIGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCAwLCBtYWcpCgkKCQlpZiAoa2V5
cCgiZiIpKSBtb2RpZnlfc2VsZWN0aW9uKCJmbGlwX3giKQoJCWlmIChrZXlwKCJ2IikpIG1vZGlm
eV9zZWxlY3Rpb24oImZsaXBfeSIpCgkJaWYgKGtleXAoInIiKSkgbW9kaWZ5X3NlbGVjdGlvbigi
cm90YXRlIikKCQkKCQktLSBvbmx5IGRlbGV0ZSBpZiBleHBsaWNpdGx5IHNlbGVjdGVkIHNvbWV0
aGluZwoJCWlmIChrZXlwKCJkZWwiKSBvciBrZXlwKCJiYWNrc3BhY2UiKSkgbW9kaWZ5X3NlbGVj
dGlvbigiY2xlYXIiKQoJZWxzZQoJCS0tIG5vdGhpbmcgc2VsZWN0ZWQ6IGFsdGVyIGN1cnJlbnRs
eSBzZWxlY3RlZCBzcHJpdGUKCQlpZiAoa2V5cCgiZiIpKSBjb2wgXl49IDB4NDAwMAoJCWlmIChr
ZXlwKCJ2IikpIGNvbCBeXj0gMHg4MDAwCgkJaWYgKGtleXAoInIiKSkgdGhlbgoJCQlsb2NhbCBy
b3RfY2N3PXtbMF09MGIxMDEsMGIxMDAsMGIwMDEsMGIwMDAsICAwYjExMSwwYjExMCwwYjAxMSww
YjAxMH0JCgkJCWNvbCA9IChjb2wgJiAweDFmZmYpIHwgKHJvdF9jY3dbKGNvbCA_PiAxMykmMHg3
XSA8PCAxMykKCQllbmQKCQkKCQkKCQktLSB0byBkbzogbHJ1ZCBzaG91bGQgbW92ZSBjYW1lcmEK
CQlsb2NhbCB2YWwgPSBtYWcgKiAxNiAvIGNpLnpvb20KCQkKCQlpZiAoa2V5cCgibGVmdCIpKSAg
aXRlbVsxXS5wYW5feCAtPSB2YWwKCQlpZiAoa2V5cCgicmlnaHQiKSkgaXRlbVsxXS5wYW5feCAr
PSB2YWwKCQlpZiAoa2V5cCgidXAiKSkgICAgaXRlbVsxXS5wYW5feSAtPSB2YWwKCQlpZiAoa2V5
cCgiZG93biIpKSAgaXRlbVsxXS5wYW5feSArPSB2YWwKCQoJZW5kCgkKIAktLSAKIAlpZiAoa2V5
KCJjdHJsIikpIHRoZW4KIAogCWlmIGtleXAoImMiKSBvciBrZXlwKCJ4IikgdGhlbgogCQlsb2Nh
bCB0Ym1wID0gY2kubGF5ZXIgb3IgY2JtcAogCQlzZXRfY2xpcGJvYXJkKHBvZCh0Ym1wLDcse3Bv
ZF90eXBlPSJtYXAifSkpCiAJCWlmIGtleXAoIngiKSB0aGVuCgkJCWJhY2t1cF9zdGF0ZSgpCgkJ
CXRibXA6Y2xlYXIoKQoJCQlpZiAoY2kubGF5ZXIpIGJsaXQoY2kubGF5ZXIsIGNibXAsIDAsIDAs
IGNpLmxheWVyX3gsIGNpLmxheWVyX3kpCgkJCW5vdGlmeShzdHJpbmcuZm9ybWF0KCJjdXQgJWQg
eCAlZCB0aWxlcyIsdGJtcDp3aWR0aCgpLHRibXA6aGVpZ2h0KCkpKQogCQllbHNlCgkJCW5vdGlm
eShzdHJpbmcuZm9ybWF0KCJjb3BpZWQgJWQgeCAlZCB0aWxlcyIsdGJtcDp3aWR0aCgpLHRibXA6
aGVpZ2h0KCkpKQoJCWVuZAoJCWlmIChtdG9vbCA9PSAic3RhbXAiKSB0aGVuCgkJCS0tIGF1dG8t
ZGVzZWxlY3QgLS0gcHJvYmFibHkgd2FudCB0byB1c2Ugc3RyYWlnaHQgYXdheQoJCQljbGVhcl9z
ZWxlY3Rpb24oKQoJCWVuZAoJZW5kCgkKCWlmIGtleXAoInYiKSB0aGVuCgkJbG9jYWwgY3QgPSBn
ZXRfY2xpcGJvYXJkKCkKCQlsb2NhbCBibXAxID0gbmlsCgkJaWYgKHN1YihjdCwxLDUpID09ICJb
bWFwXSIpIHRoZW4KCQkJYm1wMSA9IHVzZXJkYXRhKGN0KQoJCWVsc2UKCQkJYm1wMSA9IHVucG9k
KGN0KQoJCWVuZAoJCWlmICh0eXBlKGJtcDEpID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJYmFja3Vw
X3N0YXRlKCkKCQkJaXRlbVtjdXJyZW50X2l0ZW1dLmJtcCA9IGJtcDEKCQkJc2V0X2N1cnJlbnRf
aXRlbShjdXJyZW50X2l0ZW0pCgkJZW5kCgllbmQKCQoJaWYga2V5cCgieiIpIHRoZW4KCQl1bmRv
KCkKCQlzZXRfY3VycmVudF9pdGVtKGN1cnJlbnRfaXRlbSkKCQlyZWZyZXNoX2d1aSA9IHRydWUK
CWVuZAoJCglpZiBrZXlwKCJ5IikgdGhlbgoJCXJlZG8oKQoJCXNldF9jdXJyZW50X2l0ZW0oY3Vy
cmVudF9pdGVtKQoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJZW5kCgkKCWlmIGtleXAoImEiKSB0aGVu
CgkJc2VsZWN0X2FsbCgpCgllbmQKCQoJZW5kIC0tIGN0cmwKCglpZiAoa2V5cCgpKSBpdGVtW2N1
cnJlbnRfaXRlbV0udW5kb19zdGFjazpjaGVja3BvaW50KCkgLS0gc2hvdyB1bmNoYW5nZWQgY2hh
bmdlcyBhc3RlcmlzayBpbW1lZGF0ZWx5CgkKIGVuZAogCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9ImxleGFsb2ZmbGUiLGNy
ZWF0ZWQ9IjIwMjQtMDMtMjkgMTI6Mzk6NTMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDBkMGQw
ZDBkMGQwZDA3MDEwMTA3MGQwZDBkMDcwNzA3MGQwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3
MDcwZDA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwZDA3MDcwNzBkMGQwZDBkMGQwZDA3MDEwMTA3MGQw
ZDBkMGQwZDBkMDcwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MGQwNzA3MDcwZDBkMGQwNzAx
MDEwNzBkMGQwZDA3MDcwZDA3MDcwNzBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQw
ZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYw
NjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxs
b3djb2xfaWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixub3Rlcz0iIixy
dW50aW1lPTIxLHN0b3JlZD0iMjAyNC0wNC0wMyAwNjowNDoyOCIsdGl0bGU9IlBpY290cm9uIE1h
cCBFZGl0b3IiLHZlcnNpb249IjAuMS4xZSIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1
YSMxODgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InVwZGF0ZS5sdWEjMjU2Iix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJuYXYubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249ImNhbnZhcy5sdWEjMzc0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ1
bmRvLmx1YSM3Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkcmF3Lmx1YSMxIix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWkubHVhIzE3NCIsd29ya3NwYWNlX2luZGV4PTF9
LHtsb2NhdGlvbj0iZ2Z4LzBiLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0iZ2Z4
LzMxLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3Bh
Y2VfaW5kZXg9M319XV0KOjogd29ya3NwYWNlcy5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1Zr
UFNJeU1ESXpMVEUzTFRJMklERTBPakUzT2pFMklpeHRiMlJwWm1sbFpEMGlNakF5TXkweQpNQzB5
TmlBeE5qb3lNRG8wTVNJc2NtVjJhWE5wYjI0OU5EUmRYV3g2TkFCNUFBQUFHd0VBQVBjYWUzdHNi
Mk5oZEdsdmJqMGliV0ZwCmJpNXNkV0VpTEhkdmNtdHpjR0ZqWlY5cGJtUmxlRDB4ZlN3b0FFOWtj
bUYzS0FBREdUSW9BRzkxY0dSaGRHVXFBQU1aTXlvQVAyNWgKZGljQUF4azBKd0EtWjNWcEp3QURH
VFVuQUc5allXNTJZWE1xQUFNWk5pb0FUM1Z1Wkc4b0FBRlFlRDAzCjo6IFtlb2NdCg==
:: bios/apps/notebook.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTA1IDA4OjQ5OjUyIixtb2RpZmllZD0iMjAyNS0xMC0xMiAwNTo0NTowMiIs
cmV2aXNpb249MjldXQpsb2NhbCBjZQoKZnVuY3Rpb24gX2RyYXcoKQoKCWc6ZHJhd19hbGwoKSAt
LSBjb3ZlcnMgd2hvbGUgc2NyZWVuOyBkb24ndCBuZWVkIHRvIGNscygpCgplbmQKCmZ1bmN0aW9u
IF91cGRhdGUoKQoKCS0tIGNvZGUgZWRpdG9yIGFsd2F5cyBoYXMga2V5Ym9hcmQgZm9jdXMgd2hl
biBzZWFyY2ggaXMgbm90IG9wZW4KCWlmIChub3QgY2U6c2VhcmNoX2JveF9pc19vcGVuKCkpIGNl
OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoKCWc6dXBkYXRlX2FsbCgpCgkKZW5kCgoKZnVuY3Rp
b24gX2luaXQoKQoKCS0tIGRlZmF1bHQ6IHZhcmlhYmxlIHdpZHRoIGZvbnQKCXBva2UoMHg0MDAw
LGdldChmZXRjaCIvc3lzdGVtL2ZvbnRzL2xpbC5mb250IikpCgkKCglsb2NhbCBpY29uPQoJdXNl
cmRhdGEiW2dmeF0wODA4MDc3Nzc3MDA3Nzc3NzcwMDc3Nzc3NzAwNzc3Nzc3MDA3Nzc3NzcwMDc3
MDAwMDAwMDc3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIKCgl3aW5kb3d7CgkJd2lkdGggPSAyODAsCgkJ
aGVpZ2h0ID0gMjAwLAoJCS0tc3F1YXNoYWJsZSA9IHRydWUsIC0tIG1heWJlIG9wdGlvbmFsIGxh
dGVyCgkJaWNvbiAgID0gaWNvbgoJfQoJCgoJZyA9IGNyZWF0ZV9ndWkoKQoJCgljZSA9IGc6YXR0
YWNoX3RleHRfZWRpdG9yKHsKCQl4PTAseT0wLAoJCXdpZHRoPWdldF9kaXNwbGF5KCk6d2lkdGgo
KSwKCQloZWlnaHQ9Z2V0X2Rpc3BsYXkoKTpoZWlnaHQoKSwKCQl3aWR0aF9yZWwgID0gMS4wLAoJ
CWhlaWdodF9yZWwgPSAxLjAsCgkJc3ludGF4X2hpZ2hsaWdodGluZyA9IGZhbHNlLAoJCXNob3df
bGluZV9udW1iZXJzICAgPSBmYWxzZSwKCQltYXJrdXAgICAgID0gdHJ1ZSwKCQllbWJlZF9wb2Rz
ID0gdHJ1ZSwKCQloYXNfc2VhcmNoID0gdHJ1ZSwKCQliZ2NvbCA9IDcsCQoJCWZnY29sID0gNQoJ
fSkKCgoKCWNlOmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoJd3JhbmdsZV93b3JraW5nX2ZpbGUoCgoJ
CS0tIHNhdmUgdG8gb2JqCgkJZnVuY3Rpb24gKCkKCQkJLS0gc2V0dGluZyBhbiB1bmRvIGNoZWNr
cG9pbnQgaGVyZSBtZWFucyBjYW4gYWx3YXlzIHVuZG8gYmFjayB0byBhIG5vLXVuc2F2ZWQtY2hh
bmdlcyBzdGF0ZQoJCQljZTpnZXRfdW5kb19zdGFjaygpOmNoZWNrcG9pbnQoKQoJCQktLSBjb252
ZXJ0IGZyb20gbGluZXMgYmFjayB0byBhIHNpbmdsZSBzdHJpbmcKCQkJcmV0dXJuIHRhYmxlLmNv
bmNhdChjZTpnZXRfdGV4dCgpLCJcbiIpCgkJZW5kLAoKCQktLSBsb2FkIGZyb20gb2JqIChhc3N1
bWVkIHRvIGJlIGEgc3RyaW5nKQoJCWZ1bmN0aW9uIChzdHIpCgkJCWxvY2FsIHRleHQgPSBzcGxp
dChzdHIsICJcbiIsIGZhbHNlKQoJCQktLXByaW50aCgic3RyOiBbIi4uc3RyLi4iXSIpCgkJCS0t
cHJpbnRoKCJub3RlcGFkOiBsb2FkZWQgIi4uI3RleHQuLiIgbGluZXMiKQoJCQlpZiAobm90IHRl
eHQgb3IgI3RleHQgPT0gMCkgdGhlbiB0ZXh0ID0geyIifSBlbmQKCQkJY2U6c2V0X3RleHQodGV4
dCkKCQllbmQsCgoJCS0tIGRlZmF1bHQgZmlsZSAoYW5kIGV4dGVuc2lvbikKCQkiL2Rlc2t0b3Av
dW50aXRsZWQudHh0IiwgCgoJCS0tIGdldF9obG9jYXRpb24KCQluaWwsCgkJLS0gc2V0X2hsb2Nh
dGlvbgoJCW5pbCwKCgkJLS1bWwoJCQlzdGF0ZV9oaW50IChvcHRpb25hbCk6CgkJCQoJCQlyZXR1
cm4gYSB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY2lkZSBpZiB0aGVyZSBhcmUgdW5zYXZl
ZCBjaGFuZ2VzLgoJCQkKCQkJVGhlIHJldHVybiB2YWx1ZSBjYW4gYmUgYW55dGhpbmcsIGJ1dCBz
aG91bGQgYWx3YXlzIGNoYW5nZSB3aGVuIHRoZSBzdGF0ZSAKCQkJb2YgdGhlIGRvY3VtZW50ICpt
aWdodCogaGF2ZSBjaGFuZ2VkLgoKCQkJSXQgc2hvdWxkIGJlIHZlcnkgY2hlYXA7IHdoZW4gdGhl
IHJldHVybiB2YWx1ZSBjaGFuZ2VzLCBhIG1vcmUgZXhwZW5zaXZlIAoJCQlzdGF0ZSBjb21wYXJp
c29uIGlzIHRoZW4gcGVyZm9ybWVkIGJ5IHdyYW5nZXIgdG8gY29uZmlybSB0aGF0IHRoZXJlIGFy
ZSBpbiAKCQkJZmFjdCB1bnNhdmVkIGNoYW5nZXMgKHdoaWNoIHNob3dzIHVwIGFzICIqIiBpbiB0
aGUgd2luZG93IHRpdGxlIikKCQkJCgkJCVdoZW4gdGhpcyBmdW5jdGlvbiBpcyBub3QgcHJvdmlk
ZWQsIHdyYW5nbGVyIGludGVhZCBwZXJmb3JtcyB0aGUgZnVsbAoJCQlzdGF0ZSBjb21wYXJpc29u
IHBlcmlvZGljYWxseSAod2hpY2ggaXMgZmluZSBpbiBtb3N0IGNhc2VzLCBidXQgYSBiaXQgCgkJ
CW1vcmUgZXhwZW5zaXZlIGFuZCB0aGUgIioiIGRvZXNuJ3Qgc2hvdyB1cCBzdHJhaWdodCBhd2F5
KS4KCgkJCVRleHQgZmllbGRzIGNyZWF0ZWQgd2l0aCA6YXR0YWNoX3RleHRfZWRpdG9yIHByb3Zp
ZGUgdGhlaXIgb3duIHN0YXRlIGhpbnQgCgkJCWZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgaGVy
ZSwgd2hpY2ggdXNlcyBhIGNvbWJpbmF0aW9uIG9mIHVuZG8gc3RhY2sgCgkJCXBvc2l0aW9uIGFu
ZCBjdXJyZW50IGxpbmUgbGVuZ3RoOgoJCQkKCQkJcmV0dXJuICN1bmRvX3N0YWNrLnVuZG9fc3Rh
Y2sgKyAoI2xpbmVbY3VyX3ldIDw8IDgpCgoJCV1dCgkJZnVuY3Rpb24gKCkKCQkJcmV0dXJuIGNl
IGFuZCBjZTpnZXRfc3RhdGVfaGludCgpCgkJZW5kCgoKCSkKCmVuZAoKCgoKCgo6OiB1bnRpdGxl
ZC50eHQKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wMy0wNyAyMjowMzozNSIs
bW9kaWZpZWQ9IjIwMjQtMDQtMDEgMTE6MDQ6MjkiLHJldmlzaW9uPTNdXQpmaXhtZTogZGVmYXVs
dCBsb2NhdGlvbiBzaG91bGRuJ3QgYmUgL2luc2lkZS8gdGhlIGFwcCEKCgo6OiAuaW5mby5wb2QK
LS1bW3BvZCxhdXRob3I9InplcCIsY3JlYXRlZD0iMjAyNS0wMS0wNyAwMDoxNjoyNyIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDEw
ZTBlMGUwZTBlMGUwZTBlMGUwZTBlMDEwMDAwMDEwNzAxMGUwZTBlMGUwZTBlMGUwZTBlMGUwZTAx
MDAwMDAxMDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMDEwMDAwMDEwZTBlMGUwZTBlMGUwZTBlMGUw
ZTBlMGUwMTAwMDEwNzAxMGUwZTBlMGUwZTBlMGUwZTBlMGUwZTAxMDAwMDAxMDEwZTBlMGUwZTBl
MGUwZTBlMGUwZTBlMDEwMDAwMDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMGUwMTAwMDEwNzAxMGUw
ZTBlMGUwZTBlMGUwZTBlMGUwZTAxMDAwMDAxMDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMDEwMDAw
MDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMGUwMTAwMDEwNzAxMGUwZTBlMGUwZTBlMGUwZTBlMGUw
MTAxMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTA3MDEwMDAwMDEwMTA3MDcwNzA3MDcwNzA3
MDcwNzA3MGUwMTAwMDAwMDAxMGUwZTBlMGUwZTBlMGUwZTBlMGUwMTAwMDAwMDAwMDAwMTAxMDEw
MTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixub3Rl
cz0id3JpdGUgc3R1ZmYiLHJ1bnRpbWU9MjEsc3RvcmVkPSIyMDI0LTAzLTEwIDAxOjQwOjUyIix0
aXRsZT0iTm90ZWJvb2siLHZlcnNpb249IiIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1
YSMxMDMiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNl
X2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0
aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8ucG9kCi0t
W1twb2QsY3JlYXRlZD0iMjAyMy0xMC0wNSAwODo0ODo0NCIsbW9kaWZpZWQ9IjIwMjUtMTItMTQg
MDA6NDc6MzgiLHN0b3JlZD0iMjAyMy00OC0wNSAwODo0ODo0NCJdXQo6OiBnZngvMC5nZngKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBMUlEQTRPalV3T2pBNElpeHRiMlJw
Wm1sbFpEMGlNakF5TlMwdwpNUzB3TnlBd01Eb3hOam8xTWlJc2NtVjJhWE5wYjI0OU1qQmRYV3g2
TkFCdEFBQUFCVEVBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lXZHpQVEFz
Y0dGdVgzZ0lBTTk1UFRBc2VtOXZiVDA0ZlN3eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUWJUMDRmWDA9Cjo6IG1hcC8u
aW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTA1IDA4OjQ4OjQ0Iixtb2RpZmllZD0i
MjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTQ4LTA1IDA4OjQ4OjQ0Il1dCjo6IG1h
cC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEExSURBNE9qVXdP
akE0SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB3Ck1TMHdOeUF3TURveE5qbzFNaUlzY21WMmFYTnBi
MjQ5TWpCZFhXeDZOQUJjQUFBQVdBUUFBUEFJZTN0aWJYQTlkWE5sY21SaGRHRW8KSW1reE5pSXNN
VFlEQUM4aU1BRUEtLS0tNy1FSUlpa3NhR2xrWkdWdVBXWmhiSE5sTEhCaGJsOTRQVEFJQU5KNVBU
QXNkR2xzWlY5bwpQVEUyQ2dBUWR3b0FnSHB2YjIwOU1YMTkKOjogbWFwL21hcDAubWFwCmI2NCRM
UzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREE1T2pJMU9qUTBJaXh0YjJScFpt
bGxaRDBpTWpBeU5DMHcKTXkwd05pQXdPVG95TlRvME5DSXNjbVYyYVhOcGIyNDlNRjFkYkhvMEFH
a0FBQUNqQ0FBQThCTjdiR0Y1WlhJOWUxc3dYVDE3WW0xdwpQWFZ6WlhKa1lYUmhLQ0pwTVRZaUxE
RTJBd0F2SWpBQkFQLS0tX19oSWlrc2NHRnVYM2c5TUFnQThnWjVQVEFzYzJOaGJHVTlNU3gwCmFX
eGxYMmc5TVRZS0FHOTNQVEUyZlN4TEJQLS0tLTg0VURFMmZYMTkKOjogc2Z4Ly5pbmZvLnBvZAot
LVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMTAtMDUgMDg6NDg6NDQiLG1vZGlmaWVkPSIyMDI1LTEyLTE0
IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjMtNDgtMDUgMDg6NDg6NDQiXV0KOjogc2Z4LzAuc2Z4CmI2
NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xURXlJREV3T2pVMU9qRXhJaXh0YjJS
cFptbGxaRDBpTWpBeU5TMHcKTVMwd055QXdNRG94TmpvMU1pSXNjbVYyYVhOcGIyNDlNVFJkWFd4
Nk5BQndBQUFBN2djQUFOOXdlSFVBQXlnQUFBUUFCUEQtQVFEcwoteWZ4QVJBR0R5QVFBU0FCSUFI
d0FBSVFBZzRRQVNBUElTQUJNQTlBOE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NRRVFCZzR3
CkFQODVILThCQU56UF9BOUFBQThRUVAtLXNQQndDd0QtLTZNZi13RUEtNWxRLS0tLS15QT0KOjog
c2Z4L3NmeDAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREE1
T2pJMU9qUTBJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXdPVG95TlRvME5DSXNjbVYy
YVhOcGIyNDlNRjFkYkhvMEFCQUJBQUJSQndBQThDZHdlSFVBQXlnQUFBTUFCQTlBRUFJTwpBQUdn
QVNBQ29BNEFEeEFBRGZES0FRSURCQVVHQndFUC01QUlDUW9MRHd3UERROE9EdzhRQVBBQURROFJE
eElQRXc4VUR4VVBGZzhYCkV3RHhBUThZRHhrUEdnOGJEeHdQSFE4ZUR4OFVBUEVBSUE4aER5SVBJ
dzhrRHlVUEpnOG5GQUR4QUNnUEtROHFEeXNQTEE4dER5NFAKTHhRQThRQXdEekVQTWc4ekR6UVBO
UTgyRHpjVUFQOEZPQTg1RHpvUE93ODhEejBQUGc4LUFRLS04UDhCQU92LUoxb0JFQVlQSUJBQgpJ
QUVnQWZBQUFoQUNEQkFCSUE4aElBRXdEMER3d3c4b0QtLXd4Zy00Q2ctLUQ0QVA5dzhOQWZBSkFS
QUdEREFBLXprZi13RUEzTC00CkQwQUFEVUQtLTdEd2NBb0EtLTlrSC04QkFKZFEtLS0tLXg4PQo6
OiBbZW9jXQo=
:: bios/apps/podtree.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
My0wMy0zMCAwNTowMzoxMiIsbW9kaWZpZWQ9IjIwMjQtMDYtMDYgMDU6NDM6MDQiLHJldmlzaW9u
PTQ3NTJdXQotLVtbCglwdzogd3JhbmdsZXIgdmVyc2lvbiAoZm9ya2VkIGZyb20gMC4xLjBnIHJl
bGVhc2UgdmVyc2lvbikKXV0KCmxvY2FsIGtleWQgPSBrZXkgLS0gImtleSBkb3duIi4gd2FudCB0
byB1c2UgImtleSIgYXMgYSB2YXJpYWJsZSBuYW1lIQoKbG9jYWwgdG9wX2xhYmVsX21ldGFkYXRh
ID0gIlttZXRhZGF0YV0iCmxvY2FsIHRvcF9sYWJlbCA9ICJbY29udGVudF0iCgpsb2NhbCB0ZXh0
X2NvbCA9IDYKbG9jYWwgc2Nyb2xsX3kgPSAwCgpsb2NhbCBzZWxlY3RlZCA9IC0xCgpsb2NhbCBj
b250YWluZXIKbG9jYWwgY29udGVudApsb2NhbCB1bmRvX3N0YWNrCgotLSB0aGUgcG9kLCBidXQg
d3JhcHBlZCBpbiBhIHRhYmxlCi0tIG1lYW5zIGNhbiByZWZlciB0byByb290IGl0ZW1zIHVzaW5n
IHAgYXMgcGFyZW50LAotLSBidXQgYWxzbyBjYW4gaGF2ZSBtZXRhZGF0YSArIGRhdGEgZm9ya3Mu
CgpwID0gewoJbWV0YWRhdGEgPSB7CgkJdGl0bGUgPSAiZm9vIiwKCQlhdXRob3IgPSAiemVwIiwK
CQlfc3lzdGVtID0ge19kZXNjPSJhcHAgZGF0YSBnb2VzIGhlcmU7IGUuZy4gc2VhcmNoIGJsb29t
LCB1bml2ZXJzYWwgZmlsZSBJRCwgbWQ1PyJ9Cgl9LAoJY29udGVudHMgPSB7CgkJY29sb3VycyA9
IHsidGhlIiwicXVpY2siLCJicm93biIsImZveCJ9LAoJCXRoZW1lID0ge30sCgkJdm9sdW1lID0g
MjQsCgkJYXVkaW8gPSB0cnVlLAoJCWZ1bGxzY3JlZW4gPSBmYWxzZSwKCQl3aW5kb3dfc2NhbGUg
PSAyLAoJCWljb24gPSB1c2VyZGF0YSJbZ2Z4XTA4MDg3NzcwMDAwMDcwNzAwMDAwNzc3MDAwMDAw
NzAwNzc3MDA3Nzc3MDcwMDcwMDc3NzAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKCQl6c3RyID0g
InRoaXMgaXMgYSBzdHJpbmciLAoJCXpzdHIyPSAidGhpcyBpcyBhIG11bHRpbGluZSBzdHJpbmdc
bmxpbmUgMlxubGluZSAzIiwKCQl6c3RyMz0gImFub3RoZXIgc3RyaW5nIiwKCQl6c3RyND0gImFu
ZCBhbm90aGVyIiwKCX0KfQoKLS0gaGFja3kgbm90ZXRyZWUgc2NoZW1lOyBkb2Vzbid0IGhlbHAg
bXVjaCB0aG91Z2guCi0tIGRvbid0IHdhbnQgdG8gdHlwZSBpbiB0aGUgbnVtYmVycyBtYW51YWxs
eSEKcDI9ewoJbWV0YWRhdGEgPSB7fSwKCWNvbnRlbnRzID0gewoJCVsiMSBUaGUgV29ybGQgaXMg
ZXZlcnl0aGluZyB0aGF0IGlzIHRoZSBjYXNlIl0gPQoJCXsKCQkJWyIxLjEiXSA9ICJmb28iLAoJ
CQlbIjEuMiJdID0gImJhciIsCgkJfQoJfQp9CgpwMz17CgltZXRhZGF0YSA9IHt9LAoJY29udGVu
dHMgPSB7CgkJaG9nZSA9IHsiYSB0YWJsZSBmb3IgdGVzdGluZyJ9Cgl9Cn0KCmlmIChwLmNvbnRl
bnRzLnRoZW1lKSB0aGVuCmZvciBpPTEsNTAgZG8KCWFkZChwLmNvbnRlbnRzLnRoZW1lLCAidGhl
bWUgIi4uaSkKZW5kCmVuZAoKLS0gdGFibGUgcG9pbnRpbmcgdG8gZWFjaCBpdGVtLAoKbG9jYWwg
cHAgPSB7fSAgICAgICAgICAgICAgICAgICAgICAtLSBwb2QgcG9pbnRlciAtLSBnZW5lcmF0ZWQg
YWxvbmcgd2l0aCBndWkKbG9jYWwgZXhwYW5kID0ge1twLmNvbnRlbnRzXT10cnVlfSAtLSB3aGlj
aCB0YWJsZXMgdG8gZXhwYW5kLiBjb250ZW50cyBzdGFydHMgc2hvd24KCgpsb2NhbCBmdW5jdGlv
biBjbG9zZV90ZXh0ZWQoc2F2ZSkKCWlmIChub3QgdGV4dGVkKSByZXR1cm4KCWlmIChzYXZlKSB0
aGVuCgkJZW50ZXJfbmV3X3ZhbHVlKHRhYmxlLmNvbmNhdCh0ZXh0ZWQ6Z2V0X3RleHQoKSwiXG4i
KSkKCWVuZAoJCgllZGl0aW5nX3BhcmVudCA9IG5pbAoJdGV4dGVkOmRldGFjaCgpCgl0ZXh0ZWQg
PSBmYWxzZQoJd2luZG93e2NhcHR1cmVfZXNjYXBlcyA9IGZhbHNlfQoJcmVmcmVzaF9ndWkgPSB0
cnVlCgllZGl0aW5nX3doaWNoID0gbmlsCgkKZW5kCgoKbG9jYWwgZnVuY3Rpb24gY29tcChpMCwg
aTEpCgoJLS0gdGFibGUgdmFsdWVzIGdvIGZpcnN0IChzaW1pbGFyIHRvIGZpbGUgbGlzdGluZ3Mp
CgktLSAoYnV0IG9ubHkgZm9yIG5vbi1udW1iZXIgaW5kZXhlcyAtLSBjYW4gaGF2ZSB0YWJsZXMg
aW4gYW4gb3JkZXIpCglpZiAodHlwZShpMC52KSA9PSAidGFibGUiIGFuZCB0eXBlKGkwLmspICE9
ICJudW1iZXIiIGFuZCB0eXBlKGkxLnYpICE9ICJ0YWJsZSIpIHJldHVybiB0cnVlCglpZiAodHlw
ZShpMS52KSA9PSAidGFibGUiIGFuZCB0eXBlKGkxLmspICE9ICJudW1iZXIiIGFuZCB0eXBlKGkw
LnYpICE9ICJ0YWJsZSIpIHJldHVybiBmYWxzZQoJCglsb2NhbCBrMCA9IGkwLmsKCWxvY2FsIGsx
ID0gaTEuawoJCgktLSBzb3J0IGJ5IGtleSAobm90IHRhYmxlcywgb3IgYm90aCB0YWJsZXMpCglp
ZiAodHlwZShrMCkgIT0gdHlwZShrMSkpIHRoZW4KCQktLSBzb3J0IGJ5IGtleSB0eXBlLiBudW1i
ZXJzIGdvIGxhc3QKCQlpZiAodHlwZShrMCkgPT0gIm51bWJlciIpIHJldHVybiBmYWxzZQoJCWlm
ICh0eXBlKGsxKSA9PSAibnVtYmVyIikgcmV0dXJuIHRydWUKCQkKCQktLSB1bnVzdWFsIGNhc2U6
IGRpZmZlcmVuaW5nIHR5cGVzLCBhbmQgbmVpdGhlciBhcmUgdGFibGVzIG9yIG51bWJlcnMKCQkt
LSAtPiBhbHBoYWJldGljYWwgYnkgdHlwZQoJCXJldHVybiB0eXBlKGswKSA8IHR5cGUoazEpCgll
bmQKCQoJcmV0dXJuIGswIDwgazEgLS0gc2FtZSB0eXBlOiBjYW4gY29tcGFyZSwgSSB0aGluaz8K
ZW5kCgotLSB0byBkbzogbm90IGJ1YmJsZSEKbG9jYWwgZnVuY3Rpb24gYnViYmxlX3NvcnQodGJs
KQoJZm9yIHBhc3M9MSwjdGJsLTEgZG8KCQlmb3IgaT0xLCN0YmwtMSBkbwoJCQlpZiAobm90IGNv
bXAodGJsW2ldLCB0YmxbaSsxXSkpIHRibFtpXSwgdGJsW2krMV0gPSB0YmxbaSsxXSwgdGJsW2ld
CgkJZW5kCgllbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBnZXRfa2V5X3N0cihrZXksIHZhbCkKCWlm
ICh0eXBlKGtleSk9PSJudW1iZXIiKSB0aGVuIAoJCS0ta2V5ID0gIlwwMTRcfGkiLi5rZXkuLiJc
fGVcMDE1IgoJCWtleSA9ICJcXjowMDAwMDAxODE4MDAwMDAwIgoJZWxzZQoJCWlmICh0eXBlKHZh
bCkgIT0gInRhYmxlIikga2V5ID0gdG9zdHIoa2V5KS4uIjoiCgllbmQKCQoJaWYgKHZhbCA9PSBw
Lm1ldGFkYXRhKSBrZXkgPSB0b3BfbGFiZWxfbWV0YWRhdGEKCWlmICh2YWwgPT0gcC5jb250ZW50
cykga2V5ID0gdG9wX2xhYmVsCgkKCXJldHVybiBrZXkKZW5kCgpmdW5jdGlvbiBlbnRlcl9uZXdf
dmFsdWUodmFsKQoKCWxvY2FsIHJlcyA9IHVuZG9fc3RhY2s6Y2hlY2twb2ludCgpCgktLSBwcmlu
dGgoImNoZWNrcG9pbnQ6ICIuLnRvc3RyKHJlcykpCglsb2NhbCB0eXBlMCA9IHR5cGUoZWRpdGlu
Z19wYXJlbnRbZWRpdGluZ19rZXldKQoJaWYgKGVkaXRpbmdfd2hpY2ggPT0gImtleSIpIHR5cGUw
ID0gdHlwZShlZGl0aW5nX2tleSkKCQoJLS0ga2VlcCBudW1iZXJzIGFzIG51bWJlcnMKCWlmICh0
eXBlMCA9PSAibnVtYmVyIikgdGhlbgoJCWxvY2FsIG51bSA9IHRvbnVtKHZhbCkKCQlpZiAobnVt
KSB2YWwgPSBudW0KCWVuZAoJCglpZiAoZWRpdGluZ193aGljaCA9PSAia2V5IikgdGhlbgoJCgkt
LSBrZXkgY2hhbmdlZCAtLT4gc2V0IGl0CglpZiAodmFsICE9IGVkaXRpbmdfa2V5KSB0aGVuCgkJ
aWYgKHZhbCA9PSAiIikgdGhlbgoJCQktLSBpbnQga2V5CgkJCWVkaXRpbmdfcGFyZW50WyNlZGl0
aW5nX3BhcmVudCsxXSA9IGVkaXRpbmdfcGFyZW50W2VkaXRpbmdfa2V5XQoJCWVsc2UKCQkJLS0g
c3RyaW5nIGtleQoJCQllZGl0aW5nX3BhcmVudFt2YWxdID0gZWRpdGluZ19wYXJlbnRbZWRpdGlu
Z19rZXldCgkJZW5kCgkJZWRpdGluZ19wYXJlbnRbZWRpdGluZ19rZXldID0gbmlsCgllbmQKCQoJ
ZWxzZQoJCgkJZWRpdGluZ19wYXJlbnRbZWRpdGluZ19rZXldID0gdmFsCgoJZW5kCgkKZW5kCgkJ
CQkJCgkKCmZ1bmN0aW9uIGFkZF9ub2RlKGNvbnRlbnQsIHBhcmVudCwga2V5LCBzeSwgZGVwdGgs
IGd1aV9sYWJlbCkKCgktLXByaW50aCgidHlwZShwYXJlbnQpIi4udHlwZShwYXJlbnQpKQoJCgls
b2NhbCBpdGVtID0gYWRkKHBwLCB7CgkJcGFyZW50PXBhcmVudCwKCQlrZXk9a2V5LAoJCXN5PXN5
LAoJCWRlcHRoPWRlcHRoLAoJCWd1aV9sYWJlbD1ndWlfbGFiZWwsCgl9KQoJCglsb2NhbCB2YWwg
PSBwYXJlbnRba2V5XQoJCgktLSBjYWxjdWxhdGUgaXRlbSBoZWlnaHQgYmFzZWQgb24gaXRlbQoJ
bG9jYWwgc3kwID0gc3kKCV8sc3kgPSBwcmludCh0b3N0cihwYXJlbnRba2V5XSksIDEwMDAwMCwg
c3kpCglpdGVtLmhlaWdodCA9IHN5IC0gc3kwCgkKCglpZiAoZWRpdGluZ19rZXkgPT0ga2V5IGFu
ZCBlZGl0aW5nX3BhcmVudCA9PSBwYXJlbnQKCQlhbmQgZWRpdGluZ193aGljaCA9PSAia2V5Iikg
dGhlbgoJCS0tIGVkaXQgdmFsCgkJCgkJc2VsZWN0ZWQgPSAjcHAgLS0gYWx3YXlzIHNlbGVjdCB0
aGUgaXRlbSBiZWluZyBlZGl0ZWQKCQkKCQlsb2NhbCB4eCA9IDEwICsgZGVwdGggKiAxMCAtLSBp
bmRlbnRhdGlvbiBjYWxjdWxhdGlvbiBkdXBlCgkJbG9jYWwga2sgPSBnZXRfa2V5X3N0cihrZXks
IHBhcmVudFtrZXldKQoJCWxvY2FsIGt3ID0gcHJpbnQoa2ssMCwtMTAwMDApCgkJbG9jYWwgYncg
PSB0eXBlKHBhcmVudFtrZXldKSA9PSAidGFibGUiIGFuZCAyMCBvciAwIC0tIGJ1dHRvbiB3aWR0
aAoJCQoJCWxvY2FsIHgwID0geHggKyAzMAoJCXRleHRlZCA9IGNvbnRlbnQ6YXR0YWNoX3RleHRf
ZWRpdG9yewoJCQliZ2NvbCA9IDAsCgkJCXggPSB4MCwKCQkJeSA9IGl0ZW0uc3ktMywgLS0gZnVk
Z2VkIHRvIG1hdGNoCgkJCXdpZHRoID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIC0geDAgLSAyMCwK
CQkJaGVpZ2h0ID0gaXRlbS5oZWlnaHQsCgkJCWJsb2NrX3Njcm9sbGluZyA9IHRydWUsCgkJCWtl
eV9jYWxsYmFjayA9IHsgCgkJCQllbnRlciA9IGZ1bmN0aW9uICgpIAoJCQkJCS0tIGtlZXAgbmV3
IHZhbHVlIGFuZCBjbG9zZQoJCQkJCWNsb3NlX3RleHRlZCh0cnVlKQoJCQkJZW5kLAoJCQkJZXNj
YXBlCSA9IGZ1bmN0aW9uKCkKCQkJCQktLSBjbG9zZSB3aXRob3V0IGtlZXBpbmcgdmFsdWUKCQkJ
CQljbG9zZV90ZXh0ZWQoZmFsc2UpCgkJCQllbmQsCgkJCX0KCQl9CgkJdGV4dGVkOnNldF9rZXli
b2FyZF9mb2N1cyh0cnVlKQoJCXRleHRlZDpzZXRfdGV4dCh0b3N0cihrZXkpKQoJCXRleHRlZDpz
ZXRfY3Vyc29yKDEwMDAwLDEpCgkJdGV4dGVkOnNlbGVjdF9hbGwoKQoJCXdpbmRvd3tjYXB0dXJl
X2VzY2FwZXMgPSB0cnVlfQoJCQoJCWxhc3RfbnVtX2xpbmVzID0gI3RleHRlZDpnZXRfdGV4dCgp
CgkKCWVsc2VpZiAoZWRpdGluZ19rZXkgPT0ga2V5IGFuZCBlZGl0aW5nX3BhcmVudCA9PSBwYXJl
bnQpIHRoZW4KCQktLSBlZGl0IHZhbAoJCQoJCXNlbGVjdGVkID0gI3BwIC0tIGFsd2F5cyBzZWxl
Y3QgdGhlIGl0ZW0gYmVpbmcgZWRpdGVkCgkJCgkJbG9jYWwgeHggPSAxMCArIGRlcHRoICogMTAg
LS0gaW5kZW50YXRpb24gY2FsY3VsYXRpb24gZHVwZQoJCWxvY2FsIGtrID0gZ2V0X2tleV9zdHIo
a2V5LCBwYXJlbnRba2V5XSkKCQlsb2NhbCBrdyA9IHByaW50KGtrLDAsLTEwMDAwKQoJCWxvY2Fs
IGJ3ID0gdHlwZShwYXJlbnRba2V5XSkgPT0gInRhYmxlIiBhbmQgMjAgb3IgMCAtLSBidXR0b24g
d2lkdGgKCQkKCQlsb2NhbCB4MCA9IHh4ICsgYncgKyBrdyArIDEgLS0gZnVkZ2VkIHRvIG1hdGNo
CgkJdGV4dGVkID0gY29udGVudDphdHRhY2hfdGV4dF9lZGl0b3J7CgkJCWJnY29sID0gMCwKCQkJ
eCA9IHgwLAoJCQl5ID0gaXRlbS5zeS0zLCAtLSBmdWRnZWQgdG8gbWF0Y2gKCQkJd2lkdGggPSBn
ZXRfZGlzcGxheSgpOndpZHRoKCkgLSB4MCAtIDIwLAoJCQloZWlnaHQgPSBpdGVtLmhlaWdodCwK
CQkJYmxvY2tfc2Nyb2xsaW5nID0gdHJ1ZSwKCQkJa2V5X2NhbGxiYWNrID0geyAKCQkJCWVudGVy
ID0gZnVuY3Rpb24gKCkgCgkJCQkJLS0gaG9sZGluZyBzaGlmdDogbGV0IGVkaXRvciBoYW5kbGUg
dGhlIGVudGVyCgkJCQkJaWYoa2V5ZCgic2hpZnQiKSkgcmV0dXJuIHRydWUKCQkJCQkKCQkJCQkt
LSBrZWVwIG5ldyB2YWx1ZSBhbmQgY2xvc2UKCQkJCQljbG9zZV90ZXh0ZWQodHJ1ZSkKCQkJCWVu
ZCwKCQkJCWVzY2FwZQkgPSBmdW5jdGlvbigpCgkJCQkJLS0gY2xvc2Ugd2l0aG91dCBrZWVwaW5n
IHZhbHVlCgkJCQkJY2xvc2VfdGV4dGVkKGZhbHNlKQoJCQkJZW5kLAoJCQl9CgkJfQoJCXRleHRl
ZDpzZXRfa2V5Ym9hcmRfZm9jdXModHJ1ZSkKCQl0ZXh0ZWQ6c2V0X3RleHQodG9zdHIodmFsKSkK
CQl0ZXh0ZWQ6c2V0X2N1cnNvcigxMDAwMCwxKQoJCXdpbmRvd3tjYXB0dXJlX2VzY2FwZXMgPSB0
cnVlfQoJCQoJCWxhc3RfbnVtX2xpbmVzID0gI3RleHRlZDpnZXRfdGV4dCgpCgllbmQKCgkKCS0t
IG5vIHBhcmVudDogZ3VpIGl0ZW0KCWlmIChub3QgcGFyZW50KSByZXR1cm4gc3kKCQogICAtLSBk
b24ndCBleHBhbmQgcHJldiBlbmNvdW50ZXJlZCB0YWJsZQoJaWYgKGVuY291bnRlcmVkW3ZhbF0p
IHJldHVybiBzeQoJCglpZiAodHlwZSh2YWwpID09ICJ0YWJsZSIgYW5kIGV4cGFuZFt2YWxdKSB0
aGVuCgkJZW5jb3VudGVyZWRbdmFsXSA9IHRydWUKCQkKCQktLSBzb3J0IGNoaWxkcmVuCgkJbG9j
YWwgY2hpbGQgPSB7fQoJCWZvciBrLHYgaW4gcGFpcnModmFsKSBkbwoJCQlhZGQoY2hpbGQse2s9
ayx2PXZ9KQoJCWVuZAoKCQlidWJibGVfc29ydChjaGlsZCkKCQkKCQlmb3IgaT0xLCNjaGlsZCBk
bwoJCQlzeSA9IGFkZF9ub2RlKGNvbnRlbnQsIHZhbCwgY2hpbGRbaV0uaywgc3ksIGRlcHRoKzEp
CgkJZW5kCgkJCgkJLS0gc2hvdyB3aGVuIHRhYmxlIGlzIGVtcHR5IChbK10gbmVlZHMgdG8gc29t
ZXRoaW5nIHRvIGV4cGFuZCEpCgkJaWYgKCNjaGlsZCA9PSAwKSB0aGVuCgkJCXN5ID0gYWRkX25v
ZGUoY29udGVudCwgdmFsLG5pbCxzeSxkZXB0aCsxLCJ7ZW1wdHl9IikKCQllbmQKCWVuZAoJCgly
ZXR1cm4gc3kKZW5kCgoKZnVuY3Rpb24gY3JlYXRlX3BvZF9lZGl0b3IocGFyZW50LCBlbCkKCgkt
LSBpcyBsb2NhbCB0byBmaWxlCgljb250YWluZXIgPSBwYXJlbnQ6YXR0YWNoKGVsKQoJCgktLSBu
ZWVkcyBhIGRyYXcgZnVuY3Rpb24gaW4gb3JkZXIgdG8gY2xpcAoJZnVuY3Rpb24gY29udGFpbmVy
OmRyYXcoKQoJZW5kCgoJLS0gaXMgbG9jYWwgdG8gZmlsZQoJY29udGVudCA9IGNvbnRhaW5lcjph
dHRhY2h7CgkJeD0wLHk9MCwKCQl3aWR0aD1jb250YWluZXIud2lkdGgsCgkJaGVpZ2h0PWNvbnRh
aW5lci5oZWlnaHQgLS0gd2lsbCBiZSB1cGRhdGVkIGJ5IGdlbmVyYXRlX3BwCgl9CgkKCQoJY29u
dGFpbmVyOmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoKCWxvY2FsIGZ1bmN0aW9uIGdlbmVyYXRlX3Bw
KCkKCQktLSBjbG9zZSBhbnkgYWN0aXZlIGVkaXRvcgoJCWlmICh0ZXh0ZWQpIHRleHRlZDpkZXRh
Y2goKQoJCQoJCS0tIGdlbmVyYXRlIGZyb20gc2NyYXRjaCBlYWNoIHRpbWUKCQlwcCA9IHt9CgkJ
ZW5jb3VudGVyZWQgPSB7fSAKCQlwcF9oZWlnaHQgPSBhZGRfbm9kZShjb250ZW50LCBwLCAibWV0
YWRhdGEiLCA3LCAwKQoJCXBwX2hlaWdodCA9IGFkZF9ub2RlKGNvbnRlbnQsIHAsICJjb250ZW50
cyIsIHBwX2hlaWdodCwgMCkKCQoJCS0tIG1pZ2h0IGJlIHJlZ2VuZXJhdGluZyB3aXRob3V0IHJl
ZnJlc2hpbmcgZ3VpCgkJaWYgKGNvbnRlbnQpIHRoZW4KCQkJY29udGVudC5oZWlnaHQgPSBtYXgo
cHBfaGVpZ2h0ICsgMjAsIGNvbnRhaW5lci5oZWlnaHQpCgkJZW5kCgkKCWVuZAoJCgoJZnVuY3Rp
b24gY29udGVudDpkcmF3KCkKCQlyZWN0ZmlsbCgwLCAwLCBzZWxmLndpZHRoLTEsIHNlbGYuaGVp
Z2h0LTEsIDEpCgkJCgkJbG9jYWwgc3kgPSAxMAoJCWxvY2FsIGl0ZW1faCA9IDEyCgkJCgkJLS0g
dG8gZG86IHVzZSB5IHRvIHJlbmRlciBvbmx5IG5lZWRlZCBpdGVtcwoJCWZvciBpPTEsI3BwIGRv
CgkJCgkJCWxvY2FsIGl0ZW0gPSBwcFtpXQoJCQlsb2NhbCBzeCA9IDEwICsgaXRlbS5kZXB0aCAq
IDEwCgkJCS0tbG9jYWwgc3kgPSAxMCArIChpdGVtLnkgb3IgMCkgIC0tIHkKCQkJbG9jYWwgc3kg
PSBpdGVtLnN5CgkJCQoJCQlsb2NhbCBrZXkgPSBpdGVtLmtleQoJCQlsb2NhbCBwYXJlbnQgPSBp
dGVtLnBhcmVudAoJCQkKCQkJaWYgaSA9PSBzZWxlY3RlZCBhbmQgbm90IGVkaXRpbmdfcGFyZW50
IHRoZW4KCQkJCXJlY3RmaWxsKDAsc3ktMiw0ODAsc3kraXRlbS5oZWlnaHQtMywyKQoJCQllbmQK
CQkJCgkJCS0tIG1lc3N5OiB1c2UgdGhpcyBsb29wIGZvciBjYWxjdWxhdGluZyBkcmF3biB5IHRv
bwoJCQktLSB1c2UgZm9yIHBvc2l0aW9uaW5nIGN1cnNvciAvIHRleHQgYm94CgkJCS0taXRlbS5z
eSA9IHN5CgkJCWxvY2FsIHN5ID0gaXRlbS5zeSAKCQkJCgkJCWlmIGl0ZW0uZ3VpX2xhYmVsIHRo
ZW4KCQkJCS0tIGd1aSBsaW5lIChhZGQgaXRlbSkKCQkJCXByaW50KGl0ZW0uZ3VpX2xhYmVsLCBz
eCwgc3ksIDEzKQoJCQkKCQkJZWxzZWlmIGVkaXRpbmdfa2V5ID09IGtleSBhbmQgZWRpdGluZ19w
YXJlbnQgPT0gcGFyZW50IHRoZW4KCQkJCQoJCQkJaWYgKGVkaXRpbmdfd2hpY2ggPT0gImtleSIp
IHRoZW4KCQkJCQlwcmludCgia2V5OiIsIHN4LCBzeSwgMTMpCgkJCQllbHNlCgkJCQkJLS0gZWRp
dGluZyBhIHZhbHVlCgkJCQkJbG9jYWwgbGFiZWwgPSBnZXRfa2V5X3N0cihrZXkpCgkJCQkJcHJp
bnQoIlxmZSIuLmxhYmVsLi4iIFxmNiIsIHN4LCBzeSwgdGV4dF9jb2wpCgkJCQllbmQKCQkJCQoJ
CQllbHNlCgkJCQktLSB2YWx1ZQkKCQkJCWxvY2FsIHZhbCA9IHBhcmVudFtrZXldCgkJCQlpZiAo
dHlwZSh2YWwpID09ICJ0YWJsZSIpIHRoZW4KCQkJCQlsb2NhbCBsYWJlbCA9IGdldF9rZXlfc3Ry
KGtleSx2YWwpCgkJCQkJCgkJCQkJcHJpbnQoKGV4cGFuZFt2YWxdIGFuZCAiWy1dICIgb3IgIlsr
XSAiKS4ubGFiZWwsIHN4LCBzeSwgdGV4dF9jb2wpCgkJCQllbHNlCgkJCQkJbG9jYWwgbGFiZWwg
PSBnZXRfa2V5X3N0cihrZXkpLi4iICIKCQkJCQlsb2NhbCBjb2wgPSAiXGY2IgoJCQkJCWlmICh0
eXBlKHZhbCkgIT0gInN0cmluZyIpIGNvbCA9ICJcZmMiCgkJCQkJbG9jYWwgeHggPSBwcmludCgi
XGZlIi4ubGFiZWwsc3gsc3ksdGV4dF9jb2wpCgkJCQkJcHJpbnQoY29sLi50b3N0cih2YWwpLCB4
eCwgc3ksIHRleHRfY29sKQoJCQkJCQoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJCQoJZW5kCgkKCWZ1
bmN0aW9uIGNvbnRlbnQ6dGFwKG1zZykKCQktLWxvY2FsIGkgPSAxICsgeSBcIDEyCgkJY2xvc2Vf
dGV4dGVkKHRydWUpCgkJCgkJbG9jYWwgaSA9IDEKCQl3aGlsZSAoaSA8ICNwcCBhbmQgbXNnLm15
ID49IHBwW2ldLnN5ICsgcHBbaV0uaGVpZ2h0KSBkbwoJCQlpICs9IDEKCQllbmQKCQkKCQlpZiAo
aSA8IDEgb3IgaSA_ICNwcCkgcmV0dXJuCgkJCgkJbG9jYWwgc2VsZWN0ZWQwID0gc2VsZWN0ZWQK
CQlzZWxlY3RlZCA9IGkJCgkJLS1wcmludGgoInNlbGVjdGVkOiAiLi5zZWxlY3RlZCkKCgkJbG9j
YWwgaXRlbSA9IHBwW2ldCgkJbG9jYWwga2V5ID0gaXRlbS5rZXkKCQlsb2NhbCBwYXJlbnQgPSBp
dGVtLnBhcmVudAoJCQkKCQktLSBidXR0b24gKG5vdCBjdXJyZW50bHkgdXNlZCkKCQlpZiAoaXRl
bS5ndWlfbGFiZWwpIHRoZW4KCQkJaWYgKGl0ZW0uZ3VpX2xhYmVsID09ICJbbmV3XSIpIHRoZW4K
CQkJCWFkZChwYXJlbnQsICJuZXcgaXRlbSBzdHJpbmciKQoJCQkJcmVmcmVzaF9ndWkgPSB0cnVl
CgkJCQkKCQkJZW5kCgkJCXJldHVybgoJCWVuZAoJCQoJCS0tIGV4cGFuZCB0YWJsZQoJCQoJCS0t
IGNsaWNrIG9uIGl0ZW0gdG8gZXhwYW5kIC8gZWRpdAoJCWxvY2FsIHZhbCA9IHBhcmVudFtrZXld
CgkJCgkJbG9jYWwgeHggPSAxMCArIGl0ZW0uZGVwdGggKiAxMCAtLSBpbmRlbnRhdGlvbiBjYWxj
dWxhdGlvbiBkdXBlCgkJbG9jYWwga2sgPSBnZXRfa2V5X3N0cihrZXksIHZhbCkKCQlsb2NhbCBr
dyA9IHByaW50KGtrLDAsLTEwMDAwKQoJCWxvY2FsIGJ3ID0gdHlwZSh2YWwpID09ICJ0YWJsZSIg
YW5kIDIwIG9yIDAgLS0gYnV0dG9uIHdpZHRoCgkJCgkJaWYgKHR5cGUodmFsKSA9PSAidGFibGUi
IGFuZCBtc2cubXggPCB4eCArIGJ3KSB0aGVuCgkJCWV4cGFuZFt2YWxdID0gbm90IGV4cGFuZFt2
YWxdCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCWVsc2VpZiBtc2cubXggPCB4eCArIGJ3ICsga3cg
dGhlbgoJCQktLSBlZGl0IGtleQoJCQlpZiAoc2VsZWN0ZWQwID09IGkgb3IgbXNnLmxhc3RfbWIg
PiAxKSBlZGl0X3BwX2tleShpdGVtKQoJCWVsc2UKCQkJLS0gZWRpdCB2YWx1ZSAtLSBpZiBhbHJl
YWR5IHNlbGVjdGVkIAoJCQktLSB0byBkbzogcmlnaHQgY2xpY2sgZm9yIGNvbnRleHQgbWVudT8K
CQkJaWYgKHNlbGVjdGVkMCA9PSBpIG9yIG1zZy5sYXN0X21iID4gMSkgZWRpdF9wcF92YWx1ZShp
KQoJCWVuZAoJCQoJZW5kCgkKCS0tIHNvIHRoYXQgY2FuIGRvdWJsZSBjbGljayBvbiBhbiBpdGVt
IHRvIGVkaXQgaXQKCS0tIChvdGhlcndpc2Ugc2Vjb25kIHRhcCB3b24ndCBjb3VudCkKCS0tIHRv
IGRvOiByZXZpZXcgKiogbWF5YmUgYSBwcm9ibGVtIHdpdGggZXZlbnQgYmVoYXZpb3VyICoqCgkt
LSBjb250ZW50LmRvdWJsZWNsaWNrID0gY29udGVudC50YXAKCQoKCS0tIGhycm0uLiBjb3VsZCBi
ZSBhdXRvbWF0ZWQgYnkgYXR0YWNoX3Njcm9sbGJhcnMsIGJ1dCBzb21lIGN1c3RvbQoJLS0gbG9n
aWMgaW4gdGV4dCBlZGl0b3IgdmVyc2lvbgoJZnVuY3Rpb24gY29udGVudDpjbGFtcF9zY3JvbGxp
bmcoKQoJCWxvY2FsIG1heF95ID0gbWF4KDAsIGNvbnRlbnQuaGVpZ2h0IC0gY29udGFpbmVyLmhl
aWdodCkKCQljb250ZW50LnkgPSBtaWQoMCwgY29udGVudC55LCAtbWF4X3kpCgkJY29udGVudC54
ID0gbWluKDAsIGNvbnRlbnQueCkKCWVuZAoJZnVuY3Rpb24gY29udGVudDp1cGRhdGUoKQoKCQls
b2NhbCBzZWxlY3RlZF8wID0gc2VsZWN0ZWQKCQlpZiAobm90IGVkaXRpbmdfcGFyZW50KSB0aGVu
CgkJCWlmIChrZXlwKCJ1cCIpKSBzZWxlY3RlZCA9IG1pZCgxLCBzZWxlY3RlZCAtIDEsICNwcCkK
CQkJaWYgKGtleXAoImRvd24iKSkgIHNlbGVjdGVkID0gbWlkKDEsIHNlbGVjdGVkICsgMSwgI3Bw
KQoJCWVuZAoJCQoJCWlmIChzZWxlY3RlZCAhPSBzZWxlY3RlZF8wIGFuZCBjb250ZW50KSB0aGVu
CgkJCWNvbnRlbnQueSA9IG1pZCgtcHBbc2VsZWN0ZWRdLnN5LTYsIGNvbnRlbnQueSwgCgkJCQkt
cHBbc2VsZWN0ZWRdLnN5K2NvbnRhaW5lci5oZWlnaHQtMjIpCgkJZW5kCgkKCQljb250ZW50OmNs
YW1wX3Njcm9sbGluZygpCgllbmQKCQoJZnVuY3Rpb24gY29udGFpbmVyOm1vdXNld2hlZWwobXNn
KQoJCWlmIChrZXlkKCJjdHJsIikpIHRoZW4KCQkJY29udGVudC54ICs9IG1zZy53aGVlbF95ICog
MzIgCgkJZWxzZQoJCQljb250ZW50LnkgKz0gbXNnLndoZWVsX3kgKiAzMiAKCQllbmQKCWVuZAoJ
CglnZW5lcmF0ZV9wcCgpCgoJLS0gcmV0dXJuIGlubmVyIHRoaW5nIC0tIHNhbWUgYXMgY29kZSBl
ZGl0b3IKCXJldHVybiBjb250ZW50CmVuZAoKCmZ1bmN0aW9uIGdlbmVyYXRlX2d1aSgpCglndWlf
dyA9IGdldF9kaXNwbGF5KCk6d2lkdGgoKQoJZ3VpX2ggPSBnZXRfZGlzcGxheSgpOmhlaWdodCgp
CgkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCglwZSA9IGNyZWF0ZV9wb2RfZWRpdG9yKGd1aSwgewoJ
CXg9MCx5PTAsd2lkdGg9Z3VpX3csaGVpZ2h0PWd1aV9oCgl9KQoJCglwZS55ID0gc2Nyb2xsX3kK
CQoJLS0gYmFzZWQgc3RhcnRpbmcgY3Vyc29yIHBvc2l0aW9uIGluIHRleHQgZWRpdG9yIChpZiBp
dCBleGlzdHMpCgktLSBvbiBtb3VzZSBwb3NpdGlvbi4KCWlmICh0ZXh0ZWQpIHRleHRlZDpzZXRf
Y3Vyc29yKCkKCQoJCmVuZAoKLS0gc3RvcmUgZXhwYW5kW10gaW4gYSB3YXkgdGhhdCBjYW4gYmUg
c3RvcmVkIHdpdGhvdXQKLS0gcmVmZXJlbmNpbmcgdGhlIG5vZGVzIGluIHAgZGlyZWN0bHkgKGZv
ciB1bmRvaW5nKQoKZnVuY3Rpb24gc3RvcmVfZXhwYW5kX2RhdGEocCkKCS0tIHRyYXZlcnNlIHRy
ZWUgaW4gb3JkZXIKCWxvY2FsIGV4cCA9IHt9Cglsb2NhbCBmdW5jdGlvbiBhZGRfbm9kZShuKQoJ
CWlmICh0eXBlKG4pICE9ICJ0YWJsZSIpIHJldHVybgoJCWxvY2FsIG91dCA9IHtfX2V4cGFuZCA9
IGV4cGFuZFtuXX0KCQlmb3Igayx2IGluIHBhaXJzKG4pIGRvCgkJCWlmICh0eXBlKHYpID09ICJ0
YWJsZSIpIG91dFtrXSA9IGFkZF9ub2RlKHYpCgkJZW5kCgkJcmV0dXJuIG91dAoJZW5kCglyZXR1
cm4gYWRkX25vZGUocCkKZW5kCgpmdW5jdGlvbiByZXN0b3JlX2V4cGFuZF9kYXRhKHAsIGRhdCkK
CWV4cGFuZCA9IHt9CgktLXByaW50aCgiQEAgZXhwYW5kaW5nIGZyb206ICIuLnBvZChkYXQpKQoJ
LS0gcmVzdG9yZSBwb2Qgbm9kZSBwbm9kZSBmcm9tIG5vZGUgaW4gZGF0YSBkbm9kZQoJbG9jYWwg
ZnVuY3Rpb24gcmVzdG9yZV9ub2RlKHBub2RlLCBkbm9kZSkgCgkJaWYgKHR5cGUoZG5vZGUpICE9
ICJ0YWJsZSIpIHJldHVybgoJCWlmIChkbm9kZS5fX2V4cGFuZCkgZXhwYW5kW3Bub2RlXSA9IHRy
dWUKCQlmb3Igayx2IGluIHBhaXJzKGRub2RlKSBkbwoJCQlyZXN0b3JlX25vZGUocG5vZGVba10s
IGRub2RlW2tdKQoJCWVuZAoJZW5kCglyZXN0b3JlX25vZGUocCwgZGF0KQplbmQKCmZ1bmN0aW9u
IHNhdmVfd29ya2luZ19maWxlKCkKCXJldHVybiBwLmNvbnRlbnRzLCBwLm1ldGFkYXRhCgkKLS1b
WwoJc3RvcmUoY3VycmVudF9maWxlbmFtZSwgcC5jb250ZW50cywgcC5tZXRhZGF0YSkKCXByaW50
aCgic3RvcmluZyBtZXRhZGF0YTogIi4ucG9kKHAubWV0YWRhdGEpKQoJbG9jYWwgZSA9IHN0b3Jl
X2V4cGFuZF9kYXRhKHApCglsb2FkX3dvcmtpbmdfZmlsZShjdXJyZW50X2ZpbGVuYW1lKSAtLSB1
cGRhdGUgbWV0YWRhdGEhCglyZXN0b3JlX2V4cGFuZF9kYXRhKHAsIGUpCglub3RpZnkoInNhdmVk
ICIuLmN1cnJlbnRfZmlsZW5hbWUpCl1dCmVuZAoKCmZ1bmN0aW9uIGxvYWRfd29ya2luZ19maWxl
KGNvbnRlbnRzLCBtZXRhZGF0YSkKCglwID0gewoJCWNvbnRlbnRzID0gY29udGVudHMgb3Ige30s
CgkJbWV0YWRhdGEgPSBtZXRhZGF0YSBvciB7fQoJfQoKCWV4cGFuZCA9IHtbcC5jb250ZW50c109
dHJ1ZX0KZW5kCgpmdW5jdGlvbiBfaW5pdCgpCgoJcG9rZSgweDQwMDAsZ2V0KGZldGNoKCIvc3lz
dGVtL2ZvbnRzL2xpbC5mb250IikpKSAtLSB2YXJpYWJsZSB3aWR0aAoJcG9rZSgweDU2MDAsZ2V0
KGZldGNoKCIvc3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkpICAtLSBmb3IgdGlueSBudW1iZXJzCgkK
CXVuZG9fc3RhY2sgPSBjcmVhdGVfdW5kb19zdGFjaygKCQlmdW5jdGlvbigpIAoJCXJldHVybiB7
CgkJCXBvZChwKSwKCQkJc2VsZWN0ZWQsCgkJCXN0b3JlX2V4cGFuZF9kYXRhKHApLAoJCX0gCgkJ
ZW5kLAoJCQoJCWZ1bmN0aW9uKHMpCgkJCXAgPSB1bnBvZChzWzFdKQoJCQlzZWxlY3RlZCA9IHNb
Ml0KCQkJcmVzdG9yZV9leHBhbmRfZGF0YShwLCBzWzNdKQoJCQktLSBzaG93X2N1cnNvcigpCgkJ
ZW5kCgkpCgkKCQoKLS1bWwoJY2QoZW52KCkucGF0aCkKCQoJLS0gZ2V0X2ZpbGVuYW1lX2Zyb21f
YXJncyBsb2dpYwoJLS0gY2FuJ3QgdXNlIHdyYW5nbGVfd29ya2luZ19maWxlIGJlY2F1c2UgbmVl
ZCB0byBhbHNvIG1hbmFnZSBtZXRhZGF0YQoJbG9jYWwgZm4gPSAoZW52KCkuYXJndiBhbmQgZW52
KCkuYXJndlsxXSkgb3IgInVudGl0bGVkLnBvZCIKCWZuID0gZnVsbHBhdGgoZm4pCQoJY3VycmVu
dF9maWxlbmFtZSA9IGZ1bGxwYXRoKGZuKQoJCglsb2FkX3dvcmtpbmdfZmlsZShjdXJyZW50X2Zp
bGVuYW1lKQpdXQoJd2luZG93ewoJCXdpZHRoPTIwMCwKCQloZWlnaHQ9MjAwLAoJCXBhdXNlYWJs
ZSA9IGZhbHNlLAoJCWljb249dXNlcmRhdGEiW2dmeF0wODA4Nzc3MDAwMDA3MDcwMDAwMDc3NzAw
MDAwMDcwMDc3NzAwNzc3NzA3MDA3MDA3NzcwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIKCX0KCQoJ
d3JhbmdsZV93b3JraW5nX2ZpbGUoCgkJc2F2ZV93b3JraW5nX2ZpbGUsCgkJbG9hZF93b3JraW5n
X2ZpbGUsCgkJIi9yYW0vY2FydC91bnRpdGxlZC5wb2QiIC0tIGRlZmF1bHQKCSkKCQotLVtbCglt
ZW51aXRlbXsKCQlpZCA9ICJvcGVuX2ZpbGUiLAoJCWxhYmVsID0gIlxeOjdmNDE0MTQxN2Y2MTY1
MDAgT3BlbiBGaWxlIiwKCQlzaG9ydGN1dCA9ICJDVFJMLU8iLCAtLSBjdHJsLXMgaXMgaGFuZGxl
ZCBieSB3aW5kb3cgbWFuYWdlcgoJCWFjdGlvbiA9IGZ1bmN0aW9uKCkgCgkJCWNyZWF0ZV9wcm9j
ZXNzKCIvc3lzdGVtL2FwcHMvZmlsZW5hdi5wNjQiLCB7d2luZG93X2F0dHJpYnM9e3dvcmtzcGFj
ZSA9ICJjdXJyZW50In19KQoJCWVuZAoJfQoKCW1lbnVpdGVtewoJCWlkID0gInNhdmVfZmlsZSIs
CgkJbGFiZWwgPSAiXF46N2Y0MTQxNDE3ZjYxNjUwMCBTYXZlIEZpbGUiLAoJCXNob3J0Y3V0ID0g
IkNUUkwtUyIsIC0tIGN0cmwtcyBpcyBoYW5kbGVkIGJ5IHdpbmRvdyBtYW5hZ2VyCgkJYWN0aW9u
ID0gZnVuY3Rpb24oKSAKCQkJc2F2ZV93b3JraW5nX2ZpbGUoKQoJCQlub3RpZnkoInNhdmVkICIu
LmN1cnJlbnRfZmlsZW5hbWUpCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQktLXNlbmRfbWVzc2Fn
ZShwaWQoKSwge2V2ZW50ID0gInNhdmVfd29ya2luZ19maWxlIn0pCgkJZW5kCgl9Cl1dCgkKZW5k
CgoKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKDUpCgkKCWd1aTpkcmF3X2FsbCgpCgkKZW5kCgpmdW5j
dGlvbiBlZGl0X3BwX2tleShpdGVtKQoJbG9jYWwgcGFyZW50ID0gaXRlbS5wYXJlbnQKCWxvY2Fs
IGtleSA9IGl0ZW0ua2V5CgkKCWVkaXRpbmdfcGFyZW50ID0gcGFyZW50CgllZGl0aW5nX2tleSAg
ICA9IGtleQoJZWRpdGluZ193aGljaCAgPSAia2V5IgoJCQoJcmVmcmVzaF9ndWkgPSB0cnVlCmVu
ZAoKZnVuY3Rpb24gZWRpdF9wcF92YWx1ZShpLCBrKQoJbG9jYWwgaXRlbSA9IHBwW2ldCglsb2Nh
bCBwYXJlbnQgPSBpdGVtLnBhcmVudAoJbG9jYWwga2V5ID0gaXRlbS5rZXkKCQoJCgkKCS0tIGV4
cGFuZCAvIGNvbGxhcHNlIHRhYmxlCglpZiAodHlwZShwYXJlbnRba2V5XSkgPT0gInRhYmxlIikg
dGhlbgoJCWV4cGFuZFtwYXJlbnRba2V5XV0gPSBub3QgZXhwYW5kW3BhcmVudFtrZXldXQoJCXJl
ZnJlc2hfZ3VpID0gdHJ1ZQoJCXJldHVybgoJZW5kCgkKCS0tIHRvZ2dsZSBib29sZWFuCglpZiAo
dHlwZShwYXJlbnRba2V5XSkgPT0gImJvb2xlYW4iKSB0aGVuCgkJcGFyZW50W2tleV0gPSBub3Qg
cGFyZW50W2tleV0KCQlyZXR1cm4KCWVuZAoJCglpZiAodHlwZShwYXJlbnRba2V5XSkgPT0gIm51
bWJlciIgYW5kIChrPT0ibGVmdCIgb3Igaz09InJpZ2h0IikpIHRoZW4KCQlpZiAoaz09ImxlZnQi
KSBwYXJlbnRba2V5XSAtPSAxCgkJaWYgKGs9PSJyaWdodCIpIHBhcmVudFtrZXldICs9IDEKCQly
ZXR1cm4KCWVuZAoJCgktLSB1c2VyZGF0YSAtLSBjYW4ndCBlZGl0IHlldAoJaWYgKHR5cGUocGFy
ZW50W2tleV0pID09ICJ1c2VyZGF0YSIpIHRoZW4KCQlyZXR1cm4KCWVuZAoJCgllZGl0aW5nX3Bh
cmVudCA9IHBhcmVudAoJZWRpdGluZ19rZXkgICAgPSBrZXkKCWVkaXRpbmdfd2hpY2ggID0gInZh
bHVlIgoJZWRpdGluZ19pbmRleCAgPSBpCglyZWZyZXNoX2d1aSA9IHRydWUKCQplbmQKCgpmdW5j
dGlvbiB1cGRhdGVfdGV4dGVkKCkKCWlmIChub3QgdGV4dGVkKSByZXR1cm4KCQoJCWxvY2FsIG51
bV9saW5lcyA9ICN0ZXh0ZWQ6Z2V0X3RleHQoKQoJCWlmIChudW1fbGluZXMgIT0gbGFzdF9udW1f
bGluZXMpIHRoZW4KCQkKCQkJLS0gcmVzaXplICh3aXRob3V0IHJlZnJlc2hpbmcgZ3VpKQoJCQls
b2NhbCBoaDAgPSB0ZXh0ZWQucGFyZW50LmhlaWdodAoJCQlsb2NhbCBoaCAKCQkJXyxoaCA9IHBy
aW50KHRhYmxlLmNvbmNhdCh0ZXh0ZWQ6Z2V0X3RleHQoKSwiXG4iKSwgMTAwMDAwLCAwKQoJCQls
b2NhbCBkaCA9IGhoIC0gaGgwCgkJCQoJCQktLSB1cGRhdGUgaGVpZ2h0IG9mIHRleHQgZWRpdG9y
IGJveAoJCQl0ZXh0ZWQuaGVpZ2h0ICs9IGRoCgkJCXRleHRlZC5wYXJlbnQuaGVpZ2h0ICs9IGRo
CgkJCXBwX2hlaWdodCArPSBkaAoJCQlpZiAoY29udGVudCkgdGhlbgoJCQkJY29udGVudC5oZWln
aHQgPSBtYXgocHBfaGVpZ2h0ICsgMjAsIGNvbnRhaW5lci5oZWlnaHQpCgkJCWVuZAoJCQkKCQkJ
LS0gdXBkYXRlIHBvc2l0aW9ucyBvZiBpdGVtcyBiZWxvdyB0aGlzIG9uZQoJCQlwcFtlZGl0aW5n
X2luZGV4XS5oZWlnaHQgKz0gZGgKCQkJZm9yIGk9ZWRpdGluZ19pbmRleCsxLCAjcHAgZG8KCQkJ
CXBwW2ldLnN5ICs9IGRoCgkJCWVuZAoJCQkKCQllbmQKCQlsYXN0X251bV9saW5lcyA9IG51bV9s
aW5lcwoJCQplbmQKCmZ1bmN0aW9uIG5ld19pdGVtKHByZWZpeCwgbmV3dmFsLCBkaW5kZXgpCgl1
bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQoJZGluZGV4ID0gZGluZGV4IG9yIDAKCWxvY2FsIGl0ZW0g
PSBwcFtzZWxlY3RlZF0KCQlsb2NhbCBwYXJlbnQgPSBpdGVtLnBhcmVudFtpdGVtLmtleV0KCQls
b2NhbCBpbmRleCA9IG5pbAoJCQoJCS0tIGxlYWYgb3IgdW5leHBhbmRlZCB0YWJsZSAtPiBvcGVy
YXRlIG9uIHBhcmVudAoJCWlmICh0eXBlKHBhcmVudCkgIT0gInRhYmxlIiBvciBub3QgZXhwYW5k
W3BhcmVudF0pIHRoZW4KCQkJcGFyZW50ID0gaXRlbS5wYXJlbnQgCgkJCWlmICh0eXBlKGl0ZW0u
a2V5KSA9PSAibnVtYmVyIikgaW5kZXggPSBpdGVtLmtleSArIGRpbmRleAoJCWVuZAoJCQoJCWlm
ICh0eXBlKGluZGV4KSA9PSAibnVtYmVyIikgdGhlbgoJCQlhZGQocGFyZW50LCBuZXd2YWwsIGlu
ZGV4KQoJCQktLSBlZGl0IHN0cmFpZ2h0IGF3YXkgKHdoZW4gbm90IGEgdGFibGUpCgkJCWlmICh0
eXBlKG5ld3ZhbCkgIT0gInRhYmxlIikgdGhlbgoJCQkJZWRpdGluZ19wYXJlbnQgPSBwYXJlbnQK
CQkJCWVkaXRpbmdfa2V5ID0gaW5kZXgKCQkJZW5kCgkJZWxzZQoJCQktLSBuZXcgc3RyaW5nIGtl
eQoJCQlsb2NhbCBrZXlpID0gMAoJCQlsb2NhbCBrZXkgPSBwcmVmaXguLmtleWkKCQkJd2hpbGUg
dHlwZShwYXJlbnRba2V5XSkgIT0gIm5pbCIgZG8KCQkJCWtleWkgKz0gMQoJCQkJa2V5ID0gcHJl
Zml4Li5rZXlpCgkJCWVuZAoJCQlwYXJlbnRba2V5XSA9IG5ld3ZhbAoJCQktLSBlZGl0IGl0CgkJ
CWVkaXRpbmdfcGFyZW50ID0gcGFyZW50CgkJCWVkaXRpbmdfa2V5ID0ga2V5CgkJCWVkaXRpbmdf
d2hpY2ggPSAia2V5IgoJCWVuZAoJCQoJCWV4cGFuZFtwYXJlbnRdID0gdHJ1ZSAtLSBtYWtlIHN1
cmUgaXRzIHZpc2libGUKCQlyZWZyZXNoX2d1aSA9IHRydWUKZW5kCgotLVtbCgkiZmFsc2UiIDwt
LT4gZmFsc2UKCSIzLjUiICAgPC0tPiAzLjUKCSIiICAgICAgPC0tPiB7fQpdXQpmdW5jdGlvbiB0
b2dnbGVfdHlwZSgpCgl1bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQoJbG9jYWwgaXRlbSA9IHBwW3Nl
bGVjdGVkXQoJbG9jYWwgcGFyZW50ID0gaXRlbS5wYXJlbnQKCWxvY2FsIGtleSAgICA9IGl0ZW0u
a2V5Cglsb2NhbCB2YWwgICAgPSBwYXJlbnRba2V5XQoJCgl0eXBlMCA9IHR5cGUodmFsKQoJaWYg
KHR5cGUwID09ICJzdHJpbmciKSB0aGVuCgkJbG9jYWwgbnVtID0gdG9udW0odmFsKQkKCgkJaWYg
ICAgIHZhbCA9PSAiZmFsc2UiIHRoZW4gcGFyZW50W2tleV0gPSBmYWxzZQoJCWVsc2VpZiB2YWwg
PT0gInRydWUiICB0aGVuIHBhcmVudFtrZXldID0gdHJ1ZQoJCWVsc2VpZiB2YWwgPT0gIiIgICAg
ICB0aGVuIHBhcmVudFtrZXldID0ge30KCQllbHNlaWYgbnVtICAgICAgICAgICAgdGhlbiBwYXJl
bnRba2V5XSA9IG51bQoJCWVuZAoJCQoJZWxzZWlmICh0eXBlMCA9PSAiYm9vbGVhbiIgb3IgdHlw
ZTAgPT0gIm51bWJlciIpIHRoZW4KCQlwYXJlbnRba2V5XSA9IHRvc3RyKHBhcmVudFtrZXldKQoJ
ZWxzZWlmICh0eXBlMCA9PSAidGFibGUiKSB0aGVuCgkJcGFyZW50W2tleV0gPSAiIgoJZW5kCgkK
ZW5kCgoKZnVuY3Rpb24gdXBkYXRlX2tiZCgpCgoJLS0gd2hlbiBlZGl0aW5nIHRleHQsIGxldCBh
bGwga2V5Ym9hcmQgZXZlbnRzIGdvIHRoZXJlCglpZiAodGV4dGVkKSByZXR1cm4KCQoJLS0gZGVs
ZXRlIGF0IHBvcwoJaWYgKGtleXAoImRlbCIpKSB0aGVuCgkJdW5kb19zdGFjazpjaGVja3BvaW50
KCkKCQlsb2NhbCBpdGVtID0gcHBbc2VsZWN0ZWRdCgkJaXRlbS5wYXJlbnRbaXRlbS5rZXldID0g
bmlsCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJLS0gaW5zZXJ0IGF0IHBvcwoJaWYgKGtl
eXAoImluc2VydCIpKSB0aGVuCgkJbmV3X2l0ZW0oIl9rZXlfIiwiIikKCWVuZAoJCgktLSBpbnNl
cnQgYWZ0ZXIgcG9zCglpZiAoa2V5cCgiZW50ZXIiKSBhbmQga2V5ZCgic2hpZnQiKSkgdGhlbgoJ
CW5ld19pdGVtKCJfa2V5XyIsIiIsMSkKCQljbGVhcl9rZXkoImVudGVyIikKCWVuZAoJCgktLSB0
b2dnbGUgdHlwZQoJaWYgKGtleXAoInQiKSBhbmQga2V5ZCgiY3RybCIpKSB0aGVuCgkJdG9nZ2xl
X3R5cGUoKQoJZW5kCgkKCS0tIHRvIGRvOiBjYW4gYWxzbyBwcmVzcyBsZWZ0L3JpZ2h0IHRvIGV4
cGFuZC9jb2xsYXBzZSB0YWJsZXMKCS0tIGFuZCB0byBpbmMvZGVjciB2YWx1ZXMKCWlmICgoa2V5
cCgiZW50ZXIiKSBvciBrZXlwKCJsZWZ0Iikgb3IgCgkJCWtleXAoInJpZ2h0IikpKSB0aGVuCgkJ
ayA9IG5pbAoJCWlmIChrZXlwKCJsZWZ0IikpICBrID0gImxlZnQiCgkJaWYgKGtleXAoInJpZ2h0
IikpIGsgPSAicmlnaHQiCgkJCgkJZWRpdF9wcF92YWx1ZShzZWxlY3RlZCwgaykKCQljbGVhcl9r
ZXkoImVudGVyIikgLS0gZG9uJ3QgaW1tZWRpYXRlbHkgY2xvc2UgYWdhaW4JCgllbmQKCQoJaWYg
KGtleWQoImN0cmwiKSkgdGhlbgoJCWlmIGtleXAoInoiKSB0aGVuCgkJCWxvY2FsIHJlcyA9IHVu
ZG9fc3RhY2s6dW5kbygpCgkJCS0tcHJpbnRoKCJ1bmRvaW5nOiAiLi50b3N0cihyZXMpKQoJCQly
ZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCgkJaWYga2V5cCgieSIpIHRoZW4KCQkJdW5kb19zdGFj
azpyZWRvKCkKCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJZW5kCgkJLS1bWwoJCWlmIGtleXAoInMi
KSB0aGVuCgkJCXNhdmVfd29ya2luZ19maWxlKCkKCQkJbm90aWZ5KCJzYXZlZCAiLi5jdXJyZW50
X2ZpbGVuYW1lKQoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCQldXQoJCQoJCWlmIGtleXAo
InYiKSB0aGVuCgkJCWxvY2FsIGl0ZW0gPSBwcFtzZWxlY3RlZF0KCQkJbG9jYWwgdGV4dCA9IGdl
dF9jbGlwYm9hcmQoKQoJCQlsb2NhbCBjLG0gPSB1bnBvZCh0ZXh0KQoJCQlpZiAoYykgdGhlbgoJ
CQkJaXRlbS5wYXJlbnRbaXRlbS5rZXldID0gYwoJCQllbHNlCgkJCQlpdGVtLnBhcmVudFtpdGVt
LmtleV0gPSB0ZXh0CgkJCWVuZAoJCQkKCQllbmQKCQkKCQlpZiBrZXlwKCJjIikgdGhlbgoJCQls
b2NhbCBpdGVtID0gcHBbc2VsZWN0ZWRdCgkJCWxvY2FsIHZhbCA9IGl0ZW0ucGFyZW50W2l0ZW0u
a2V5XQoJCQlpZiAodHlwZSh2YWwpID09ICJzdHJpbmciIG9yIHR5cGUodmFsKSA9PSAibnVtYmVy
IikgdGhlbgoJCQkJc2V0X2NsaXBib2FyZCh0b3N0cih2YWwpKQoJCQllbHNlCgkJCQlzZXRfY2xp
cGJvYXJkKHRvc3RyKHBvZCkpCgkJCWVuZAoJCWVuZAoJCQoJCQoJZW5kCmVuZAoKCmZ1bmN0aW9u
IF91cGRhdGUoKQoKCXVwZGF0ZV90ZXh0ZWQoKQoJdXBkYXRlX2tiZCgpCgkKCWlmIHJlZnJlc2hf
Z3VpIG9yCgkJZ3VpX3cgIT0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIG9yCgkJZ3VpX2ggIT0gZ2V0
X2Rpc3BsYXkoKTpoZWlnaHQoKQoJdGhlbgoJCWdlbmVyYXRlX2d1aSgpCgkJcmVmcmVzaF9ndWkg
PSBmYWxzZQoJZW5kCgkKCWd1aTp1cGRhdGVfYWxsKCkKCQoJc2Nyb2xsX3kgPSBwZS55CmVuZAoK
Cgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9InplcCIsY3JlYXRlZD0iMjAyMy0xMC0yMiAx
MDoyODoxMyIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDAwMDAw
MDAwMDAwMDAwMDAwMDEwNjA2MDcwNzA3MDEwMDAwMDAwMDAwMDAwMDAwMDAwMTA2MDYwNzA3MDcw
MTAwMDAwMDAwMDAwMDAwMDAwMDAxMDYwNjA2MDYwNjAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAx
MGQwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZDAxMDAwMDAwMDEwMTAxMDEwMTAxMDAw
MDAwMDAwMTBkMDEwMTAxMDEwMTA2MDYwNzA3MDEwMDAwMDAwMDAxMGQwZDBkMGQwZDBkMDYwNjA3
MDcwMTAwMDAwMDAwMDEwZDAxMDEwMTAxMDEwNjA2MDYwNjAxMDAwMDAwMDAwMTBkMDEwMDAwMDAw
MTAxMDEwMTAxMDEwMDAwMDAwMDAxMGQwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZDAx
MDAwMDAwMDEwMTAxMDEwMTAxMDAwMDAwMDAwMTBkMDEwMTAxMDEwMTA2MDYwNzA3MDEwMDAwMDAw
MDAxMGQwZDBkMGQwZDBkMDYwNjA3MDcwMTAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwNjA2MDYwNjAx
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9k
aWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLG5vdGVzPSIiLHJ1bnRpbWU9NyxzdG9yZWQ9IjIw
MjMtMjUtMTggMTE6MjU6MjIiLHRpdGxlPSJwb2R0cmVlIix2ZXJzaW9uPSIwLjEiLHdvcmtzcGFj
ZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
Z2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn19XV0KOjogY29kZS5wb2QKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEyTFRBMElERXhPakl3T2pBMElpeHRiMlJwWm1sbFpEMGlN
akF5TkMwdwpOaTB3TkNBeE1Ub3lNRG93TkNJc2NtVjJhWE5wYjI0OU1GMWRiSG8wQUFNQUFBQUNB
QUFBSUh0OQo6OiBkYXQucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFeUxU
RXdJREExT2pFeU9qUXlJaXh0YjJScFptbGxaRDBpTWpBeU15MHkKT0MweE1DQXdOVG95T0RveE5T
SXNjbVYyYVhOcGIyNDlOMTFkZTJadmJ6MGlOaUlzYUc5blpUMGliMnRsZVdSdmEyVWlmUT09Cjo6
IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIyIDEwOjI4OjEzIixtb2Rp
ZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTI4LTIyIDEwOjI4OjEzIl1d
Cjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUQTFMVE13SURF
d09qQTFPak16SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck5pMHdOaUF3TlRvME16b3dOQ0lzY21W
MmFYTnBiMjQ5TVRRM1hWMXNlalFBcUFBQUFGQXhBQUR4Rm50Yk1GMDllMkp0Y0Qxd2VIVUEKUXlB
UUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NFBUSUlBTXA1UFRJc2VtOXZiVDA0ZlN3eEFHVUFZWUFC
UndFRUFQVUdJUWNob0FFSApBU0JSTUFFSFFUY0JNQUVIUmpjQkRBQUNHQUF1QWNBaUFHOWhOd0dR
VVFCOEFCd3Y4UEF4QVAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tNlpRYlQwNGZYMD0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9k
LGNyZWF0ZWQ9IjIwMjMtMTAtMjIgMTA6Mjg6MTMiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3
OjM4IixzdG9yZWQ9IjIwMjMtMjgtMjIgMTA6Mjg6MTMiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRRM0xURTRJREV3T2pRM09qTXpJaXh0YjJScFptbGxa
RDBpTWpBeU15MHgKT0MweU1pQXdOVG94T0RveE5TSXNjbVYyYVhOcGIyNDlOMTFkZTJ4aGVXVnlQ
WHRiTUYwOWUySnRjRDExYzJWeVpHRjBZU2dpYVRFMgpJaXd4Tml3eE5pd2lNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURB
d01DSXBMSEJoYmw5NFBUQXNjR0Z1WDNrOU1DeHpZMkZzWlQweExIUnBiR1ZmYUQweE5peDBhV3hs
WDNjOU1UWjlmWDA9Cjo6IHVudGl0bGVkLnBvZApiNjQkTFMxYlczQnZaQ3hmYzNsemRHVnRQWHRm
WkdWell6MGlZWEJ3SUdSaGRHRWdaMjlsY3lCb1pYSmxPeUJsTG1jdUlITmxZWEpqCmFDQmliRzl2
YlN3Z2RXNXBkbVZ5YzJGc0lHWnBiR1VnU1VRc0lHMWtOVDhpZlN4aGRYUm9iM0k5SW5wbGNESWlM
R055WldGMFpXUTkKSWpJd01qUXRNRFl0TURRZ01EWTZNak02TWpjaUxHMXZaR2xtYVdWa1BTSXlN
REkwTFRBMkxUQTJJREEwT2pVeE9qVXpJaXh5WlhacApjMmx2YmoweE1DeDBhWFJzWlQwaVptOXZJ
bDFkYkhvMEFLb0JBQUFkQXdBQTh5NTdZWFZrYVc4OVptRnNjMlVzWTI5c2IzVnljejE3CkluUm9a
U0lzSW5GMWFXTnJJaXdpWW5KdmQyNGlMQ0ptYjNnaWZTeG1kV3hzYzJOeVpXVnVOd0R5R21samIy
NDljSGgxQUVNZ0NBZ0UKSjBBSEFBZEFKMUFIRUNjUU53QUhFQWNRSi1BQkxIUm9aVzFsV1FCamJX
VWdNU0lzQ2dBVk1nb0FGVE1LQUJVMENnQVZOUW9BRlRZSwpBQlUzQ2dBVk9Bb0FGVGtLQUNZeE1B
c0FCbVlBRmpGbkFCWXhhQUFXTVdrQUZqRnFBQll4YXdBV01Xd0FGakZ0QUJZeGJnQVdNbTRBCkZ6
TFVBQVp1QUJZeWJnQVdNbTRBRmpKdUFCWXliZ0FXTW00QUZqSnVBQll5YmdBV00yNEFGak51QUJZ
emJnQVdNMjRBRmpOdUFCWXoKYmdBV00yNEFGak51QUJZemJnQVdNMjRBRmpSdUFCWTBiZ0FXTkc0
QUZqUnVBQlkwYmdBV05HNEFGalJ1QUJZMGJnQVdORzRBRmpSdQpBUEVtTlRBaWZTeDJiMngxYldV
OU1qUXNkMmx1Wkc5M1gzTmpZV3hsUFRJc2VuTjBjajBpZEdocGN5QnBjeUJoSUhOMGNtbHVaeUlZ
CkFCZ3lHUUNUYlhWc2RHbHNhVzVsSXdBaFhHNE5BQk15Q0FBaU0ySTBBS2t6UFNKaGJtOTBhR1Z5
U3dBUU5CY0FzR1FnWVc1dmRHaGwKY2lKOQo6OiBbZW9jXQo=
:: bios/apps/settings.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTAyIDA2OjQ0OjUyIixtb2RpZmllZD0iMjAyNS0wNi0yNiAwNDo0Njo1OSIs
cmV2aXNpb249MTYxN11dCi0tIHBpY290cm9uIHNldHRpbmdzCi0tIGE4OiB0YWJiZWQKCnBhZ2Ug
PSAxCnNkYXQgPSB7fQoKCmZ1bmN0aW9uIGNyZWF0ZV9jaGVja2JveCh4LCB5LCBsYWJlbCwga2V5
KQoJbG9jYWwgZWwgPSB7CgkJeCA9IHgsIHkgPSB5LAoJCXdpZHRoID0gOTgsCgkJaGVpZ2h0ICA9
IDEyLAoJCWxhYmVsID0gbGFiZWwsCgkJa2V5ID0ga2V5LAoJCWN1cnNvciA9ICJwb2ludGVyIgoJ
fQoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0KDAsMCw4LDgsMSkKCQlpZiAoc2RhdFtrZXld
KSByZWN0ZmlsbCgyLDIsNiw2LDEpCgkJcHJpbnQobGFiZWwsIDE1LCAxLCAxMykKCWVuZAoJCglm
dW5jdGlvbiBlbDpjbGljaygpCgkJc2RhdFtrZXldID0gbm90IHNkYXRba2V5XQoJCXN0b3JlX3Nl
dHRpbmdzKCkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVfY2hvb3Nlcihw
YXJlbnQsIHgsIHksIGtleSwgcGF0aCkKCglsb2NhbCBlbCA9IHBhcmVudDphdHRhY2h7CgkJeCA9
IHgsIHkgPSB5LAoJCXdpZHRoID0gOTYsCgkJaGVpZ2h0PTYwLAoJCWtleT1rZXksCgkJcGF0aD1w
YXRoLAoJCXNxdWFzaF90b19jbGlwPXRydWUKCX0KCQoJbG9jYWwgaXRlbV9oID0gMTIKCQoJZnVu
Y3Rpb24gZWw6ZHJhdygpCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQt
MSwxKQoJCWxvY2FsIHJlY3QgPSB7Y2xpcCgpfQoJCXByaW50KCJcMDE0XF5pICIuLnNlbGYua2V5
Li4iICIsMSwtNiwxMykKCQljbGlwKHVucGFjayhyZWN0KSkKCWVuZAoKCWxvY2FsIHBhdGgxID0g
cGF0aAoKCgktLSBjdXN0b20gZm9sZGVyCglpZiAoZnN0YXQoIi9hcHBkYXRhIi4ucGF0aCkgPT0g
ImZvbGRlciIpIHRoZW4KCQlwYXRoMSA9ICIvYXBwZGF0YSIuLnBhdGgKCWVuZAoJZmlsZXMgPSBs
cyhwYXRoMSkgb3Ige30KCQoJCglsb2NhbCBpdGVtID0ge30KCWlmIChwYXRoID09ICIvc3lzdGVt
L3RoZW1lcyIpIHRoZW4KCQlhZGQoaXRlbSwge2xhYmVsID0gIltjdXN0b21dIiwgZmlsZW5hbWUg
PSAiL2FwcGRhdGEvc3lzdGVtL3RoZW1lLnBvZCJ9KQoJZW5kCgoJaWYgKHBhdGggPT0gIi9zeXN0
ZW0vc2NyZWVuc2F2ZXJzIikgdGhlbgoJCWFkZChpdGVtLCB7bGFiZWwgPSAiW25vbmVdIiwgZmls
ZW5hbWUgPSBuaWx9KQoJZW5kCgkKCWZvciBpPTEsICNmaWxlcyBkbwoJCWFkZChpdGVtLCB7bGFi
ZWwgPSBzcGxpdChmaWxlc1tpXSwiLiIpWzFdLCBmaWxlbmFtZSA9IHBhdGgxLi4iLyIuLmZpbGVz
W2ldfSkKCWVuZAoJCglsb2NhbCBjb250ZW50cyA9IGVsOmF0dGFjaHsKCQl4ID0gMCwgeSA9IDAs
CgkJd2lkdGggPSA4MCwgaGVpZ2h0ID0gOCArICNpdGVtICogaXRlbV9oLAoJCWl0ZW0gPSBpdGVt
Cgl9CgkKCWZ1bmN0aW9uIGNvbnRlbnRzOmRyYXcoKQoJCWZvciBpID0gMSwgI3NlbGYuaXRlbSBk
bwoJCQlsb2NhbCBpdGVtID0gc2VsZi5pdGVtW2ldCgkJCWxvY2FsIHl5ID0gNCArIChpLTEpKml0
ZW1faAoJCQljb2xvcig2KQoJCQlpZiAoaXRlbS5maWxlbmFtZSA9PSBzZGF0W2tleV0pIHJlY3Rm
aWxsKDAseXktMSxzZWxmLndpZHRoLTEseXkrOCkgY29sb3IoMSkKCQkJcHJpbnQoaXRlbS5sYWJl
bCwgMywgeXkpCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gY29udGVudHM6Y2xpY2sobXNnKQoJCWxv
Y2FsIGkgPSBtaWQoMSwgMSArIChtc2cubXkgLSA0KSBcIGl0ZW1faCwgI3NlbGYuaXRlbSkKCQlu
ZXdpID0gaSB_PSBsYXN0X2kgbGFzdF9pID0gaQoJCQoJCS0tIGFjdCBvbiBzZWxlY3Rpb24gKGNh
biByZXR1cm4gZWFybHkgdG8gcmVqZWN0IGNoYW5nZSkKCQkKCQktLSB0aGVtZSBjaGFuZ2U6IGNv
cHkgb3ZlciBzeXN0ZW0gZGVmYXVsdAoJCWlmIChwYXRoID09ICIvc3lzdGVtL3RoZW1lcyIpIHRo
ZW4KCQkJbG9jYWwgdGRhdCA9IGZldGNoKHNlbGYuaXRlbVtpXS5maWxlbmFtZSkKCQkJaWYgKHRk
YXQpIHN0b3JlKCIvcmFtL3NoYXJlZC90aGVtZS5wb2QiLCB0ZGF0KQoJCWVuZAoJCQoJCS0tIGRl
c2t0b3AgY2hhbmdlOiBraWxsIHByb2Nlc3MgYW5kIHN0YXJ0IG5ldyBvbmUgKCEpCgkJaWYgKHBh
dGggPT0gIi9zeXN0ZW0vd2FsbHBhcGVycyIpIHRoZW4KCQkJc2VuZF9tZXNzYWdlKDMsIHtldmVu
dD0ic2V0X3dhbGxwYXBlciIsIHdhbGxwYXBlciA9IHNlbGYuaXRlbVtpXS5maWxlbmFtZX0pCgkJ
ZW5kCQoJCQoJCS0tIHN0b3JlIGNoYW5nZSBpbiBzeXN0ZW0gc2V0dGluZ3MKCQktLSB0aGVtZSwg
d2FsbHBhcGVyIGFuZCBzY3JlZW5zYXZlciBhcmUgYWxsIGZ1bGwgcGF0aCBmaWxlbmFtZXMKCQkK
CQlzZGF0W2tleV0gPSBzZWxmLml0ZW1baV0uZmlsZW5hbWUKCQlzdG9yZV9zZXR0aW5ncygpCgkJ
CgllbmQKCQoJZnVuY3Rpb24gY29udGVudHM6ZG91YmxlY2xpY2sobXNnKQoJCWxvY2FsIGkgPSBt
aWQoMSwgMSArIChtc2cubXkgLSA0KSBcIGl0ZW1faCwgI3NlbGYuaXRlbSkKCQlpZiAobmV3aSkg
cmV0dXJuIC0tIGRvbid0IGNvdW50IGFzIGEgZG91YmxlIGNsaWNrCgkJCgkJaWYgKGtleT09InNj
cmVlbnNhdmVyIiBhbmQgc2RhdC5zY3JlZW5zYXZlcikgc2VuZF9tZXNzYWdlKDMsIHtldmVudD0i
dGVzdF9zY3JlZW5zYXZlciJ9KQoJCQoJCWlmIChrZXk9PSJ0aGVtZSIpIHRoZW4KCQkJLS0gY29w
eSBvdmVyIHN5c3RlbSBkZWZhdWx0IGFuZCBlZGl0IHRoYXQKCQkJc2RhdC50aGVtZSA9ICIvYXBw
ZGF0YS9zeXN0ZW0vdGhlbWUucG9kIgoJCQlzdG9yZV9zZXR0aW5ncygpCgkJCQoJCQlsb2NhbCB0
ZGF0ID0gZmV0Y2goc2VsZi5pdGVtW2ldLmZpbGVuYW1lKQoJCQlpZiAodGRhdCkgc3RvcmUoIi9h
cHBkYXRhL3N5c3RlbS90aGVtZS5wb2QiLCB0ZGF0KQoJCQljcmVhdGVfcHJvY2VzcygiL3N5c3Rl
bS9hcHBzL3RoZW1lZC5wNjQiLCB7YXJndj17Ii9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QifX0p
CgkJZW5kCgllbmQKCQoJCgllbDphdHRhY2hfc2Nyb2xsYmFyc3thdXRvaGlkZT10cnVlfQoKCXJl
dHVybiBlbAplbmQKCmZ1bmN0aW9uIGNyZWF0ZV90YWJfYnV0dG9uKGVsKQoJZWwud2lkdGggPSAj
ZWwubGFiZWwgKiA1ICsgOAoJZWwuaGVpZ2h0ID0gMTEKCWVsLmN1cnNvciA9ICJwb2ludGVyIgoJ
ZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJbG9jYWwgeXkgPSAobXNnLmhhc19wb2ludGVyIGFuZCBt
c2cubWIgPiAwKSBhbmQgMSBvciAwCgkJcmVjdGZpbGwoMCx5eSsxLHNlbGYud2lkdGgtMSxzZWxm
LmhlaWdodC0xLHBhZ2UgPT0gZWwucGFnZSBhbmQgNyBvciA2KQoJCXJlY3RmaWxsKDEseXkrMCxz
ZWxmLndpZHRoLTIsc2VsZi5oZWlnaHQtMSxwYWdlID09IGVsLnBhZ2UgYW5kIDcgb3IgNikKCQkK
CQlwcmludChlbC5sYWJlbCw0LHl5KzIsMSkKCWVuZAoJZnVuY3Rpb24gZWw6dGFwKCkKCQlwYWdl
ID0gc2VsZi5wYWdlCgkJZ2VuZXJhdGVfZ3VpKCkKCWVuZAoJcmV0dXJuIGVsCmVuZAoKZnVuY3Rp
b24gZ2VuZXJhdGVfZ3VpKCkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCglsb2NhbCB4ID0gMgoJbG9j
YWwgc3BhY2luZyA9IDIKCXggKz0gZ3VpOmF0dGFjaChjcmVhdGVfdGFiX2J1dHRvbntsYWJlbD0i
RGVza3RvcCIscGFnZT0xLHg9eCx5PTF9KS53aWR0aCArIHNwYWNpbmcKLS0JeCArPSBndWk6YXR0
YWNoKGNyZWF0ZV90YWJfYnV0dG9ue2xhYmVsPSJTY3JlZW5zYXZlciIscGFnZT0yLHg9eCx5PTF9
KS53aWR0aCArIHNwYWNpbmcKCXggKz0gZ3VpOmF0dGFjaChjcmVhdGVfdGFiX2J1dHRvbntsYWJl
bD0iQXVkaW8iLHBhZ2U9Myx4PXgseT0xfSkud2lkdGggKyBzcGFjaW5nCgl4ICs9IGd1aTphdHRh
Y2goY3JlYXRlX3RhYl9idXR0b257bGFiZWw9IlZpZGVvIixwYWdlPTQseD14LHk9MX0pLndpZHRo
ICsgc3BhY2luZwoJeCArPSBndWk6YXR0YWNoKGNyZWF0ZV90YWJfYnV0dG9ue2xhYmVsPSJTeXN0
ZW0iLHBhZ2U9NSx4PXgseT0xfSkud2lkdGggKyBzcGFjaW5nCgkKCWxvY2FsIHgsIHkgPSA2LDEw
Cglsb2NhbCB5MCA9IHkKCWxvY2FsIHgyID0gMTA4Cglsb2NhbCBsaW5lX2ggPSAxMgoJCglsb2Nh
bCBjb250YWluZXIgPSBndWk6YXR0YWNoewoJCXg9MCx5PTEyLAoJCXdpZHRoX3JlbD0xLjAsCgkJ
aGVpZ2h0X3JlbD0xLjAsaGVpZ2h0X2FkZD0tMTIKCX0KCWxvY2FsIHBhbmUgPSBjb250YWluZXI6
YXR0YWNoewoJCXg9MCx5PTAsCgkJd2lkdGhfcmVsPTEuMCxoZWlnaHQ9MzAwCgl9Ci0tCWNvbnRh
aW5lcjphdHRhY2hfc2Nyb2xsYmFycygpCgoJLS0gZGVza3RvcAoJaWYgKHBhZ2UgPT0gMSkgdGhl
bgoJCXBhbmU6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LHksICJTcXVpc2h5IFdpbmRvd3MiLCAi
c3F1aXNoeV93aW5kb3dzIikpIHkgKz0gbGluZV9oCgkJcGFuZTphdHRhY2goY3JlYXRlX2NoZWNr
Ym94KHgsIHksICJTcGFya2xlcyIsICAgICAgICJzcGFya2xlcyIpKSB5ICs9IGxpbmVfaAoJCXBh
bmU6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiU25hcCBUbyBHcmlkIiwgICAic25hcF90
b19ncmlkIikpIHkgKz0gbGluZV9oCgkJCgkJeD0xMDYgeT15MAoJCXBhbmU6YXR0YWNoKGNyZWF0
ZV9jaGVja2JveCh4LCB5LCAiTG93LUNvbG91ciBJY29ucyIsICJsb3djb2xfaWNvbnMiKSkgeSAr
PSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIlJTSElGVCBNYWdu
aWZ5IiwgInJzaGlmdF9tYWduaWZ5IikpIHkgKz0gbGluZV9oCgkJCgkJY3JlYXRlX2Nob29zZXIo
cGFuZSwgNiwgNjAsICJ0aGVtZSIsICIvc3lzdGVtL3RoZW1lcyIpCgkJY3JlYXRlX2Nob29zZXIo
cGFuZSwgMTA4LCA2MCwgIndhbGxwYXBlciIsICIvc3lzdGVtL3dhbGxwYXBlcnMiKQoJZW5kCgkK
CQoJLS0gYXVkaW8KCWlmIChwYWdlID09IDMpIHRoZW4KCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hl
Y2tib3goeCwgeSwgIk11dGUiLCAibXV0ZV9hdWRpbyIpKSB5ICs9IGxpbmVfaAoJCXBhbmU6YXR0
YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiU3dhcCBTdGVyZW8iLCAic3dhcF9zdGVyZW8iKSkg
eSArPSBsaW5lX2gKCWVuZAoJCgktLSB2aWRlbwoJaWYgKHBhZ2UgPT0gNCkgdGhlbgoJCXBhbmU6
YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiRnVsbHNjcmVlbiIsICJmdWxsc2NyZWVuIikp
IHkgKz0gbGluZV9oCgkJcGFuZTphdHRhY2goY3JlYXRlX2NoZWNrYm94KHgsIHksICJQaXhlbCBQ
ZXJmZWN0IiwgInBpeGVsX3BlcmZlY3QiKSkgeSArPSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVh
dGVfY2hlY2tib3goeCwgeSwgIlN0cmV0Y2giLCAic3RyZXRjaCIpKSB5ICs9IGxpbmVfaAoJCXg9
MTA2IHk9eTAKCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIkFsbG93IEhpZ2gg
RFBJIiwgImFsbG93X2hpZ2hkcGkiKSkgeSArPSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVhdGVf
Y2hlY2tib3goeCwgeSwgIkZ1bGxzY3JlZW46V2luZG93IiwgImZ1bGxzY3JlZW5fd2luZG93Iikp
IHkgKz0gbGluZV9oCgkJCgkJLS0gbm90IHRoYXQgZGlmZmVyZW50IGZyb20gYmlsaW5lYXIgc2Nh
bGluZyBmcm9tIGEgM3ggcHJlYmxpdAoJCS0tIG1heWJlIGV4cG9zZSBsYXRlciBpZiBjYW4gaW1w
cm92ZSBpdCwgYnV0IGRvbid0IHdhbnQgc2V0dGluZ3MKCQktLSB0byBiZSB0b28gdGVjaG5pY2Fs
CgkJLS0gdXBkYXRlOiBhbHNvIG5pY2UgZm9yIG5ldGJvb2tzIHRoYXQgYXJlIGFuIGF3a3dhcmQg
cmVzb2x1dGlvbiwgYW5kCgkJLS0gaXQgaXMgYmV0dGVyIHRvIGxldHRlcmJveCBhdCA3MjBwCgkJ
cGFuZTphdHRhY2goY3JlYXRlX2NoZWNrYm94KHgsIHksICI3MjBwIHVwc2NhbGVyIiwgImJsaXRf
NzIwcCIpKSB5ICs9IGxpbmVfaAoJCQoJCWNyZWF0ZV9jaG9vc2VyKHBhbmUsIDYsIDYwLCAic2Ny
ZWVuc2F2ZXIiLCAiL3N5c3RlbS9zY3JlZW5zYXZlcnMiKQoJZW5kCgkKCWlmIChwYWdlID09IDUp
IHRoZW4KCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIk5ldHdvcmsiLCAibmV0
d29ya19hY2Nlc3MiKSkgeSArPSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3go
eCwgeSwgIkJhdHRlcnkgU2F2ZXIiLCAiYmF0dGVyeV9zYXZlciIpKSB5ICs9IGxpbmVfaAoJCXBh
bmU6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiQW55d2hlbiIsICJhbnl3aGVuIikpIHkg
Kz0gbGluZV9oCgkJcGFuZTphdHRhY2goY3JlYXRlX2NoZWNrYm94KHgsIHksICJDVFJMLVEgU2h1
dGRvd24iLCAiZmFzdHF1aXQiKSkgeSArPSBsaW5lX2gKCQoJZW5kCgoKCQplbmQKCmZ1bmN0aW9u
IHN0b3JlX3NldHRpbmdzKCkKCS0tcHJpbnRoKCJzdG9yaW5nIHNldHRpbmdzOiAiLi5wb2Qoc2Rh
dCkpCglzdG9yZSgiL2FwcGRhdGEvc3lzdGVtL3NldHRpbmdzLnBvZCIsIHNkYXQpCmVuZAoKZnVu
Y3Rpb24gX2luaXQoKQoKCXdpbmRvd3sKCQl3aWR0aD0yMTAsCgkJaGVpZ2h0PTE0MCwKCQltYXhf
d2lkdGg9MjIwLAoJCW1heF9oZWlnaHQ9MTYwLAoJCXRpdGxlPSJTeXN0ZW0gU2V0dGluZ3MiLAoJ
CXJlc2l6ZWFibGUgPSB0cnVlCgl9CgkKCXBva2UoMHg0MDAwLCBnZXQoZmV0Y2giL3N5c3RlbS9m
b250cy9saWwuZm9udCIpKQoJCglzZGF0ID0gZmV0Y2giL2FwcGRhdGEvc3lzdGVtL3NldHRpbmdz
LnBvZCIgb3Ige30KCQoJZ2VuZXJhdGVfZ3VpKCkKZW5kCgpmdW5jdGlvbiBfZHJhdygpCgljbHMo
MTMpCgljb2xvcig1KQoJCglyZWN0ZmlsbCgwLDEyLDEwMDAsMTAwMCw3KQoJCi0tW1sKCWxvY2Fs
IHl5ID0gNjcKCWxvY2FsIHByZWZpeCA9ICIiLS0iXDEyOFwtaiIKCQoJaWYgKHBhZ2UgPT0gMSkg
dGhlbgoJCXByaW50KCJWaWRlbyIsMTAsNSkKCQlwcmludCgiQXVkaW8iLDEwNSw1KQoJCQoJCXBy
aW50KHByZWZpeC4uIlRoZW1lIiwxMCx5eSkKCQlwcmludChwcmVmaXguLiJXYWxscGFwZXIiLDEw
NSx5eSkKCWVsc2UKCQlwcmludCgiU3lzdGVtIiwxMCw1KQoJCXByaW50KHByZWZpeC4uIlNjcmVl
bnNhdmVyIiwxMCx5eSkKCQlwcmludChwcmVmaXguLiJFeHBlcmltZW50YWwiLDEwNSx5eSkKCWVu
ZApdXQoJCglndWk6ZHJhd19hbGwoKQplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJZ3VpOnVwZGF0
ZV9hbGwoKQplbmQKCi0tIHJlbG9hZCBjaGFuZ2VzCm9uX2V2ZW50KCJtb2RpZmllZDovYXBwZGF0
YS9zeXN0ZW0vc2V0dGluZ3MucG9kIiwgZnVuY3Rpb24obXNnKQoJc2RhdCA9IGZldGNoKG1zZy5m
aWxlbmFtZSkgb3Igc2RhdCBvciB7fQplbmQpCgoKOjogLmluZm8ucG9kCi0tW1twb2QsYXV0aG9y
PSJ6ZXAiLGNyZWF0ZWQ9IjIwMjQtMDQtMTIgMDI6MTY6MDciLGljb249dXNlcmRhdGEoInU4Iiwx
NiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcw
NzA3MDcwNzAxMDAwMDAwMDEwNzExMTExMTExMTExMTExMTExMTExMDcwMTAwMDEwNzExMTExMTEx
MTExMTExMTExMTExMTExMTA3MDEwMTA3MTExMTExMTExMTExMTEwNzA3MTExMTExMDcwMTAxMDcx
MTExMDEwMTAxMDEwMTA3MDcwMTExMTEwNzAxMDEwNzExMTExMTExMTExMTExMDcwNzExMTExMTA3
MDEwMTA3MTExMTExMDcwNzExMTExMTExMTExMTExMDcwMTAxMDcxMTExMDEwNzA3MDEwMTAxMDEw
MTExMTEwNzAxMDEwNzExMTExMTA3MDcxMTExMTExMTExMTExMTA3MDEwMTA3MTExMTExMTExMTEx
MTExMTExMTExMTExMDcwMTAxMDYwNzExMTExMTExMTExMTExMTExMTExMDcwNjAxMDEwNjA2MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAw
MDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAiKSxtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsbm90ZXM9IiIscnVudGltZT0x
OSxzdG9yZWQ9IjIwMjQtMDMtMjMgMTg6MzY6MDgiLHRpdGxlPSJQaWNvdHJvbiBTZXR0aW5ncyIs
dmVyc2lvbj0iIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzIxNyIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIs
d29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDIzLTEwLTAyIDA2OjQ0OjIwIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVk
PSIyMDIzLTQ0LTAyIDA2OjQ0OjIwIl1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBPalV5SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB3
Ck5pMHlOaUF3TkRvME5qbzFPU0lzY21WMmFYTnBiMjQ5TVRFM00xMWRiSG8wQUcwQUFBQUZNUUFB
OHhSN1d6QmRQWHRpYlhBOWNIaDEKQUVNZ0VCQUU4UEFzWm14aFozTTlNQ3h3WVc1ZmVBZ0F6M2s5
TUN4NmIyOXRQVGg5TERFQS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tNTFCdFBUaDlmUT09Cjo6IG1hcC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAyIDA2OjQ0OjIwIixtb2RpZmllZD0iMjAyNS0xMi0xNCAw
MDo0NzozOCIsc3RvcmVkPSIyMDIzLTQ0LTAyIDA2OjQ0OjIwIl1dCjo6IG1hcC8wLm1hcApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBPalV5SWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB3Ck5pMHlOaUF3TkRvME5qbzFPU0lzY21WMmFYTnBiMjQ5TVRFMk5sMWRi
SG8wQUdnQUFBQllFQUFBOEFoN2UySnRjRDExYzJWeVpHRjAKWVNnaWFURTJJaXd6TWdNQUx5SXdB
UUQtLS0tLS0tLS0tLS0tLS0tLS0tLTc4UWdpS1N4b2FXUmtaVzQ5Wm1Gc2MyVXNjR0Z1WDNnOQpN
QWdBMG5rOU1DeDBhV3hsWDJnOU1UWUtBQkIzQ2dDQWVtOXZiVDB4ZlgwPQo6OiBtYXAvbWFwMC5t
YXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVFE0TFRBMElERTJPalE0T2pBeElp
eHRiMlJwWm1sbFpEMGlNakF5TkMwMApPQzB3TkNBeE5qbzBPRG93TVNJc2NtVjJhWE5wYjI0OU1G
MWRiSG8wQUdrQUFBQ2pDQUFBOEJON2JHRjVaWEk5ZTFzd1hUMTdZbTF3ClBYVnpaWEprWVhSaEtD
SnBNVFlpTERFMkF3QXZJakFCQVAtLS1fX2hJaWtzY0dGdVgzZzlNQWdBOGdaNVBUQXNjMk5oYkdV
OU1TeDAKYVd4bFgyZzlNVFlLQUc5M1BURTJmU3hMQlAtLS0tODRVREUyZlgxOQo6OiBzZngvLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0wMiAwNjo0NDoyMCIsbW9kaWZpZWQ9IjIw
MjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyMy00NC0wMiAwNjo0NDoyMCJdXQo6OiBzZngv
MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBeUlEQTJPalEwT2pV
eUlpeHRiMlJwWm1sbFpEMGlNakF5TlMwdwpOaTB5TmlBd05EbzBOam8xT1NJc2NtVjJhWE5wYjI0
OU1URXlNbDFkYkhvMEFIQUFBQUR1QndBQTMzQjRkUUFES0FBQUJBQUU4UDhCCkFPei1KLUVCRUFZ
UElCQUJJQUVnQWZBQUFoQUNEaEFCSUE4aElBRXdEMER3d3c4b0QtLXd4Zy00Q2ctLUQ0QVA5dzhO
QWZBSkFSQUcKRGpBQS16a2Ytd0VBM00tNEQwQUFEeEJBLS1fdzhIQUxBUC0tb3gtLUFRRC1tVkQt
LS0tLUlBPT0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkw
TFRRNExUQTBJREUyT2pRNE9qQXhJaXh0YjJScFptbGxaRDBpTWpBeU5DMDAKT0Mwd05DQXhOam8w
T0Rvd01TSXNjbVYyYVhOcGIyNDlNRjFkYkhvMEFCQUJBQUJSQndBQThDZHdlSFVBQXlnQUFBTUFC
QTlBRUFJTwpBQUdnQVNBQ29BNEFEeEFBRGZES0FRSURCQVVHQndFUC01QUlDUW9MRHd3UERROE9E
dzhRQVBBQURROFJEeElQRXc4VUR4VVBGZzhYCkV3RHhBUThZRHhrUEdnOGJEeHdQSFE4ZUR4OFVB
UEVBSUE4aER5SVBJdzhrRHlVUEpnOG5GQUR4QUNnUEtROHFEeXNQTEE4dER5NFAKTHhRQThRQXdE
ekVQTWc4ekR6UVBOUTgyRHpjVUFQOEZPQTg1RHpvUE93ODhEejBQUGc4LUFRLS04UDhCQU92LUox
b0JFQVlQSUJBQgpJQUVnQWZBQUFoQUNEQkFCSUE4aElBRXdEMER3d3c4b0QtLXd4Zy00Q2ctLUQ0
QVA5dzhOQWZBSkFSQUdEREFBLXprZi13RUEzTC00CkQwQUFEVUQtLTdEd2NBb0EtLTlrSC04QkFK
ZFEtLS0tLXg4PQo6OiBbZW9jXQo=
:: bios/apps/sfx.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogYW1wLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIz
LTI5LTE3IDEzOjI5OjQ4IixyZXZpc2lvbj0yNTcsc3RvcmVkPSIyMDIzLTI3LTE5IDIzOjI3OjE3
Il1dCi0tIGFtcCBmaWx0ZXIKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiBkYXRhLmx1YQotLVtbcG9kX2Zv
cm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTI0IDAwOjM2OjU4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODoyNzoxNSIscmV2aXNpb249MTEzNTIsc3RvcmVkPSIyMDIzLTM2LTI5IDA0OjM2OjQw
Il1dCgpmdW5jdGlvbiBpbml0X3RyYWNrKGFkZHIpCi0tCXByaW50aCgiaW5pdF90cmFjayAiLi5h
ZGRyKQoJcG9rZTIoYWRkciwgNjQpIC0tIGxlbgoJcG9rZShhZGRyKzIsMTYpIC0tIHNwZAoJcG9r
ZShhZGRyKzMsMCkgIC0tIGxvb3AwCglwb2tlKGFkZHIrNCwwKSAgLS0gbG9vcDEKCXBva2UoYWRk
cis1LDApICAtLSBkZWxheQoJcG9rZShhZGRyKzYsMCkgIC0tIGZsYWdzICgweDEgbXV0ZSkKCXBv
a2UoYWRkcis3LDApICAtLSB1bnVzZWQKCQoJLS0gcGl0Y2gsIGluc3QsIHZvbDogbm90IHNldCAo
MHhmZikKCW1lbXNldChhZGRyKzgsIDB4ZmYsIDY0KjMpCgkKCS0tIGZ4LCBmeF9wOiBjbGVhcgoJ
bWVtc2V0KGFkZHIrOCs2NCozLCAweDAsIDY0KjIpCmVuZAoKZnVuY3Rpb24gY2xlYXJfcGF0dGVy
bihpKQoJbG9jYWwgYWRkciA9IDB4MzAxMDAgKyBpKjIwCgltZW1zZXQoYWRkciwwLDIwKQplbmQK
CmZ1bmN0aW9uIGNsZWFyX2luc3RydW1lbnQoaSkKCWxvY2FsIGFkZHIgPSAweDQwMDAwICsgaSAq
IDB4MjAwCgkKCW1lbXNldChhZGRyLCAwLCAweDIwMCkKCQoJLS0gbm9kZSAwOiByb290Cglwb2tl
KGFkZHIgKyAoMCAqIDMyKSwgLS0gbm9kZSAwCgkKCQkJMCwgICAgLS0gcGFyZW50ICgweDcpICBv
cCAoMHhmMCkKCQkJMSwgICAgLS0ga2luZCAoMHgwZik6IDEgcm9vdCAga2luZF9wICgweGYwKTog
MCAgLS0gd2F2ZXRhYmxlX2luZGV4CgkJCTAsICAgIC0tIGZsYWdzCgkJCTAsICAgIC0tIHVudXNl
ZCBleHRyYQoJCQkJCgkJCS0tIE1WQUxzOiAga2luZC9mbGFncywgIHZhbDAsIHZhbDEsIGVudmVs
b3BlX2luZGV4CgkJCQoJCQkweDJ8MHg0LDB4MzAsMCwwLCAgLS0gdm9sdW1lOiBtdWx0LiAweDQw
IGlzIG1heCAoLTB4NDAgdG8gaW52ZXJ0LCAweDdmIHRvIG92ZXJhbXApCgkJCTB4MSwwLDAsMCwg
ICAgIC0tIHBhbjogICBhZGQuIGNlbnRlcgoJCQkweDEsMCwwLDAsICAgICAtLSB0dW5lOiArMCAt
LSAwLDQ4LDAsMCBhYnNvbHV0ZSBmb3IgbWlkZGxlIGMgKGM0KSAyNjEuNiBIegoJCQkweDEsMCww
LDAsICAgICAtLSBiZW5kOiBub25lCgkJCS0tIGZvbGxvd2luZyBzaG91bGRuJ3QgYmUgaW4gcm9v
dAoJCQkweDAsMCwwLDAsICAgICAtLSB3YXZlOiB1c2Ugd2F2ZSAwIAoJCQkweDAsMCwwLDAgICAg
ICAtLSBwaGFzZSAKCSkKCQoJCgktLSBub2RlIDE6IHNpbmUKCXBva2UoYWRkciArICgxICogMzIp
LCAtLSBpbnN0cnVtZW50IDAsIG5vZGUgMQoJCgkJCTAsICAgIC0tIHBhcmVudCAoMHg3KSAgb3Ag
KDB4ZjApCgkJCTIsICAgIC0tIGtpbmQgKDB4MGYpOiAyIG9zYyAga2luZF9wICgweGYwKTogMCAg
LS0gd2F2ZXRhYmxlX2luZGV4CgkJCTAsICAgIC0tIGZsYWdzCgkJCTAsICAgIC0tIHVudXNlZCBl
eHRyYQoJCQkJCgkJCS0tIE1WQUxzOiAga2luZC9mbGFncywgIHZhbDAsIHZhbDEsIGVudmVsb3Bl
X2luZGV4CgkJCQoJCQkweDIsMHgzMCwwLDAsICAtLSB2b2x1bWU6IG11bHQuIDB4NDAgaXMgbWF4
ICgtMHg0MCB0byBpbnZlcnQsIDB4N2YgdG8gb3ZlcmFtcCkKCQkJMHgxLDAsMCwwLCAgICAgLS0g
cGFuOiAgIGFkZC4gY2VudGVyCgkJCTB4MjEsMCwwLDAsICAgIC0tIHR1bmU6ICswIC0tIDAsNDgs
MCwwIGFic29sdXRlIGZvciBtaWRkbGUgYyAoYzQpIDI2MS42IEh6CgkJCSAgICAgICAgICAgICAg
IC0tIHR1bmUgaXMgcXVhbnRpemVkIHRvIHNlbWl0b25lcyB3aXRoIDB4MjAKCQkJMHgxLDAsMCww
LCAgICAgLS0gYmVuZDogbm9uZQoJCQkweDAsMHg0MCwwLDAsICAtLSB3YXZlOiB0cmlhbmdsZQoJ
CQkweDAsMCwwLDAgICAgICAtLSBwaGFzZSAKCSkKCQoJCgktLSB3YXZldGFibGVzCglwb2tlKGFk
ZHIgKyAweDFlMCwKCQkweDAwLCAtLSBhZGRyZXNzIChsb3cpICBpbiAyNTYgYnl0ZSBpbmNyZW1l
bnRzCgkJMHhmOCwgLS0gYWRkcmVzcyAoaGlnaCkgaW4gNjRrIGluY3JlbWVudHMKCQkweDBhLCAt
LSBzYW1wbGVzICgxIDw8IG4pIDEwMjQKCQkweGZmLCAgLS0gd3RfaGVpZ2h0IDI1NigwKTsgd2F2
ZSBtdmFsIHBvaW50cyBhdCBvbmUgb2YgdGhlIGVudHJpZXMKCQkKCQktLSB3aGl0ZSBub2lzZQoJ
CTB4ODAsCgkJMHhmNywKCQkweDBkLCAtLSBzYW1wbGVzICgxIDw8IG4pIDgxOTIKCQkweDAxCgkp
CgoJLS0gZW52ZWxvcGUgMCBpbnN0IDEKCQoJcG9rZShhZGRyICsgMHgxMDAsCgkJMCwwLDAsMCwg
MCwwLDAsMCwKCQkwLDQwLDI1NSwwIC0tIGFkc3IKCSkKZW5kCgoKZnVuY3Rpb24gaW5pdF9kYXRh
KCkKCgktLSB1c2UgMjU2ayBmcm9tIDB4MzAwMDAKCS0tIGdpdmVzIDM5OSBTRlggYW5kIG1hbmFn
ZW1hYmxlIHNpemUgZm9yIHVuZG8gc3RhdGUgY29tcGFyaXNvbnMKCS0tIGlmIGNoYW5nZSB0aGlz
IG5lZWQsIHRvIGFkanVzdCB1bmRvIHN0YWNrIHNpemUgYW5kIGxvYWRlci9zYXZlcgoJCgltZW1z
ZXQoMHgzMDAwMCwgMCwgMHg0MDAwMCkKCQoKCS0tIGluZGV4ICgweDMwMDAwKQoJCgktLSBmaXJz
dCAzIHZhbHVlcyBhcmUgYWxtb3N0IG1ldGFkYXRhIG9ubHkgLS0gbm90IGN1cnJlbnRseQoJLS0g
YWN0ZWQgb24gYW55d2hlcmUuIHBlcmhhcHMgdXNlZnVsIGluIGZ1dHVyZSBmb3IgZGVjaWRpbmcK
CS0tIHNjb3BlIG9mIGNvcHkvcGFzdGUsIGFuZCBndWkgY3VlcywgYnV0IGNhbiBiZSBjYWxjdWxh
dGVkCgktLSBmcm9tIGNvbnRlbnQuCgkKCXBva2UyKDB4MzAwMDAsCgkJNjQsICAtLSBudW1faW5z
dHJ1bWVudHMKCQk1MTIsIC0tIG51bV90cmFja3MgKDY0IHBhdHRlcm5zICogOCBjaGFubmVscyBm
b3IgZGVmYXVsdCBpbmRleGluZykKCQk2NCwgIC0tIG51bV9wYXR0ZXJucwoJCS0tIGZsYWdzOiAw
eDEgdXNlIGRlZmF1bHQgdHJhY2sgaW5kZXhpbmcgKGJhc2UrMHgyMDAwMCwgaW5jcmVtZW50cyBv
ZiAzMjggYnl0ZXMpCgkJMHgxCgkpCglwb2tlNCgweDMwMDEwLAoJCTB4MTAwMDAsIC0tIGluc3Rz
X2FkZHIgICAgICAoSTMyKSAgICByZWxhdGl2ZSBhZGRyZXNzIG9mIGluc3RydW1lbnRzCgkJMHgy
MDAwMCwgLS0gdHJhY2tzX2FkZHIgICAgIChJMzIpICAgIHJlbGF0aXZlIGFkZHJlc3Mgb2YgdHJh
Y2sgaW5kZXgKCQkwLCAgICAgICAtLSBwYXR0ZXJuc19hZGRyICAgKEkzMikgICAgcmVsYXRpdmUg
YWRkcmVzcyBvZiBwYXR0ZXJuIGRhdGEKCQkwICAgICAgICAtLSB1bnVzZWQgICAgICAgICAgKEkz
MikgICAgc2hvdWxkIGJlIDAKCSkKCXBva2UyKDB4MzAwMjAsCgkJMCwgIC0tIHRpY2sgbGVuICgw
IGZvciBkZWZhdWx0IC0tIGN1c3RvbSB2YWxzIG5vdCBzdXBwb3J0ZWQgeWV0KQoJCTY0LCAtLSBk
ZWZhdWx0IHRyYWNrIGxlbmd0aAoJCTE2IC0tIGRlZmF1bHQgdHJhY2sgc3BkCgkpCgkKCS0tIGRl
ZmF1bHQgdHJhY2sgc3BlZWQgKCszIHVudXNlZCkKCXBva2UoMHgzMDAyNiwgMTYsIDAsIDAsIDAp
IAoJCgktLSBwYXR0ZXJuIGRhdGE6IGZpcnN0IDE2IHBhdHRlcm5zCgktLSB3YW50IHRvIGtlZXAg
ZGVmYXVsdCBzZnggZmlsZSBxdWl0ZSB0aW55CgktLSAuLiBzaG91bGQgYmUgb2sgdG8gc2F2ZSBh
IHdob2xlIC5zZnggZm9yIGp1c3Qgb25lIGluc3QgLyBleHBlcmltZW50CgktLSBsYXRlcjogaW50
ZXJmYWNlIHRvIGdlbmVyYXRlIG1vcmUgZGVmYXVsdCBwYXR0ZXJucwoJCglmb3IgcHAgPSAwLDMK
CWRvCgkJbG9jYWwgYWRkciA9IDB4MzAxMDAgKyBwcCAqIDIwCgkJZm9yIGkgPSAwLCAzIGRvCgkJ
CXBva2UoYWRkcitpLCBwcCo0ICsgaSkKCQllbmQKCQlwb2tlKGFkZHIrOCwgMHgwKSAgLS0gZmxv
dyBmbGFncwoJCXBva2UoYWRkcis5LCAweDBmKSAtLSBjaGFubmVsIG1hc2sgLS0gNCBjaGFubmVs
cwoJCXBva2UoYWRkcisxMCwgMCwwKSAtLSBsZW5ndGggKEkxNikKCQkKCWVuZAoJCgkKCS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0KCS0tIHNpbmdsZSBpbnN0cnVtZW50IGF0IDB4NDAwMDAgKGluc3RydW1l
bnQgMCkKCQoJY2xlYXJfaW5zdHJ1bWVudCgwKQoJCgktLSBjb3B5IGRlZmF1bHQgaW5zdHJ1bWVu
dCB0byAxLi4zMQoJZm9yIGk9MSwzMSBkbwoJCW1lbWNweSgweDQwMDAwICsgMHgyMDAqaSwgMHg0
MDAwMCwgMHgyMDApCgllbmQKCQoJCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLQoJLS0gVHJhY2sgRGF0YSAgMHg1MDAwMAoJLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQoJLS0gRGVmYXVsdCB0cmFjayBz
aXplIGlzIDUgKiA2NCByb3dzICsgOCA9IDMyOCBieXRlcwoJCgktLSBoZWFkZXIgKDgpCgkKCWlu
aXRfdHJhY2soMHg1MDAwMCkKCQoJLS0gY29weSB0byBvdGhlciB0cmFja3M6IDEyOGsgd29ydGgK
CS0tICoqIG9ubHkgZmlyc3QgMzk5IGFyZSBzYXZlZCAvIHVuZG9hYmxlICgweDIwMDAwXDMyOCkg
KioKCS0tIDM4NCB1c2VkIGluIHRyYWNrZXIKCS0tW1sKCWZvciBpPTEsMzk4IGRvCgkJbWVtY3B5
KDB4NTAwMDAgKyBpKjMyOCwgMHg1MDAwMCwgMzI4KQoJZW5kCgldXQoKZW5kCgoKCgoKCjo6IGRl
YnVnLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTAzLTEzIDA4OjM2OjQ1
Iixtb2RpZmllZD0iMjAyNC0wNS0xNiAyMTo1NDozMyIscmV2aXNpb249MTA3Ml1dCgpmdW5jdGlv
biBkcmF3X211ZG9fc3RhdGUoeCx5KQoJcmVjdGZpbGwoeCx5LHgrOTkseSs2MCwwKQoJCglmb3Ig
aT0wLDcgZG8KCQlsb2NhbCBzeCA9IHggKyAyCgkJbG9jYWwgc3kgPSB5ICsgaSAqIDYJCgkJCgkJ
LS0gY2hhbi0_cGxheWluZ190cmFja19pbmRleAoJCXByaW50KCJcMTQiLi5zdGF0KDQwMCtpLDEy
KSwgc3gsIHN5LCA3KQoJCQoJCS0tIGNoYW4tPmluc3QJCQoJCXByaW50KCJcMTQiLi5zdGF0KDQw
MCtpLDEgKSwgc3grMzAsIHN5LCA3KQoJCQoJCS0tIGNoYW4tPnRyYWNrX3JvdwoJCXByaW50KCJc
MTQiLi5zdGF0KDQwMCtpLDkgKSwgc3grNjAsIHN5LCAxMykKCQkKCWVuZAoJcHJpbnQoc3RyaW5n
LmZvcm1hdCgiY3B1OiUzLjNmIiwgc3RhdCgxKSkseCx5KzUyLDEzKQoJcHJpbnQoKHNvbWV0aGlu
Z19pc19wbGF5aW5nIGFuZCAicCIgb3IgIi0iKSx4KzUwLHkrNTIsMTQpCglwcmludCgoZm9sbG93
aW5nX3BsYXliYWNrIGFuZCAiZiIgb3IgIi0iKSx4KzYwLHkrNTIsMTQpCgplbmQKCjo6IGVudi5s
dWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0wOCAwMzozMjo1OCIsbW9k
aWZpZWQ9IjIwMjUtMDctMTAgMDM6MjY6MjYiLHJldmlzaW9uPTgyNTEsc3RvcmVkPSIyMDIzLTM2
LTI5IDA0OjM2OjQwIl1dCgotLSBmbGFnczogbGVycCwgcmFuZG9tIHN0YXJ0IHBvc2l0aW9uCi0t
IHVzZWQgYnkgREFUQSBlbnZlbG9wZQpmdW5jdGlvbiBjcmVhdGVfZW52X2ZsYWdfdG9nZ2xlKGFk
ZHIsZmxhZyxsYWJlbCx4LHkpCglsb2NhbCBlbCA9IHsKCQlhZGRyID0gYWRkciwgZmxhZyA9IGZs
YWcsIGxhYmVsPWxhYmVsLAoJCXggPSB4LCB5ID0geSwgd2lkdGggPSAxOCsjbGFiZWwqNCwgaGVp
Z2h0ID0gNwoJfQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJbG9jYWwgeXkgPSAobXNnLmhhc19w
b2ludGVyIGFuZCBtc2cubWIgPiAwKSBhbmQgMSBvciAwCgkJbG9jYWwgdmFsID0gKEBzZWxmLmFk
ZHIpICYgc2VsZi5mbGFnCgkJLS1jbGlwKCkKCQktLXJlY3RmaWxsKDAsMCt5eSxzZWxmLndpZHRo
LTEsNit5eSxtc2cuaGFzX3BvaW50ZXIgYW5kIDE0IG9yIAoJCS0tCSh2YWw_MCBhbmQgNyBvciAx
MykpCgkJbG9jYWwgc3RyPXZhbD4wIGFuZCAiWy9dICIgb3IgIlsgXSAiCgkJaWYgKHNlbGYuZmxh
ZyA9PSAweDEwKSBzdHIgPSAiIiAtLSBFRl9BRFZBTkNFRF9PUFRTIGRvZXNuJ3QgaGF2ZSBjaGVj
a2JveAoJCXByaW50KHN0ci4uc2VsZi5sYWJlbCwyLDEreXksMTMpCgllbmQKCWZ1bmN0aW9uIGVs
OmNsaWNrKCkKCQljaGVja3BvaW50KCkKCQlsb2NhbCB2YWwgPSBwZWVrKHNlbGYuYWRkcikKCQl2
YWwgXl49IHNlbGYuZmxhZwoJCXBva2Uoc2VsZi5hZGRyLCB2YWwpCgkJcmVmcmVzaF9ndWkgPSB0
cnVlCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCmVudl90eXBlX3N0ciA9IHtbMF09CgkiYWRzciIs
CgkibGZvIiwKCSJkYXRhIiwKfQoKCgpmdW5jdGlvbiBjcmVhdGVfZW52X3R5cGVfdG9nZ2xlKGFk
ZHIseCx5KQoJbG9jYWwgZWwgPSB7IAoJCWFkZHIgPSBhZGRyLAoJCXggPSB4LCB5ID0geSwgd2lk
dGggPSAyMCwgaGVpZ2h0ID0gNwoJfQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJbG9jYWwgeXkg
PSAobXNnLmhhc19wb2ludGVyIGFuZCBtc2cubWIgPiAwKSBhbmQgMSBvciAwCgkJbG9jYWwgdmFs
ID0gKEBzZWxmLmFkZHIpICYgMHhmCgkJY2xpcCgpCgkJLS1wYWwoNywxKQoJCXJlY3RmaWxsKDAs
MCt5eSxzZWxmLndpZHRoLTEsNit5eSxtc2cuaGFzX3BvaW50ZXIgYW5kIDE0IG9yIDYpCgkJLS1z
cHIodmFsLDEsMSt5eSkKCQlwcmludChlbnZfdHlwZV9zdHJbdmFsXSwyLDEreXksMSkKCQktLXBh
bCgpCgllbmQKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQljaGVja3BvaW50KCkKCQlsb2NhbCB2YWwg
PSBwZWVrKHNlbGYuYWRkcikKCQl2YWwgPSAodmFsICsgMSkgJSAzCgkJcG9rZShzZWxmLmFkZHIs
IChwZWVrKHNlbGYuYWRkcikgJiAweGYwKSB8ICh2YWwgJiAweDBmKSkKCQlyZWZyZXNoX2d1aSA9
IHRydWUKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVfZW52X3BsdWcoaW5k
ZXgsIHgsIHkpCglsb2NhbCBlbCA9IHsKCQl4PXgseT15LHdpZHRoPTcsaGVpZ2h0PTcsaW5kZXg9
aW5kZXgsCgkJY2xpY2s9Y2hlY2twb2ludAoJfQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJY2ly
Y2ZpbGwoMywzLDIsMTMpCgkJY2lyYygzLDMsMiwxKQoJZW5kCglmdW5jdGlvbiBlbDpyZWxlYXNl
KG1zZykKCQlsb2NhbCBzeD1zZWxmLnN4ICsgbXNnLm14CgkJbG9jYWwgc3k9c2VsZi5zeSArIG1z
Zy5teQoJCQoJCWxvY2FsIGVsMiA9IGd1aTplbF9hdF94eShzeCxzeSkKCQlpZiAoZWwyLmRyb3Bf
ZW52X3BsdWcpIGVsMjpkcm9wX2Vudl9wbHVne2luZGV4PXNlbGYuaW5kZXh9CgkJCgllbmQKCQoJ
cmV0dXJuIGVsCmVuZAoKCi0tW1sKCWVkaXQgYW4gOC1iaXQgdmFsdWUgaW4gbWVtb3J5Cl1dCmZ1
bmN0aW9uIGNyZWF0ZV90aW55X2tub2IobGFiZWwsYWRkcix4LHksaGFzX2tub2IpCglsb2NhbCBl
bD17CgkJeD14LHk9eSwKCQl3aWR0aD0xNSxoZWlnaHQ9aGFzX2tub2IgYW5kIDI0IG9yIDE0LAoJ
CWxhYmVsPWxhYmVsLGFkZHI9YWRkciwKCQlkdmFsPTAsCgkJY3Vyc29yPSJkaWFsIgoJCS0tY3Vy
c29yPSJncmFiIiAtLSB0byBkbzogZGlhbCBzcGlubmluZyBjdXJzb3IgdGhhdCBkaXNhcHBlYXJz
Cgl9CgkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxvY2FsIHZhbD1wZWVrKHNlbGYuYWRkcikKCQlp
ZiAoaGFzX2tub2IpIHRoZW4KCQkJY2lyYyg3LDUsNSwxMykKCQkJbG9jYWwgYWE9LjctdmFsKi45
LzI1NS4wCgkJCWxpbmUoNy41K2NvcyhhYSksNS41K3NpbihhYSksNy41K2NvcyhhYSkqNCw1LjUr
c2luKGFhKSo0LDcpCgkJZW5kCgkJCgkJY2xpcCgpCgkJCgkJLS0gCgkJbG9jYWwgeXk9aGFzX2tu
b2IgYW5kIDE0IG9yIDIKCQlyZWN0ZmlsbCgwLHl5LDE0LHl5KzYsMCkKCQlsb2NhbCBzdHI9dG9z
dHIodmFsKQoJCXByaW50KHN0ciwxNC0jc3RyKjQseXkrMSwzKQoJCQoJCXByaW50KHNlbGYubGFi
ZWwsOS0jc2VsZi5sYWJlbCoyLHl5KzEwLDEzKQoKCWVuZAoJCgktLSB0dXJuIG1vdXNlIGxvY2tp
bmcgb24gd2hpbGUgZHJhZ2dpbmcKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCQltb3VzZWxvY2so
MHg0fDB4OCwgMC41LCAwLjA1KSAtLSAweDQgbG9jayAweDggYXV0by1yZWxlYXNlLCBldmVudCBz
cGVlZCwgbW92ZSBzcGVlZCAKCWVuZAoJCgktLSBkb2Vzbid0IHdvcmsgdW5sZXNzIHJlcXVpcmUg
bWIgPiAwIGJlY2F1c2UgdXNlIHRvIHNjcm9sbCAKCS0tIGVudiBwYW5lbCB1bnRpbCBoaXQgdGlu
eSBrbm9iIGJ5IGFjY2lkZW50IC5fLgoJZnVuY3Rpb24gZWw6bW91c2V3aGVlbChtc2cpCgkJbG9j
YWwgbWFnID0ga2V5ImN0cmwiIGFuZCA4IG9yIDEKCQkKCQktLXNlbGY6ZHJhZyh7bWI9bXNnLm1i
PjAgYW5kIG1zZy5tYiBvciAxLGR4PTAsZHk9LW1zZy53aGVlbF95ICogbWFnfSkKCQlpZiAobXNn
Lm1iID4gMCkgdGhlbgoJCQlzZWxmOmRyYWcoe21iPW1zZy5tYixkeD0wLGR5PS1tc2cud2hlZWxf
eSAqIG1hZ30pCgkJCXJldHVybiB0cnVlIC0tIGRvbid0IHNjcm9sbCBpbnN0cnVtZW50IHBhbmVs
CgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgdmFsPXBlZWsoc2Vs
Zi5hZGRyKQoJCS0tIGFjY3VtdWxhdGUgY2hhbmdlIGF0IDAuNSBwZXIgcGl4ZWwKCQllbC5kdmFs
ICs9IChtc2cuZHggLSBtc2cuZHkpICogMC41CgkJaWYgKGVsLmR2YWwgPD0gLTEpIHRoZW4KCQkJ
dmFsIC09IGZscigtZWwuZHZhbCkKCQkJZWwuZHZhbCArPSBmbHIoLWVsLmR2YWwpCgkJZW5kCgkJ
aWYgKGVsLmR2YWwgPj0gMSkgdGhlbgoJCQl2YWwgKz0gZmxyKGVsLmR2YWwpCgkJCWVsLmR2YWwg
JT0gMQoJCWVuZAoJCXZhbCA9IG1pZCgwLHZhbCwyNTUpCgkJcG9rZShzZWxmLmFkZHIsIHZhbCkK
CQlyZXR1cm4gdHJ1ZSAtLSBkb24ndCBkcmFnIGVudl9jb250ZW50CgllbmQKCQotLVtbCgktLSBh
bm5veWluZwoJLS0gZG9lc24ndCBtaXggd2l0aCBkcmFnIGNvbnRyb2wKCS0tIHBpY28tOCBhY3R1
YWxseSBzdWZmZXJzIGZyb20gdGhlIHNhbWUgcHJvYmxlbSEKCS0tIChqdXN0IG5vdCBwcm9ub3Vu
Y2VkIGJlY2F1c2UgZWFzeSB0byBrZWVwIHRoZSBjdXJzb3Igc3RpbGwsCgktLSAgYW5kIGhhcmQg
dG8gZHJhZyAtMSBvciArMSB3aGlsZSBzdGFydGluZyBhbmQgZW5kaW5nIGluc2lkZSBlbCkKCQoJ
ZnVuY3Rpb24gZWw6dGFwKG1zZykKCQlsb2NhbCB2YWwgPSBwZWVrKHNlbGYuYWRkcikKCQlsb2Nh
bCBtYWcgPSBrZXkoImN0cmwiKSBhbmQgOCBvciAxCgkJdmFsICs9IG1zZy5sYXN0X21iID09IDIg
YW5kIC1tYWcgb3IgbWFnCgkJcG9rZShzZWxmLmFkZHIsbWlkKDAsdmFsLDI1NSkpCgllbmQKXV0K
CQoJcmV0dXJuIGVsCmVuZAoKCmZ1bmN0aW9uIGNyZWF0ZV9kYXRhX2Vudl9lZGl0b3IoYWRkciwg
eCwgeSwgd2lkdGgsIGhlaWdodCkKCWxvY2FsIGVsPXsKCQlhZGRyPWFkZHIsCgkJeD14LHk9eSx3
aWR0aD13aWR0aCxoZWlnaHQ9aGVpZ2h0Cgl9CglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0Zmls
bCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMCkKCQlsb2NhbCB3dz13aWR0aFwxNgoJ
CWxvY2FsIGhoPXNlbGYuaGVpZ2h0CgkJbG9jYWwgbG9vcDAgPSBAKGFkZHIrMykKCQlsb2NhbCBs
b29wMSA9IEAoYWRkcis0KQoJCQoJCS0tIHNob3cgbG9vcCBwb2ludHMKCQlmaWxscCgweDVhNWEp
CgkJY29sID0gbG9vcDAgPCBsb29wMSBhbmQgNiBvciA1CgkJbGluZShsb29wMCp3dy0xLDAsIGxv
b3AwKnd3LTEsc2VsZi5oZWlnaHQsY29sKQoJCWxpbmUobG9vcDEqd3ctMSwwLCBsb29wMSp3dy0x
LHNlbGYuaGVpZ2h0LGNvbCkKCQlmaWxscCgpCgkJCgkJLS0gc2hvdyBkYXRhCgkJZm9yIGk9MCwx
NSBkbwoJCQlsb2NhbCBzeCA9IGkqd3cKCQkJbG9jYWwgdmFsID0gcGVlayhzZWxmLmFkZHIraSs4
KQoJCQlsb2NhbCBjb2wgPSBpID49IGxvb3AwIGFuZCBpIDwgbG9vcDEgYW5kIDEzIG9yIDEyCgkJ
CXJlY3RmaWxsKHN4LGhoLHN4K3d3LTIsaGgtdmFsKmhoLzI1NSxjb2wpCgkJCXJlY3RmaWxsKHN4
LGhoLXZhbCpoaC8yNTUsc3grd3ctMixoaC12YWwqaGgvMjU1LDI4KQoJCWVuZAoJCQoJZW5kCgkK
CWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWxvY2FsIHd3PXdpZHRoXDE2CgkJbG9jYWwgaGg9c2Vs
Zi5oZWlnaHQKCQlsb2NhbCB4eD1taWQoMCxtc2cubXhcd3csMTUpCgkJbG9jYWwgeXk9KG1zZy5t
eSkgKiAyNTUgLyBzZWxmLmhlaWdodAoJCXBva2Uoc2VsZi5hZGRyK3h4KzgsbWlkKDAsMjU1LXl5
LDI1NSkpCgkJcmV0dXJuIHRydWUgLS0gZG9uJ3QgZHJhZyBlbnZfY29udGVudAoJZW5kCgkKCXJl
dHVybiBlbAplbmQKCgpmdW5jdGlvbiBjcmVhdGVfZW52X2VkaXRvcihpbmRleCwgYWRkciwgbGFi
ZWwsIHgsIHksIHdpZHRoKQoKCWxvY2FsIGhlaWdodCA9IDQ2CglpZiAoQGFkZHIgPT0gMSkgaGVp
Z2h0ID0gNTQgLS0gbGZvCglpZiAoQGFkZHIgPT0gMikgaGVpZ2h0ID0gODYgLS0gZGF0YQoJCgls
b2NhbCBoZWlnaHQwID0gaGVpZ2h0CgkKCWlmIChwZWVrKGFkZHIrMSkmMHgxMD4wIGFuZCBAYWRk
cjwyKSB0aGVuCgkJaGVpZ2h0ICs9IDI4CgllbmQKCQoJbG9jYWwgcGFuZSA9IGd1aTphdHRhY2go
Y3JlYXRlX3BhbmUoIlxmaCIuLmxhYmVsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAweDA3MDEpKQoJ
cGFuZS5pbmRleCA9IGluZGV4CgkKCS0tIGRvbid0IG5lZWQgcGx1ZyEganVzdCBkcmFnIHdob2xl
IHBhbmUKCS0tcGFuZTphdHRhY2goY3JlYXRlX2Vudl9wbHVnKGluZGV4LDIsMSkpCgkKCQoJcGFu
ZTphdHRhY2goY3JlYXRlX2Vudl90eXBlX3RvZ2dsZShhZGRyLDQ0LDEpKQoJCgkKCS0tIGFkc3IK
CWlmIChwZWVrKGFkZHIpID09IDApIHRoZW4KCQktLSBubyBsYWJlbHM6IGl0J3MgaW4gdGhlIG5h
bWUgb2YgdGhlIGVudmVsb3BlIQoJCS0tbG9jYWwga25vYl9uYW1lPXtbMF09ImF0ayIsImRjeSIs
InN1cyIsInJlbCJ9CgkJZm9yIGk9MCwzIGRvCgkJCXBhbmU6YXR0YWNoKGNyZWF0ZV90aW55X2tu
b2IoIiIsYWRkcis4K2ksMitpKjIwLDE2LHRydWUpKQoJCWVuZAoJZW5kCgkKCS0tIGxmbwoJaWYg
KHBlZWsoYWRkcikgPT0gMSkgdGhlbgoJCXBhbmU6YXR0YWNoKGNyZWF0ZV90aW55X2tub2IoImZy
ZXEiLGFkZHIrMTIrMCw4LDE2LHRydWUpKQoJCS0tcGFuZTphdHRhY2goY3JlYXRlX3Rpbnlfa25v
YigiZnVuYyIsYWRkcisxMyswLDMxLDI4LGZhbHNlKSkKCQlwYW5lOmF0dGFjaChjcmVhdGVfdGlu
eV9rbm9iKCJwaGFzZSIsYWRkcisxNCswLDU0LDE2LHRydWUpKQoJCQoJZW5kCgkKCS0tIGRhdGEg
Zm9vdGVyIHRoaW5nCglpZiAocGVlayhhZGRyKSA9PSAyIG9yIHBlZWsoYWRkcisxKSYweDEwPjAp
IHRoZW4KCQkKCQlpZiAocGVlayhhZGRyKSAhPSAyKSB0aGVuCgkJCS0tIG5vbi1kYXRhIG9ubHkg
bmVlZHMgdGhlIHN0YXJ0IGF0IHJuZCh0MCksIHNvIGNhbiBoYXZlIG1vcmUgdmVyYm9zZSB2ZXJz
aW9uCgkJCS0tcGFuZTphdHRhY2goY3JlYXRlX2Vudl9mbGFnX3RvZ2dsZShhZGRyKzEsMHg4LCJy
bmQgc3RhcnQiLDIwLHBhbmUuaGVpZ2h0LTI3KSkKCQkJcGFuZTphdHRhY2goY3JlYXRlX2Vudl9m
bGFnX3RvZ2dsZShhZGRyKzEsMHg4LCJybmQiLDQ2LHBhbmUuaGVpZ2h0LTI3KSkKCQllbmQKCQkK
CQktLSBzdGFydGluZyBmcm9tIGVudl9kZWZbMV0gIC0tIGVudl9kZWZbMF0gaXMgZmxhZ3MKCQls
b2NhbCBrbm9iX25hbWU9e1swXT0ic3BkIiwibHAwIiwibHAxIiwidDAifQoJCWZvciBpPTAsMyBk
bwoJCQlwYW5lOmF0dGFjaChjcmVhdGVfdGlueV9rbm9iKGtub2JfbmFtZVtpXSxhZGRyKzIraSwy
K2kqMjAsCgkJCQlwYW5lLmhlaWdodC0yMCxmYWxzZSkpCgkJZW5kCgkJCgllbmQKCQoJLS0gZGF0
YSBlZGl0b3IKCWlmIChwZWVrKGFkZHIpID09IDIpIHRoZW4KCQlwYW5lOmF0dGFjaChjcmVhdGVf
ZGF0YV9lbnZfZWRpdG9yKGFkZHIsMCw5LDgwLDQ4KSkKCQoJCS0tIGxlcnAsIHJuZF9zdGFydAoJ
CXBhbmU6YXR0YWNoKGNyZWF0ZV9lbnZfZmxhZ190b2dnbGUoYWRkcisxLDB4MSwibGVycCIsMixw
YW5lLmhlaWdodC0yNykpCgkJcGFuZTphdHRhY2goY3JlYXRlX2Vudl9mbGFnX3RvZ2dsZShhZGRy
KzEsMHg4LCJybmQiLDQ2LHBhbmUuaGVpZ2h0LTI3KSkKCQkKCWVuZAoJCgktLSBzaG93IGFkdmFu
Y2VkIG9wdGlvbnMgLyAuLi4gYnV0dG9uCglpZiAocGVlayhhZGRyKSA8IDIpIHRoZW4KCQlsb2Nh
bCBzdHI9IlxmNVxeOjAwMDAwMDE1MDAwMDAwMDAiIC0tIC4uLgoJCWlmIChwZWVrKGFkZHIrMSkm
MHgxMD4wKSBzdHI9IlxmNVxeOjAwMDAwNDBlMWYwMDAwMDAiIC0tIHVwIGFycm93CgkJcGFuZTph
dHRhY2goY3JlYXRlX2Vudl9mbGFnX3RvZ2dsZShhZGRyKzEsMHgxMCxzdHIsd2lkdGgvMi02LGhl
aWdodDAtOCkpCgllbmQKCQoJLS0gZG9uJ3Qgc2Nyb2xsIHdoZW4gZ3JhYmJpbmcgImVudi0wIiBw
YXJ0IG9mIHRpdGxlIGJhcgoJLS0_IHNvIHRoYXQgY2FuIGRyYWcgYW5kIGRyb3Agd2l0aG91dCBz
Y3JvbGxpbmcgZW52IGNvbnRhaW5lcgoJcGFuZTphdHRhY2h7CgkJeD0wLHk9MCx3aWR0aD0yNixo
ZWlnaHQ9MTAsCgkJY3Vyc29yPSJncmFiIiwKCQljbGljaz1mdW5jdGlvbihzZWxmKQoJCQlncmFi
YmVkX2VudmVsb3BlID0gcGFuZS5pbmRleAoJCQlyZXR1cm4KCQllbmQsCgkJZHJhZz1mdW5jdGlv
bigpCgkJCXJldHVybiB0cnVlIAoJCWVuZAoJfQoJCgktLSBjYW4gZHJhZyBhbmQgZHJvcCBhbnl3
aGVyZSBvbiBwYW5lCglmdW5jdGlvbiBwYW5lOnJlbGVhc2UobXNnKQoJCWxvY2FsIHN4PXNlbGYu
c3ggKyBtc2cubXgKCQlsb2NhbCBzeT1zZWxmLnN5ICsgbXNnLm15CgkJCgkJbG9jYWwgZWwyID0g
Z3VpOmVsX2F0X3h5KHN4LHN5KQoJCWlmIChlbDIgYW5kIGVsMi5kcm9wX2Vudl9wbHVnKSBlbDI6
ZHJvcF9lbnZfcGx1Z3tpbmRleD1zZWxmLmluZGV4fQoJCQoJCWdyYWJiZWRfZW52ZWxvcGUgPSBu
aWwKCWVuZAoJCglyZXR1cm4gcGFuZQplbmQKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6IGd1aS5sdWEKLS1b
W3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yMiAwNzozMjoxMSIsbW9kaWZpZWQ9
IjIwMjUtMDctMTAgMDM6MjY6MjciLHJldmlzaW9uPTE1ODMzLHN0b3JlZD0iMjAyMy0zNi0yOSAw
NDozNjo0MCJdXQoKZnVuY3Rpb24gY3JlYXRlX3BhbmUodGl0bGUsIHgsIHksIHcsIGgsIGNvbCwg
b250YXApCgoJaWYgKG5vdCBjb2wpIGNvbCA9IDB4MDcwNSAtLSBkZWZhdWx0IGJhY2sKCQoJbG9j
YWwgZWw9ewoJCXRpdGxlPXRpdGxlLAoJCXg9eCx5PXksd2lkdGg9dyxoZWlnaHQ9aCwKCQljb2w9
Y29sCgl9CgkKCWlmIChvbnRhcCkgZWwuY3Vyc29yID0gInBvaW50ZXIiCgkKCWZ1bmN0aW9uIGVs
OmRyYXcoKQoJCgkJbG9jYWwgY29sID0gKHNlbGYuY29sID4_IDApICYgMHhmZgoJCWxvY2FsIGhj
b2wgPSAoc2VsZi5jb2wgPj4gOCkgJiAweGZmCgkJCgkJcmVjdGZpbGwoMSwwLHNlbGYud2lkdGgt
MiwwLGhjb2wpCgkJcmVjdGZpbGwoMCwxLHNlbGYud2lkdGgsOCxoY29sKQoJCXJlY3RmaWxsKDAs
OSxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMixjb2wpCgkJcmVjdGZpbGwoMSxzZWxmLmhlaWdo
dC0xLHNlbGYud2lkdGgtMixzZWxmLmhlaWdodC0xLGNvbCkKCQkKCQktLXByaW50KHRpdGxlLDE0
LDIsMSkgLS0gYXNzdW1lIHNvbWUga2luZCBvZiBpY29uIHRvIHRoZSBsZWZ0CgkJbG9jYWwgc3Ry
ID0gdGl0bGUKLS0JCWlmIChzdHIgPT0gImluc3RydW1lbnRzIikgc3RyID0gc3RyaW5nLmZvcm1h
dCgiaW5zdCAlMDJ4IFxmNiglZCkiLCBjaSxjaSkKCQlpZiAoc3RyID09ICJzZngiKSBzdHIgPSAi
c2Z4ICIuLmZscihjdCkKCQlwcmludChzdHIsNiwyLDEpIC0tIGFzc3VtZSBzb21lIGtpbmQgb2Yg
aWNvbiB0byB0aGUgbGVmdAoJCQoJZW5kCgkKCS0tIG9uIHRhcCBoZWFkZXIKCWZ1bmN0aW9uIGVs
OnRhcChtc2cpCgkJaWYgKG9udGFwIGFuZCBtc2cubXkgPD0gOSkgb250YXAoc2VsZixtc2cpCgll
bmQKCQoJcmV0dXJuIGVsCmVuZAoKZnVuY3Rpb24gZXh0ZW5kX2luc3RydW1lbnRfc2VsZWN0aW9u
KCkKCWlmIChjaSA8IGNpMikgdGhlbgoJCWNpMCA9IGNpIC0tIGV4dGVuZCB0byBsZWZ0CgkJY2kx
ID0gY2kyCgllbHNlCgkJY2kxID0gY2kgLS0gZXh0ZW5kIHRvIHJpZ2h0CgkJY2kwID0gY2kyCgll
bmQKZW5kCgpmdW5jdGlvbiBleHRlbmRfdHJhY2tfc2VsZWN0aW9uKCkKCWlmIChjdCA8IGN0Mikg
dGhlbgoJCWN0MCA9IGN0IC0tIGV4dGVuZCB0byBsZWZ0CgkJY3QxID0gY3QyCgllbHNlCgkJY3Qx
ID0gY3QgLS0gZXh0ZW5kIHRvIHJpZ2h0CgkJY3QwID0gY3QyCgllbmQKZW5kCgpmdW5jdGlvbiBl
eHRlbmRfcGF0dGVybl9zZWxlY3Rpb24oKQoJaWYgKGNwIDwgY3AyKSB0aGVuCgkJY3AwID0gY3Ag
LS0gZXh0ZW5kIHRvIGxlZnQKCQljcDEgPSBjcDIKCWVsc2UKCQljcDEgPSBjcCAtLSBleHRlbmQg
dG8gcmlnaHQKCQljcDAgPSBjcDIKCWVuZAplbmQKCgpmdW5jdGlvbiBjcmVhdGVfaW5zdHJ1bWVu
dF9jaG9vc2VyKGVsKQoJbG9jYWwgY29udGVudHMKCS0tIGluc3RydW1lbnQgY2hvb3NlcgoJbG9j
YWwgY29udGFpbmVyID0gZWw6YXR0YWNoewoJCXg9Mix5PTEwLHdpZHRoPWVsLndpZHRoLTIsaGVp
Z2h0PWVsLmhlaWdodC0xMSwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCS0tIHNvbWUgcGFyZW50
IHR1cm5lZCBjbGlwcGluZyBvZmY7IGNhbiB0dXJuIGJhY2sgb24gaGVyZQoJCQljbGlwKHNlbGYu
c3gsc2VsZi5zeSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0KQoJCWVuZCwKCQl1cGRhdGU9ZnVuY3Rp
b24oc2VsZikKCQkJc2Nyb2xsWzFdID0gY29udGVudHMueQoJCWVuZAoJfQoJY29udGVudHMgPSBj
b250YWluZXI6YXR0YWNoewoJCXg9MCx5PTAsd2lkdGg9ODYsaGVpZ2h0PTUxMiwKCQlkcmF3PWZ1
bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGkwID0gbWlkKDAsICgtY29udGVudHMueSlcOCwgNjMpCgkJ
CWxvY2FsIGkxID0gbWlkKDAsIGkwICsgOCwgNjMpCgkJCWZvciBpPWkwLGkxIGRvCgkJCQlpZiAo
aSA_PSBjaTAgYW5kIGkgPD0gY2kxIGFuZCBtb2RlPT0iaW5zdHJ1bWVudCIpIHRoZW4KCQkJCQly
ZWN0ZmlsbCgwLGkqOCxzZWxmLndpZHRoLTEsaSo4KzYsMzEpCgkJCQllbmQKCQkJCWlmIChjaSA9
PSBpKSB0aGVuCgkJCQkJcmVjdGZpbGwoMCxpKjgsc2VsZi53aWR0aC0xLGkqOCs2LAoJCQkJCW1v
ZGU9PSJpbnN0cnVtZW50IiBhbmQgMTQgb3IgMTYpCgkJCQllbmQKCQkJCWxvY2FsIGZtdCA9IChj
aSA9PSBpKSBhbmQgIiUwMnggXGY3JXMgIiBvciAiJTAyeCBcZmQlcyAiCgkJCQlwcmludChzdHJp
bmcuZm9ybWF0KGZtdCxpLGdldF9pbnN0X25hbWUoaSkpLDAsMSArIGkqOCwgNyktLTYpCgkJCQkt
LXByaW50KHN0cmluZy5mb3JtYXQoIiUwMmkgaW5zdCAiLGkpLDIsMSArIGkqOCw2KQoJCQllbmQK
CQllbmQsCgkJY2xpY2s9ZnVuY3Rpb24oc2VsZixtc2cpCgkJCWNpID0gbXNnLm15XDgKCQkJCgkJ
CWlmIChrZXkic2hpZnQiKSB0aGVuCgkJCQlleHRlbmRfaW5zdHJ1bWVudF9zZWxlY3Rpb24oKQoJ
CQkJbW9kZSA9ICJpbnN0cnVtZW50IgoJCQllbHNlCgkJCQljaTAsY2kxLGNpMiA9IGNpLGNpLGNp
IC0tIHJlc2V0IGluc3RydW1lbnQgc2VsZWN0aW9uCgkJCWVuZAoJCQkKCQkJaWYgKGtleSJjdHJs
Iikgc2V0X21vZGUoImluc3RydW1lbnQiKQoJCQlpZiAobW9kZSA9PSAiaW5zdHJ1bWVudCIpIHJl
ZnJlc2hfZ3VpID0gdHJ1ZQoJCWVuZCwKCQlkb3VibGVjbGljayA9IGZ1bmN0aW9uKHNlbGYsbXNn
KQoJCQljaSA9IG1zZy5teVw4CgkJCWNpMCxjaTEsY2kyID0gY2ksY2ksY2kKCQkJc2V0X21vZGUo
Imluc3RydW1lbnQiKQoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCX0KCgkKCWNvbnRhaW5l
cjphdHRhY2hfc2Nyb2xsYmFycygpCgkKCS0tIHN0YXJ0IGNlbnRlcmVkCgljb250ZW50cy55ID0g
LWNpICogOCArIDMwCglpZiAoc2Nyb2xsWzFdKSBjb250ZW50cy55ID0gc2Nyb2xsWzFdCgoJLS0g
Y2xhbXAKCWNvbnRlbnRzLnkgPSBtaWQoMCwgY29udGVudHMueSwgLSAoY29udGVudHMuaGVpZ2h0
IC0gY29udGFpbmVyLmhlaWdodCkpCmVuZAoKc2Z4X3RodW1iPXt9CmZ1bmN0aW9uIGdldF9zZnhf
dGh1bWIoc2Z4aSwgdXNlX2NhY2hlZCkKCWxvY2FsIGFkZHIgPSAweDUwMDAwICsgc2Z4aSAqIDMy
OCArIDgKCWlmIG5vdCBzZnhfdGh1bWJbYWRkcl0gb3Igbm90IHVzZV9jYWNoZWQgdGhlbgoJCWxv
Y2FsIGJtcCA9IHVzZXJkYXRhKCJ1OCIsOCw3KQoJCS0tIG11bHRpcGxlIGRvdHMgcGVyIHgKCQlm
b3IgeD0wLDMxIGRvCgkJCWxvY2FsIHBpdGNoID0gQChhZGRyK3gpCgkJCWxvY2FsIGluc3QgID0g
QChhZGRyK3grNjQpCgkJCWlmIChpbnN0ICE9IDB4ZmYpIHNldChibXAsIHgvNCwgbWlkKDAsMTAt
cGl0Y2gvOCw3KSwgOCsoaW5zdCUyNCkpCgkJZW5kCi0tW1sKCQlmb3IgeD0wLDcgZG8KCQkJbG9j
YWwgcGl0Y2ggPSAwCgkJCWxvY2FsIGluc3QgPSAweGZmCgkJCWZvciBqPTAsMyBkbwoJCQkJbG9j
YWwgYWRkcjI9YWRkcit4KjQragoJCQkJaWYgKEBhZGRyMiA_IHBpdGNoKSB0aGVuCgkJCQkJcGl0
Y2ggPSBAYWRkcjIgaW5zdCA9IEAoYWRkcjIrNjQpCgkJCQllbmQKCQkJZW5kCgkJCXNldChibXAs
eCwxMC1waXRjaC82LDgrKGluc3QlMjQpKQoJCWVuZAotLV1dCgkJCgkJc2Z4X3RodW1iW2FkZHJd
ID0gYm1wCgllbmQKCXJldHVybiBzZnhfdGh1bWJbYWRkcl0KZW5kCgoKZnVuY3Rpb24gZ2V0X3Ry
YWNrX2luZGV4X2Zyb21fbmF2X214eShteCwgbXkpCglsb2NhbCB4eCAgPSBtaWQoMCwgKG14LTIp
IFwgOSwgNykKCWxvY2FsIHl5ICA9IChteS0yKQoJbG9jYWwgeXkxID0gKHl5XDc0KSo4ICsgbWlk
KDAsKHl5JTc0LTgpXDgsNykKCQoJcmV0dXJuIGZscih4eCArIHl5MSAqIDgpCmVuZAoJCgoKZnVu
Y3Rpb24gY3JlYXRlX3RyYWNrX2Nob29zZXIoZWwpCgoJbG9jYWwgY29udGVudHMKCWxvY2FsIGNv
bnRhaW5lciA9IGVsOmF0dGFjaHsKCQl4PTEseT0xMCx3aWR0aD1lbC53aWR0aC0yLGhlaWdodD1l
bC5oZWlnaHQtMTAsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQktLSBzb21lIHBhcmVudCB0dXJu
ZWQgY2xpcHBpbmcgb2ZmOyBjYW4gdHVybiBiYWNrIG9uIGhlcmUKCQkJY2xpcChzZWxmLnN4LHNl
bGYuc3ksc2VsZi53aWR0aCxzZWxmLmhlaWdodCkKCQllbmQsCgkJdXBkYXRlPWZ1bmN0aW9uKHNl
bGYpCgkJCXNjcm9sbFsyXSA9IGNvbnRlbnRzLnkKCQllbmQKCX0KCQoJY29udGVudHMgPSBjb250
YWluZXI6YXR0YWNoewoJCXg9MCx5PTAsd2lkdGg9ODYsaGVpZ2h0PTc0KjYrMiwKCQlkcmF3PWZ1
bmN0aW9uKHNlbGYpCgkJCgkJCWZvciBncm91cCA9IDAsNSBkbwoJCQkJbG9jYWwgeCA9IDIKCQkJ
CWxvY2FsIHkgPSAyICsgZ3JvdXAgKiA3NAoJCQkJcHJpbnQoc3RyaW5nLmZvcm1hdCgiJTAzZCIs
Z3JvdXAqNjQpLHgseSwxMykKCQkJCXkrPTgKCQkJCS0tIGNsaXAgYnkgZ3JvdXAKCQkJCWlmIHkg
KyBjb250ZW50cy55ID4gLTc0IGFuZCB5ICsgY29udGVudHMueSA8IGNvbnRhaW5lci5oZWlnaHQg
dGhlbgoJCQkJZm9yIGkgPSBncm91cCo2NCwgZ3JvdXAqNjQrNjMgZG8KCQkJCQktLSBjbGlwIGJ5
IGxpbmUKCQkJCQlpZiB5ICsgY29udGVudHMueSA_IC0xMiBhbmQgeSArIGNvbnRlbnRzLnkgPCBj
b250YWluZXIuaGVpZ2h0IHRoZW4KCQkJCQkJcmVjdGZpbGwoeCx5LHgrNyx5KzYsMCkKCQkJCQkJ
CgkJCQkJCWlmIChpID49IGN0MCBhbmQgaSA8PSBjdDEgYW5kIG1vZGUgPT0idHJhY2siKSB0aGVu
CgkJCQkJCQktLSB0cmFjayBzZWxlY3Rpb24KCQkJCQkJCXJlY3QoeC0xLHktMSx4KzgseSs3LCAx
MCkKCQkJCQkJZW5kCgkJCQkJCWlmIChjdCA9PSBpKSB0aGVuCgkJCQkJCQktLSBjdXJyZW50IHRy
YWNrIGhpZ2hsaWdodGVkCgkJCQkJCQlyZWN0KHgtMSx5LTEseCs4LHkrNywgZm9jdXM9PSJ0cmFj
a19pdGVtIiBhbmQgNyBvciAxMykKCQkJCQkJZW5kCgkJCQkJCQoJCQkJCQktLSBzaG93IGlzIHBs
YXlpbmcKCQkJCQkJbG9jYWwgcHIgPSBwbGF5aW5nX3JvdyhpKQoJCQkJCQlpZiAocHIpIHRoZW4K
CQkJCQkJCXJlY3RmaWxsKHgseSx4KzcseSs2LDUpIC0tIGp1c3QgaGlnaGxpZ2h0IGJhY2tncm91
bmQKCQkJCQkJCS0tIHNob3cgcG9zaXRpb24uIG5vdCB0aGF0IHVzZWZ1bCEKCQkJCQkJCS0tbGlu
ZSh4K3ByLzgsIHksIHgrcHIvOCwgeSs2LCA3KQoJCQkJCQkJLS0gYmxpbmt5IGJhcnM6IGN1dGVy
LCBidXQgdG9vIG11Y2gKCQkJCQkJCS0tW1sKCQkJCQkJCWZvciBqPTAsMiBkbwoJCQkJCQkJCXJl
Y3RmaWxsKHgraiozLHkrNix4KzEraiozLHkrNi1tYXgoY29zKC1qKi4zK3QoKSozKSkqMiwKCQkJ
CQkJCQkJKHRpbWUoKSoyK2ovNSklMTwuNCBhbmQgNiBvciAxMykKCQkJCQkJCWVuZAoJCQkJCQkJ
XV0KCQkJCQkJZW5kCgkJCQkJCQoJCQkJCQlzcHIoZ2V0X3NmeF90aHVtYihpLCBpICE9IGN0KSx4
LHkpCgkJCQkJCQoJCQkJCWVuZAoJCQkJCgkJCQkJeCArPSA5CgkJCQkJaWYgKHggPiA3MikgdGhl
bgoJCQkJCQl4ID0gMiB5ICs9IDgKCQkJCQllbmQKCQkJCQoJCQkJZW5kCgkJCQllbmQKCQkJZW5k
CQoKLS1bWwoJCQlmb3IgaT0wLDM4MyBkbwoJCQkJbG9jYWwgeCA9IDIgKyAoaSAlIDgpICogOQoJ
CQkJbG9jYWwgeSA9IDIgKyAoaSBcIDgpICogOCArIChpXDY0KSoxMAoJCQkJLS1yZWN0ZmlsbCh4
LHkseCs3LHkrNiwgY3QgPT0gaSBhbmQgMjkgb3IgMTgpCgkJCQlyZWN0ZmlsbCh4LHkseCs3LHkr
NiwwKQoJCQkJaWYgKGN0ID09IGkpIHJlY3QoeC0xLHktMSx4KzgseSs3LDcpCgkJCQktLSB0aHVt
YgoJCQkJbG9jYWwgZGF0X2FkZHIgPSAweDUwMDAwICsgaSAqIDMyOCArIDgKCQkJCXNwcihnZXRf
c2Z4X3RodW1iKGRhdF9hZGRyLCBpICE9IGN0KSx4LHkpCgkJCQkKCQkJCS0tcHJpbnQoc3RyaW5n
LmZvcm1hdCgiJTAyeCIsaSkseCsxLHkrMSwxKQoJCQkJaWYgKHBsYXlpbmdfcm93KGkpKSB0aGVu
CgkJCQkJZm9yIGo9MCwyIGRvCgkJCQkJCS0tY2lyY2ZpbGwoeCs0K2oqNCx5KzEwLC44K2Nvcygt
aiouMyt0KCkqMiksIDcpCgkJCQkJCXJlY3RmaWxsKHgrMytqKjQseSsxMSx4KzUraio0LHkrMTEt
bWF4KGNvcygtaiouMyt0KCkqMykpKjIsNykKCQkJCQllbmQKCQkJCWVuZAoJCQllbmQKCQkJXV0K
CQllbmQsCgkJCgkJcmVsZWFzZT1mdW5jdGlvbihzZWxmLG1zZykKCQkJCgkJCWxvY2FsIHN4PXNl
bGYuc3ggKyBtc2cubXgKCQkJbG9jYWwgc3k9c2VsZi5zeSArIG1zZy5teQoJCQkKCQkJbG9jYWwg
ZWwyID0gZ3VpOmVsX2F0X3h5KHN4LHN5KQoJCQlpZiAoZWwyIGFuZCBlbDIuZHJvcF90cmFja19p
bmRleCkgZWwyOmRyb3BfdHJhY2tfaW5kZXh7aW5kZXg9Z3JhYmJlZF90cmFja30KCQkJCgkJCWdy
YWJiZWRfdHJhY2sgPSBuaWwKCQllbmQsCgkJCgkJY2xpY2s9ZnVuY3Rpb24oc2VsZiwgbXNnKQoJ
CQlncmFiYmVkX3RyYWNrID0gZ2V0X3RyYWNrX2luZGV4X2Zyb21fbmF2X214eShtc2cubXgsIG1z
Zy5teSkKCQkJZ3JhYmJlZF90cmFja190ID0gdGltZSgpCgkJZW5kLAoJCgkJCgkJdGFwPWZ1bmN0
aW9uKHNlbGYsIG1zZykKCQkJY2hlY2twb2ludCgpCgkJCQkKCQkJY3QgPSBnZXRfdHJhY2tfaW5k
ZXhfZnJvbV9uYXZfbXh5KG1zZy5teCwgbXNnLm15KQoJCQlpZiAoa2V5InNoaWZ0IikgdGhlbgoJ
CQkJZXh0ZW5kX3RyYWNrX3NlbGVjdGlvbigpCgkJCWVsc2UKCQkJCWN0MCxjdDEsY3QyID0gY3Qs
Y3QsY3QgLS0gcmVzZXQgdHJhY2sgc2VsZWN0aW9uCgkJCWVuZAoJCQlzZXRfbW9kZSgidHJhY2si
KQoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCX0KCWNvbnRhaW5lcjphdHRhY2hfc2Nyb2xs
YmFycygpCgkKCWlmIChtb2RlID09ICJ0cmFjayIpIHRoZW4KCQktLSBpZiBhbHJlYWR5IGluIHRy
YWNrIG1vZGUsIGRvbid0IG5lZWQgdG8gYmUgYWJsZSB0bwoJCS0tIGRyYWcgdHJhY2ssIGFuZCB3
YW50IHNlbGVjdGlvbiBiZSBzbmFwcGllciAoaGFwcGVuCgkJLS0gb24gY2xpY2sgaW5zdGVhZCBv
ZiB0YXApCgkJY29udGVudHMuY2xpY2sgPSBjb250ZW50cy50YXAKCQljb250ZW50cy50YXAgPSBu
aWwKCWVuZAoJCglpZiAoc2Nyb2xsWzJdKSBjb250ZW50cy55ID0gc2Nyb2xsWzJdCgkKCQplbmQK
Ci0tIDEyOCBwYXR0ZXJucwotLSBjYW4gYWRkIGEgd2F5IHRvIGFkZCBtb3JlIGxhdGVyLCBidXQg
PiAxMjggYmVjb21lcyBhd2t3YXJkIHRvIG5hdmlnYXRlCmZ1bmN0aW9uIGNyZWF0ZV9wYXR0ZXJu
X2Nob29zZXIoZWwpCgoJbG9jYWwgY29udGVudHMKCWxvY2FsIGNvbnRhaW5lciA9IGVsOmF0dGFj
aHsKCQl4PTIseT0xMCx3aWR0aD1lbC53aWR0aC0yLGhlaWdodD1lbC5oZWlnaHQtMTEsCgkJZHJh
dz1mdW5jdGlvbihzZWxmKQoJCQktLSBzb21lIHBhcmVudCB0dXJuZWQgY2xpcHBpbmcgb2ZmOyBj
YW4gdHVybiBiYWNrIG9uIGhlcmUKCQkJY2xpcChzZWxmLnN4LHNlbGYuc3ksc2VsZi53aWR0aCxz
ZWxmLmhlaWdodCkKCQllbmQsCgkJdXBkYXRlPWZ1bmN0aW9uKHNlbGYpCgkJCXNjcm9sbFszXSA9
IGNvbnRlbnRzLnkKCQllbmQKCX0KCWNvbnRlbnRzID0gY29udGFpbmVyOmF0dGFjaHsKCQl4PTAs
eT0wLHdpZHRoPTg2LGhlaWdodD0oMTI4LzQqMTIpKzQsCgkJCgkJZHJhdz1mdW5jdGlvbihzZWxm
KQoJCQlsb2NhbCBwbGF5aW5nX3BhdHRlcm4gPSBzdGF0KDQ2NikKCQkJaTAgPSBtaWQoMCwgKCgt
Y29udGVudHMueSkgXCAxMikgKiA0LCAxMjcpCgkJCWkxID0gbWlkKDAsIGkwICsgMjMsIDEyNykK
CQkJZm9yIGk9aTAsaTEgZG8KCQkJCWxvY2FsIGFkZHIgPSAweDMwMTAwICsgaSAqIDIwCgkJCQls
b2NhbCBmbGFncyA9IHBlZWsoYWRkcis4KSAgLS0gZmxvdyBmbGFncwoJCQkJbG9jYWwgbWFzayA9
ICBwZWVrKGFkZHIrOSkgLS0gY2hhbm5lbCBtYXNrIC0tIDQgY2hhbm5lbHMKCQkJCQoJCQkJbG9j
YWwgeCA9IDAgKyAoaSAlIDQpICogMTkKCQkJCWxvY2FsIHkgPSAyICsgKGkgXCA0KSAqIDEyCgkJ
CQlyZWN0ZmlsbCh4LHkseCsxNix5KzgsCgkJCQkJKGkgPj0gY3AwIGFuZCBpIDw9IGNwMSBhbmQg
bW9kZT09InBhdHRlcm4iKSBhbmQgCgkJCQkJKGZvY3VzID09ICJwYXR0ZXJuIiBhbmQgMTQgb3Ig
MzApIG9yIAoJCQkJCShtYXNrID09IDAgYW5kIDAgb3IgMTgpKQoJCQkJLS1yZWN0KHgseSx4KzE2
LHkrOCwgY3AgPT0gaSBhbmQgMTQgb3IgMTMpCgkJCQkKCQkJCS0tIGxvb3AwOiBjdXQgdG9wIGxl
ZnQgY29ybmVyCgkJCQlpZiAoZmxhZ3MgJiAxID4gMCkgdGhlbgoJCQkJCXBzZXQoeCx5LDEpCgkJ
CQkJbGluZSh4LHkrMSx4KzEseSwxKQoJCQkJZW5kCgkJCQktLSBsb29wMTogY3V0IHRvcCByaWdo
dCBjb3JuZXIKCQkJCWlmIChmbGFncyAmIDIgPiAwKSB0aGVuCgkJCQkJcHNldCh4KzE2LHksMSkK
CQkJCQlsaW5lKHgrMTYseSsxLHgrMTUseSwxKQoJCQkJZW5kCgkJCQktLSBzdG9wOiBjdXQgYm90
dG9tIHJpZ2h0IGNvcm5lcgoJCQkJaWYgKGZsYWdzICYgNCA_IDApIHRoZW4KCQkJCQlwc2V0KHgr
MTYseSs4LDEpCgkJCQkJbGluZSh4KzE2LHkrNyx4KzE1LHkrOCwxKQoJCQkJZW5kCgkJCQkKCQkJ
CWlmIChtYXNrID09IDApIHRoZW4KCQkJCQkKCQkJCWVsc2VpZiAobWFzayAmIDB4ZjApID4gMCB0
aGVuCgkJCQkJLS0gOCBjaGFubmVscwoJCQkJCWZvciBqPTAsNyBkbwoJCQkJCQlsb2NhbCBpbmRl
eCA9IEAoYWRkcitqKQoJCQkJCQlwc2V0KDEreCtqKjIseSsxMCwobWFzayAmICgxPDxqKSkgPiAw
IGFuZCA4KyhpbmRleCUxNikgb3IgMCkKCQkJCQllbmQKCQkJCWVsc2UKCQkJCQktLSBvbmx5IHVz
ZSBjaGFubmVscyAwLi4zCgkJCQkJZm9yIGo9MCwzIGRvCgkJCQkJCWxvY2FsIGluZGV4ID0gQChh
ZGRyK2opCgkJCQkJCWxvY2FsIHh4PTEreCtqKjQKCQkJCQkJbG9jYWwgeXk9eSsxMAoJCQkJCQls
aW5lKHh4LHl5LHh4KzIseXksKG1hc2sgJiAoMTw8aikpID4gMCBhbmQgOCsoaW5kZXglMTYpIG9y
IDApCgkJCQkJZW5kCgkJCQllbmQKCQkJCWxvY2FsIGlzdHI9c3RyaW5nLmZvcm1hdCgiJTAyaSIs
aSkKCQkJCXByaW50KGlzdHIseCs5LSNpc3RyKjIseSsyLCBjcCA9PSBpIGFuZCA3IG9yIDEpCgkJ
CQkKCQkJCS0tIGJsaW5reSB2ZXJpb24gd2hlbiBwbGF5aW5nIGJhY2sKCQkJCQoJCQkJaWYgKHBs
YXlpbmdfcGF0dGVybiA9PSBpKSB0aGVuCgkJCQkJbG9jYWwgd3cgPSAobWFzayAmIDB4ZjApID4g
MCBhbmQgMiBvciA0CgkJCQkJbG9jYWwgamogPSAobWFzayAmIDB4ZjApID4gMCBhbmQgNyBvciAz
CgkJCQkJZm9yIGo9MCxqaiBkbwoJCQkJCQlsb2NhbCBpbmRleCA9IEAoYWRkcitqKQoJCQkJCQls
b2NhbCBjb2wgPSAobWFzayAmICgxPDxqKSkgPiAwIGFuZCA4KyhpbmRleCUxNikgb3IgMAoJCQkJ
CQlsb2NhbCB4eD0xK3graip3dwoJCQkJCQlsb2NhbCB5eT15KzEwCgkJCQkJCWlmICgodGltZSgp
KjItKGoqNS43KSklMSA8IDAuNCkgY29sID0gNyAtLSBibGluayB3aGl0ZQoJCQkJCQlyZWN0Zmls
bCh4eCx5eStjb3ModGltZSgpKjItai81KSowLjUseHgrd3ctMix5eSxjb2wpCgkJCQkJZW5kCgkJ
CQllbmQKCQkJCQoJCQllbmQKCQllbmQsCgkJCgkJdGFwPWZ1bmN0aW9uKHNlbGYsIG1zZykKCQkJ
Y2hlY2twb2ludCgpCgkJCWNwID0gZmxyKG1pZCgwLCBtc2cubXggXCAyMCwgMykgKyAoKG1zZy5t
eS0yKSBcIDEyKSAqIDQpCgkJCQoJCQlpZiAoa2V5InNoaWZ0IikgdGhlbgoJCQkJZXh0ZW5kX3Bh
dHRlcm5fc2VsZWN0aW9uKCkKCQkJZWxzZQoJCQkJY3AwLGNwMSxjcDIgPSBjcCxjcCxjcCAtLSBy
ZXNldCBwYXR0ZXJuIHNlbGVjdGlvbgoJCQllbmQKCQkJCgkJCXNldF9tb2RlKCJwYXR0ZXJuIikK
CQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJZW5kCgl9Cgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJh
cnMoKQoJCgljb250ZW50cy55ID0gLShjcFw0KSAqIDEyICsgMjAKCWlmIChzY3JvbGxbM10pIGNv
bnRlbnRzLnkgPSBzY3JvbGxbM10KCgktLSBjbGFtcAoJY29udGVudHMueSA9IG1pZCgwLCBjb250
ZW50cy55LCAtIChjb250ZW50cy5oZWlnaHQgLSBjb250YWluZXIuaGVpZ2h0KSkKCQplbmQKCmZ1
bmN0aW9uIGNyZWF0ZV92b2x1bWVfY2hvb3Nlcih4LCB5KQoJbG9jYWwgZWwgPXsKCQl4ID0geCwg
eSA9IHksIHdpZHRoPTQ4LCBoZWlnaHQgPSA3LAoJCWN1cnNvciA9ICJwb2ludGVyIgoJfQoJZnVu
Y3Rpb24gZWw6ZHJhdyhtc2cpCgkJY2xpcCgpCgkJaWYgKG1zZy5tYj4wIGFuZCBtc2cuaGFzX3Bv
aW50ZXIpIHRoZW4KCQkJcHJpbnQoY3ZvbCwtMTUsMSwxNikKCQllbHNlCgkJCXByaW50KCJ2b2wi
LC0xNSwxLDE2KQoJCWVuZAoJCWZvciBpPTAsNyBkbwoJCQlsb2NhbCBzeCA9IGkgKiA1CgkJCXJl
Y3RmaWxsKHN4LDAsc3grNCw2LCAoaSsxKSoweDggPT0gY3ZvbCYofjB4NykgYW5kIDYgb3IgMTMp
CgkJCS0tcHJpbnQoIlwwMTQiLi4oaSsxKSxzeCsxLDEsMTMpCgkJZW5kCgllbmQKCWZ1bmN0aW9u
IGVsOmRyYWcobXNnKQoJCWN2b2wgPSBtaWQoMSwoMSsobXNnLm14XDUpKSw4KSoweDgKCWVuZAoJ
CglyZXR1cm4gZWwKZW5kCgogCmZ1bmN0aW9uIGNyZWF0ZV9vY3RhdmVfY2hvb3Nlcih4LCB5KQoJ
bG9jYWwgZWwgPXsKCQl4ID0geCwgeSA9IHksIHdpZHRoPTQ4LCBoZWlnaHQgPSA3LAoJCWN1cnNv
ciA9ICJwb2ludGVyIgoJfQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJY2xpcCgpCgkJcHJpbnQoIm9j
dCIsLTE1LDEsMTYpCgkJZm9yIGk9MCw3IGRvCgkJCWxvY2FsIHN4ID0gaSAqIDUKCQkJcmVjdGZp
bGwoc3gsMCxzeCs0LDYsaSsxID09IGNvY3QgYW5kIDYgb3IgMTMpCgkJCXByaW50KCJcMDE0Ii4u
KGkrMSksc3grMSwxLGkrMSA9PSBjb2N0IGFuZCAxMyBvciAxMykKCQllbmQKCWVuZAoJZnVuY3Rp
b24gZWw6ZHJhZyhtc2cpCgkJY29jdCA9IG1pZCgxLDErKG1zZy5teFw1KSw4KQoJZW5kCgkKCXJl
dHVybiBlbAplbmQKCgpmdW5jdGlvbiBnZW5lcmF0ZV9ndWlfdHJhY2soKQoKCWxvY2FsIHh4ID0g
OTIKCXRyYWNrX3BhbmUgPSBndWk6YXR0YWNoKGNyZWF0ZV9wYW5lKCJcZjZzZnggIi4uY3QseHgs
NCwzODQsODIsMHgxMDAxKSkKCQoJdHJhY2tfcGFuZS5jbGljayA9IGZ1bmN0aW9uKCkKCQktLSBj
b3B5L3Bhc3RlIGFwcGxpZXMgdG8gdGhlIHdob2xlIHNmeCwgbm90IG5vdGUgc2VsZWN0aW9uIAoJ
CS0tIGNsaWNrIG9uIHRyYWNrIHRvIGNoYW5nZSBmb2N1cyB0byB0cmFjayAobm90ZSBzZWxlY3Rp
b24pCgkJZm9jdXMgPSAidHJhY2tfaXRlbSIKCWVuZAoJCglmb2N1cyA9ICJ0cmFja19pdGVtIgoJ
Cglsb2NhbCB0cmFja19hZGRyID0gMHg1MDAwMCArIGN0ICogMzI4CgktLSBkb24ndCBleHBvc2Ug
bGVuZ3RoIGZvciBub3c7IGFsd2F5cyA2NAoJLS0gZnV0dXJlOiB3aGVuIGNoYW5nZSBsZW4sIG5l
ZWQgdG8gdXBkYXRlIHN0cmlkZSB0byBtYXRjaCEKCS0tdHJhY2tfcGFuZTphdHRhY2goY3JlYXRl
X3RpbnlfbnVtX2ZpZWxkKCJsZW4iLCAgdHJhY2tfYWRkciArIDAsMTAwLDEpKQoJCi0tW1sgZGVs
ZXRlbWUgLS0gbW92ZWQgdG8gbGVmdCBwYW5lCgl0cmFja19wYW5lOmF0dGFjaChjcmVhdGVfb2N0
YXZlX2Nob29zZXIoIDc1LDEpKQoJdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX3ZvbHVtZV9jaG9v
c2VyKDE0NSwxKSkKXV0KCi0tIGlzIG5vdCBqdXN0IHBsYXkgbGVuZ3RoIC0tIGRpY3RhdGVzIGhv
dyBkYXRhIGlzIGFycmFuZ2VkIChzdHJpZGUgYmV0d2VlbiBjb2x1bW5zKQotLQl0cmFja19wYW5l
OmF0dGFjaChjcmVhdGVfdGlueV9udW1fZmllbGQoImxlbiIsICB0cmFja19hZGRyICsgMCwyMzAs
MSwgIDEsNjQpKQoKCQoJdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX3RpbnlfbnVtX2ZpZWxkKCJz
cGQiLCAgdHJhY2tfYWRkciArIDIsMjYwLDEsMSkpCgl0cmFja19wYW5lOmF0dGFjaChjcmVhdGVf
dGlueV9udW1fZmllbGQoImxvb3AwIiwgdHJhY2tfYWRkciArIDMsMzEwLDEpKQoJdHJhY2tfcGFu
ZTphdHRhY2goY3JlYXRlX3RpbnlfbnVtX2ZpZWxkKCJsb29wMSIsdHJhY2tfYWRkciArIDQsMzYw
LDEpKQoJCgktLSA4IHNlZ21lbnRzIG9mIHNhbWUgdHJhY2sKCWZvciBpPTAsNyBkbwoJCXRyYWNr
X3BhbmU6YXR0YWNoKGNyZWF0ZV90cmFja19zZWdtZW50ewoJCQl4PTIgKyBpICogNDgsIHk9MTIs
IHJvd3M9OCwKCQkJcm93MCA9IGkqOCwKCQkJaW5kZXggPSBjdCAtLSBzZnhfaW5kZXgKCQl9KQoJ
ZW5kCgkKCQoJZ3VpOmF0dGFjaChjcmVhdGVfcGFuZSgiXGY2cGl0Y2ggIix4eCw5MCwzODQsODgs
MHgxMDAwKSkKCQk6YXR0YWNoKGNyZWF0ZV9waXRjaF9zY3JpYmJsZXJ7CgkJCXg9MCx5PTEwLHdp
ZHRoPTM4NCxoZWlnaHQ9NzYsYWRkcj10cmFja19hZGRyICsgOCxzdHJpZGU9NjR9KQoJCglndWk6
YXR0YWNoKGNyZWF0ZV9wYW5lKCJcZjZ2b2x1bWUgIix4eCwxODAsMzg2LDc2LDB4MTAwMCkpCgkJ
OmF0dGFjaChjcmVhdGVfdm9sdW1lX3NjcmliYmxlcnsKCQkJeD0wLHk9MTAsd2lkdGg9Mzg0LGhl
aWdodD02NixhZGRyPXRyYWNrX2FkZHIgKyA4ICsgMTI4LHN0cmlkZT02NH0pCgkKZW5kCgpsb2Nh
bCBmdW5jdGlvbiBjcmVhdGVfZmxvd190b2dnbGUoZWwpCgllbC53aWR0aCA9IDcKCWVsLmhlaWdo
dCA9IDcKCWVsLmN1cnNvciA9ICJwb2ludGVyIgoJbG9jYWwgYWRkciA9IDB4MzAxMDAgKyBjcCoy
MCs4CglmdW5jdGlvbiBlbDpkcmF3KCkKCQlwb2tlKDB4MzAxMDAgKyBjcCoyMCs4KQoJCWxvY2Fs
IHNlbGVjdGVkID0gKHBlZWsoYWRkcikgJiBlbC5iaXQpID4gMAoJCS0tcmVjdGZpbGwoMCwwLDYs
NixzZWxlY3RlZCBhbmQgMTAgb3IgMTMpCgkJcGFsKDcsIHNlbGVjdGVkIGFuZCAxMCBvciAxKQoJ
CXNwcihlbC5pY29uLDAsMCkKCQlwYWwoKQoJCgllbmQKCWZ1bmN0aW9uIGVsOnRhcCgpCgkJcG9r
ZShhZGRyLCBwZWVrKGFkZHIpIF5eIGVsLmJpdCkKCWVuZAoJcmV0dXJuIGVsCmVuZAoKCmxvY2Fs
IGZ1bmN0aW9uIGNyZWF0ZV9pbnN0X2ZsYWdfdG9nZ2xlKGVsKQoJbG9jYWwgaW5zdF9hZGRyID0g
MHg0MDAwMCArIGNpKjB4MjAwCglsb2NhbCBlbCA9IGVsIG9yIHt9CgllbC53aWR0aCA9IDQwCgll
bC5oZWlnaHQgPSAxNwoJZWwuY3Vyc29yID0gInBvaW50ZXIiCglsb2NhbCBhZGRyID0gaW5zdF9h
ZGRyICsgMHgxZGYgLS0gb25lIGJ5dGUgYmVmb3JlIHd0IGRlZmluaXRpb24KCWZ1bmN0aW9uIGVs
OmRyYXcoKQoJCWxvY2FsIHNlbGVjdGVkID0gKHBlZWsoYWRkcikgJiBlbC5iaXQpID4gMAoJCXJl
Y3RmaWxsKDEsMSw1LDUsMSkKCQlpZiAoc2VsZWN0ZWQpIHJlY3RmaWxsKDIsMiw0LDQsNykKCQlw
cmludChlbC5sYWJlbCwgMTAsIDEsIHNlbGVjdGVkIGFuZCA3IG9yIDEpCgllbmQKCWZ1bmN0aW9u
IGVsOnRhcCgpCgkJcG9rZShhZGRyLCBwZWVrKGFkZHIpIF5eIGVsLmJpdCkKCQlyZWZyZXNoX2d1
aSA9IHRydWUKCWVuZAoJcmV0dXJuIGVsCmVuZAoKCmZ1bmN0aW9uIGNyZWF0ZV9jaGFubmVsX3Nj
b3BlKGksIHgsIHkpCglsb2NhbCBlbD17CgkJeD14LHk9eSwKCQl3aWR0aD00MCwgaGVpZ2h0PTIw
Cgl9CglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLCBzZWxm
LmhlaWdodC0xLDApCgkJaWYgKHNvbWV0aGluZ19pc19wbGF5aW5nKSB0aGVuCgkJCWxvY2FsIG4g
PSBzdGF0KDQwMCtpLDE5LDB4OTAwMDApCgkJCWZvciB4eD0wLHNlbGYud2lkdGgtMSBkbwoJCQkJ
bG9jYWwgeXk9MTArcGVlazIoMHg5MDAwMCsgeHgqMTYpLzMyNzYKCQkJCXBzZXQoeHgsIHl5LCAx
NikKCQkJCXl5PTEwK3BlZWsyKDB4OTAwMDIrIHh4KjE2KS8zMjc2CgkJCQlwc2V0KHh4LCB5eSwg
cGdldCh4eCx5eSk9PTAgYW5kIDI0IG9yIDMwKQoJCQkJCgkJCQkKCQkJZW5kCgkJZW5kCgllbmQK
CQoJcmV0dXJuIGVsCmVuZAoKCmZ1bmN0aW9uIGdlbmVyYXRlX2d1aV9wYXR0ZXJuKCkKCglsb2Nh
bCBwYW5lID0gZ3VpOmF0dGFjaChjcmVhdGVfcGFuZSgiXGY2cGF0dGVybiAiLi5jcCw5Miw0LDM4
NCs0LDI1MiwweDEwMDEpKQoJCglwYW5lLmNsaWNrID0gZnVuY3Rpb24oKSAKCQlmb2N1cyA9ICJw
YXR0ZXJuIgoJZW5kCgkKCS0tIGZvY3VzIGZvciBjb3B5aW5nIC8gcGFzdGluZwoJZm9jdXMgPSAi
cGF0dGVybiIKCi0tW1sgZGVsZXRlbWUKCXBhbmU6YXR0YWNoKGNyZWF0ZV9vY3RhdmVfY2hvb3Nl
ciggNzUsMSkpCglwYW5lOmF0dGFjaChjcmVhdGVfdm9sdW1lX2Nob29zZXIoMTQ1LDEpKQpdXQoK
CS0tIHBsYXliYWNrIGZsb3cgZmxhZyB0b2dnbGVzOiBzdGFydCwgZW5kLCBzdG9wCgkKCXBhbmU6
YXR0YWNoKGNyZWF0ZV9mbG93X3RvZ2dsZXsKCQl4ID0gMzUwLCB5ID0gMSwgYml0ID0gMHgxLCBp
Y29uID0gZ2V0X3Nwcig1OCkKCX0pCglwYW5lOmF0dGFjaChjcmVhdGVfZmxvd190b2dnbGV7CgkJ
eCA9IDM2MCwgeSA9IDEsIGJpdCA9IDB4MiwgaWNvbiA9IGdldF9zcHIoNTkpCgl9KQoJcGFuZTph
dHRhY2goY3JlYXRlX2Zsb3dfdG9nZ2xlewoJCXggPSAzNzAsIHkgPSAxLCBiaXQgPSAweDQsIGlj
b24gPSBnZXRfc3ByKDYwKQoJfSkKCQoJCglsb2NhbCBjb250YWluZXIgPSBwYW5lOmF0dGFjaHsK
CQl4PTAseT0yNCsyMix3aWR0aD1wYW5lLndpZHRoLGhlaWdodD0yMjgtMzIsCgkJZHJhdz1mdW5j
dGlvbigpCWVuZCAtLSB0byBnZXQgY2xpcHBpbmcKCX0KCQoKCWxvY2FsIGNvbnRlbnRzID0gY29u
dGFpbmVyOmF0dGFjaHsKCQl4PTAsIHk9MCwgd2lkdGg9cGFuZS53aWR0aCwgaGVpZ2h0PTUyMSwK
CQlkcmF3ID0gZnVuY3Rpb24oKQoJCQktLSBtYXJrZXJzIHNob3dpbmcgcm93cwoJCQktLVtbCgkJ
CWZpbGxwKDB4ZjAwMCkKCQkJZm9yIGk9MCw3LDIgZG8KCQkJCXJlY3RmaWxsKDAsaSo2NCwgMTAw
MCxpKjY0KzY0LDE2K2kvMikJCgkJCWVuZAoJCQlmaWxscCgpCgkJCV1dCgkJZW5kCgkJCgl9CgkK
CXBhdHRlcm5fY29udGVudHMgPSBjb250ZW50cwoJCgktLSB3aG9sZSB0cmFjayBmb3IgZWFjaCBj
aGFubmVsCglsb2NhbCBjaGFuX21hc2sgPSBwZWVrKDB4MzAxMDAgKyBjcCAqIDIwICsgOSkKCXRy
YWNrX3NlZ19lbCA9IHt9CgkJCglmb3IgaT0wLDcgZG8KCQoJCWxvY2FsIHN4ID0gMiArIGkqNDcK
CQlsb2NhbCBzeSA9IDEzCgkJbG9jYWwgd3cgPSA3CgkJCgkJLS0gZHJhZyBhbmQgZHJvcCB0cmFj
ayBpbmRleCBpbnRvIGEgY2hhbm5lbCB0byBhc3NpZ24gaXQKCQktLSAoY2FsbGJhY2sgb24gYW55
IGNoYW5uZWwtc3BlY2lmaWMgZWxlbWVudHMpCgkJbG9jYWwgZHJvcF90cmFja19pbmRleCA9IGZ1
bmN0aW9uKHNlbGYsbXNnKQoJCQljaGVja3BvaW50KCkKCQkJY2hhbl9tYXNrIHw9ICgxIDw8IGkp
CgkJCXBva2UoMHgzMDEwMCArIGNwKjIwKzksIGNoYW5fbWFzaykKCQkJcG9rZSgweDMwMTAwICsg
Y3AqMjAraSwgbXNnLmluZGV4KQoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCQkKCQkKCQlp
ZiAoY2hhbl9tYXNrICYgKDEgPDwgaSkgPiAwKSB0aGVuCgkJCWxvY2FsIHRpbnkgPSBwYW5lOmF0
dGFjaCgKCQkJCWNyZWF0ZV90aW55X251bV9maWVsZCgiIiwweDMwMTAwICsgY3AgKiAyMCArIGks
IHN4KzE1LCBzeSkKCQkJKQoJCQkKCQkJdGlueS5kcm9wX3RyYWNrX2luZGV4ID0gZHJvcF90cmFj
a19pbmRleAoJCQkKCQllbHNlCgkJCXd3ID0gMjQKCQllbmQKCQkKCQlwYW5lOmF0dGFjaChjcmVh
dGVfY2hhbm5lbF9zY29wZShpLCBzeCsyLCBzeSsxMCkpCgkJCgkJLS0gdG9nZ2xlIGNoYW5uZWwg
Yml0CgkJcGFuZTphdHRhY2h7CgkJCXggPSBzeCs1LCB5ID0gc3ksCgkJCXdpZHRoPXd3LCBoZWln
aHQgPSA3LAoJCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCQlyZWN0KDAsMCw2LDYsNSkKCQkJCWlm
IChjaGFuX21hc2sgJiAoMSA8PCBpKSA_IDApIHRoZW4KCQkJCQlyZWN0KDAsMCw2LDYsMTYpCgkJ
CQkJcmVjdGZpbGwoMiwyLDQsNCw2KQoJCQkJZWxzZQoJCQkJCXJlY3RmaWxsKDksMCwyNCw3LCAw
KQoJCQkJZW5kCgkJCQkKCQkJZW5kLAoJCQl0YXA9ZnVuY3Rpb24oKQoJCQkJY2hhbl9tYXNrIF5e
PSAoMSA8PCBpKQoJCQkJcG9rZSgweDMwMTAwICsgY3AqMjArOSwgY2hhbl9tYXNrKQoJCQkJcmVm
cmVzaF9ndWkgPSB0cnVlCgkJCWVuZCwKCQkJZHJvcF90cmFja19pbmRleD1kcm9wX3RyYWNrX2lu
ZGV4CgkJCQoJCX0KCQkKCQktLSBlZGl0IHRyYWNrCgkJcGFuZTphdHRhY2h7CgkJCXggPSBzeCsz
MywgeSA9IHN5LAoJCQl3aWR0aD13dywgaGVpZ2h0ID0gNywgY3Vyc29yPSJwb2ludGVyIiwKCQkJ
ZHJhdz1mdW5jdGlvbihzZWxmKQoJCQkJc3ByKDIzLDAsMCkKCQkJZW5kLAoJCQl0YXA9ZnVuY3Rp
b24oKQoJCQkJbW9kZT0idHJhY2siCgkJCQljdD1wZWVrKDB4MzAxMDAgKyBjcCAqIDIwICsgaSkK
CQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQl9CgkKCQlpZiAoY2hhbl9tYXNrICYgKDEg
PDwgaSkgPiAwKSB0aGVuCgkJCXRyYWNrX3NlZ19lbFtpXSA9IGNvbnRlbnRzOmF0dGFjaChjcmVh
dGVfdHJhY2tfc2VnbWVudHsKCQkJCXg9IHN4LCB5PTAsIHJvd3M9NjQsCgkJCQlsaXZlX2luZGV4
ID0gdHJ1ZSwKCQkJCWNoYW5faSA9IGksCgkJCQlpbmRleCA9IHBlZWsoMHgzMDEwMCArIGNwICog
MjAgKyBpKSwgLS0gdHJhY2sgKHNmeCkgaW5kZXgKCQkJCWRyb3BfdHJhY2tfaW5kZXg9ZHJvcF90
cmFja19pbmRleAoJCQl9KQoJCWVsc2UKCQkJLS0gZHVtbXkKCQkJY29udGVudHM6YXR0YWNoewoJ
CQkJeD1zeCwgeT0wLAoJCQkJd2lkdGggPSA0NCwgaGVpZ2h0ID0gNjQgKiA4ICsgMiwgLS0gbWF0
Y2ggc2l6ZSBpbiBjcmVhdGVfdHJhY2tfc2VnbWVudAoJCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYs
IG1zZykKCQkJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsIDApCgkJ
CQkJaWYgKGdyYWJiZWRfdHJhY2sgYW5kCgkJCQkJCW1zZy5teD49MCBhbmQgbXNnLm14IDxzZWxm
LndpZHRoIGFuZCBtc2cubXkgPj0gMCApIHRoZW4KCQkJCQkJcmVjdCgwLDAsc2VsZi53aWR0aC0x
LHNlbGYuaGVpZ2h0LTEsIDEwKQoJCQkJCWVuZAoJCQkJCS0tcmVjdCgwLDAsc2VsZi53aWR0aC0x
LHNlbGYuaGVpZ2h0LTEsIDUpCgkJCQllbmQsCgkJCQlkcm9wX3RyYWNrX2luZGV4PWRyb3BfdHJh
Y2tfaW5kZXgKCQkJfQoJCWVuZAoJCQoJCS0tIGp1bXAgdG8gY2hhbm5lbCBwZW5jaWwKCWVuZAoJ
Cgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnMoKQoJCgktLSBpbmZvIGF0IGJvdHRvbQoJcGFu
ZTphdHRhY2h7CgkJeD0zLHk9MjQ0LHdpZHRoPTgwLGhlaWdodD0xMCwKCQlkcmF3PWZ1bmN0aW9u
KCkKCQkJaWYgKHNvbWV0aGluZ19pc19wbGF5aW5nIGFuZCBmb2xsb3dpbmdfcGxheWJhY2spIHRo
ZW4KCQkJCWxvY2FsIHJvdyA9IHN0YXQoNDAwICsgc3RhdCg0NjcpLDkpCgkJCQlwcmludCgicGxh
eWluZyByb3c6ICIuLmZscihyb3cpLDAsMCwxMykKCQkJZWxzZQoJCQkJbG9jYWwgcm93ID0gY3Vy
X3kgLSAoMHg1MDAwMCArIChjdCAqIDMyOCkgKyA4KQoJCQkJcHJpbnQoInJvdzogIi4uZmxyKHJv
dyksMCwwLDEzKQoJCQllbmQKCQkJCgkJZW5kCgkJCgl9CgkKCmVuZAoKCmZ1bmN0aW9uIGNyZWF0
ZV9wbGF5X2J1dHRvbigpCglsb2NhbCBlbCA9IGd1aTphdHRhY2h7CgkJeD0yLHk9MywKCQl3aWR0
aD0yNixoZWlnaHQ9MTgsCgkJY3Vyc29yPSJwb2ludGVyIgoJfQoJCglmdW5jdGlvbiBlbDpkcmF3
KG1zZykKCQlsb2NhbCB5eSA9IChtc2cuaGFzX3BvaW50ZXIgYW5kIG1zZy5tYiA_IDApIGFuZCAx
IG9yIDAKCQlycmVjdGZpbGwoMCx5eSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0LTEsMSwxMykJCQoJ
CXNwcihzb21ldGhpbmdfaXNfcGxheWluZyBhbmQgNjMgb3IgNjIsIDUsIHl5ICsgMSkKCWVuZAoJ
CgktLSBjb250cm9sIHBsYXliYWNrIGZvciB0cmFjayBhbmQgcGF0dGVybiB1c2luZwoJLS0gdGFw
IHNvIHRoYXQgZm9sbG93aW5nX3BsYXliYWNrIGlzIG5vdCBjYW5jZWxsZWQgYnkgY2xpY2sKCWZ1
bmN0aW9uIGVsOnRhcCgpCgkJaWYgKG1vZGUgPT0gImluc3RydW1lbnQiKSByZXR1cm4gLS0gaGFu
ZGxlZCBieSBjbGljayBiZWxvdwoJCWlmIHNvbWV0aGluZ19pc19wbGF5aW5nIHRoZW4KCQkJbm90
ZSgpCgkJZWxzZWlmIG1vZGUgPT0gInRyYWNrIiB0aGVuCgkJCXNmeChjdCwgOSkKCQllbHNlaWYg
bW9kZSA9PSAicGF0dGVybiIgdGhlbgoJCQltdXNpYyhjcCkgZm9sbG93aW5nX3BsYXliYWNrID0g
dHJ1ZQoJCWVuZAoJZW5kCgkKCS0tIGluIGluc3RydW1lbnQgbW9kZSwgY2FuIGhvbGQgZG93biBh
cyBpZiBob2xkaW5nCgktLSBkb3duIGEgbm90ZSBrZXkKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQlp
ZiAobW9kZSB_PSAiaW5zdHJ1bWVudCIpIHJldHVybgoJCWlmIChzb21ldGhpbmdfaXNfcGxheWlu
ZykgdGhlbgoJCQlub3RlKCkKCQllbHNlCgkJCW5vdGUoY29jdCoxMixjaSxjdm9sLDAsMCwgOCwg
dHJ1ZSkKCQllbmQKCWVuZAoJCgktLSByZWR1bmRhbnQ7IGlzIGhhbmRsZWQgaW4gdXBkYXRlIChz
ZWFyY2g6ICJyZWxlYXNlIG5vdGUiKQoJLS1bWwoJZnVuY3Rpb24gZWw6cmVsZWFzZSgpCgkJLS0g
c3RvcCBwbGF5aW5nIGluc3RydW1lbnQKCQlpZiBtb2RlID09ICJpbnN0cnVtZW50IiB0aGVuCgkJ
CW5vdGUoMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgOCkKCQllbmQKCWVuZAoJXV0KCQpl
bmQKCgpmdW5jdGlvbiBzZXRfbW9kZSh3aGljaCkKCWNoZWNrcG9pbnQoKQoJLS0gbGFzdF9tb2Rl
IHVzZWQgdG8gZGVjaWRlIGlmIHNwYWNlIHBsYXlzIHNmeCBvciBwYXR0ZXJuIChmcm9tIGluc3Qg
ZWRpdG9yKQoJaWYgKGxhc3RfbW9kZSB_PSBtb2RlKSBsYXN0X21vZGUgPSBtb2RlIAoJbW9kZSA9
IHdoaWNoCglyZWFkdGV4dCh0cnVlKSAtLSBjbGVhciBidWZmZXIKCXJlZnJlc2hfZ3VpID0gdHJ1
ZQplbmQKCmZ1bmN0aW9uIGdlbmVyYXRlX2d1aSgpCgoJY2kgPSBtaWQoMCxjaSw2MykKCWN0ID0g
bWlkKDAsY3QsMzgzKQoJY3AgPSBtaWQoMCxjcCwxMjcpCgkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoK
CS0tIG1vZGUgYnV0dG9uczsgbm93IHJlZHVuZGFudCAtLSB1c2UgY2hvb3NlciBoZWFkZXJzLCBv
ciBwcmVzcyB0YWIKLS1bWwkKCWxvY2FsIG1vZGVfbGFiZWw9e1swXT0iaW5zdCIsInNmeCIsInBh
dCJ9Cglsb2NhbCBtb2RlX25hbWUgPXtbMF09Imluc3RydW1lbnQiLCJ0cmFjayIsInBhdHRlcm4i
fQoJCglmb3IgaT0wLDIgZG8KCQlndWk6YXR0YWNoewoJCQl4PTIgKyBpKjI5LHk9MisyMSwKCQkJ
d2lkdGg9MjcsaGVpZ2h0PTExLAoJCQlsYWJlbD1tb2RlX2xhYmVsW2ldLAoJCQltb2RlPW1vZGVf
bmFtZVtpXSwKCQkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQkJbG9jYWwgc2VsID0gc2VsZi5tb2Rl
PT1tb2RlCgkJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsIHNlbCBh
bmQgMTQgb3IgMSkKCQkJCXByaW50KHNlbGYubGFiZWwsc2VsZi53aWR0aC8yIC0gI3NlbGYubGFi
ZWwqMiwgMyxzZWwgYW5kIDcgb3IgMTMpCgkJCWVuZCwKCQkJdGFwPWZ1bmN0aW9uKHNlbGYpCgkJ
CQljaGVja3BvaW50KCkKCQkJCW1vZGUgPSBzZWxmLm1vZGUKCQkJCXJlYWR0ZXh0KHRydWUpIC0t
IGNsZWFyIGJ1ZmZlcgoJCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJCWVuZAoJCX0KCWVuZApdXQoJ
LS0gcGxheSBidXR0b24KCQoJY3JlYXRlX3BsYXlfYnV0dG9uKCkKCQoJLS0gb2N0YXZlIGFuZCB2
b2x1bWUgY2hvb3NlcnMKCQoJZ3VpOmF0dGFjaChjcmVhdGVfb2N0YXZlX2Nob29zZXIoNDcsMykp
CglndWk6YXR0YWNoKGNyZWF0ZV92b2x1bWVfY2hvb3Nlcig0NywxMykpCgkKCWxvY2FsIHl5ID0g
MzctMTQKCWxvY2FsIHd3ID0gODYgCglsb2NhbCBwY29sID0gbW9kZSA9PSAiaW5zdHJ1bWVudCIg
YW5kIDB4MGUwMSBvciAweDA3MDEKCWxvY2FsIGVsID0gZ3VpOmF0dGFjaCgKCQljcmVhdGVfcGFu
ZSgiaW5zdHJ1bWVudHMiLDIseXksd3csNjMrMTQsIHBjb2wsCgkJZnVuY3Rpb24oKSBzZXRfbW9k
ZSgiaW5zdHJ1bWVudCIpIGVuZCkpCgoJLS1bWyAKCQktLXBlbmNpbCB0byBzaG93IGNhbiBjbGlj
ayB0byBlbnRlciBpbnN0cnVtZW50IG1vZGU-IG5vdCBjb25zaXN0ZW50CgkJLS0gY2FuIGNhbiBk
b3VibGUgY2xpY2sgYW55d2F5CgkJZWw6YXR0YWNoe3g9NzgseT0xLHdpZHRoPTcsaGVpZ2h0PTcs
CgkJCWN1cnNvcj0icG9pbnRlciIsCgkJCWRyYXc9ZnVuY3Rpb24oKXNwcigyMywwLDApZW5kCgkJ
fQoJXV0KCWNyZWF0ZV9pbnN0cnVtZW50X2Nob29zZXIoZWwpCgl5eSArPSBlbC5oZWlnaHQgKyA0
CgkKCXBjb2wgPSBtb2RlID09ICJ0cmFjayIgYW5kIDB4MGUwMSBvciAweDA3MDEKCWxvY2FsIGVs
ID0gZ3VpOmF0dGFjaChjcmVhdGVfcGFuZSgic2Z4IiwyLHl5LHd3LDc2LHBjb2wsCgkJZnVuY3Rp
b24oKSBzZXRfbW9kZSgidHJhY2siKSBlbmQpKQoJY3JlYXRlX3RyYWNrX2Nob29zZXIoZWwpCgl5
eSArPSBlbC5oZWlnaHQgKyA0CgkKCXBjb2wgPSBtb2RlID09ICJwYXR0ZXJuIiBhbmQgMHgwZTAx
IG9yIDB4MDcwMQoJbG9jYWwgZWwgPSBndWk6YXR0YWNoKGNyZWF0ZV9wYW5lKCJwYXR0ZXJucyIs
Mix5eSx3dyw3MixwY29sLAoJCWZ1bmN0aW9uKCkgc2V0X21vZGUoInBhdHRlcm4iKSBlbmQpKQoJ
Y3JlYXRlX3BhdHRlcm5fY2hvb3NlcihlbCkKCQoKCWlmIChtb2RlID09ICJpbnN0cnVtZW50Iikg
Z2VuZXJhdGVfZ3VpX2luc3RydW1lbnQoKQoJaWYgKG1vZGUgPT0gInRyYWNrIikgICAgICBnZW5l
cmF0ZV9ndWlfdHJhY2soKQoJaWYgKG1vZGUgPT0gInBhdHRlcm4iKSAgICBnZW5lcmF0ZV9ndWlf
cGF0dGVybigpCgkKZW5kCgoKZnVuY3Rpb24gYWRkX2luc3RydW1lbnRfYXR0cmlidXRlcyhwYXJl
bnQpCgoJLS0gaW5zdHJ1bWVudCBhdHRyaWJ1dGVzIChwdXQgaW5zaWRlIG5vZGVfY29udGVudCAt
LSBjYW4gc2Nyb2xsIG91dCkKCQoJaW5zdF9uYW1lX2VkaXRvciA9IHBhcmVudDphdHRhY2hfdGV4
dF9lZGl0b3J7CgkJeD0yNCwgeT0xLAoJCXdpZHRoID0gNzIsIGhlaWdodD03LAoJCWJnY29sID0g
MSwgZmdjb2wgPSA2LCBjdXJjb2wgPSA4LAoJCWJsb2NrX3Njcm9sbGluZyA9IHRydWUsIG1heF9s
aW5lcyA9IDEsCgkJbWFyZ2luX3RvcCA9IDEsCgkJa2V5X2NhbGxiYWNrID0gewoJCQllbnRlciA9
IGZ1bmN0aW9uICgpIAoJCQkJc2V0X2luc3RfbmFtZShjaSxpbnN0X25hbWVfZWRpdG9yOmdldF90
ZXh0KClbMV0pCgkJCQlpbnN0X25hbWVfZWRpdG9yOnNldF9rZXlib2FyZF9mb2N1cyhmYWxzZSkK
CQkJZW5kCgkJfSwKCQl1cGRhdGUgPSBmdW5jdGlvbihzZWxmKQoJCQktLSB1cGRhdGUgaW4gcmVh
bHRpbWUgLS0gZG9uJ3QgbmVlZCB0byBwcmVzcyBlbnRlciB0byBjaGFuZ2UKCQkJaWYgKGluc3Rf
bmFtZV9lZGl0b3I6aGFzX2tleWJvYXJkX2ZvY3VzKCkpIHRoZW4KCQkJCXNldF9pbnN0X25hbWUo
Y2ksaW5zdF9uYW1lX2VkaXRvcjpnZXRfdGV4dCgpWzFdKQoJCQllbmQKCQllbmQKCX0KCWluc3Rf
bmFtZV9lZGl0b3I6c2V0X3RleHR7Z2V0X2luc3RfbmFtZShjaSl9CgkKCXBhcmVudDphdHRhY2go
Y3JlYXRlX2luc3RfZmxhZ190b2dnbGV7CgkJeCA9IDExMCwgeSA9IDEsCgkJYml0ID0gMHgxLAoJ
CWxhYmVsID0gInJldHJpZyIgLS0gbWVhbnM6ICJhbHdheXMgcmV0cmlnZ2VyIHdoZW4gaW5zdCBp
cyBnaXZlbiBpbiByb3ciCgl9KQoJCglwYXJlbnQ6YXR0YWNoKGNyZWF0ZV9pbnN0X2ZsYWdfdG9n
Z2xlewoJCXggPSAxNTQsIHkgPSAxLAoJCWJpdCA9IDB4MiwKCQlsYWJlbCA9ICJ3aWRlIiAtLSBt
ZWFuczogImNhbiB2YXJ5IHBhbm5pbmcgb2YgZGVwdGg6MSBvc2Mgbm9kZXMiCgl9KQoJCmVuZAoK
CmZ1bmN0aW9uIGdlbmVyYXRlX2d1aV9pbnN0cnVtZW50KCkKCQoJLS0gYWRkIG5vZGVzIHRvIGEg
c2Nyb2xsYWJsZSBhcmVhCgkKCWxvY2FsIG5vZGVfY29udGFpbmVyID0gZ3VpOmF0dGFjaHsKCQoJ
CXggPSA5MiwgeSA9IDAsIHdpZHRoID0gMzAwLCBoZWlnaHQgPSAyNTIsCgoJCW1vdXNld2hlZWwg
PSBmdW5jdGlvbihzZWxmLCBtc2cpCgkJCXNlbGYuY2hpbGRbMV0ueSArPSBtc2cud2hlZWxfeSAq
IDE2CgkJCXNlbGYuY2hpbGRbMV0ueSA9IG1pZCgwLCBzZWxmLmNoaWxkWzFdLnksIHNlbGYuaGVp
Z2h0IC0gc2VsZi5jaGlsZFsxXS5oZWlnaHQpCgkJCWxhc3Rfbm9kZV9jb250ZW50X2luc3QgPSBj
aQoJCQlsYXN0X25vZGVfY29udGVudF95ID0gc2VsZi5jaGlsZFsxXS55CgkJZW5kLAoJCQoJCWRy
YWcgPSBmdW5jdGlvbihzZWxmLCBtc2cpCgkJCXNlbGYuY2hpbGRbMV0ueSArPSBtc2cuZHkKCQkJ
c2VsZi5jaGlsZFsxXS55ID0gbWlkKDAsIHNlbGYuY2hpbGRbMV0ueSwgc2VsZi5oZWlnaHQgLSBz
ZWxmLmNoaWxkWzFdLmhlaWdodCkKCQkJbGFzdF9ub2RlX2NvbnRlbnRfaW5zdCA9IGNpCgkJCWxh
c3Rfbm9kZV9jb250ZW50X3kgPSBzZWxmLmNoaWxkWzFdLnkKCQllbmQsCgkJCgkJdXBkYXRlID0g
ZnVuY3Rpb24oc2VsZikKCQkJLS1pZiAoc2VsZi5jaGlsZFsxXSkgc2VsZi5jaGlsZFsxXS55ICs9
IDEKCQllbmQKCX0KCQoJbG9jYWwgbm9kZV9jb250ZW50ID0gbm9kZV9jb250YWluZXI6YXR0YWNo
ewoJCXg9MCx5PTAsd2lkdGg9bm9kZV9jb250YWluZXIud2lkdGgsaGVpZ2h0PTMwMAoJfQoJCgls
b2NhbCB5eSA9IDQKCW5vZGVfZGVwdGg9e30KCW5vZGVfcGFyZW50X2luZGV4PXt9CgkKCQoJLS0g
Y2FsY3VsYXRlIG5vZGUgZGVwdGggZmlyc3QKCS0tIChuZWVkZWQgdG8gZGVjaWRlIHdoZW4gdG8g
Y3JlYXRlIHNpYmxpbmcgc2h1ZmZsZSBidXR0b25zKQoJZm9yIGk9MCw3IGRvCgkJbG9jYWwgaW5z
dF9hZGRyID0gMHg0MDAwMCArIGNpKjB4MjAwCgkJbG9jYWwgbm9kZV9hZGRyID0gaW5zdF9hZGRy
ICsgaSoweDIwCgkJbG9jYWwgbm9kZV90eXBlID0gcGVlayhub2RlX2FkZHIrMSkgJiAweGYKCQls
b2NhbCBub2RlX3BhcmVudCA9IHBlZWsobm9kZV9hZGRyKzApICYgMHg3CgkJCgkJbm9kZV9kZXB0
aFtpXSA9IG5vZGVfZGVwdGhbbm9kZV9wYXJlbnRdIGFuZCBub2RlX2RlcHRoW25vZGVfcGFyZW50
XSsxIG9yIDAKCQlub2RlX3BhcmVudF9pbmRleFtpXSA9IG5vZGVfcGFyZW50CgkJaWYgKG5vZGVf
dHlwZSA9PSAwKSBub2RlX2RlcHRoW2ldID0gLTEKCWVuZAoJCglmb3IgaT0wLDcgZG8KCQoJCWxv
Y2FsIGluc3RfYWRkciA9IDB4NDAwMDAgKyBjaSoweDIwMAoJCWxvY2FsIG5vZGVfYWRkciA9IGlu
c3RfYWRkciArIGkqMHgyMAoJCWxvY2FsIG5vZGVfdHlwZSA9IHBlZWsobm9kZV9hZGRyKzEpICYg
MHhmCgkJbG9jYWwgbm9kZV9wYXJlbnQgPSBwZWVrKG5vZGVfYWRkciswKSAmIDB4NwoJCQoJCWxv
Y2FsIHgwID0gbm9kZV9kZXB0aFtpXSAqIDgKCQoJCWlmIChub2RlX3R5cGUgPiAwKSB0aGVuCgkJ
CWxvY2FsIG4gPSBjcmVhdGVfbm9kZV9lZGl0b3Iobm9kZV9jb250ZW50LCBpLCB4MCwgeXksIG5v
ZGVfZGVwdGhbaV0pCi0tW1sgZGVsZXRlbWUKCQkJaWYgKGkgPT0gMCkgdGhlbgoJCQkJbjphdHRh
Y2goY3JlYXRlX29jdGF2ZV9jaG9vc2VyKDgwLDEpKQoJCQkJbjphdHRhY2goY3JlYXRlX3ZvbHVt
ZV9jaG9vc2VyKDE0NSwxKSkKCQkJZW5kCl1dCgkJCWlmIChpPT0wKSBhZGRfaW5zdHJ1bWVudF9h
dHRyaWJ1dGVzKG4pCQoJCQkKCQkJeXkgKz0gbi5oZWlnaHQgKyA0CgkJZW5kCgkJCgkJbm9kZV9j
b250ZW50LmhlaWdodCA9IG1heCh5eSArIDE2LCBub2RlX2NvbnRhaW5lci5oZWlnaHQpCgkJCgkJ
CgllbmQKCQoJCgktLSBlbnZlbG9wZSBjb250YWluZXIKCS0tIChkdXBlIGZyb20gbm9kZV9jb250
YWluZXIpCgoJbG9jYWwgZW52X2NvbnRhaW5lciA9IGd1aTphdHRhY2h7CgkKCQl4ID0gMzk2LCB5
ID0gMCwgd2lkdGggPSA4NCwgaGVpZ2h0ID0gMjUwLAoKCQltb3VzZXdoZWVsID0gZnVuY3Rpb24o
c2VsZiwgbXNnKQoJCQlzZWxmLmNoaWxkWzFdLnkgKz0gbXNnLndoZWVsX3kgKiAxNgoJCQlzZWxm
LmNoaWxkWzFdLnkgPSBtaWQoMCwgc2VsZi5jaGlsZFsxXS55LCBzZWxmLmhlaWdodCAtIHNlbGYu
Y2hpbGRbMV0uaGVpZ2h0KQoJCQlsYXN0X2Vudl9jb250ZW50X2luc3QgPSBjaQoJCQlsYXN0X2Vu
dl9jb250ZW50X3kgPSBzZWxmLmNoaWxkWzFdLnkKCQllbmQsCgkJCgkJZHJhZyA9IGZ1bmN0aW9u
KHNlbGYsIG1zZykKCQkJc2VsZi5jaGlsZFsxXS55ICs9IG1zZy5keQoJCQlzZWxmLmNoaWxkWzFd
LnkgPSBtaWQoMCwgc2VsZi5jaGlsZFsxXS55LCBzZWxmLmhlaWdodCAtIHNlbGYuY2hpbGRbMV0u
aGVpZ2h0KQoJCQlsYXN0X2Vudl9jb250ZW50X2luc3QgPSBjaQoJCQlsYXN0X2Vudl9jb250ZW50
X3kgPSBzZWxmLmNoaWxkWzFdLnkKCQllbmQsCgkJCgkJdXBkYXRlID0gZnVuY3Rpb24oc2VsZikK
CQkJLS1pZiAoc2VsZi5jaGlsZFsxXSkgc2VsZi5jaGlsZFsxXS55ICs9IDEKCQllbmQKCX0KCQoK
CS0tIGVudmVsb3BlcwoJCi0tCWxvY2FsIGVudl9jb250ZW50ID0gZ3VpOmF0dGFjaHsKLS0JCXg9
Mzk2LHk9MCx3aWR0aD0xMDAsaGVpZ2h0PTMwMAotLQl9Cglsb2NhbCBlbnZfY29udGVudCA9IGVu
dl9jb250YWluZXI6YXR0YWNoewoJCXg9MCx5PTAsd2lkdGg9ZW52X2NvbnRhaW5lci53aWR0aCxo
ZWlnaHQ9NDAwCgl9CgkKCWxvY2FsIHl5ID0gNAoJZm9yIGk9MCw0IGRvIC0tIDAuMS4waDogNSBl
bnZlbG9wZXMgZml0IG5pY2VseTsgdXN1YWxseSBlbm91Z2g-CgkJbG9jYWwgaW5zdF9hZGRyID0g
MHg0MDAwMCArIGNpKjB4MjAwCgkJbG9jYWwgZW52X2FkZHIgPSBpbnN0X2FkZHIgKyAyNTYgKyBp
ICogMjQKCQlsb2NhbCBlID0gZW52X2NvbnRlbnQ6YXR0YWNoKGNyZWF0ZV9lbnZfZWRpdG9yKGks
ZW52X2FkZHIsImVudi0iLi5pLDAseXksODApKQoJCXl5ICs9IGUuaGVpZ2h0ICsgNAoJZW5kCgkK
CWVudl9jb250ZW50LmhlaWdodCA9IG1heCh5eSArIDE2LCBlbnZfY29udGFpbmVyLmhlaWdodCkK
CQoJLS0gcHJlc2VydmUgbm9kZSBjb250ZW50IHNjcm9sbCBwb3NpdGlvbgoJLS0gdG8gZG86IGZp
bmQgYSBsZXNzIHNpbGx5IHdheSB0byBkbyB0aGlzCglpZiAobGFzdF9ub2RlX2NvbnRlbnRfaW5z
dCA9PSBjaSkgdGhlbgoJCW5vZGVfY29udGVudC55ID0gbGFzdF9ub2RlX2NvbnRlbnRfeQoJZW5k
CglpZiAobGFzdF9lbnZfY29udGVudF9pbnN0ID09IGNpKSB0aGVuCgkJZW52X2NvbnRlbnQueSA9
IGxhc3RfZW52X2NvbnRlbnRfeQoJZW5kCgkKZW5kCgoKOjogaW5zdC5sdWEKLS1bW3BvZF9mb3Jt
YXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yNyAxODoxNjozOCIsbW9kaWZpZWQ9IjIwMjUtMDct
MTYgMDU6MjA6NDIiLHJldmlzaW9uPTk4NTVdXQoKZnVuY3Rpb24gZ2V0X2luc3RfbmFtZShpKQoJ
bG9jYWwgaW5zdF9hZGRyID0gMHg0MDAwMCArIGkqMHgyMDAKCWxvY2FsIGxlbiA9IDE2Cglmb3Ig
aj0xNSwwLC0xIGRvCgkJaWYgKHBlZWsoaW5zdF9hZGRyKzQ5NitqKSA9PSAwKSBsZW4gPSBqCgll
bmQKCXJldHVybiBjaHIocGVlayhpbnN0X2FkZHIrNDk2LGxlbikpCmVuZAoKZnVuY3Rpb24gc2V0
X2luc3RfbmFtZShpLCBzdHIpCglsb2NhbCBpbnN0X2FkZHIgPSAweDQwMDAwICsgaSoweDIwMAoJ
bWVtc2V0KGluc3RfYWRkcis0OTYsMCwxNikKCXBva2UoaW5zdF9hZGRyKzQ5NixvcmQoc3RyLDEs
bWluKDE2LCNzdHIpKSkKZW5kCgoKCi0tIDB4MTcwMgpsb2NhbCBub2RlX3R5cGVfY29sID0gewoJ
WzBdPTB4MSwweDBlMDUsMHgwNzA1LDB4NSwKCTAsMCwwLDAsCgkweDBjMDUsMHgwYzA1LDB4MGMw
NSwweDBjMDUsCgktLTB4MTEwNSwweDBjMDUsMHgxOTA1LDB4MDgwNSwKfQoKLS0gbGFiZWxzOiBt
YXggNSBjaGFycyAoNCBwcmVmZXJyZWQpCgpmdW5jdGlvbiBjcmVhdGVfbXZhbF9rbm9iKGxhYmVs
LG5vZGVfdHlwZSxtdmFsX2luZGV4LGFkZHIseCx5KQoKCWxvY2FsIGVsID0gewoJCXggPSB4LCB5
ID0geSwgCgkJd2lkdGggPSA1NCwgLS0gaW5jbHVkZXMgdGhlIG51bWJlciBib3g7IGFuZCBlbnZl
bG9wZSBjb25uZWN0aW9uCgkJaGVpZ2h0ID0gMjAsCgkJbGFiZWw9bGFiZWwsCgkJYWRkcj1hZGRy
LAoJCW12YWxfaW5kZXg9bXZhbF9pbmRleCwKCQl2MCA9IC0xMjgsIHYxID0gMTI3LCAtLSBlZGl0
YWJsZSByYW5nZSBmb3Igc2lnbmVkIHZhbHVlcwoJCXZ6ID0gMCwgLS0gInplcm8iIC0tIHdoZXJl
IHRvIGZpbGwgcGllIGZyb20gLyB1bnRpbAoJCWFjID0gMSwgLS0gYW5nbGUgY29lZmZpY2llbnQg
KG5vdGNoIGFuZ2xlKQoJCWEwID0gMC4wLAoJCS0tIGN1cnNvciA9ICJncmFiIiwgLS0gdG8gZG86
IHNob3VsZG4ndCBzZXQgY3Vyc29yIHdoaWxlIGRyYWcgb3V0c2lkZSBvZiBlbGVtZW50CgkJbm9k
ZV9jb2wgPSBub2RlX3R5cGVfY29sW25vZGVfdHlwZV0sCgkJY2xpY2sgPSBjaGVja3BvaW50LAoJ
CWR2YWwgPSAwLAoJCWN1cnNvciA9ICJkaWFsIgoJCS0tY3Vyc29yPSJncmFiIiAtLSB0byBkbzog
ZGlhbCBzcGlubmluZyBjdXJzb3IgdGhhdCBkaXNhcHBlYXJzCgl9CgkKCWlmIChsYWJlbCA9PSAi
dm9sIikgZWwudjAsIGVsLnYxID0gMCwgNjQKCQoJLS0gbWF5YmUgbGF0ZXIKCS0taWYgKGxhYmVs
ID09ICJ0dW5lIikgZWwudjAsZWwudjEgPSAtMTIwLCAxMjAgZWwuYWMgPSAyMCBlbC5hMCA9IDAu
NQoJaWYgKGxhYmVsID09ICJ3YXZlIikgZWwudjAsZWwudjEgPSAwLCAyNTUKCQoJLS0gZnggcGFy
YW1ldGVycyBhcmUgYWxsIDAuLjI1NSAoZmxhZyAweDggaXMgbm90IHNldCkKCWlmIChub2RlX3R5
cGUgPj0gOCkgZWwudjAsZWwudjEgPSAwLCAyNTUKCQkKCS0tIGdhaW4gbWl4OyBjYW4gdXNlICo4
IGlmIHdhbnQgdG8gb3ZlciBtaXghCglpZiAobGFiZWwgPT0gIm1peCIpIGVsLnYwLCBlbC52MSA9
IDAsIDY0CgkKCWZ1bmN0aW9uIGVsOmRyb3BfZW52X3BsdWcobXNnKQoJCWNoZWNrcG9pbnQoKQoJ
CS0tcHJpbnRoKCJzZXR0aW5nICIuLnBvZChtc2cpKQoJCXBva2UoYWRkciszLCAocGVlayhhZGRy
KzMpICYgfjB4ZikgfCBtc2cuaW5kZXgpCgkJLS1zZXQgb2JzZXJ2ZV9lbnZlbG9wZSBiaXQKCQlw
b2tlKGFkZHIsIHBlZWsoYWRkcikgfCAweDQpCgllbmQKCQoJZnVuY3Rpb24gZWw6dXBkYXRlKG1z
ZykKCQlpZiAobm90IChtc2cubXggYW5kIG1zZy5teSkpIHJldHVybiAtLSB0byBkbzogc2hvdWxk
IHRoYXQgZXZlciBoYXBwZW4-CgkJc2VsZi5jdXJzb3IgPSAobXNnLm14IDwgMTgpIGFuZCAiZGlh
bCIgb3IgInBvaW50ZXIiCgkJCgkJaWYgKGxhYmVsID09ICJ0dW5lIikgdGhlbgoJCQktLSBzaWdu
ZWQgcmFuZ2UgY2FuIGNoYW5nZSBkZXBlbmRpbmcgb24gbXVsdGlwbHkgbW9kZQoJCQlpZiAocGVl
ayhzZWxmLmFkZHIpICYgMHgzKSA9PSAyIHRoZW4gLS0gZmxhZ3MKCQkJCWVsLnYwLCBlbC52MSA9
IDAsIDI1NQoJCQllbHNlCgkJCQllbC52MCwgZWwudjEgPSAtMTI4LCAxMjcKCQkJZW5kCgkJCQoJ
CWVuZAoJCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkKCQktLXJlY3RmaWxsKDAsMCwx
MDAwLDEwMDAsOCthZGRyLzQpCgkJCQoJCWxvY2FsIHh4LHl5ID0gOC41LDYuNQoJCQoJCWNpcmNm
aWxsKHh4LTEseXkrMSw3LChzZWxmLm5vZGVfY29sJjB4NSA9PSA1KSBhbmQgMSBvciAyMSkKCQlj
aXJjZmlsbCh4eCx5eSw3LDApCgkJCgkJLS0gZHJhdyBtdmFsCQoJCWxvY2FsIGZsYWdzLHZhbDEs
dmFsMCxlbnYgPSBwZWVrKGFkZHIsNCkKCQkKCQkKCQkKCQlpZiAoZWwudjEgPCAxMjgpIHRoZW4g
LS0gc2lnbmVkIGludDgncwoJCQlpZiAodmFsMSA_PSAxMjgpIHZhbDEgLT0gMjU2CgkJCWlmICh2
YWwwID49IDEyOCkgdmFsMCAtPSAyNTYKCQllbmQKCQkKCQlsb2NhbCByYW5nZSA9IHNlbGYudjEg
LSBzZWxmLnYwCgkJCgkJLS0gMC43IC0gMC45ICogLi4KCQktLWxvY2FsIHAwLHAxID0gMC43LDAu
OSAtLSB3ZWRnZSBhdCBib3R0b20KCQlsb2NhbCBwMCwgcDEgPSAwLjc1LCAxLjAgCgkJCgkJCgkJ
bG9jYWwgYTAgPSBzZWxmLmEwICsgcDAgLSBwMSAqICh2YWwxIC0gc2VsZi52MCkgKiBzZWxmLmFj
IC8gcmFuZ2UKCQkKCQlsb2NhbCBhMSA9IHAwIC0gcDEgKiAodmFsMCAtIHNlbGYudjApIC8gcmFu
Z2UKCQkKCQkKCQktLWxvY2FsIGExID0gc2VsZi5hMCArIHAwIC0gKHNlbGYudnogLSBzZWxmLnYw
KSAqIHNlbGYuYWMgKiBwMSAvIHJhbmdlCgkKCQktLSBzaG93IHJhbmdlICh0byBkbzogZGVjaWRl
IG9uIGZsYWdzIGZvciB0aGF0KQoJCWNvbG9yIChwZWVrKHNlbGYuYWRkcikgJiAweDQgPiAwIGFu
ZCAxMiBvciAxNCkKCQkKCQktLSBhcmMgZnJvbSBhbmdsZSB2YWwwIC0_IHZhbDEKCQlsb2NhbCBh
YTAsYWExID0gYTAsIGExCgkJaWYgKGFhMCA_IGFhMSkgYWEwLGFhMSA9IGFhMSxhYTAKCQlmb3Ig
YWEgPSAtLjI1LCAuNzUsIDEvMzIgZG8KCQkJaWYgKGFhID49IGFhMCBhbmQgYWEgPD0gYWExKSB0
aGVuCgkJCQlwc2V0KHh4K2NvcyhhYSkqNSwgeXkrc2luKGFhKSo1KQoJCQllbmQKCQllbmQJCQoJ
CQoJCWxpbmUoeHgrY29zKGEwKSoyLCB5eStzaW4oYTApKjIsIHh4K2NvcyhhMCkqNiwgeXkrc2lu
KGEwKSo2LCA3KQoKCQljbGlwKCkKCQlwcmludChzZWxmLmxhYmVsLCAtMjAsNCw2KQoJCQoJCXJl
Y3RmaWxsKHh4KzcsMix4eCszNiwxMCwwKQoJCQoJCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0KCQktLSAgIGVudmVsb3BlIGFzc2lnbm1lbnQgcGx1ZyB0byByaWdo
dCAgIC0tCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJCQoJ
CWlmIChwZWVrKHNlbGYuYWRkcikgJiAweDQgPiAwKSB0aGVuCgkJCXJlY3RmaWxsKHh4KzM3LDIs
eHgrNDQsMTAsNykKCQkJcmVjdGZpbGwoeHgrMzcsMyx4eCs0NSw5LDcpCgkJCQoJCQlpZiAocGVl
ayhzZWxmLmFkZHIpICYgMHg4ID4gMCkgdGhlbgoJCQkJcHJpbnQocGVlayhzZWxmLmFkZHIrMykm
MHhmLCB4eCs0MCwgMywgMTIpCgkJCQlwcmludCgiXF46MTUwMDAwMDAwMDAwMDAwMCIseHgrMzks
OSwxMikgLS0gMyBkb3RzCgkJCWVsc2UKCQkJCXByaW50KHBlZWsoc2VsZi5hZGRyKzMpJjB4Ziwg
eHgrNDAsIDQsIDEyKQoJCQllbmQKCQllbHNlCgkJCS0tIGNob29zZSByYW5kb21seSBmcm9tIHJh
bmdlCgkJCWlmIChwZWVrKHNlbGYuYWRkcikgJiAweDEwID4gMCkgdGhlbgoJCQkJcmVjdGZpbGwo
eHgrMzcsMix4eCs0NCwxMCwxNCkKCQkJCXJlY3RmaWxsKHh4KzM3LDMseHgrNDUsOSwxNCkKCQkJ
CXByaW50KCJyIiwgeHgrNDAsIDQsIDcpCgkJCWVuZAoJCWVuZAoJCQoJCS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQktLSAgICAgIHNjYWxlIHVuZGVybmVhdGgg
YXQgcmlnaHQgICAgICAgIC0tCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLQoJCQoJCWxvY2FsIHN2YWwgPSBwZWVrKHNlbGYuYWRkciszKQoJCQoJCWlmIChzdmFs
ICYgMHhjMCA_IDApIHRoZW4KCgkJCXN0cjIgPSAoc3ZhbCAmIDB4MjAgPT0gMCkgYW5kIAoJCQkJ
IlxeOjUwMjA1MDAwMDAwMDAwMDAiIG9yICAtLSAqCgkJCQkiXF46NDAyMDEwMDAwMDAwMDAwMCIg
ICAgIC0tIC8KCQkJCgkJCWlmIChzdmFsICYgMHhjMCA9PSAweDQwKSBzdHIyIC4uPSAiXF46NTA3
MDQwMDAwMDAwMDAwMCIgLS0gNAoJCQlpZiAoc3ZhbCAmIDB4YzAgPT0gMHg4MCkgc3RyMiAuLj0g
IlxeOjEzNzI3NzAwMDAwMDAwMDAiIC0tIDE2CgkJCWlmIChzdmFsICYgMHhjMCA9PSAweGMwKSBz
dHIyIC4uPSAiXF46NTE3NzQ3MDAwMDAwMDAwMCIgLS0gNjQKCQkJCgkJCS0tcmVjdGZpbGwoeHgr
MjQsMTEseHgrMzYsMTUsMTMpCgkJCXByaW50KHN0cjIsIHh4KzIwLDEyLDcpCgkJZW5kCgkJCgkJ
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJCS0tICAgICB2YWx1
ZSBhbmQgcGFyZW50IHJlbGF0aW9uc2hpcCAgICAgLS0KCQktLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkJCgkJaWYgKGZsYWdzICYgMHgzID4gMCkgdGhlbgoJCQls
b2NhbCBsZXR0ZXIgPSAiPyIKCQkJaWYgKGZsYWdzICYgMHgzID09IDB4MSkgbGV0dGVyID0gIisi
CgkJCWlmIChmbGFncyAmIDB4MyA9PSAweDIpIGxldHRlciA9ICIqIgoJCQlwcmludChsZXR0ZXIs
MzUtNCo0LDQsMykKCQllbmQKCQkKCQktLSBzaG93IHZhbHVlCgkJbG9jYWwgc3RyLCBzdHJfY29s
ID0gdG9zdHIodmFsMSksIDI3CgkJCgkJaWYgKG1zZy5tYiA9PSAyIGFuZCBtc2cuaGFzX3BvaW50
ZXIgYW5kCgkJCSBtc2cubXggPD0gNDQgYW5kIG1zZy5teSA8PSAxMikgdGhlbgoJCQlzdHIgPSB0
b3N0cih2YWwwKQoJCQlzdHJfY29sID0gMTQKCQllbmQKCQkKCQlpZiAoZmxhZ3MgJiAweDMgPT0g
MiBhbmQgbGFiZWw9PSJ0dW5lIikgdGhlbgoJCQktLSBtdWx0aXBseSBieSByYXRpbwoJCQktLSBv
bmx5IG1ha2VzIHNlbnNlIGZvciBwaXRjaAoJCQlsb2NhbCBydmFsID0gKG1zZy5tYiA9PSAyIGFu
ZCBtc2cuaGFzX3BvaW50ZXIpIGFuZCB2YWwwIG9yIHZhbDEKCQkJbG9jYWwgbnVtID0gMSArIHJ2
YWwgJSAxNgoJCQlsb2NhbCBkZW4gPSAxICsgcnZhbCBcIDE2CgkJCgkJCXN0ciA9IG51bS4uIi8i
Li5kZW4KCQllbmQKCQkKCQktLSBldmVyeXRoaW5nIGVsc2U6IHNob3cgcmF3IHZhbHVlCgkJcHJp
bnQoc3RyLCB4eCszNS0jc3RyKjQsIDQsIHN0cl9jb2wpCgkJCgkJY2lyYyh4eCx5eSw3LDEzKS0t
c2VsZi5ub2RlX2NvbCYweGZmKQoJCS0tY2lyYyh4eCx5eSw4LG5vZGVfY29sJjB4ZmYpCgkJCgkJ
CgllbmQKCQoJLS0gdHVybiBtb3VzZSBsb2NraW5nIG9uIHdoaWxlIGRyYWdnaW5nIChhbmQgc2V0
IHVuZG8gY2hlY2twb2ludCkKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCQltb3VzZWxvY2soMHg0
fDB4OCwgMC41LCAwLjA1KSAtLSAweDQgbG9jayAweDggYXV0by1yZWxlYXNlLCBldmVudCBzcGVl
ZCwgbW92ZSBzcGVlZCAKCQljaGVja3BvaW50KCkKCWVuZAoKCS0tIGRvZXNuJ3Qgd29yayB1bmxl
c3MgcmVxdWlyZSBtYiA_IDAgYmVjYXVzZSB1c2UgdG8gc2Nyb2xsIAoJLS0gaW5zdHJ1bWVudCBw
YW5lbCB1bnRpbCBoaXQgbXZhbCBmaWVsZCBieSBhY2NpZGVudCAuXy4KCWZ1bmN0aW9uIGVsOm1v
dXNld2hlZWwobXNnKQoJCWxvY2FsIG1hZyA9IGtleSJjdHJsIiBhbmQgOCBvciAxCgkJCgkJLS1z
ZWxmOmRyYWcoe21iPW1zZy5tYj4wIGFuZCBtc2cubWIgb3IgMSxkeD0wLGR5PS1tc2cud2hlZWxf
eSAqIG1hZ30pCgkJaWYgKG1zZy5tYiA_IDApIHRoZW4KCQkJc2VsZjpkcmFnKHttYj1tc2cubWIs
ZHg9MCxkeT0tbXNnLndoZWVsX3kgKiBtYWd9KQoJCQlyZXR1cm4gdHJ1ZSAtLSBkb24ndCBzY3Jv
bGwgaW5zdHJ1bWVudCBwYW5lbAoJCWVuZAoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJ
CWxvY2FsIGZsYWdzLHZhbDEsdmFsMCxlbnYgPSBwZWVrKGFkZHIsNCkKCQoJCWxvY2FsIGR2YWwg
PSAobXNnLmR4IC0gbXNnLmR5KQoJCQoJCS0tIHNpZ25lZCBpbnQ4IGJlaGF2aW91cgoJCWlmIChl
bC52MSA8IDEyOCkgdGhlbiAKCQkJaWYgKHZhbDA_PTEyOCkgdmFsMCAtPSAyNTYKCQkJaWYgKHZh
bDE_PTEyOCkgdmFsMSAtPSAyNTYKCQllbmQKCQkKCQlpZiAobXNnLm1iID4gMSkgdGhlbgoJCQkt
LSBkcmFnIHZhbDAgKHN0YXJ0IG9mIHJhbmdlKQoJCQl2YWwwID0gbWlkKHNlbGYudjAsIHZhbDAg
KyBkdmFsLCBzZWxmLnYxKQoJCWVsc2UKCQkJLS0gcmVndWxhciB3aGl0ZSBuZWVkbGUgZHJhZ2dp
bmcKCQkJdmFsMSA9IG1pZChzZWxmLnYwLCB2YWwxICsgZHZhbCwgc2VsZi52MSkKCQllbmQJCgkK
CQlwb2tlKGFkZHIrMSx2YWwxKQoJCXBva2UoYWRkcisyLHZhbDApCgkJcmV0dXJuIDEgLS0gZG9u
J3QgZHJhZyB0aGUgbm9kZSBjb250ZW50CgllbmQKCQoJZnVuY3Rpb24gZWw6dGFwKG1zZykKCQlj
aGVja3BvaW50KCkKCQlsb2NhbCBmbGFncyx2YWwxLHZhbDAsZW52ID0gcGVlayhhZGRyLDQpCgkJ
CgkJLS0gdXNlIHNhbWUgZ3VpIGVsIC8gY2FuIHN0aWxsIGdyYWIgYW5kIGRyYWcgdmFsdWUgd2l0
aG91dAoJCS0tIGhhdmluZyB0byBhdm9pZCB0aGUgb3BlcmF0b3IgYXJlYS4gdXN1YWxseSBvcGVy
YXRvciBzdGF5cwoJCS0tIHVudG91Y2hlZCwgc28gcHJlZmVyYWJsZSB0byBoYXZlIGEgbGl0dGxl
IGZyaWN0aW9uIHRvIGNoYW5nZSBpdC4KCQkKCQlpZiAobXNnLm15ID4gMTEgYW5kIG1zZy5teCA_
IDM0KSB0aGVuCgkJCS0tIGNoYW5nZSBzY2FsZSBiaXRzCgkJCWxvY2FsIGN0cmxfaGVsZCA9IGtl
eSgiY3RybCIpCgkJCWxvY2FsIHZhbCA9IHBlZWsoYWRkciszKSAmIDB4ZTAKCQkJaWYgKHZhbCA9
PSAwKSAgICAgICAgdGhlbiB2YWwgPSAweDAwIHwgMHg0MCAtLSAqNAoJCQllbHNlaWYgKHZhbCA9
PSAweDQwKSB0aGVuIHZhbCA9IDB4MjAgfCAweDQwIC0tIC80CgkJCWVsc2VpZiAodmFsID09IDB4
NjAgYW5kIGN0cmxfaGVsZCkgdGhlbiB2YWwgPSAweDAwIHwgMHg4MCAtLSAqMTYKCQkJZWxzZWlm
ICh2YWwgPT0gMHg4MCBhbmQgY3RybF9oZWxkKSB0aGVuIHZhbCA9IDB4MjAgfCAweDgwIC0tIC8x
NgoJCQllbHNlaWYgKHZhbCA9PSAweGEwIGFuZCBjdHJsX2hlbGQpIHRoZW4gdmFsID0gMHgwMCB8
IDB4YzAgLS0gKjY0CgkJCWVsc2VpZiAodmFsID09IDB4YzAgYW5kIGN0cmxfaGVsZCkgdGhlbiB2
YWwgPSAweDIwIHwgMHhjMCAtLSAvNjQKCQkJZWxzZSB2YWwgPSAwIGVuZAoJCQlwb2tlKGFkZHIr
MywocGVlayhhZGRyKzMpICYgfjB4ZTApIHwgdmFsKQoJCWVsc2VpZiAobXNnLm14ID49IDE4IGFu
ZCBtc2cubXggPD0gMjQpIHRoZW4KCQkKCQkJLS0gY2hhbmdlIHBhcmVudCBvcGVyYXRvcgoJCQkK
CQkJaWYgbm9kZV90eXBlID49IDggYW5kIHNlbGYubGFiZWwgfj0gInJlcyIgYW5kIHNlbGYubGFi
ZWwgfj0gIm1peCIgdGhlbgoJCQkJLS0gZmlsdGVyOnJlcyBhbmQgc2hhcGU6bWl4IGNhbiBtdWx0
aXBseSB3aXRoIHBhcmVudC4KCQkJCS0tIGFueSBvdGhlciBmeCBmaWx0ZXIgbXZhbHMgc2hvdWxk
bid0IGhhdmUgYW55IHBhcmVudCBvcGVyYXRvcnMKCQkJCXBva2UoYWRkciwgZmxhZ3MgJiB_MHgz
KQoJCQllbHNlaWYgKGZsYWdzICYgMHgzID4gMCkgdGhlbgoJCQkJaWYgKHNlbGYubGFiZWwgPT0g
InR1bmUiKSB0aGVuCgkJCQkJcG9rZShhZGRyLCAoZmxhZ3MgJiB_MHgzKSB8ICgoZmxhZ3MgJiAy
ID4gMCkgYW5kIDAgb3IgMikpCgkJCQllbHNlCgkJCQkJcG9rZShhZGRyLCBmbGFncyAmIH4weDMp
IC0tIGNsZWFyIGFkZCAvIG11bHQgYml0CgkJCQllbmQKCQkJZWxzZQoJCQkJaWYgKHNlbGYubGFi
ZWwgPT0gInZvbCIgb3Igc2VsZi5sYWJlbCA9PSAibWl4IiBvciBzZWxmLmxhYmVsID09ICJyZXMi
KQoJCQkJdGhlbgoJCQkJCS0tIHNldCBiaXQ6IG11bHQgcGFyZW50CgkJCQkJcG9rZShhZGRyLCBm
bGFncyB8IDB4MikKCQkJCWVsc2UKCQkJCQktLSBzZXQgYml0OiBhZGQgcGFyZW50CgkJCQkJcG9r
ZShhZGRyLCBmbGFncyB8IDB4MSkKCQkJCWVuZAoJCQllbmQKCQllbHNlaWYgKG1zZy5teCA_PSA0
NSkgdGhlbgoJCQktLSB0b2dnbGUgZW52ZWxvcGUgYXNzaWdubWVudCBiaXQKCQkJLS0gbWIyIHRv
IHRvZ2dsZSBjb250aW51YXRpb24KCQkJaWYgKHBlZWsoYWRkcikgJiAweDQgPiAwIG9yIG1zZy5s
YXN0X21iID09IDEpIHRoZW4KCQkJCXBva2UoYWRkciwgcGVlayhhZGRyKSBeXiAobXNnLmxhc3Rf
bWIgPT0gMSBhbmQgMHg0IG9yIDB4OCkpCgkJCWVsc2UKCQkJCS0tIHRvZ2dsZSBybmQKCQkJCXBv
a2UoYWRkciwgcGVlayhhZGRyKSBeXiAweDEwKQoJCQllbmQKCQllbHNlCgkJCS0tIHNldCB2YWww
IHRvIHZhbD8KCQkJLS0gbmFoIC0tIGp1c3QgYWx3YXlzIGRyYWcgbWIyCgkJCS0tIHBva2UoYWRk
cisyLHZhbDEpCgkJZW5kCgllbmQKCQoJCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBnZXRfbXZh
bF9zY2FsZShhZGRyKQoJbG9jYWwgdmFsID0gQGFkZHIKCWxvY2FsIGJpdHMgPSAwCglpZiAodmFs
ICYgMHhjMCA9PSAwKSByZXR1cm4gMQoJaWYgKHZhbCAmIDB4NDAgPiAgMCkgYml0cyArPSAyCglp
ZiAodmFsICYgMHg4MCA_ICAwKSBiaXRzICs9IDIKCXJldHVybiAodmFsICYgMHgyMCkgPiAwIGFu
ZCAxLygxPDxiaXRzKSBvciAoMTw8Yml0cykKZW5kCgoKLS0gYWRkcmVzcyBpcyBvZiB0aGUgd2F2
ZXRhYmxlcwpmdW5jdGlvbiBjcmVhdGVfc2NvcGUoYWRkciwgbm9kZV9pbmRleCwgeCwgeSwgdywg
aCkKCWxvY2FsIGVsID0gZ3VpOmF0dGFjaHsKCQl4PXgseT15LAoJCXdpZHRoPXcsIGhlaWdodD1o
LAoJCWFkZHI9YWRkciwKCQlibXA9dXNlcmRhdGEoInU4Iix3LGgpLAoJCWRpdGhlcl90ID0gNywK
CQlyZWZyZXNoID0gdHJ1ZQoJfQoJZnVuY3Rpb24gZWw6Y2xpY2sobXNnKQoJCWNoZWNrcG9pbnQo
KQoJCWxvY2FsIGluc3RfYWRkciA9IDB4NDAwMDAgKyBjaSoweDIwMAoJCWxvY2FsIG5vZGVfYWRk
ciA9IGluc3RfYWRkciArIG5vZGVfaW5kZXgqMHgyMAoJCWxvY2FsIHd0X2luZGV4ID0gcGVlayhu
b2RlX2FkZHIrMSk_PjQKCQkKCQlpZiAobXNnLm14IDwgMTggYW5kIG1zZy5teSA8IDEwKSB0aGVu
CgkJCXd0X2luZGV4ID0gKHd0X2luZGV4ICsgMSkgJSA0CgkJCXBva2Uobm9kZV9hZGRyKzEsIChw
ZWVrKG5vZGVfYWRkcisxKSAmIH4weGYwKSB8ICh3dF9pbmRleCA8PCA0KSkKCQllbmQKCWVuZAoJ
CglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQoJCXNlbGYuZGl0aGVyX3QgPSAoc2VsZi5kaXRoZXJf
dCArIDEpICUgOAoKCQlzZXRfZHJhd190YXJnZXQoc2VsZi5ibXApCgkJY2FtZXJhKCkgLS0gdG8g
ZG86IHNob3VsZCBjYW1lcmEgZ2V0IHJlc2V0IHRoZSBzYW1lIHdheSBhcyBjbGlwcGluZz8KCQkK
CQktLSBncmFiIGluc3RydW1lbnQgYXR0cmlidXRlcwoJCWxvY2FsIGluc3RfYWRkciA9IDB4NDAw
MDAgKyBjaSoweDIwMAoJCWxvY2FsIG5vZGVfYWRkciA9IGluc3RfYWRkciArIG5vZGVfaW5kZXgq
MHgyMAoJCWxvY2FsIG5vZGVfdHlwZSA9IHBlZWsobm9kZV9hZGRyKzEpICYgMHhmCgkJbG9jYWwg
d2F2ZV9hZGRyID0gbm9kZV9hZGRyICsgNCArIDQqNAoJCWxvY2FsIHdhdmVfdmFsICA9IHBlZWso
d2F2ZV9hZGRyKzEpCgkJCgkJLS0gd2F2ZXRhYmxlCgkJbG9jYWwgd3RfaW5kZXggPSAocGVlayhu
b2RlX2FkZHIrMSk_PjQpCgkJbG9jYWwgd3RfYWRkciA9IGVsLmFkZHIgKyB3dF9pbmRleCAqIDQK
CQlsb2NhbCBhZGRyMCwgYWRkcjEsIHdpZHRoX2JpdHMsIHd0X2hlaWdodCA9IHBlZWsod3RfYWRk
ciw0KQoJCWxvY2FsIGRhdF9hZGRyID0gKGFkZHIwIDw8IDgpIHwgKGFkZHIxIDw8IDE2KQoJCWxv
Y2FsIHd0X3dpZHRoID0gMSA8PCB3aWR0aF9iaXRzCgkJCgkJZGF0X2FkZHIgKz0gKHdhdmVfdmFs
ICogd3RfaGVpZ2h0ID4_IDgpICogd3Rfd2lkdGgqMgoJCQoJCWxvY2FsIHBoYXNlX2FkZHIgPSBu
b2RlX2FkZHIgKyA0ICsgNSo0CgkJbG9jYWwgcGhhc2VfdmFsICA9IChwZWVrKHBoYXNlX2FkZHIr
MSkgKyAxMjgpICUgMjU2IC0gMTI4CgkKCQlsb2NhbCBzdHJldGNoX2FkZHIgPSBub2RlX2FkZHIg
KyA0ICsgNSo0CgkJbG9jYWwgc3RyZXRjaF92YWwgID0gMC0tcGVlayhzdHJldGNoX2FkZHIrMSkK
CQkKCQlpZiAoc3RyZXRjaF92YWwgPj0gMTI4KSBzdHJldGNoX3ZhbCAtPSAyNTYKCQlzdHJldGNo
X3ZhbCA9IChzdHJldGNoX3ZhbCArIDEyOCkgLyAxMjggLS0gMC4uMgoJCQoJCgkJbG9jYWwgdm9s
X2FkZHIgPSBub2RlX2FkZHIgKyA0ICsgMCo0CgkJbG9jYWwgdm9sX3ZhbCAgPSBwZWVrKHZvbF9h
ZGRyKzEpCgkJCgkJLS0gZGVjaWRlIHdoZW4gdG8gcmVkcmF3IHNjb3BlOwoJCS0tIGF0IGxlYXN0
IDhwZnMsIG9yIGV2ZXJ5IGZyYW1lIHdoZW4gbW91c2UgaXMgZG93bgoJCWxvY2FsIHJlZnJlc2hf
c2NvcGUgPSAgbXNnLm1iID4gMCBvciBzZWxmLmRpdGhlcl90PT1ub2RlX2luZGV4CgkJaWYgKHNl
bGYucmVmcmVzaCkgcmVmcmVzaF9zY29wZSA9IHRydWUgc2VsZi5yZWZyZXNoID0gZmFsc2UKCQlp
ZiAoc2VsZi5zeT4yNzAgb3Igc2VsZi5zeSA8IC1oKSByZWZyZXNoX3Njb3BlID0gZmFsc2UgLS0g
bm90IHZpc2libGUKCQktLQoJCQoJCWlmIChyZWZyZXNoX3Njb3BlKSBzZWxmLmJtcDpjbGVhcigp
CgkJCgkJaWYgKG5vdCByZWZyZXNoX3Njb3BlKSB0aGVuCgkJCS0tIG5vdGhpbmcgaGFwcGVuaW5n
IChtb3VzZSBidXR0b24gdXApOiB1cGRhdGUgNGZwcwoJCQkKCQllbHNlaWYgKG5vZGVfdHlwZSA9
PSAyIGFuZCBub3Qgc29tZXRoaW5nX2lzX3BsYXlpbmcpIHRoZW4KCQkJLS0gb3NjIHdoZW4gbm90
aGluZyBpcyBwbGF5aW5nOiB2aXN1YWxpc2Ugd2F2ZWZvcm0KCQkJbGluZSgpCgkJCXNlbGYuYm1w
OmNsZWFyKCkKCQkJLS1mb3IgaSA9IHNlbGYuZGl0aGVyX3QsIHNlbGYud2lkdGgtMSwgNCBkbwoJ
CQlmb3IgaSA9IDAsIHNlbGYud2lkdGgtMSwuNSBkbwoJCQkKCQkJCWxvY2FsIHNhbXggPSBpIC8g
c2VsZi53aWR0aAoJCQkJc2FteCArPSBwaGFzZV92YWwvMjU2CgkJCQlzYW14ID0gKHNhbXggKiBz
dHJldGNoX3ZhbCkgJSAxCgkJCQkKCQkJCWxvY2FsIGkyID0gZmxyKHNhbXggKiB3dF93aWR0aCkK
CQkJCWxvY2FsIHZhbCA9IHBlZWsyKGRhdF9hZGRyICsgaTIqMikKCQkJCXZhbCAqPSAodm9sX3Zh
bC8weDQwKQoJCQkJCgkJCQlsb2NhbCB4eCA9IGkKCQkJCWxvY2FsIHl5ID0gc2VsZi5oZWlnaHQv
MiAtIHZhbCAqIHNlbGYuaGVpZ2h0LzcyMDAwCgkJCQktLWxpbmUoeHgseXksMTEpCgkJCQlwc2V0
KHh4LHl5LCBwZ2V0KHh4LHl5KSA9PSAzIGFuZCAxMSBvciAzKQoJCQkJLS1wb2tlKDB4NTQwYSww
LDApCgkJCQktLWxpbmUoeHgsMCx4eCxoLDApCgkJCQktLXBzZXQoeHgseXksMTEpCgkJCWVuZAoJ
CQkKCQkJcHJpbnQoInd0LSIuLnd0X2luZGV4LDIsMiwzKQoJCWVsc2VpZiAobm9kZV90eXBlID09
IDgpIHRoZW4KCQkJbG9jYWwgbG93ICAgID0gcGVlayhub2RlX2FkZHIgKyA0ICsgMCo0ICsgMSkg
LyAyNTUuMAoJCQlsb2NhbCBoaWdoICAgPSBwZWVrKG5vZGVfYWRkciArIDQgKyAxKjQgKyAxKSAv
IDI1NS4wCgkJCWxvY2FsIHJlcyAgICA9IHBlZWsobm9kZV9hZGRyICsgNCArIDIqNCArIDEpIC8g
MjU1LjAKCQkJCgkJCS0tIHRvIGRvOiBjYWxjdWxhdGUgY3V0b2ZmIGluIEh6IG9yIHNvbWV0aGlu
Zz8KCQoJCWVsc2VpZiAobm9kZV90eXBlID09IDkpIHRoZW4KCQkJbG9jYWwgZGVsYXkgICA9IHBl
ZWsobm9kZV9hZGRyICsgNCArIDAqNCArIDEpCgkJCWxvY2FsIHZvbCAgICAgPSBwZWVrKG5vZGVf
YWRkciArIDQgKyAxKjQgKyAxKSAvIDI1NS4wCgkJCWxvY2FsIHd3ID0gc2VsZi53aWR0aCBcIDcK
CQkJbG9jYWwgaGggPSBzZWxmLmhlaWdodCAtIDQKCQkJZm9yIGk9MCw2IGRvCgkJCQkgbG9jYWwg
eHg9Mit3dyppCgkJCQkgcmVjdGZpbGwoeHgrMSxzZWxmLmhlaWdodC0yLHh4K3d3LTIsc2VsZi5o
ZWlnaHQtMi1oaCwxMikKCQkJCSBoaCAqPSB2b2wKCQkJZW5kCgkJZWxzZWlmIChub2RlX3R5cGUg
PT0gMTApIHRoZW4KCQkKCQkJbG9jYWwgZ2FpbiAgPSBwZWVrKG5vZGVfYWRkciArIDQgKyAwKjQg
KyAxKSAqIDcuMCAvIDI1NS4wCgkJCWdhaW4gPSAxLjAgKyBnYWluICogZ2V0X212YWxfc2NhbGUo
bm9kZV9hZGRyICsgNCArIDMpCgkJCQoJCQlsb2NhbCBlbGJvdyA9IHBlZWsobm9kZV9hZGRyICsg
NCArIDEqNCArIDEpIC8gMjU1LjAKCQkJZWxib3cgKj0gZ2V0X212YWxfc2NhbGUobm9kZV9hZGRy
ICsgNCArIDEqNCArIDMpCgkJCQoJCQlsb2NhbCBjdXQgICA9IDEuMCAtIHBlZWsobm9kZV9hZGRy
ICsgNCArIDIqNCArIDEpIC8gMjU1LjAKCQkJbG9jYWwgbWl4ICAgPSBwZWVrKG5vZGVfYWRkciAr
IDQgKyAzKjQgKyAxKQoJCQlsb2NhbCB3dyA9IHNlbGYud2lkdGgKCQkJbG9jYWwgaGggPSBzZWxm
LmhlaWdodAoJCQkKCQkJCgkJCWZpbGxwKDB4NTU1NSkKCQkJbGluZSgwLCBoaCAtIGN1dCAqIGho
LCB3dywgaGggLSBjdXQgKiBoaCwgMTMpCgkJCWZpbGxwKCkKCQkJCgkJCWxvY2FsIGVsYm93X3kg
PSBjdXQKCQkJbG9jYWwgZWxib3dfeCA9IGVsYm93X3kgLyBnYWluCgkJCWxvY2FsIHNsb3BlID0g
MAoJCQkKCQkJaWYgKGVsYm93X3ggPT0gMS4wKSB0aGVuCgkJCQlzbG9wZSA9IDAKCQkJZWxzZWlm
IChlbGJvdyA8IDAuNSkgdGhlbgoJCQkKCQkJCWxvY2FsIHR0ID0gZWxib3cgKiAyCgkJCQlsb2Nh
bCBzbG9wZTAgPSAoZ2Fpbi1lbGJvd195KSAvICgxLWVsYm93X3gpCgkJCQlsb2NhbCBzbG9wZTEg
PSAoMS1lbGJvd195KSAvICgxLWVsYm93X3gpCgkJCQlzbG9wZSA9ICgxLXR0KSAqIHNsb3BlMCAr
ICh0dCAqIHNsb3BlMSkKCQkJZWxzZQoJCQkJbG9jYWwgdHQgPSAoZWxib3ctLjUpKjIKCQkJCWxv
Y2FsIHNsb3BlMCA9ICgxLWVsYm93X3kpIC8gKDEtZWxib3dfeCkKCQkJCXNsb3BlID0gKDEtdHQp
ICogc2xvcGUwCgkJCWVuZAoJCQkKCQkJZm9yIGkgPSAwLHNlbGYud2lkdGgtMSwgLjUgZG8KCQkJ
CWxvY2FsIHR0ID0gaSAvIHNlbGYud2lkdGgKCQkJCWxvY2FsIHZhbD0wCgkJCQkKCQkJCWlmIHR0
IDwgZWxib3dfeCB0aGVuCgkJCQkJdmFsID0gdHQqZ2FpbgoJCQkJZWxzZQoJCQkJCWlmIGVsYm93
IDwgMSB0aGVuCgkJCQkJCXZhbCA9IGVsYm93X3kgKyAodHQtZWxib3dfeCkqc2xvcGUKCQkJCQll
bHNlCgkJCQkJCS0tIGZvbGRiYWNrIFxtLwoJCQkJCQlsb2NhbCBlMiA9IGVsYm93LTEKCQkJCQkJ
bG9jYWwgaDIgPSBlbGJvd195IC8gMgoJCQkJCQktLXZhbCA9IGgyICsgY29zKCh0dC1lbGJvd194
KSplMikgKiBoMgoJCQkJCQktLSAwLjEuMGg6IGxpbmVhciByZWZsZWN0aW9uCgkJCQkJCXZhbCA9
ICgodHQtZWxib3dfeCkqZTIpJTEKCQkJCQkJdmFsID0gKCh2YWwgPCAwLjUpIGFuZCAxLXZhbCo0
IG9yIC0xICsgKHZhbC0wLjUpKjQpCgkJCQkJCXZhbCA9IGgyICsgdmFsICogaDIKCQkJCQllbmQK
CQkJCWVuZAoJCQkJCgkJCQlsb2NhbCB4eCA9IGkKCQkJCWxvY2FsIHl5ID0gc2VsZi5oZWlnaHQg
LSB2YWwgKiBzZWxmLmhlaWdodAoJCQkKCQkJCXBzZXQoeHgseXksIHBnZXQoeHgseXkpID09IDMg
YW5kIDExIG9yIDMpCgkJCWVuZAoJCWVsc2UKCQkJCgkJCS0tLS0tLS0tLSBsaXZlIG91dHB1dCAt
LS0tLS0tLS0tCgkJCQoJCQljaV9jaGFubmVsID0gOCAtLSB0byBkbzogc2VhcmNoIGZvciBpbnN0
cnVtZW50IG9uIGNoYW5uZWwgOSAvIGluIG11c2ljIGNoYW5uZWxzCgkJCQoJCQlpZiAoY2lfY2hh
bm5lbCA8IDApIHJldHVybiAtLSBkb24ndCBrbm93IHdoaWNoIGNoYW5uZWwgW3lldD9dIC0tIHNr
aXAKCQkJCgkJCS0tIHRpY2tfbGVuIGlzIG5ldmVyIGxhcmdlciB0aGFuIDRrCgkJCWxvY2FsIHRp
Y2tfYWRkciA9IDB4MjAwMDAwICsgbm9kZV9pbmRleCAqIDgxOTIKCQkJCgkJCWxvY2FsIHRpY2tf
bGVuID0gc3RhdCg0MDAgKyBjaV9jaGFubmVsLCA4KQoJCgkJCS0tIGdyYWIgYXQgMTVmcHMgKHBl
cmYgKyBzbyBpcyByZWFkYmxlKQoJCQktLWlmICgoZ2xvYmFsX3QgKyBub2RlX2luZGV4KSAmIDMg
PT0gMCBhbmQgKG5vdCBtc2cuaGFzX3BvaW50ZXIgb3IgbXNnLm1iPT0wKSkgCgkJCWlmICh0cnVl
KQoJCQl0aGVuCgkJCQl0aWNrX2xlbiA9IHN0YXQoNDAwICsgY2lfY2hhbm5lbCwgMjAgKyBub2Rl
X2luZGV4LCB0aWNrX2FkZHIpCgkJCWVuZAoJCQkKCQkJZm9yIGkgPSAwLHNlbGYud2lkdGgtMSBk
bwoJCQkJbG9jYWwgaTIgPSBpXC41IC0tIDIgc2FtcGxlcyBwZXIgcGl4ZWwKCQkJCWxvY2FsIHZh
bCA9IHBlZWsyKHRpY2tfYWRkciArIGkyKjIpCgkJCQlsb2NhbCB5eSA9IHNlbGYuaGVpZ2h0LzIg
LSB2YWwgKiBzZWxmLmhlaWdodC83MjAwMAoJCQkJLS1wc2V0KGkseXksIHBnZXQoaSx5eSkgPT0g
MyBhbmQgMTEgb3IgMykKCQkJCXBzZXQoaSx5eSwxMSkKCQkJZW5kCgkJZW5kCgkJCgkJc2V0X2Ry
YXdfdGFyZ2V0KCkKCQlibGl0KHNlbGYuYm1wLG5pbCwwLDAsc2VsZi5zeCxzZWxmLnN5KQoJCQoJ
ZW5kCglyZXR1cm4gZWwKZW5kCQoKCmZ1bmN0aW9uIGNyZWF0ZV9tdXRlZF9ub2RlX3RvZ2dsZShh
ZGRyLHgseSkKCWxvY2FsIGVsID0geyAKCQlhZGRyID0gYWRkciwKCQl4ID0geCwgeSA9IHksIHdp
ZHRoID0gNywgaGVpZ2h0ID0gNwoJfQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJbG9jYWwgeXkg
PSAobXNnLmhhc19wb2ludGVyIGFuZCBtc2cubWIgPiAwKSBhbmQgMSBvciAwCgkJbG9jYWwgdmFs
ID0gKEBzZWxmLmFkZHIpICYgMHgyCgkJY2xpcCgpCgkJcGFsKDcsMSkKCQlzcHIoKHZhbCAmIDB4
MiA_IDApIGFuZCA1NyBvciA1NiwwLDAreXkpCgkJcGFsKCkKCWVuZAoJZnVuY3Rpb24gZWw6dGFw
KCkKCQljaGVja3BvaW50KCkKCQlsb2NhbCB2YWwgPSBwZWVrKHNlbGYuYWRkcikKCQl2YWwgXl49
IDB4MgoJCXBva2Uoc2VsZi5hZGRyLCB2YWwpCgkJLS1yZWZyZXNoX2d1aSA9IHRydWUKCWVuZAoJ
CglyZXR1cm4gZWwKZW5kCgoKZnVuY3Rpb24gZGVsZXRlX25vZGUoaW5kZXgpCglsb2NhbCB0ciA9
IHJlYWRfbm9kZV90cmVlKDB4NDAwMDAgKyBjaSoweDIwMCwgMCwgbmlsKQoJY2hlY2twb2ludCgp
CgktLSBvcCBoZXJlCglsb2NhbCBuLCBpID0gZ2V0X25vZGVfYnlfaW5kZXgoaW5kZXgsIHRyKQoJ
bG9jYWwgcCA9IG4ucGFyZW50CglkZWxpKHAuY2hpbGQsIGkpCgkKCS0tIHdyaXRlIGJhY2sgb3V0
CgltZW1zZXQoMHg0MDAwMCArIGNpKjB4MjAwLCAwLCAweDIwICogOCkKCXdyaXRlX25vZGVfdHJl
ZSgweDQwMDAwICsgY2kqMHgyMDAsIHRyLCAwLCAwKQoJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAoK
CmZ1bmN0aW9uIGNyZWF0ZV9jaGlsZF9ub2RlKHBhcmVudF9pbmRleCwgbm9kZV90eXBlLCBpc19t
b2R1bGF0b3IsIGNvcHlfZnJvbV9wYXJlbnQpCgoJaWYgKHBlZWsoMHg0MDAwMCArIGNpKjB4MjAw
ICsgNyAqIDB4MjAgKyAxKSA_IDApIHRoZW4KCQlub3RpZnkoInRvbyBtYW55IG5vZGVzIChtYXg6
IDgpIikKCQlyZXR1cm4KCWVuZAoJCglsb2NhbCB0ciA9IHJlYWRfbm9kZV90cmVlKDB4NDAwMDAg
KyBjaSoweDIwMCwgMCwgbmlsKQoJY2hlY2twb2ludCgpCgkKCQoJbG9jYWwgcCA9IGdldF9ub2Rl
X2J5X2luZGV4KHBhcmVudF9pbmRleCwgdHIpCgkKCS0tIGNyZWF0ZSBub2RlIGl0ZW0gd2l0aCBk
ZWZhdWx0IGRhdGEKCQoJbG9jYWwgbiA9IHsgY29udGVudCA9IHVzZXJkYXRhKCJ1OCIsMHgyMCks
IHBhcmVudCA9IHAsIGNoaWxkID0ge30gfQoJLS0gZHVtbXk7IHBhcmVudCBpbmRleCBpcyBjYWxj
dWxhdGVkIGF0IGVuZCB3aGVuIHdyaXRpbmcgb3V0IHRyZWUKCWxvY2FsIHBhcmVudF9pbmRleCA9
IHAuaW5kZXgKCQoJaWYgKG5vZGVfdHlwZSA9PSAweDIgYW5kIGlzX21vZHVsYXRvcikgdGhlbgoJ
CXNldChuLmNvbnRlbnQsIDAsCgkJCXBhcmVudF9pbmRleCB8IDE2LAoJCQlub2RlX3R5cGUsIDAs
IDAsCgkJCTB4MCwweDIwLDAsMCwgIC0tIHZvbHVtZTphYnNvbHV0ZQoJCQkweDAsMCwwLDAsICAg
ICAtLSBwYW46ICBub3QgdXNlZAoJCQkweDEsMCwwLDAsICAgICAtLSB0dW5lOiBwYXJlbnQrMCAt
LSBub3QgcXVhbnRpemVkCgkJCTB4MSwwLDAsMCwgICAgIC0tIGJlbmQ6IHBhcmVudCswCgkJCTAs
MCwwLDAsICAgICAgIC0tIHdhdmVmb3JtCgkJCTB4MCwwLDAsMCAgICAgIC0tIHBoYXNlCgkJKQoJ
ZWxzZWlmIChub2RlX3R5cGUgPT0gMHgyKSB0aGVuCgkJc2V0KG4uY29udGVudCwgMCwKCQkJcGFy
ZW50X2luZGV4LCBub2RlX3R5cGUsIDAsIDAsCgkJCTB4MiwweDIwLDAsMCwgIC0tIHZvbHVtZTog
bXVsdC4gMHg0MCBpcyBtYXggKC0weDQwIHRvIGludmVydCwgMHg3ZiB0byBvdmVyYW1wKQoJCQkw
eDEsMCwwLDAsICAgICAtLSBwYW46ICBwYXJlbnQrMAoJCQkweDIxLDAsMCwwLCAgICAtLSB0dW5l
OiBwYXJlbnQrMCAgIDB4MjAgcXVhbnRpemVkOwoJCQkweDEsMCwwLDAsICAgICAtLSBiZW5kOiBw
YXJlbnQrMAoJCQkwLDAsMCwwLCAgICAgICAtLSB3YXZlZm9ybQoJCQkweDAsMCwwLDAgICAgICAt
LSBwaGFzZQoJCSkKCQkKCWVsc2UKCQktLSBmeDogbm8gcGFyZW50IG9wcwoJCXNldChuLmNvbnRl
bnQsIDAsCgkJCXBhcmVudF9pbmRleCwgbm9kZV90eXBlLCAwLCAwCgkJCS0tIGFsbCB6ZXJvOiBm
eCBrbm9icyBhcmUgYWxsIHVpbnQ4LCBzbyBkb24ndCBuZWVkIDB4OCBmbGFncyBzZXQKCQkpCgkJ
LS0gLi5leGNlcHQgZm9yIGZ4OmZpbHRlcgoJCXNldChuLmNvbnRlbnQsIDQrMio0LCAweDIpCgll
bmQKCQoJLS0gY29weSBkYXRhIGZyb20gcGFyZW50IHdoZW4gYm90aCBhcmUgb3NjCglpZiAoY29w
eV9mcm9tX3BhcmVudCkgdGhlbgoJCXNldChuLmNvbnRlbnQsIDQsCgkJCXBlZWsoMHg0MDAwMCAr
IGNpKjB4MjAwICsgcGFyZW50X2luZGV4KjB4MjAgKyA0LCAyOCkKCQkpCgllbmQKCQoJLS0gYWRk
IGl0IHRvIHRyZWUgKGF0IGVuZCBvZiBjaGlsZHJlbikgYW5kIHdyaXRlIHRyZWUgYmFjayBvdXQK
CWFkZChwLmNoaWxkLCBuKQoJCgltZW1zZXQoMHg0MDAwMCArIGNpKjB4MjAwLCAwLCAweDIwICog
OCkKCXdyaXRlX25vZGVfdHJlZSgweDQwMDAwICsgY2kqMHgyMDAsIHRyLCAwLCAwKQoJcmVmcmVz
aF9ndWkgPSB0cnVlCgkKZW5kCgoKbG9jYWwgbm9kZV9vcF9zdHI9ewoJWzBdPSJjYXJyaWVyIiwi
Zm0gbW9kIiwicmluZyBtb2QiLCAieG9yIiwib3IiCn0KZnVuY3Rpb24gY3JlYXRlX29wX3RvZ2ds
ZShhZGRyLHgseSkKCWxvY2FsIGVsID0geyAKCQlhZGRyID0gYWRkciwgY3Vyc29yPSJwb2ludGVy
IiwKCQl4ID0geCwgeSA9IHksIHdpZHRoID0gNDAsIGhlaWdodCA9IDcKCX0KCWZ1bmN0aW9uIGVs
OmRyYXcobXNnKQoJCWxvY2FsIHl5ID0gKG1zZy5oYXNfcG9pbnRlciBhbmQgbXNnLm1iID4gMCkg
YW5kIDEgb3IgMAoJCWxvY2FsIHZhbCA9IChAc2VsZi5hZGRyKSA_PiA0CgkJY2xpcCgpCgkJcGFs
KDcsMSkKCQlyZWN0ZmlsbCgwLDAreXksc2VsZi53aWR0aC0xLDYreXksbXNnLmhhc19wb2ludGVy
IGFuZCAxNCBvciA2KS0tNit2YWwqMykKCQktLXNwcih2YWwsMSwxK3l5KQoJCXByaW50KG5vZGVf
b3Bfc3RyW3ZhbF0sMiwxK3l5LDEpCgkJcGFsKCkKCWVuZAoJZnVuY3Rpb24gZWw6Y2xpY2soKQoJ
CWNoZWNrcG9pbnQoKQoJCWxvY2FsIHZhbCA9IHBlZWsoc2VsZi5hZGRyKSA_PiA0Ci0tW1sKCQkt
LSBleHBlcmltZW50OiBtb2R1bGF0ZSB1c2luZyB4b3IgLyBvcgoJCS0tIGRvbid0IHVzZSEgKHdp
bGwgYnJlYWsgLyBkaXNhcHBlYXIgaW4gZnV0dXJlKQoJCS0tIG5vdCBzdXJlIGlmIGV2ZW4gd29y
dGggaGF2aW5nIHVuZG9jdW1lbnRlZCBpbiBydW50aW1lOwoJCS0tIHByb2R1Y2VzIGV4dHJlbWVs
eSBoYXJzaCBhbmQgZGlydHkgcmVzdWx0cyBiZWNhdXNlIG5vbi1saW5lYXIKCQktLSAoY29uc2lk
ZXI6IGhpZ2ggdmFsdWUgYml0IGZsaXBwaW5nIG9uIGluIG1vZHVsYXRpbmcgc2lnbmFsKQoJCWlm
ICh2YWwgPT0gMCBvciB2YWwgPT0gMyBvciB2YWwgPT0gNCkgdGhlbgoJCQlpZiB2YWwgPT0gMCB0
aGVuIHZhbCA9IDMKCQkJZWxzZWlmIHZhbCA9PSAzIHRoZW4gdmFsID0gNAoJCQllbHNlIHZhbCA9
IDAgZW5kCgkJCXBva2Uoc2VsZi5hZGRyLCAocGVlayhzZWxmLmFkZHIpICYgMHhmKSB8ICh2YWwg
PDwgNCkpCgkJZWxzZV1daWYgKHZhbCA_IDApIHRoZW4KCQkJdmFsID0gdmFsID09IDEgYW5kIDIg
b3IgMQoJCQlwb2tlKHNlbGYuYWRkciwgKHBlZWsoc2VsZi5hZGRyKSAmIDB4ZikgfCAodmFsIDw8
IDQpKQoJCWVuZAoJCS0tcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoK
bG9jYWwgbm9kZV9meF9zdHI9ewoJWzhdPSJmaWx0ZXIiLFs5XT0iZWNobyIsWzEwXT0ic2hhcGUi
LCBbMTFdPSJjcnVzaCIKfQpmdW5jdGlvbiBjcmVhdGVfZnhfdHlwZV90b2dnbGUoYWRkcix4LHkp
Cglsb2NhbCBlbCA9IHsgCgkJYWRkciA9IGFkZHIsCgkJeCA9IHgsIHkgPSB5LCB3aWR0aCA9IDQw
LCBoZWlnaHQgPSA3Cgl9CglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQlsb2NhbCB5eSA9IChtc2cu
aGFzX3BvaW50ZXIgYW5kIG1zZy5tYiA_IDApIGFuZCAxIG9yIDAKCQlsb2NhbCB2YWwgPSAoQHNl
bGYuYWRkcikgJiAweGYKCQljbGlwKCkKCQlwYWwoNywxKQoJCXJlY3RmaWxsKDAsMCt5eSxzZWxm
LndpZHRoLTEsNit5eSxtc2cuaGFzX3BvaW50ZXIgYW5kIDE0IG9yIDYpCgkJLS1zcHIodmFsLDEs
MSt5eSkKCQlwcmludChub2RlX2Z4X3N0clt2YWxdLDIsMSt5eSwxKQoJCXBhbCgpCgllbmQKCWZ1
bmN0aW9uIGVsOmNsaWNrKCkKCQljaGVja3BvaW50KCkKCQlsb2NhbCB2YWwgPSBwZWVrKHNlbGYu
YWRkcikKCQl2YWwgPSA4ICsgKCgodmFsLTgpICsgMSkgJSAzKSAtLSBvbmx5IG5lZWQgZmlsdGVy
LCBlY2hvLCBnYWluCgkJcG9rZShzZWxmLmFkZHIsIChwZWVrKHNlbGYuYWRkcikgJiAweGYwKSB8
ICh2YWwgJiAweDBmKSkKCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkKCQktLSByZXNldCBwYXJlbnQg
b3BlcmF0b3IgYml0cyB0byBkZWZhdWx0cyAoMCBleGNlcHQgZm9yIEZYOkZJTFRFUjpSRVMpCgkJ
Zm9yIGk9MCw2IGRvCgkJCWxvY2FsIG12YWxfYWRkciA9IHNlbGYuYWRkciArIDMgKyBpKjQgLS0g
Zmlyc3QgYnl0ZSBvZiBtdmFsIChmbGFncykKCQkJcG9rZShtdmFsX2FkZHIsIHBlZWsobXZhbF9h
ZGRyKSAmIH4weDAzKSAtLSBzdHJpcCBsb3cgMiBiaXRzIChvcCkKCQkJLS0gb25seSBGWDpGSUxU
RVI6UkVTICh0eXBlIDgsIG5vZGUgMikgaGFzIE1GX01VTF9QQVJFTlQgc2V0CgkJCWlmIChpID09
IDIgYW5kIHZhbCA9PSA4KSBwb2tlKG12YWxfYWRkcixwZWVrKG12YWxfYWRkcikgfCAweDIpCgkJ
ZW5kCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCmxvY2FsIG5vZGVfdHlwZV9zdHI9ewpbMF09Im5v
bmUiLCAiIiwib3NjOiIsImFsaWFzIiwgLS0gcm9vdCBoYXMgbm8gbGFiZWwgLS0gcHV0IGluc3Ry
dW1lbnQgbmFtZSB0aGVyZQoiIiwiIiwiIiwiIiwKImZ4OiIsImZ4OiIsImZ4OiIsImZ4OiIKfQoK
bG9jYWwgbXZhbF9kYXQgPSB7Cgl7InZvbCIsInBhbiIsInR1bmUiLCJiZW5kIiwicDAiLCJwMSJ9
LAoJeyJ2b2wiLCJwYW4iLCJ0dW5lIiwiYmVuZCIsIndhdmUiLCJwaGFzZSJ9LAoJbmlsLAoJbmls
LG5pbCxuaWwsbmlsLAoJLS0gcmVhbGx5IHdhbnQgZnggYm94ZXMgdG8gYmUgdGlueSBhbmQgc3Bl
Y2lhbGl6ZWQKCS0tIChhbmQgdG8gY29zdCBub2RlcyEgLS0gdGhleSBhcmUgZ2VuZXJhbGx5IGV4
cGVuc2l2ZSBvbiBob3N0KQoJLS0gdG8gZG86IHN0YW5kYXJkICJjbGlwIiBmb3IgYWxsIGZ4IG5v
ZGVzCgktLSAwLi4xMjcgbWVhbnMgY2xpcCB0byBtYXguLm9zY192b2wgIDEyOC4uMjU1IG1lYW5z
IGNsaXAgdG8gb3NjX3ZvbC4uMAoJeyJsb3ciLCJoaWdoIiwicmVzIn0sCgl7ImRlbGF5Iiwidm9s
In0sCgl7ImdhaW4iLCJlbGJvdyIsImN1dCIsIm1peCJ9LAoJeyJyZXN4IiwicmVzeSIsImxwZiJ9
LCAtLSBjYW4gYWRqdXN0IHRoZSBzYW1wbGUgcmF0ZSwgc2FtcGxlIHByZWNpc2lvbgp9CgpmdW5j
dGlvbiBnZXRfbm9kZV9ieV9pbmRleChpbmRleCwgdHIsIGNoaWxkaSkKCWlmICh0ci5pbmRleCA9
PSBpbmRleCkgcmV0dXJuIHRyLCBjaGlsZGkKCWZvciBpPTEsI3RyLmNoaWxkIGRvCgkJbG9jYWwg
cmVzLCBjaGlsZGkgPSBnZXRfbm9kZV9ieV9pbmRleChpbmRleCwgdHIuY2hpbGRbaV0sIGkpCgkJ
aWYgKHJlcykgdGhlbgoJCQlyZXR1cm4gcmVzLCBjaGlsZGkKCQllbmQKCWVuZAoJcmV0dXJuIG5p
bAplbmQKCgpmdW5jdGlvbiByZWFkX25vZGVfdHJlZShhZGRyLCBpbmRleCwgcGFyZW50KQoJbG9j
YWwgdHIgPSB7cGFyZW50ID0gcGFyZW50fQoJCgl0ci5jb250ZW50ID0gdXNlcmRhdGEoInU4Iiwg
MzIpCgl0ci5pbmRleCA9IGluZGV4IC0tIHRoZSBvcmlnaW5hbCBpbmRleCBiZWZvcmUgdHJhbnNm
b3JtYXRpb24KCXRyLmNvbnRlbnQ6c2V0KDAsIHBlZWsoYWRkciArIGluZGV4ICogMHgyMCwgMHgy
MCkpCgl0ci5jaGlsZCA9IHt9CgoJLS0gYWRkIGNoaWxkcmVuIGlmIHRoZXkgZXhpc3QKCWZvciBp
PWluZGV4KzEsNyBkbwoJCS0tcHJpbnRoKCIgbG9va2luZyBmb3IgY2hpbGQgYXQgaSAiLi5pLi4i
ICBwYXJlbnQ6Ii4ucGVlayhhZGRyICsgaSoweDIwKSkKCQlpZiAocGVlayhhZGRyICsgaSoweDIw
KSAmIDB4ZikgPT0gaW5kZXggLS0gcGFyZW50IGlzIGdpdmVuIGluZGV4CgkJCWFuZCBwZWVrKGFk
ZHIgKyBpKjB4MjAgKyAxKSYweGYgPiAwIC0tIG5vbi1lbXB0eSBub2RlCgkJdGhlbgoJCQlhZGQo
dHIuY2hpbGQsIHJlYWRfbm9kZV90cmVlKGFkZHIsIGksIHRyKSkKCQllbmQKCWVuZAkKCglyZXR1
cm4gdHIKZW5kCgpmdW5jdGlvbiB3cml0ZV9ub2RlX3RyZWUoYWRkciwgdHIsIGluZGV4LCBwYXJl
bnRfaW5kZXgpCglpZiAodHIuY29udGVudFsxXSAmIDB4ZiA9PSAwKSByZXR1cm4gaW5kZXggLS0g
dHlwZTpub25lCglpZiAoaW5kZXggPj0gOCkgcmV0dXJuIGluZGV4IC0tIHNhZmV0eTogdG9vIG1h
bnkgbm9kZXMKCQoJLS1wcmludGgoIndyaXRpbmcgbm9kZSAiLi5pbmRleC4uIiBjb250ZW50OiIu
LnBvZCh0ci5jb250ZW50LDApKQoJCglwb2tlKGFkZHIgKyBpbmRleCAqIDB4MjAsIGdldCh0ci5j
b250ZW50KSkKCQoJLS0gdXBkYXRlIHBhcmVudCBpbmRleC4gKGV2ZXJ5dGhpbmcgZWxzZSBpcyB0
aGUgc2FtZSkKCXBva2UoYWRkciArIGluZGV4ICogMHgyMCwKCQkocGVlayhhZGRyICsgaW5kZXgg
KiAweDIwKSAmIDB4ZjApIHwgcGFyZW50X2luZGV4KQoJCglsb2NhbCBjaGlsZF9wYXJlbnQgPSBp
bmRleAoJaW5kZXggKz0gMQoJZm9yIGk9MSwjdHIuY2hpbGQgZG8KCQlpbmRleCA9IHdyaXRlX25v
ZGVfdHJlZShhZGRyLCB0ci5jaGlsZFtpXSwgaW5kZXgsIGNoaWxkX3BhcmVudCkKCWVuZAkJCQoJ
cmV0dXJuIGluZGV4CmVuZAoKZnVuY3Rpb24gcHJpbnRfbm9kZV90cmVlKHRyLCBkZXB0aCkKCXBy
aW50aChkZXB0aC4uIiBAICIuLnRyLmluZGV4Li4iICIuLnBvZCh0ci5jb250ZW50KSkKCWZvciBp
PTEsI3RyLmNoaWxkIGRvCgkJcHJpbnRfbm9kZV90cmVlKHRyLmNoaWxkW2ldLGRlcHRoKzEpCgll
bmQKZW5kCgkKLS0gcmVhZCBldmVyeWh0aW5nIGludG8gYSB0cmVlLCBtb2RpZnkgdGhlIHRyZWUs
IHRoZW4gd3JpdGUgYmFjayBvdXQuCmZ1bmN0aW9uIHN3YXBfbm9kZV9icmFuY2hlcyhuMCwgbjEp
Cglsb2NhbCB0ciA9IHJlYWRfbm9kZV90cmVlKDB4NDAwMDAgKyBjaSoweDIwMCwgMCwgbmlsKQoJ
CgkKCgktLSBjaGVjayBjYW4gd3JpdGUgYmFjayBzYW1lIGFzIHJlYWQgaW4JCgktLSBpZiAoMSkg
d3JpdGVfbm9kZV90cmVlKDB4NDAwMDAgKyBjaSoweDIwMCwgdHIsIDAsIDApIHJldHVybgoJCgls
b2NhbCBuMCwgaTAgPSBnZXRfbm9kZV9ieV9pbmRleChuMCwgdHIpCglsb2NhbCBuMSwgaTEgPSBn
ZXRfbm9kZV9ieV9pbmRleChuMSwgdHIpCgkKCWlmIChub3QgbjAgb3Igbm90IG4xKSBwcmludGgo
IkBAQCBjb3VsZCBub3QgZmluZCBub2RlcyIpIHJldHVybgoJCglsb2NhbCBwID0gbjAucGFyZW50
CgkKCWNoZWNrcG9pbnQoKQoJLS1wcmludGgoImJlZm9yZSBzd2FwIikgcHJpbnRfbm9kZV90cmVl
KHRyLCAwKQoJCglwLmNoaWxkW2kwXSwgcC5jaGlsZFtpMV0gPSBwLmNoaWxkW2kxXSwgcC5jaGls
ZFtpMF0KCQoJLS0gcHJpbnRoKCJhZnRlciBzd2FwIikgcHJpbnRfbm9kZV90cmVlKHRyLCAwKQoJ
bWVtc2V0KDB4NDAwMDAgKyBjaSoweDIwMCwgMCwgMHgyMCAqIDgpCgl3cml0ZV9ub2RlX3RyZWUo
MHg0MDAwMCArIGNpKjB4MjAwLCB0ciwgMCwgMCkKCglyZWZyZXNoX2d1aSA9IHRydWUKZW5kCgoK
ZnVuY3Rpb24gbW92ZV9zaWJsaW5nX25vZGUoaW5kZXgsIGRpcikKCQoJaWYgKGRpciA9PSAwKSB0
aGVuCgkJLS0gY2hlY2sgdGhlcmUgaXMgYW5vdGhlciBzaWJsaW5nIGF0IHNhbWUgbGV2ZWwKCQlm
b3IgaT0xLDcgZG8KCQkJaWYgaSB_PSBpbmRleCBhbmQgbm9kZV9wYXJlbnRfaW5kZXhbaV0gPT0g
bm9kZV9wYXJlbnRfaW5kZXhbaW5kZXhdCgkJCXRoZW4KCQkJCXJldHVybiB0cnVlIC0tIHNvbWUg
c2libGluZ3MKCQkJZW5kCgkJZW5kCgkJcmV0dXJuIGZhbHNlIC0tIG5vIG5lZWQgZm9yIHNpYmxp
bmcgc2h1ZmZsZSBidXR0b24KCWVuZAoJCglsb2NhbCB0YXJnZXQgPSAtMQoJaWYgZGlyIDwgMCB0
aGVuCgkJLS0gZmluZCBwcmV2aW91cyBzaWJsaW5nCgkJZm9yIGkgPSBpbmRleC0xLDEsLTEgZG8K
CQkJaWYgKG5vZGVfZGVwdGhbaV0gPT0gbm9kZV9kZXB0aFtpbmRleF0gYW5kIHRhcmdldCA9PSAt
MSkgdGFyZ2V0ID0gaQoJCWVuZAoJZWxzZQoJCS0tIGZpbmQgbmV4dCBzaWJsaW5nCgkJZm9yIGkg
PSBpbmRleCsxLCA3IGRvCgkJCWlmIChub2RlX2RlcHRoW2ldID09IG5vZGVfZGVwdGhbaW5kZXhd
IGFuZCB0YXJnZXQgPT0gLTEpIHRhcmdldCA9IGkKCQllbmQKCWVuZAoJCglpZiAodGFyZ2V0ID09
IC0xKSByZXR1cm4gLS0gY291bGRuJ3QgbW92ZQoJCgktLSBzd2FwIHNpYmxpbmdzCglzd2FwX25v
ZGVfYnJhbmNoZXModGFyZ2V0LCBpbmRleCkKCQplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9ub2RlX2Vk
aXRvcihwYXJlbnQsIG5vZGVfaW5kZXgsIHgsIHksIGRlcHRoKQoKCWxvY2FsIGluc3RfYWRkciA9
IDB4NDAwMDAgKyBjaSoweDIwMAoJbG9jYWwgbm9kZV9hZGRyID0gaW5zdF9hZGRyICsgbm9kZV9p
bmRleCoweDIwCglsb2NhbCBub2RlX3R5cGUgPSBwZWVrKG5vZGVfYWRkcisxKSAmIDB4ZgoJbG9j
YWwgbm9kZV9vcCA9IHBlZWsobm9kZV9hZGRyKSA_PiA0CgkKCWxvY2FsIGxhYmVscyA9IG12YWxf
ZGF0W25vZGVfdHlwZV0gb3Ige30KCQoJbG9jYWwgd2lkdGggPSAyNDAKCQoJbG9jYWwgcm93cyA9
IDMKCWlmIChub2RlX3R5cGUgPT0gMSkgcm93cz0yCglpZiAobm9kZV90eXBlID49IDgpIHJvd3M9
MiAtLXdpZHRoID0gMTE4CgkKCWxvY2FsIGhlaWdodCA9IDIwICsgcm93cyAqIDE2CgkKCQoJCgls
b2NhbCBkZXNjID0gbm9kZV90eXBlX3N0cltub2RlX3R5cGVdIG9yICI-PyIKCWlmIChkZXNjID09
ICIiKSBkZXNjID0gc3RyaW5nLmZvcm1hdCgiJTAyeCIsIGNpKQoJLS1pZiAobm9kZV90eXBlID09
IDIpIGRlc2MgLi49ICIgIi4uKG5vZGVfb3Bfc3RyW25vZGVfb3BdIG9yICI-PyIpCgkKCWxvY2Fs
IGhlYWRfY29sID0gbm9kZV90eXBlX2NvbFtub2RlX3R5cGVdCglpZiAobm9kZV90eXBlID09IDIg
YW5kIG5vZGVfb3AgPiAwKSBoZWFkX2NvbCA9IDB4ZDA1CgoJbG9jYWwgZWwgPSBwYXJlbnQ6YXR0
YWNoKGNyZWF0ZV9wYW5lKCIgICIuLmRlc2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGhlYWRfY29s
KSkKCQkKCS0tIGFjdGl2ZSAvIG5vdCBhY3RpdmUgdG9nZ2xlCgllbDphdHRhY2goY3JlYXRlX211
dGVkX25vZGVfdG9nZ2xlKG5vZGVfYWRkcisyLCAzLDEpKQoJCgktLSBvcGVyYXRvciBidXR0b24g
Zm9yIG9zY2lsbGF0b3IgY2hpbGRyZW4KCWlmIChub2RlX3R5cGUgPT0gMikgdGhlbgoJCWVsOmF0
dGFjaChjcmVhdGVfb3BfdG9nZ2xlKG5vZGVfYWRkciwgMzQsMSkpCgllbmQKCQoJaWYgKG5vZGVf
dHlwZSA_PSA4KSB0aGVuCgkJZWw6YXR0YWNoKGNyZWF0ZV9meF90eXBlX3RvZ2dsZShub2RlX2Fk
ZHIrMSwgMzAsMSkpCgllbmQKCQoJCgktLSBjaGlsZCBjcmVhdGlvbiBidXR0b25zIGZvciBvc2Np
bGxhdG9ycyAvIHJvb3QKCWlmIChub2RlX3R5cGUgPCA0KSB0aGVuCgkJbG9jYWwgeHg9ZWwud2lk
dGgtNzIgCgkJaWYgKG5vZGVfdHlwZSA9PSAxKSB4eCArPSAzMAoJCWlmIChub2RlX3R5cGUgIT0g
MSkgeHggLT0gMjAgLS0gbm90IHJvb3Q6IG1ha2Ugc3BhY2UgZm9yIHNpYmxpbmcgb3JkZXIgYnV0
dG9ucwoJCQoJCWlmIChub2RlX3R5cGUgPT0gMikgdGhlbiAtLSArbW9kIG9ubHkgZm9yIGNhcnJp
ZXIgb3NjCgkJeHggKz0gZWw6YXR0YWNoewoJCQl4PXh4LHk9MSx3aWR0aD0xOSxoZWlnaHQ9Nyxj
dXJzb3I9InBvaW50ZXIiLAoJCQlkcmF3ID0gZnVuY3Rpb24odGhpcyxtc2cpCgkJCQlyZWN0Zmls
bCgwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCxtc2cuaGFzX3BvaW50ZXIgYW5kIDIzIG9yIDYp
IAoJCQkJcHJpbnQoIittb2QiLDIsMSw1KQoJCQllbmQsCgkJCXRhcCA9IGZ1bmN0aW9uKCkgY3Jl
YXRlX2NoaWxkX25vZGUobm9kZV9pbmRleCwyLHRydWUpIGVuZAoJCX0ud2lkdGgrMgoJCWVuZAoJ
CXh4Kz1lbDphdHRhY2h7CgkJCXg9eHgseT0xLHdpZHRoPTE5LGhlaWdodD03LGN1cnNvcj0icG9p
bnRlciIsCgkJCWRyYXcgPSBmdW5jdGlvbih0aGlzLG1zZykKCQkJCXJlY3RmaWxsKDAsMCx0aGlz
LndpZHRoLHRoaXMuaGVpZ2h0LG1zZy5oYXNfcG9pbnRlciBhbmQgMjMgb3IgNikgCgkJCQlwcmlu
dCgiK29zYyIsMiwxLDUpCgkJCWVuZCwKCQkJdGFwID0gZnVuY3Rpb24oKSBjcmVhdGVfY2hpbGRf
bm9kZShub2RlX2luZGV4LDIsIG5pbCwgdHJ1ZSkgZW5kCgkJfS53aWR0aCsyCgkJCgkJeHgrPWVs
OmF0dGFjaHsKCQkJeD14eCx5PTEsd2lkdGg9MTUsaGVpZ2h0PTcsY3Vyc29yPSJwb2ludGVyIiwK
CQkJZHJhdyA9IGZ1bmN0aW9uKHRoaXMsbXNnKQoJCQkJcmVjdGZpbGwoMCwwLHRoaXMud2lkdGgs
dGhpcy5oZWlnaHQsbXNnLmhhc19wb2ludGVyIGFuZCAyMyBvciA2KSAKCQkJCXByaW50KCIrZngi
LDIsMSw1KQoJCQllbmQsCgkJCXRhcCA9IGZ1bmN0aW9uKCkgY3JlYXRlX2NoaWxkX25vZGUobm9k
ZV9pbmRleCw4KSBlbmQKCQl9LndpZHRoKzIKCWVuZAoJCglpZiAobm9kZV90eXBlICE9IDEpIHRo
ZW4KCQktLSBzaWJsaW5nIHJlb3JkZXJpbmcKCQlsb2NhbCB4eD1lbC53aWR0aC0zMAoJCQoJCS0t
IG1vdmUgdXAKCQlpZiAobW92ZV9zaWJsaW5nX25vZGUobm9kZV9pbmRleCwwKSkgdGhlbgoJCQl4
eCArPSBlbDphdHRhY2h7CgkJCQl4PXh4LHk9MSx3aWR0aD03LGhlaWdodD03LGN1cnNvcj0icG9p
bnRlciIsCgkJCQlkcmF3ID0gZnVuY3Rpb24odGhpcyxtc2cpCgkJCQkJcmVjdGZpbGwoMCwwLHRo
aXMud2lkdGgsdGhpcy5oZWlnaHQsbXNnLmhhc19wb2ludGVyIGFuZCAyMyBvciA2KSAKCQkJCQlw
cmludCgiXF46MDAwNDBlMWYwMDAwMDAwMCIsMSwxLDEzKQoJCQkJZW5kLAoJCQkJdGFwID0gZnVu
Y3Rpb24oKSBtb3ZlX3NpYmxpbmdfbm9kZShub2RlX2luZGV4LCAtMSkgZW5kCgkJCX0ud2lkdGgr
MgoJCgkJCXh4ICs9IGVsOmF0dGFjaHsKCQkJCXg9eHgseT0xLHdpZHRoPTcsaGVpZ2h0PTcsY3Vy
c29yPSJwb2ludGVyIiwKCQkJCWRyYXcgPSBmdW5jdGlvbih0aGlzLG1zZykKCQkJCQlyZWN0Zmls
bCgwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCxtc2cuaGFzX3BvaW50ZXIgYW5kIDIzIG9yIDYp
IAoJCQkJCXByaW50KCJcXjowMDFmMGUwNDAwMDAwMDAwIiwxLDEsMTMpCgkJCQllbmQsCgkJCQl0
YXAgPSBmdW5jdGlvbigpIG1vdmVfc2libGluZ19ub2RlKG5vZGVfaW5kZXgsIDEpIGVuZAoJCQl9
LndpZHRoKzIKCQllbmQKCWVuZAoJCgktLSBkZWxldGUgbm9kZQoJaWYgKG5vZGVfdHlwZSA_IDEp
IHRoZW4KCWVsOmF0dGFjaHsKCQl4PWVsLndpZHRoLTEwLHk9MSx3aWR0aD04LGhlaWdodD03LGN1
cnNvcj0icG9pbnRlciIsCgkJZHJhdyA9IGZ1bmN0aW9uKHRoaXMsbXNnKQoJCQlyZWN0ZmlsbCgw
LDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCxtc2cuaGFzX3BvaW50ZXIgYW5kIDggb3IgNikgCgkJ
CXByaW50KCJYIiwyLDEsNSkKCQllbmQsCgkJdGFwID0gZnVuY3Rpb24oKSBkZWxldGVfbm9kZShu
b2RlX2luZGV4KSBlbmQKCX0KCWVuZAoJCgkKCS0tIGtub2JzCgkKCWZvciB5PTAscm93cy0xIGRv
IGZvciB4PTAseT09MiBhbmQgcm93cy0xIG9yIDEgZG8KCQlsb2NhbCBtdmFsX2luZGV4ID0geSoy
ICsgeAoJCWxvY2FsIGxhYmVsID0gbGFiZWxzW212YWxfaW5kZXgrMV0gb3IgIj8-IgoJCQoJCS0t
IHBhbiBpcyBvbmx5IHNob3duIG9uIGRlcHRoOjEgT1NDIGFuZCByb290CgkJaWYgKGxhYmVsID09
ICJwYW4iIGFuZCAoCgkJCWRlcHRoID4gMSBvciAtLSBhbnl0aGluZyAyIG9yIGRlZXBlciBkb2Vz
IG5vdCBoYXZlIGEgc3RlcmVvIHBvc2l0aW9uCgkJCShkZXB0aCA9PSAxIGFuZCBub2RlX3R5cGUg
fj0gMikgb3IgLS0gb25seSBvc2MgY2FuIGhhdmUgcGFuIGF0IGxldmVsIDEKCQkJKGRlcHRoID09
IDEgYW5kIHBlZWsoaW5zdF9hZGRyICsgMHgxZGYpICYgMHgyID09IDApIC0tIHN0ZXJlbyBub3Qg
ZW5hYmxlZAoJCSkpIHRoZW4KCQkJbGFiZWwgPSBuaWwgLS0gaGlkZQoJCWVuZAoJCQoJCQoKCQlp
ZiAobXZhbF9pbmRleCA8ICNsYWJlbHMgYW5kIGxhYmVsKSB0aGVuCgkJCWVsOmF0dGFjaChjcmVh
dGVfbXZhbF9rbm9iKGxhYmVsLCBub2RlX3R5cGUsIG12YWxfaW5kZXgsCgkJCQlub2RlX2FkZHIg
KyA0ICsgbXZhbF9pbmRleCo0LCAyNiArIHgqODAsIDEzICsgeSoxOCkpCgkJZW5kCgllbmQgZW5k
CgkKCWVsOmF0dGFjaChjcmVhdGVfc2NvcGUoaW5zdF9hZGRyKzB4MWUwLG5vZGVfaW5kZXgsMTY0
LDE0LCA2OSwgZWwuaGVpZ2h0LTE5KSkKCglyZXR1cm4gZWwKZW5kCgoKZnVuY3Rpb24gdXBkYXRl
X2luc3RydW1lbnRfZWRpdG9yKCkKCgktLSBjb3B5IGFuZCBwYXN0ZSBpbnN0cnVtZW50cwoJaWYg
KGtleSJjdHJsIikgdGhlbgoJCgkJaWYga2V5cCgiYyIpIG9yIGtleXAieCIgdGhlbgoJCQlsb2Nh
bCB1ZCA9IHVzZXJkYXRhKCJ1OCIsMHgyMDAgKiAoY2kxLWNpMCsxKSk6cGVlaygweDQwMDAwK2Np
MCoweDIwMCkKCQkJc2V0X2NsaXBib2FyZChwb2QoewoJCQkJaW5zdHJ1bWVudD11ZAoJCQl9LDcs
e3BvZF90eXBlPSJpbnN0cnVtZW50In0pKQoJCQlpZiBrZXlwIngiIHRoZW4KCQkJCWZvciBpPWNp
MCxjaTEgZG8gY2xlYXJfaW5zdHJ1bWVudChpKSBlbmQKCQkJCW5vdGlmeSgiY3V0ICIuLihjaTEt
Y2kwKzEpLi4iIGluc3RydW1lbnRzIikKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbHNlCgkJ
CQlub3RpZnkoImNvcGllZCAiLi4oY2kxLWNpMCsxKS4uIiBpbnN0cnVtZW50cyIpCgkJCWVuZAoJ
CWVuZAoJCQoJCWlmIGtleXAoInYiKSB0aGVuCgkJCWNoZWNrcG9pbnQoKQoJCQlsb2NhbCBkYXQg
PSB1bnBvZChnZXRfY2xpcGJvYXJkKCkpCgkJCQoJCQlpZiAoZGF0IGFuZCB0eXBlKGRhdC5pbnN0
cnVtZW50KSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJCQlkYXQuaW5zdHJ1bWVudDpwb2tlKDB4NDAw
MDArY2kqMHgyMDApCgkJCQlub3RpZnkoInBhc3RlZCAiLi4oI2RhdCBcIDB4MjAwKS4uIiBpbnN0
cnVtZW50cyIpCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZWxzZQoJCQkJbm90aWZ5KCJjb3Vs
ZCBub3QgZmluZCBpbnN0cnVtZW50IGRhdGEgdG8gcGFzdGUiKQoJCQllbmQKCQllbmQKCQoJZW5k
CmVuZAoKCgo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEw
LTIyIDA3OjMwOjA0Iixtb2RpZmllZD0iMjAyNS0wOS0xMCAyMjozNzo0NyIscmV2aXNpb249MTQ1
ODAsc3RvcmVkPSIyMDIzLTM2LTI5IDA0OjM2OjQwIl1dCi0tW1sKCVBpY290cm9uIFRyYWNrZXIK
CShjKSBMZXhhbG9mZmxlIEdhbWVzIExMUApdXQoKaW5jbHVkZSAiZGF0YS5sdWEiCmluY2x1ZGUg
Imluc3QubHVhIgppbmNsdWRlICJ0cmFjay5sdWEiCmluY2x1ZGUgImVudi5sdWEiCmluY2x1ZGUg
Imd1aS5sdWEiCmluY2x1ZGUgInVwZGF0ZS5sdWEiCmluY2x1ZGUgInVuZG8ubHVhIgoKaW5jbHVk
ZSAiZGVidWcubHVhIgoKZnVuY3Rpb24gX2luaXQoKQoJCglwb2tlKDB4NDAwMCwgZ2V0KGZldGNo
Ii9zeXN0ZW0vZm9udHMvcDguZm9udCIpKQoJCgl3aW5kb3d7CgkJdGFiYmVkPXRydWUsCgkJaWNv
biA9IHVzZXJkYXRhIltnZnhdMDgwODAwNzc3Nzc3MDA3MDAwMDcwMDcwMDAwNzAwNzAwMDA3MDA3
MDA3Nzc3NzcwMDc3Nzc3NzAwMDAwMDAwMDAwMDBbL2dmeF0iLAoJCXRpdGxlPSJzZngiCgl9CgkK
CW1rZGlyICIvcmFtL2NhcnQvc2Z4IgoJCgl3cmFuZ2xlX3dvcmtpbmdfZmlsZSgKCQlmdW5jdGlv
bigpCgkJCWxvY2FsIHVkID0gdXNlcmRhdGEoInU4IiwweDQwMDAwKQoJCQl1ZDpwZWVrKDB4MzAw
MDApCgkJCXJldHVybiB1ZAoJCWVuZCwKCQlmdW5jdGlvbiAodWQpCgkJCWlmICh0eXBlKHVkKX49
InVzZXJkYXRhIikgdGhlbgoJCQkJaW5pdF9kYXRhKCkKCQkJZWxzZQoJCQkJbWVtc2V0KDB4MzAw
MDAsIDAsIDB4NDAwMDApIC0tIGluIGNhc2Ugc3RvcmVkIHNob3J0IC8gbGVnYWN5IHVzZXJkYXRh
CgkJCQl1ZDpwb2tlKDB4MzAwMDApCgkJCWVuZAoJCQl0ZGF0PXt9CgkJCWluaXRfdW5kbygpCgkJ
ZW5kLAoJCSIvcmFtL2NhcnQvc2Z4LzAuc2Z4IiwKCQluaWwsbmlsLCAtLSB0byBkbzogbG9jYXRp
b25zCgkJZnVuY3Rpb24gKCkKCQkJcmV0dXJuIHVuZG9fc3RhY2sgYW5kICN1bmRvX3N0YWNrLnVu
ZG9fc3RhY2sKCQllbmQKCSkKCQoKCS0tIGN1cnJlbnQgbm9kZSwgaW5zdHJ1bWVudCwgdHJhY2ss
IHBhdHRlcm4KCWNuID0gMAoJY2kgPSAwCgljdCA9IDAKCWNwID0gMAoJCgktLSBpdGVtIHNlbGVj
dGlvbiByYW5nZXMgZm9yIGluc3RydW1lbnRzLCB0cmFja3MsIHBhdHRlcm5zCgljaTAsY2kxLGNp
MiA9IDAsMCwwCgljdDAsY3QxLGN0MiA9IDAsMCwwCgljcDAsY3AxLGNwMiA9IDAsMCwwCgkKCWN2
b2wgPSAweDIwCgljb2N0ID0gNAoJCgltb2RlID0gInRyYWNrIgoJCglzY3JvbGwgPSB7fSAtLSBz
Y3JvbGwgcG9zaXRpb24gZm9yIGNob29zZXJzCgoJaW5pdF91bmRvKCkKCQplbmQKCi0tIGZvciBt
b2NraW5nIHVwCmZ1bmN0aW9uIGRyYXdfcGFuZSh0aXRsZSwgeCwgeSwgdywgaCwgY29sKQoJY29s
ID0gY29sIG9yIDUKCXkgPSB5ICsgMgoJcmVjdGZpbGwoeCx5LHgrdy0xLHkraC0xLGNvbCkKCXJl
Y3RmaWxsKHgseSx4K3ctMSx5KzYsNykKCXByaW50KHRpdGxlLHgrNCx5KzEsMSkKCQoJLS1wc2V0
KHgseSwwKSBwc2V0KHgrdy0xLHksMCkKCS0tcHNldCh4LHkraC0xLDApCXBzZXQoeCt3LTEseSto
LTEsMCkKZW5kCgoKZnVuY3Rpb24gZHJhd19ub2RlX2F0dHIobGFiZWwsIHgsIHkpCgotLQlyZWN0
ZmlsbCh4LCB5LCB4KzYwLCB5KzgsIDYpCgoKCXJlY3RmaWxsKHgrMzAseSx4KzcwLHkrOCwwKQoK
CS0tICoyLjArMSBtZWFucyAqMi4wIHJlbGF0aXZlIHRvIHBhcmVudCwgICsxIHNlbWl0b25lCgkt
LSBzcGVjaWFsIGZvciB0dW5lLiBjbGljayBsYWJlbCB0byB0b2dnbGUgYmV0d2VlbiAqMi4wKzEg
YW5kICsxCgktLSBvdGhlciBhdHRyaWJ1dGVzOiBjbGljayBsYWJlbCB0byB0b2dnbGUgYmV0d2Vl
biAxLjAgYW5kICoxLjAKCglpZiAobGFiZWwgPT0gInR1bmUiKSB0aGVuCgkJcHJpbnQoIioyLjAw
KzEiLHgrNDIseSsyLCAxMykKCWVsc2UKCQlwcmludCgiMS4wMDAiLHgrNDcseSsyLCAxMykKCWVu
ZAoKCWNpcmNmaWxsKHgrMzAseSs0LDcsMCkKCWNpcmMgICAgKHgrMzAseSs0LDcsNykKCQoJCglw
cmludChsYWJlbCwgeCsyLCB5KzIsIDYpCgplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCgoJLS1maWxs
cCgxKQoJLS1maWxscCh_MHg4MTNkKQoJZmlsbHAofjB4ODIzOSkgLS0gYnJ1c2hlZCBtZXRhbD8g
c29tZXRoaW5nIGluZHVzdHJpYWwKCXJlY3RmaWxsKDAsMCw0ODAsMjcwLDMyIHwgKDMzKjI1Nikp
CglmaWxscCgpCgkKCS0tcmVjdGZpbGwoMzY4LDAsNDgwLDI3MCw1KQoJLS1yZWN0ZmlsbCgwLDAs
MTA4LDI3MCw1KQoJCi0tW1sKCWRyYXdfcGFuZSgic29uZyBpbmZvIiwgMiwyLDk2LDU2LDEpCglk
cmF3X3BhbmUoImluc3RydW1lbnRzIiwyLDYyLDk2LDk4LDEpCgktLWRyYXdfcGFuZSgibXVkbyBz
dGF0ZSIsMiwxNjQsOTYsOTAsMCkKXV0KCQoJCgktLSBvcGVyYXRpb25zIGR1cmluZyBfdXBkYXRl
IGNhbiByZXF1ZXN0IGEKCS0tIGd1aSB1cGRhdGUgYmVmb3JlIGl0IGlzIG5leHQgZHJhdyAoYXZv
aWQgZmxpY2tlcikKCWlmIChyZWZyZXNoX2d1aSBvciBub3QgZ3VpKSB0aGVuCgkJcmVhZHRleHQo
dHJ1ZSkgLS0gY2xlYXIgdGV4dCBpbnB1dCBidWZmZXIKCQlnZW5lcmF0ZV9ndWkoKQoJCS0tIGd1
aTpkcmF3X2FsbCgpIGV4cGVjdHMgOnVwZGF0ZV9hbGwoKSBjYWxsZWQgZmlyc3Qgb24gY3VycmVu
dCBzdGF0ZSBvZiBndWkKCQlndWk6dXBkYXRlX2FsbCgpCgkJcmVmcmVzaF9ndWkgPSBmYWxzZQoJ
ZW5kCgkKCWd1aTpkcmF3X2FsbCgpCgkKCWlmIChtb2RlID09ICJpbnN0cnVtZW50IiBhbmQgZ3Jh
YmJlZF9lbnZlbG9wZSkgdGhlbgoJCWxvY2FsIG14LG15LG1iPW1vdXNlKCkKCQlpZiAobWI_MCkg
cHJpbnQoIlwjNyAgZW52LSIuLmdyYWJiZWRfZW52ZWxvcGUsbXgtMyxteSwxNykJCgllbmQKCQoJ
aWYgKG1vZGUgIT0gImluc3RydW1lbnQiIGFuZCBncmFiYmVkX3RyYWNrIGFuZCB0aW1lKCk_Z3Jh
YmJlZF90cmFja190Ky4yNSkgdGhlbgoJCWxvY2FsIG14LG15LG1iPW1vdXNlKCkKCQlpZiAobWI_
MCkgdGhlbgoJCQkKCQkJbG9jYWwgc3gsc3k9bXgtMjAsbXktOAoJCQlyZWN0ZmlsbChzeCxzeSxz
eCszOSxzeSs4LDUpCgkJCXBhbHQoMCkKCQkJc3ByKGdldF9zZnhfdGh1bWIoZ3JhYmJlZF90cmFj
ayksc3grMixzeSsxKQoJCQlwcmludCgic2Z4OiIuLmdyYWJiZWRfdHJhY2ssc3grMTIsc3krMiwx
MSkKCQkJcGFsdCgpCgkJZW5kCgllbmQKCQoJLS0gY3VzdG9tIGRpc3BsYXkgcGFsZXR0ZQoJLS0g
YXQgZW5kLi4gc29tZXRoaW5nIGluIDpkcmF3X2FsbCgpIHByb2JhYmx5IGNhbGxzIHBhbCgpCglw
b2tlNCgweDUwMDArMzIqNCwgMHgyMDIwMjApCgkKCS0tcG9rZTQoMHg1MDAwKzMyKjQsIDB4ZjAy
MGYwKSAtLSBkZWJ1ZyBmbGFzaGluZwoJCi0tCXByaW50KHN0cmluZy5mb3JtYXQoImNwdTolMy4z
ZiIsc3RhdCgxKSksNDQwLDI1MCw3KQotLWRyYXdfbXVkb19zdGF0ZSgzODAsMjAwKQoJCgkKZW5k
CgoKOjogdHJhY2subHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMjcg
MTg6NDk6MTgiLG1vZGlmaWVkPSIyMDI1LTExLTEwIDE2OjEyOjIxIixyZXZpc2lvbj0xMDgyNl1d
Ci0tW1sKCgl0cmFjayBlZGl0b3IKCl1dCgoKCmZ1bmN0aW9uIGNyZWF0ZV90aW55X251bV9maWVs
ZChsYWJlbCxhZGRyLHgseSwgIHZtaW4sIHZtYXgpCglsb2NhbCBlbD17CgkJeD14LHk9eSwKCQl3
aWR0aD0xNSxoZWlnaHQ9MTQsCgkJbGFiZWw9bGFiZWwsYWRkcj1hZGRyLAoJCXZtaW49dm1pbiwg
dm1heD12bWF4Cgl9CgkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxvY2FsIHZhbD1wZWVrKHNlbGYu
YWRkcikKCQlpZiAoaGFzX2tub2IpIHRoZW4KCQkJY2lyYyg3LDUsNSwxMykKCQkJbG9jYWwgYWE9
LjctdmFsKi45LzI1NS4wCgkJCWxpbmUoNy41K2NvcyhhYSksNS41K3NpbihhYSksNy41K2Nvcyhh
YSkqNCw1LjUrc2luKGFhKSo0LDcpCgkJZW5kCgkJCgkJY2xpcCgpCgkJCgkJLS0gCgkJbG9jYWwg
eXk9IDAKCQlyZWN0ZmlsbCgwLHl5LDE0LHl5KzYsMCkKCQlsb2NhbCBzdHI9dG9zdHIodmFsKQoJ
CXByaW50KHN0ciwxNC0jc3RyKjQseXkrMSwzKQoJCQoJCWxvY2FsIGxhYmVsID0gc2VsZi5sYWJl
bAoJCWlmIChsYWJlbCA9PSAibG9vcDAiIGFuZCBwZWVrKHNlbGYuYWRkcisxKSA8PSB2YWwpIGxh
YmVsID0gImxlbiIKCQlwcmludChsYWJlbCwtKDIrI2xhYmVsKjQpLHl5KzEsNikKCgllbmQKCQoJ
ZnVuY3Rpb24gZWw6Y2xpY2sobXNnKQoJCW1vdXNlbG9jaygweDR8MHg4LCAwLjI1LCAwLjA1KSAt
LSAweDQgbG9jayAweDggYXV0by1yZWxlYXNlLCBldmVudCBzcGVlZCwgbW92ZSBzcGVlZCAKCWVu
ZAoJCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCQlsb2NhbCBtYWcgPSBrZXkiY3RybCIg
YW5kIDggb3IgMQoJCXNlbGY6ZHJhZyh7bWI9bXNnLm1iLGR4PTAsZHk9LW1zZy53aGVlbF95ICog
bWFnfSkKCQlyZXR1cm4gdHJ1ZSAtLSBzYWZldHkgKGN1cnJlbnRseSBubyBzaXR1YXRpb24gd2hl
cmUgdGhhdCBpcyBuZWVkZWQpCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwg
dmFsPXBlZWsoc2VsZi5hZGRyKQoJCXZhbCArPSBtc2cuZHggLSBtc2cuZHkKCQlsb2NhbCB2bWlu
ID0gZWwudm1pbiBvciAwCgkJbG9jYWwgdm1heCA9IGVsLnZtYXggb3IgMjU1CgkJCgkJdmFsID0g
bWlkKHZtaW4sdmFsLHZtYXgpCgkJcG9rZShzZWxmLmFkZHIsIHZhbCkKCWVuZAoJCglyZXR1cm4g
ZWwKZW5kCgoKY3VyX3ggPSAwCmN1cl95ID0gMHg1MDAwMCArIDgKCmxvY2FsIG5vdGVfbmFtZSA9
IHtbMF09CiJjICIsImMjIiwiZCAiLCJkIyIsImUgIiwiZiAiLCJmIyIsImcgIiwiZyMiLCJhICIs
ImEjIiwiYiAiCn0KbG9jYWwgdmFsX3RvX3N0cl8weGZmID0ge30KbG9jYWwgdmFsX3RvX3N0cl8w
eDAwID0ge30KbG9jYWwgdmFsX3RvX25vdGUgICAgID0ge30KCmZvciBpPTAsMjU1IGRvCgl2YWxf
dG9fc3RyXzB4ZmZbaV0gPSBzdHJpbmcuZm9ybWF0KCIlMDJ4IixpKSAKCXZhbF90b19zdHJfMHgw
MFtpXSA9IHN0cmluZy5mb3JtYXQoIiUwMngiLGkpIAoJdmFsX3RvX25vdGVbaV0gPSBub3RlX25h
bWVbaSUxMl0uLihpXDEyKQplbmQKCi0tdmFsX3RvX3N0cl8weDAwWzB4MDBdID0gIi4uIgp2YWxf
dG9fc3RyXzB4ZmZbMHhmZl0gPSAiLi4iCnZhbF90b19ub3RlICAgIFsweGZmXSA9ICIuLi4iCgoK
bG9jYWwgZnVuY3Rpb24gcmVuZGVyX3JvdyhhZGRyLCBzdHJpZGUpCgkKCWxvY2FsIGZyZXEgPSBA
YWRkciBhZGRyICs9IHN0cmlkZQoJbG9jYWwgaW5zdCA9IEBhZGRyIGFkZHIgKz0gc3RyaWRlCgls
b2NhbCB2b2wgID0gQGFkZHIgYWRkciArPSBzdHJpZGUKCWxvY2FsIGZ4ICAgPSBAYWRkciBhZGRy
ICs9IHN0cmlkZQoJbG9jYWwgZnhwICA9IEBhZGRyCgkKCS0tIHRvIGRvOiBjcHUgY29zdCBmb3Ig
c3RyaW5nLmZvcm1hdAoJLS0gY291bGQga2VlcCBhIGxhcmdlIGNhY2hlIGJ5IGludDY0IGhhc2gg
b2YgaW5wdXQKCXJldHVybiBzdHJpbmcuZm9ybWF0KCIlc1wtaFxmZSVzXC1oXGZjJXNcLWhcZmQl
c1xmNiVzIiwKCQl2YWxfdG9fbm90ZVtmcmVxXSwKCQl2YWxfdG9fc3RyXzB4ZmZbaW5zdF0sIHZh
bF90b19zdHJfMHhmZlt2b2xdLAoJCWZ4ID09IDAgYW5kICIuIiBvciBjaHIoZngpLAoJCWZ4ID09
IDAgYW5kICIuLiIgb3IgdmFsX3RvX3N0cl8weDAwW2Z4cF0KCSkKCQplbmQKCmxvY2FsIGZ1bmN0
aW9uIHJlbmRlcl9zZWxlY3Rpb24oeDAsIHgxKQoJaWYgKHgwID4geDEpIHgwLHgxID0geDEseDAK
CWxvY2FsIHN0cj0iIgoJbG9jYWwgc3RyMSA9ICIgICIKCWZvciBpPTAsOCBkbwoJCWlmICh4MCA8
PSBpIGFuZCB4MSA_PSBpKSB0aGVuCgkJCXN0ci4uPSAiXF5pIi4uc3RyMS4uIlxeLWkiCgkJZWxz
ZQoJCQlzdHIuLj0gc3RyMQoJCWVuZAoJCXN0cjEgPSAiICIgLS0gc3Vic2VxdWVudCBpdGVtcyBh
cmUgYSBzaW5nbGUgY2hhcmFjdGVyCgkJaWYgKGkgPT0gMCBvciBpID09IDIgb3IgaSA9PSA0KSBz
dHIxIC4uPSAiXC1oIiAtLSAxcHggc3BhY2UKCWVuZAoJCgoJcmV0dXJuIHN0cgotLVtbCglyZXR1
cm4gc3RyaW5nLmZvcm1hdCgiJXMlc1wtaCVzXC1oJXNcLWglcyVzIiwKCQkoeDAgPD0gMCBhbmQg
eDEgPj0gMCkgYW5kICJcXmkgIFxeLWkiIG9yICIgICIsCgkJKHgwIDw9IDEgYW5kIHgxID49IDEp
IGFuZCAiXF5pIFxeLWkiIG9yICIgIiwKCQkoeDAgPD0gMiBhbmQgeDEgPj0gMikgYW5kICJcXmkg
IFxeLWkiICBvciAiICAiLAoJCSh4MCA8PSAzIGFuZCB4MSA_PSAzKSBhbmQgIlxeaSAgXF4taSIg
IG9yICIgICIsCgkJKHgwIDw9IDQgYW5kIHgxID49IDQpIGFuZCAiXF5pIFxeLWkiICAgb3IgIiAi
LAoJCSh4MCA8PSA1IGFuZCB4MSA_PSA1KSBhbmQgIlxeaSAgXF4taSIgIG9yICIgICIKCSkKXV0K
ZW5kCgotLSBieSBzZnhfaW5kZXg7IGNvdWxkIGRvIGJ5IGNoYW5uZWwgbGF0ZXIgZXNwCi0tIGlm
IHBsYXlpbmcgc2FtZSBzZnggb24gdHdvIGRpZmZyZW50IGNoYW5uZWxzCmZ1bmN0aW9uIHBsYXlp
bmdfcm93KHNmeF9pbmRleCkKCglpZiAoc3RhdCg0NjQpPT0wKSByZXR1cm4gbmlsIC0tIG5vdGhp
bmcgcGxheWluZwoJCglmb3IgaT0wLDE1IGRvCgkJaWYgKHN0YXQoNDAwICsgaSwgMTIpID09IHNm
eF9pbmRleCkgdGhlbgoJCQktLXByaW50aCgicGxheWluZ19yb3cgZm9yIHNmeCAiLi5zZnhfaW5k
ZXguLiI6ICIuLnN0YXQoNDAwICsgaSwgOSkpCgkJCXJldHVybiBzdGF0KDQwMCArIGksIDkpCgkJ
ZW5kCgllbmQKZW5kCgpmdW5jdGlvbiBjcmVhdGVfdHJhY2tfc2VnbWVudChlbCkKCglsb2NhbCBy
b3dfaCA9IDgKCQoJZWwueCA9IGVsLnggb3IgMAoJZWwueSA9IGVsLnkgb3IgMAoJZWwucm93cyAg
ICA9IGVsLnJvd3Mgb3IgMzIKCWVsLndpZHRoICAgPSA0NCAtLSBhbHdheXMgNDgKCWVsLmhlaWdo
dCAgPSBlbC5oZWlnaHQgb3IgZWwucm93cyAqIHJvd19oICsgMgoJZWwucm93MCAgICA9IGVsLnJv
dzAgb3IgMAoJZWwuaW5kZXggICA9IGVsLmluZGV4IG9yIGN0IC0tIHNmeCBpbmRleAoJZWwubGFz
dF9pbmRleCA9IC0xCgllbC5yb3dzdHI9e30KCQoJCglpZiAobm90IHRkYXRbZWwuaW5kZXhdKSB0
ZGF0W2VsLmluZGV4XSA9IHt9Cglsb2NhbCBkZGF0ID0gdGRhdFtlbC5pbmRleF0gLS0gZGVjb3Jh
dGlvbiBkYXRhCgkKCS0tIHJlY2FsbCBwZXItc2Z4IGN1cnNvcgoJaWYgKGRkYXQuY3VyKSB0aGVu
CgkJY3VyX3ggPSBkZGF0LmN1ci54CgkJY3VyX3kgPSBkZGF0LmN1ci55CgllbmQKCQoJLS10ZGF0
W2VsLmluZGV4XS5zZWw9e3gwPTAseTA9MCx4MT0zLHkxPTV9CgoJLS0gZS5nLiAweDUwMDA4IGZv
ciBmaXJzdCBlbGVtZW50IG9uIGZpcnN0IHJvdyBvZiBmaXJzdCB0cmFjawoJLS0gYWRkICsgZWwu
cm93MCB0byBnZXQgYWRkcmVzcyBvZiBmaXJzdCByb3cgaW4gc2VnbWVudAkKCWxvY2FsIGJhc2Vf
YWRkciA9IDB4NTAwMDAgKyAoZWwuaW5kZXggKiAzMjgpICsgOAoJCglmdW5jdGlvbiBlbDp1cGRh
dGUoKQoJCWlmIChlbC5saXZlX2luZGV4KSB0aGVuCgkJCWVsLmluZGV4ID0gcGVlaygweDMwMTAw
ICsgY3AgKiAyMCArIGVsLmNoYW5faSkKCQkJYmFzZV9hZGRyID0gMHg1MDAwMCArIChlbC5pbmRl
eCAqIDMyOCkgKyA4CgkJCQoJCQktLSBjcmVhdGUgZGVmYXVsdCB0cmFjayBkYXRhIHdoZW4gbmVl
ZGVkCgkJCWlmIChlbC5pbmRleCB_PSBlbC5sYXN0X2luZGV4KSB0aGVuCgkJCQllbC5sYXN0X2lu
ZGV4ID0gZWxfaW5kZXgKCQkJCWxvY2FsIGFkZHIgPSAweDUwMDAwICsgKGVsLmluZGV4ICogMzI4
KQoJCQkJaWYgcGVlazgoYWRkcikgPT0gMCBhbmQgcGVlazgoYWRkciArIDgpID09IDAgdGhlbgoJ
CQkJCWluaXRfdHJhY2soYWRkcikKCQkJCWVuZAoJCQllbmQKCQkJCgkJZW5kCgkJZGRhdC5jdXI9
e3g9Y3VyX3gseT1jdXJfeX0gLS0gc3RvcmUgcGVyLXNmeCBjdXJzb3IKCWVuZAoJCgoJZnVuY3Rp
b24gZWw6ZHJhdyhtc2cpCgkKCQlsb2NhbCBzZWwgPSBkZGF0LnNlbAoJCQoJCXJlY3RmaWxsKDAs
MCwxMDAwLDEwMDAsMCkKCQkKCQlsb2NhbCB5MCA9IDAKCQlsb2NhbCB5MSA9IHNlbGYucm93cyAt
IDEKCQkKCQl5MCA9IG1pZCgwLCAoLXNlbGYuc3kpXHJvd19oICsgMSwgc2VsZi5yb3dzLTEpCgkJ
eTEgPSBtaWQoMCwgeTAgKyAyNzBccm93X2gsIHNlbGYucm93cy0xKQoJCQoJCQoJCQoJCWZvciBp
ID0geTAseTEgZG8KCQkKCQkJaWYgKGklOCA9PSAwIGFuZCBzZWxmLnJvd3MgPiA4KSB0aGVuCgkJ
CQlyZWN0ZmlsbCgwLGkqcm93X2gsIHNlbGYud2lkdGgtMSxpKnJvd19oK3Jvd19oLCBpID09IDMy
IGFuZCAyIG9yIDIxKQoJCQllbmQKCQkJCgkJCWlmIChpICsgc2VsZi5yb3cwID09IHBsYXlpbmdf
cm93KGVsLmluZGV4KSkgdGhlbgoJCQkJcmVjdGZpbGwoMCxpKnJvd19oLCBzZWxmLndpZHRoLTEs
aSpyb3dfaCtyb3dfaCwgMTgpCgkJCWVuZAoJCQkKCQkJLS0gbm90ZSgzKSBpbnN0KDIpIHZvbCgy
KSBlZmZlY3QoMykKCQkJCgkJCS0tcHJpbnQoImMgM1wtaFxmZS4uXC1oXGZjLi5cLWhcZmQuLjAi
LCAxLCAxK2kqNywgNikKCQkJCgkJCS0tIHNlbGVjdGVkIChvbmx5IHdoZW4gdmlld2luZyBjdXJy
ZW50IHRyYWNrKQoJCQlpZiBlbC5pbmRleCA9PSBjdCB0aGVuCgkJCQoJCQkJaWYgc2VsIHRoZW4K
CQkJCQlsb2NhbCB4MCx5MCx4MSx5MSA9IGdldF90cmFja19zZWxlY3Rpb24oc2VsKQoJCQkJCWlm
IGkgKyBlbC5yb3cwID49IHkwIGFuZCAgaSArIGVsLnJvdzAgPD0geTEgdGhlbiAKCQkJCQkJcHJp
bnQocmVuZGVyX3NlbGVjdGlvbih4MCwgeDEpLCAxLCAxK2kqcm93X2gsIDEwKQoJCQkJCWVuZAoJ
CQkJZW5kCgkJCQkKCQkJCS0tIHNpbmdsZQoJCQkJLS1bWyBkb24ndCBuZWVkIC0tIHNpbmdsZS1j
ZWwgc2VsZWN0aW9uIGFsd2F5cyBmb2xsb3dzIGN1cnNvciBub3cKCQkJCWlmIChjdXJfeSA9PSBi
YXNlX2FkZHIgKyBpICsgZWwucm93MCkgdGhlbgoJCQkJCXByaW50KHJlbmRlcl9zZWxlY3Rpb24o
Y3VyX3gsIGN1cl94KSwgMSwgMStpKnJvd19oLCA5KQoJCQkJZW5kCgkJCQldXQoJCQllbmQKCQkJ
CgkJCXByaW50KHJlbmRlcl9yb3coYmFzZV9hZGRyICsgaSArIGVsLnJvdzAsIDY0KSwgMSwgMitp
KnJvd19oLCA2KQoJCQkKCQllbmQKCQkKCQktLXJlY3RmaWxsKDQzLDAsNDUsc2VsZi5yb3dzKjct
MywxNikKCQkKCQktLSBsaWdodCB1cCB3aGVuIHRyYWdnaW5nIGEgdHJhY2sgaW5kZXggb3ZlciB0
cmFjayBzZWdtZW50CgkJLS0gKGRyb3AgdG8gYXNzaWduIHRyYWNrIHRvIHBhdHRlcm4gY2hhbm5l
bCkKCQlpZiAoc2VsZi5kcm9wX3RyYWNrX2luZGV4IGFuZAoJCQltc2cubXg_PTAgYW5kIG1zZy5t
eCA8c2VsZi53aWR0aCBhbmQgbXNnLm15ID49IDAgYW5kIGdyYWJiZWRfdHJhY2spIHRoZW4KCQkJ
cmVjdCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsIDEwKQoJCWVuZAoJCQoJZW5kCgkK
CWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCQoJCWZvY3VzID0gInRyYWNrIgoJCWNoZWNrcG9pbnQo
KQoJCQoJCWxvY2FsIGk9KG1zZy5teS0yKVxyb3dfaAoJCWN1cl95ID0gYmFzZV9hZGRyICsgaSAr
IGVsLnJvdzAKCQljdCA9IGVsLmluZGV4CgkJCgkJLS0JcHJpbnRoKHN0cmluZy5mb3JtYXQoImJh
c2VfYWRkcjogJXggaTogJWQiLCBiYXNlX2FkZHIsIGkpKQoJCQoJCWxvY2FsIGNvbF94ID0ge1sw
XT0wLDgsMTMsMTcsMjIsMjYsMzEsMzUsMzl9CgkJZm9yIGk9MCw4IGRvCgkJCWlmIChtc2cubXgg
Pj0gY29sX3hbaV0pIGN1cl94ID0gaQoJCWVuZAoKCQlpZiAoa2V5ImN0cmwiIGFuZCBmYWxzZSkg
dGhlbgoJCQoJCQktLSAgc2VhcmNoIHJlcGxhY2UJCgoJCWVsc2VpZiAobXNnLm1iID09IDIpIHRo
ZW4KCQkKCQkJLS0gcGljayB1cCBpbnN0cnVtZW50CgkJCWlmIChjdXJfeD49MyBhbmQgY3VyX3g8
PTQgYW5kIHBlZWsoY3VyX3krNjQpIH49IDB4ZmYpIGNpID0gcGVlayhjdXJfeSs2NCkKCQkJCgkJ
CS0tIHBpY2sgdXAgdm9sdW1lCgkJCWlmIChjdXJfeD49NSBhbmQgY3VyX3g8PTYgYW5kIHBlZWso
Y3VyX3krMTI4KSB_PSAweGZmKSBjdm9sID0gcGVlayhjdXJfeSsxMjgpCgkJCQoJCQktLSBzdGFy
dCBuZXcgc2VsZWN0aW9uCgkJCWRkYXQuc2VsID0gewoJCQkJeDA9Y3VyX3gsIHkwPWkgKyBlbC5y
b3cwLCAKCQkJCXgxPWN1cl94LCB5MT1pICsgZWwucm93MAoJCQl9CgoJCWVsc2VpZiAoa2V5InNo
aWZ0IikgdGhlbgoJCQktLSBleHRlbmQgc2VsZWN0aW9uCgkJCWRkYXQuc2VsPWRkYXQuc2VsIG9y
IHt4MD1jdXJfeCwgeTA9aSArIGVsLnJvdzAsIHgxPWN1cl94LCB5MT1pICsgZWwucm93MH0KCQkJ
ZGRhdC5zZWwueDEgPSBjdXJfeAoJCQlkZGF0LnNlbC55MSA9IGkgKyBlbC5yb3cwCgkJZWxzZQoJ
CQktLSBzdGFydCBuZXcgc2VsZWN0aW9uCgkJCWRkYXQuc2VsID0gewoJCQkJeDA9Y3VyX3gsIHkw
PWkgKyBlbC5yb3cwLCAKCQkJCXgxPWN1cl94LCB5MT1pICsgZWwucm93MAoJCQl9CgkJZW5kCgkJ
CgkJcmV0dXJuIHRydWUgLS0gZG9uJ3QgcGFzcyB0aHJvdWdoIHRvIHBhbmUKCWVuZAoJCglmdW5j
dGlvbiBlbDpkcmFnKG1zZykKCQlsb2NhbCBpPShtc2cubXktMilccm93X2gKCQljdXJfeSA9IGJh
c2VfYWRkciArIGkgKyBlbC5yb3cwCgkJbG9jYWwgY29sX3ggPSB7WzBdPTAsOCwxMywxNywyMiwy
NiwzMSwzNSwzOX0KCQlmb3IgaT0wLDggZG8KCQkJaWYgKG1zZy5teCA_PSBjb2xfeFtpXSkgY3Vy
X3ggPSBpCgkJZW5kCgkJZGRhdC5zZWwueDEgPSBjdXJfeAoJCWRkYXQuc2VsLnkxID0gaSArIGVs
LnJvdzAKCWVuZAoJCgktLSBpZiB0cmFjayBpcyB6ZXJvZWQsIHNldCB1cCBkZWZhdWx0IHRyYWNr
IHZhbHVlCglsb2NhbCBhZGRyID0gMHg1MDAwMCArIChlbC5pbmRleCAqIDMyOCkKCWlmIHBlZWs4
KGFkZHIpID09IDAgYW5kIHBlZWs4KGFkZHIgKyA4KSA9PSAwIHRoZW4KCQktLSBjYW4gYXNzdW1l
IHBvaW50cyB0byB6ZXJvZWQgcmFtIC0tPiBpbml0aWFsaXNlCgkJaW5pdF90cmFjayhhZGRyKQoJ
ZW5kCgkKCXJldHVybiBlbAplbmQKCgotLSBkb29kbGUgcGl0Y2ggdmFsdWVzCi0tIHNoaWZ0IHRv
IHBhaW50IG9ubHkgaW5zdHJ1bWVudApmdW5jdGlvbiBjcmVhdGVfcGl0Y2hfc2NyaWJibGVyKGVs
KQoJZWwuaW5kZXggCT0gZWwuaW5kZXggb3IgY3QKCWVsLmNsaWNrIAk9IGNoZWNrcG9pbnQKCWxv
Y2FsIHlfb2Zmc2V0ID0gMTIKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxpbmUoMCxzZWxmLmhlaWdo
dC0xLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQtMSwxKQoJCWZvciBpPTAsNjMgZG8KCQkJbG9jYWwg
dmFsID0gKEAoZWwuYWRkciArIGkpKQoJCQlpZiAodmFsIH49IDB4ZmYpIHRoZW4KCQkJCWxvY2Fs
IHh4ID0gaSAqIDYKCQkJCWxvY2FsIGluc3QgPSBAKGVsLmFkZHIgKyBpICsgZWwuc3RyaWRlKQoJ
CQkJbG9jYWwgeXkgPSBlbC5oZWlnaHQgLSB2YWwgLSAxICsgeV9vZmZzZXQKCQkJCXJlY3RmaWxs
KHh4KzEsIHl5LCB4eCArIDQsIGVsLmhlaWdodCwgaT09cGxheWluZ19yb3coZWwuaW5kZXgpIGFu
ZCAxMiBvciAxKQoJCQkJcmVjdGZpbGwoeHgrMSwgeXksIHh4ICsgNCwgeXkrMSAsIDggKyBpbnN0
JTI0KQoJCQllbmQKCQllbmQKCQlsb2NhbCB0cmFja19hZGRyID0gMHg1MDAwMCArIGN0ICogMzI4
CgkJbG9jYWwgeHggPSBwZWVrKHRyYWNrX2FkZHIrMykqNgoJCWlmICh4eD4wKSBsaW5lKHh4LDAs
eHgsc2VsZi5oZWlnaHQsMTIpCgkJbG9jYWwgeHgxID0gcGVlayh0cmFja19hZGRyKzQpKjYKCQlp
ZiAoeHgxPnh4KSBsaW5lKHh4MSwwLHh4MSxzZWxmLmhlaWdodCwxNCkKCWVuZAoJCglmdW5jdGlv
biBlbDpkcmFnKG1zZykKCQlsb2NhbCB4eCAgPSBtaWQoMCwgbXNnLm14IFwgNiwgNjMpCgkJbG9j
YWwgdmFsID0gbWlkKDAsIGVsLmhlaWdodCAtIG1zZy5teSArIHlfb2Zmc2V0LCAyNTUpCgkJCgkJ
aWYgKG1zZy5tYiA9PSAyKSB0aGVuCgkJCWNpID0gcGVlayhlbC5hZGRyICsgeHggKyBlbC5zdHJp
ZGUpCgkJZWxzZQoJCQktLSBzZXQgaW5zdHJ1bWVudAoJCQlwb2tlKGVsLmFkZHIgKyB4eCArIGVs
LnN0cmlkZSwgY2kpCgkJCQoJCQktLSBzZXQgcGl0Y2ggW2FuZCB2b2x1bWVdIG9ubHkgd2hlbiBz
aGlmdCBpcyBub3QgaGVsZAoJCQlpZiBub3Qga2V5InNoaWZ0IiB0aGVuCgkJCQlwb2tlKGVsLmFk
ZHIgKyB4eCwgdmFsKQoJCQkJbG9jYWwgdm9sX2FkZHIgPSBlbC5hZGRyICsgeHggKyBlbC5zdHJp
ZGUqMgoJCQkJaWYgKEB2b2xfYWRkciA9PSAweGZmKSBwb2tlKHZvbF9hZGRyLCAzMikgLS0gc2V0
IHZvbHVtZSB3aGVuIHVuZGVmaW5lZAoJCQllbmQKCQllbmQKCWVuZAoJCglyZXR1cm4gZWwKZW5k
CgoKLS0gZHVwZQpmdW5jdGlvbiBjcmVhdGVfdm9sdW1lX3NjcmliYmxlcihlbCkKCWVsLmluZGV4
IAk9IGVsLmluZGV4IG9yIGN0CgllbC5jbGljayAgCT0gY2hlY2twb2ludAoJZnVuY3Rpb24gZWw6
ZHJhdygpCgkJbGluZSgwLHNlbGYuaGVpZ2h0LTEsc2VsZi53aWR0aCxzZWxmLmhlaWdodC0xLDEp
CgkJZm9yIGk9MCw2MyBkbwoJCQlsb2NhbCB2YWwgPSBAKGVsLmFkZHIgKyBpKQoJCQlpZiAodmFs
IH49IDB4ZmYpIHRoZW4KCQkJbG9jYWwgeHggPSBpICogNgoJCQlsb2NhbCB5eSA9IGVsLmhlaWdo
dCAtIHZhbCAtIDEKCQkJcmVjdCh4eCsxLCB5eSwgeHggKyA0LCB5eSwgaT09cGxheWluZ19yb3co
ZWwuaW5kZXgpIGFuZCA3IG9yIDEyKQoJCQllbmQKCQllbmQKCWVuZAoJCglmdW5jdGlvbiBlbDpk
cmFnKG1zZykKCQlsb2NhbCB4eCAgPSBtaWQoMCwgbXNnLm14IFwgNiwgNjMpCgkJbG9jYWwgdmFs
ID0gbWlkKDAsIGVsLmhlaWdodCAtIG1zZy5teSwgOTkpCgkJcG9rZShlbC5hZGRyICsgeHgsIHZh
bCkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBnZXRfdHJhY2tfc2VsZWN0aW9uKHNl
bCkKCWxvY2FsIHgwLHkwLHgxLHkxID0gc2VsLngwLCBzZWwueTAsIHNlbC54MSwgc2VsLnkxCglp
ZiB5MCA_IHkxIG9yICh5MCA9PSB5MSBhbmQgeDAgPiB4MSkgdGhlbgoJCXgwLHkwLHgxLHkxID0g
eDEseTEseDAseTAKCWVuZAoJcmV0dXJuIHgwLHkwLHgxLHkxCmVuZAoKZnVuY3Rpb24gZ2V0X3Ry
YWNrX3NlbGVjdGlvbl9zaXplKHRkYXQpCglpZiAobm90IHRkYXQpIHJldHVybiAwCglpZiAobm90
IHRkYXQuc2VsKSByZXR1cm4gMAoJbG9jYWwgc2VsID0gdGRhdC5zZWwKCWxvY2FsIHgwLHkwLHgx
LHkxID0gZ2V0X3RyYWNrX3NlbGVjdGlvbihzZWwpCglyZXR1cm4gbWF4KHgwLXgxLCB5MC15MSkK
ZW5kCgoKCmxvY2FsIGZ4X2lucHV0ID0gewoJWyIwIl0gPSAiXDAiLCBbIi4iXSA9ICJcMCIsCglb
IjEiXSA9ICJzIiwgcz0icyIsCglbIjIiXSA9ICJ2Iiwgdj0idiIsCglbIjMiXSA9ICItIiwgWyIt
Il0gPSAiLSIsIAoJWyI0Il0gPSAiPCIsIFsiPCJdID0gIjwiLCAKCVsiNSJdID0gIj4iLCBbIj4i
XSA9ICI_IiwgCglbIjYiXSA9ICJhIiwgYSA9ICJhIiwgQSA9ICJBIiwKCVsiNyJdID0gImIiLCBi
ID0gImIiLCBCID0gIkIiLAoJWyI4Il0gPSAidCIsIFsidCJdID0gInQiLAoJWyI5Il0gPSAiKyIs
IFsiKyJdID0gIisiLAoJdyA9ICJ3IiwgCglyID0gInIiLCBjID0gImMiLCBkID0gImQiLCAKCXAg
PSAicCIsCglmID0gImYiLCAtLSBmYWRlICgwLjIuMWMpCgltID0gIm0iLCBNID0gIk0iLCAtLSBh
cnAgc3BkIDEKCW4gPSAibiIsIE4gPSAiTiIsIC0tIGFycCBzcGQgMgoJbyA9ICJvIiwgTyA9ICJP
IiAtLSBvcm5hbWVudCAoMi1ub3RlIGFycCB3LyBzcGQgcGFyYW1ldGVyKQp9CgpmdW5jdGlvbiBj
bGVhcl9ub3RlcyhhZGRyMCwgYWRkcjEsIHgwLCB4MSkKCXgwID0geDAgb3IgMAoJeDEgPSB4MSBv
ciA5Cglmb3IgYWRkcj1hZGRyMCwgYWRkcjEgZG8KCQlpZiAoeDA8PTEpIHBva2UoYWRkciwweGZm
KQoJCWlmICh4MDw9MyBhbmQgeDE_PTIpIHBva2UoYWRkcis2NCwweGZmKQoJCWlmICh4MDw9NSBh
bmQgeDE_PTQpIHBva2UoYWRkcisxMjgsMHhmZikKCQlpZiAoeDA8PTYgYW5kIHgxPj02KSBwb2tl
KGFkZHIrMTkyLDApCgkJaWYgKHgwPD04IGFuZCB4MT49NykgcG9rZShhZGRyKzI1NiwwKQkJCQkK
CWVuZAplbmQKCgpmdW5jdGlvbiB1cGRhdGVfdHJhY2tfZWRpdG9yKCkJCglsb2NhbCB0cmFja19h
ZGRyID0gMHg1MDAwMCArIGN0ICogMzI4Cglsb2NhbCByb3cwX2FkZHIgPSB0cmFja19hZGRyICsg
OAoJbG9jYWwgc3BkX2FkZHIgPSB0cmFja19hZGRyICsgMgoJbG9jYWwgc3RyaWRlID0gNjQKCWxv
Y2FsIG1heF9hZGRyID0gcm93MF9hZGRyICsgNjMKCQoJbG9jYWwgbGFzdF9jdXJfeCwgbGFzdF9j
dXJfeSA9IGN1cl94LCBjdXJfeQoJbG9jYWwgZW50ZXJlZF9meCA9IGZhbHNlCgkKCQoJLS0gY2Fu
IHBsYXkgZXZlbiB3aGVuIGN1cnNvciBpcyBub3QgaW4gcmFuZ2UKCWlmIChrZXlwKCJzcGFjZSIp
IGFuZCBtb2RlID09ICJ0cmFjayIpIHRoZW4KCQlpZiAoc29tZXRoaW5nX2lzX3BsYXlpbmcpIHRo
ZW4KCQkJLS0gc3RvcCBhbGwgYXVkaW8gd2hlbiBzb21ldGhpbmcgd2FzIHBsYXlpbmcKCQkJbm90
ZSgpCgkJZWxzZQoJCQoJCQlsb2NhbCBzdGFydF9yb3cgPSAwCgkJCS0tIHBsYXlyb3VuZCBjdXJz
b3IgKGN0cmwrc3BhY2UpIG9yIGdyb3VwZCBvZiA4IChzaGlmdCtzcGFjZSkKCQkJaWYgY3VyX3kg
Pj0gcm93MF9hZGRyIHRoZW4KCQkJCWlmIChrZXkiY3RybCIpIHN0YXJ0X3JvdyA9IChjdXJfeS1y
b3cwX2FkZHIpCgkJCQlpZiAoa2V5InNoaWZ0Iikgc3RhcnRfcm93ID0gKGN1cl95LXJvdzBfYWRk
cikgJiB_MHg3CgkJCWVuZAoJCQkKCQkJLS0gcGxheSBvbiBjaGFubmVsIDkKCQkJc2Z4KGN0LCA5
LCBzdGFydF9yb3csIDApCgkJCQoJCWVuZAoJZW5kCgkKCS0tIHNlbGVjdAoJCglpZiAoa2V5KCJj
dHJsIikgYW5kIGtleXAoImEiKSkgdGhlbgoJCWNoZWNrcG9pbnQoKQoJCXRkYXRbY3RdLnNlbCA9
IHt4MD0wLHkwPTAseDE9OCx5MT02M30KCWVuZAoJCgktLSBwYXN0ZSBub3RlcwoJaWYga2V5KCJj
dHJsIikgYW5kIGtleXAoInYiKSB0aGVuCgkJY2hlY2twb2ludCgpCgkJbG9jYWwgZGF0ID0gdW5w
b2QoZ2V0X2NsaXBib2FyZCgpKQoJCWlmIChkYXQgYW5kIHR5cGUoZGF0Lm5vdGVzKSA9PSAidXNl
cmRhdGEiKSB0aGVuCgkJCWxvY2FsIHgwPXRvbnVtKGRhdC54MCkgb3IgMAoJCQlsb2NhbCB4MT10
b251bShkYXQueDEpIG9yIDgKCQkJbG9jYWwgbWF4eSA9IG1pbihkYXQubm90ZXM6aGVpZ2h0KCkt
MSwgNjMtKGN1cl95LXJvdzBfYWRkcikpCgkJCS0tbm90aWZ5KHN0cmluZy5mb3JtYXQoInBhc3Rp
bmcgJWQgJWQgJWQiLHgwLCB4MSwgbWF4eSkpCgkJCW5vdGlmeSgicGFzdGVkICIuLihtYXh5KzEp
Li4iIG5vdGVzIikKCQkJZm9yIHk9MCxtYXh5IGRvCgkJCQlpZiAoeDA8PTEpIHBva2UoY3VyX3kr
eSxkYXQubm90ZXM6Z2V0KDAseSkpCgkJCQlpZiAoeDA8PTMgYW5kIHgxPj0yKSBwb2tlKGN1cl95
K3krNjQsZGF0Lm5vdGVzOmdldCgxLHkpKQoJCQkJaWYgKHgwPD01IGFuZCB4MT49NCkgcG9rZShj
dXJfeSt5KzEyOCxkYXQubm90ZXM6Z2V0KDIseSkpCgkJCQlpZiAoeDA8PTYgYW5kIHgxPj02KSBw
b2tlKGN1cl95K3krMTkyLGRhdC5ub3RlczpnZXQoMyx5KSkKCQkJCWlmICh4MDw9OCBhbmQgeDE_
PTcpIHBva2UoY3VyX3kreSsyNTYsZGF0Lm5vdGVzOmdldCg0LHkpKQoJCQllbmQKCQllbHNlaWYg
ZGF0IGFuZCB0eXBlKGRhdC5zZngpID09ICJ1c2VyZGF0YSIgdGhlbgoJCQlkYXQuc2Z4OnBva2Uo
MHg1MDAwMCArIGN0MCozMjgpCgkJCXNmeF90aHVtYj17fSAtLSBpbnZhbGlkYXRlIHRodW1icwoJ
CQlub3RpZnkoInBhc3RlZCAiLi4oI2RhdC5zZnggXCAzMjgpLi4gIiBzZngiKQoJCWVsc2UKCQkJ
bm90aWZ5KCJjb3VsZCBub3QgZmluZCBub3RlIGRhdGEgb3Igc2Z4IHRvIHBhc3RlIikKCQllbmQK
CWVuZAoJCgktLSBvcGVyYXRpb25zIG9uIHNlbGVjdGlvbnMKCQoJaWYgKGZvY3VzID09ICJ0cmFj
a19pdGVtIikgdGhlbgoJCS0tIG9wZXJhdGlvbnMgb24gdGhlIHNmeAoJCWlmIGtleSJjdHJsIiBh
bmQgKGtleXAiYyIgb3Iga2V5cCJ4IikgdGhlbgoJCQktLSBjb3B5IGEgd2hvbGUgc2Z4IChsYXRl
cjogbXVsdGlwbGUgc2Z4IGNhbiBqdXN0IGJlIGxvbmdlciB1c2VyZGF0YSkKCQkJLS0gbGF0ZXI6
IHZhcmlhdGlvbiB0byBzdXBwb3J0IHZhcmlhYmxlIGxlbmd0aCBzZnggaW4gY29sbGVjdGlvbi4K
CQkJLS0gYXZvaWQgbmVlZGluZyB0byBkZWNpZGUgaWYgInNmeGVzIiAoYmxlZ2gpIGlzIHBsdXJh
bCBvZiBzZngKCQkJCgkJCXNldF9jbGlwYm9hcmQocG9kKHsKCQkJCXNmeCA9IHVzZXJkYXRhKCJ1
OCIsKGN0MS1jdDArMSkqMzI4KTpwZWVrKDB4NTAwMDArY3QwKjMyOCkKCQkJfSwweDcse3BvZF90
eXBlPSJzZngifSkpCgkJCQoJCQlpZiAoa2V5cCJ4IikgdGhlbgoJCQkJLS0gY2xlYXIKCQkJCWZv
ciBpPWN0MCwgY3QxIGRvCgkJCQkJY2xlYXJfbm90ZXMoMHg1MDAwMCtpKjMyOCs4LDB4NTAwMDAr
aSozMjgrOCs2MykKCQkJCWVuZAoJCQkJY2xlYXJfbm90ZXMocm93MF9hZGRyKzAsIHJvdzBfYWRk
cis2MykKCQkJCW5vdGlmeSgiY3V0ICIuLihjdDEtY3QwKzEpLi4iIHNmeCIpCgkJCQlzZnhfdGh1
bWI9e30KCQkJZWxzZQoJCQkJbm90aWZ5KCJjb3BpZWQgIi4uKGN0MS1jdDArMSkuLiIgc2Z4IikK
CQkJZW5kCgkJCgkJZW5kCgllbHNlaWYgKHRkYXRbY3RdIGFuZCB0ZGF0W2N0XS5zZWwpIHRoZW4K
CQoJCWxvY2FsIHNlbCA9IHRkYXRbY3RdLnNlbAoJCWxvY2FsIHgwLHkwLHgxLHkxID0gZ2V0X3Ry
YWNrX3NlbGVjdGlvbih0ZGF0W2N0XS5zZWwpCgkJbG9jYWwgZGlkX2N1dCA9IGZhbHNlCgkJCgkJ
aWYgKHgwfj14MSBvciB5MH49eTEpIHRoZW4KCQkJLS0gc29tZSBvcGVyYXRpb25zIHNob3VsZG4n
dCBhcHBseSB0byBzaW5nbGUgY2VsIChkZXNlbGVjdCAvIGRlbGV0ZSkJCgkJCQoJCQktLSByZW1v
dmUgc2VsZWN0aW9uCgkJCWlmIChrZXlwKCJlbnRlciIpKSB0aGVuCgkJCQlpZiAodGRhdFtjdF0p
IHRkYXRbY3RdLnNlbCA9IG5pbCAKCQkJCXRkYXRbY3RdLnNlbCA9IHsKCQkJCQl4MD1jdXJfeCwg
eTA9Y3VyX3kgLSByb3cwX2FkZHIsCgkJCQkJeDE9Y3VyX3gsIHkxPWN1cl95IC0gcm93MF9hZGRy
CgkJCQl9CgkJCQljbGVhcl9rZXkoImVudGVyIikgLS0gZG9uJ3QgaW5zZXJ0IGEgbGluZQoJCQll
bmQKCQkKCQkJLS0gY2xlYXIgKGFsc28gdXNlIGFmdGVyIGN1dHRpbmcpIC0tIAoJCQktLSB0byBk
bzogYWxsb3cgY2xlYXJpbmcgYXQgdGhlIG5pYmJsZSBsZXZlbAoJCQlpZiAoa2V5cCgiYmFja3Nw
YWNlIikgb3Iga2V5cCgiZGVsZXRlIikgb3IgZGlkX2N1dCkgdGhlbgoJCQkJY2hlY2twb2ludCgp
CgkJCQljbGVhcl9ub3Rlcyhyb3cwX2FkZHIreTAsIHJvdzBfYWRkcit5MSwgeDAsIHgxKQoJCQll
bmQKCQkJCgkJZW5kCgkJCgkJLS0gY29weSBub3RlIGRhdGEgKGNhbiBkbyBvbiBzaW5nbGUgY2Vs
IHNlbGVjdGlvbiB0b28pCgkJLS0gYWx3YXlzIGFsbCB2YWxzIGJ1dCByZWNvcmQgcmFuZ2UgdG8g
d3JpdGUgb24gcGFzdGUKCQlpZiBrZXkoImN0cmwiKSBhbmQgKGtleXAoIngiKSBvciBrZXlwKCJj
IikpIHRoZW4KCQkJZGlkX2N1dCA9IGtleXAoIngiKQoJCQlsb2NhbCB1ZCA9IHVzZXJkYXRhKCJ1
OCIsNSx5MS15MCsxKQoJCQlmb3IgeD0wLDQgZG8KCQkJCWZvciB5PXkwLHkxIGRvCgkJCQkJdWQ6
c2V0KHgseS15MCxwZWVrKHJvdzBfYWRkcit4KjY0K3kpKQoJCQkJCWlmIChkaWRfY3V0KSBwb2tl
KHJvdzBfYWRkcit4KjY0K3ksIHggPCAzIGFuZCAweGZmIG9yIDApIC0tIGNsZWFyCgkJCQllbmQK
CQkJZW5kCgkJCXNldF9jbGlwYm9hcmQocG9kKHsKCQkJCW5vdGVzPXVkLAoJCQkJeDA9eDAsIHgx
PXgxCgkJCX0sNyx7cG9kX3R5cGU9Im5vdGVzIn0pKQoJCQkKCQkJbm90aWZ5KChkaWRfY3V0IGFu
ZCAiY3V0ICIgb3IgImNvcGllZCAiKS4uKHkxLXkwKzEpLi4iIG5vdGVzICIpCgkJCQoJCQktLW5v
dGlmeSgiY29waWVkICIuLih5MS15MCsxKS4uIiBub3RlcyAiLi5wb2R7eDAseDEseTAseTF9KSAt
LSBkZWJ1ZwoJCWVuZAoJCQkKCQkJCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0KCQktLVtbCgkJaWYgKHgwfj14MSBvciB5MH49eTEpIC0tIGxldCBzaW5nbGUtY2VsIHNl
bGVjdGlvbiBwYXNzIHRocm91Z2gKCQlhbmQgbm90IGtleSJzaGlmdCIgICAgLS0gbm90IHRyeWlu
ZyB0byBjaGFuZ2Ugc2l6ZSBvZiBzZWxlY3Rpb24KCQl0aGVuCgkJCXJlYWR0ZXh0KHRydWUpIC0t
IGRpc2NhcmQgYW55IGxlZnRvdmVyIGtleXByZXNzZXMKCQkJcmV0dXJuCgkJZW5kCgkJXV0KCQkt
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJZW5kCgkKCS0tIHRvIGRvOiBj
dXJfeSBwZXIgdHJhY2sKCS0tIGN1cnNvciBpc24ndCBpbiBjdXJyZW50IHRyYWNrOyBkb24ndCBh
bGxvdyBlZGl0aW5nCgkKCWlmIChjdXJfeSA8IHJvdzBfYWRkciBvciBjdXJfeSA_PSByb3cwX2Fk
ZHIgKyA2NCkgdGhlbgoJCgkJcmVhZHRleHQodHJ1ZSkgLS0gY29uc3VtZSAoYW5kIGlnbm9yZSkg
YW55IHRleHQgZW50cnkKCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
CQlyZXR1cm4JIAoJCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgllbmQK
CQoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLQoJLS0gY3Vyc29yIG1vdmVtZW50CgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkKCWlmIGtleSJjdHJsIiB0
aGVuCgkJaWYgKGtleXAoInVwIikpICBjdXJfeSAtPSA0CgkJaWYgKGtleXAoImRvd24iKSkgY3Vy
X3kgKz0gNAoJCQoJCWlmIChtb2RlID09ICJ0cmFjayIpIHRoZW4KCQkJaWYgKGtleXAoImxlZnQi
KSkgIGN1cl95IC09IDgKCQkJaWYgKGtleXAoInJpZ2h0IikpIGN1cl95ICs9IDgKCQllbHNlaWYg
bW9kZSA9PSAicGF0dGVybiIgdGhlbgoJCQktLSB1c2UgdHJhY2stanVtcGluZyBsb2dpYyBiZWxv
dwoJCQlpZiAoa2V5cCgibGVmdCIpKSAgY3VyX3ggLT0gOQoJCQlpZiAoa2V5cCgicmlnaHQiKSkg
Y3VyX3ggKz0gOQoJCWVuZAoJZWxzZQoJCgkJaWYgKGtleXAoImxlZnQiKSkgIGN1cl94IC09IDEK
CQlpZiAoa2V5cCgicmlnaHQiKSkgY3VyX3ggKz0gMQoJCWlmIChrZXlwKCJ1cCIpKSAgICBjdXJf
eSAtPSAxCgkJaWYgKGtleXAoImRvd24iKSkgIGN1cl95ICs9IDEKCQoJZW5kCgkKCWlmIChrZXlw
KCJwYWdldXAiKSkgICAgY3VyX3kgLT0gNAoJaWYgKGtleXAoInBhZ2Vkb3duIikpICBjdXJfeSAr
PSA0CgkKCQotLVtbCgl0byBkbzogaG93IHRvIGhhbmRsZSBsaW1pdHM-IHRyYWNrIHZzIHBhdHRl
cm4KCXdoaWxlIChjdXJfeSA8ICAweDUwMDA4K2N0KjMyOCswMCkgY3VyX3kgKz0gNjQKCXdoaWxl
IChjdXJfeSA_PSAweDUwMDA4K2N0KjMyOCs2NCkgY3VyX3kgLT0gNjQKXV0KCQoJCgktLSBnb2lu
ZyBvdmVyIHNpZGUgbWVhbnMgZGlmZnJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiBsYXlvdXQKCWlm
IChtb2RlID09ICJ0cmFjayIpIHRoZW4KCQlpZiAoY3VyX3ggPiA4KSB0aGVuCgkJCWN1cl94ID0g
MAoJCQljdXJfeSArPSA4CgkJZW5kCgkJaWYgKGN1cl94IDwgMCkgdGhlbgoJCQljdXJfeCA9IDgK
CQkJY3VyX3kgLT0gOAoJCWVuZAoJZW5kCgkKCWlmIChtb2RlID09ICJwYXR0ZXJuIikgdGhlbgoJ
CS0tIGp1bXAgdG8gcmlnaHQKCQktLSAxLiBmaW5kIG91dCBjdXJyZW50CgkJbG9jYWwgcGF0cyA9
IDB4MzAxMDAgKyBjcCAqIDIwCgkJbG9jYWwgY2hhbmkgPSBuaWwKCQlsb2NhbCBpMCxpMSA9IG5p
bCxuaWwKCQlpZiAoY3VyX3ggPiA4KSBpMCxpMT0wLDE1IC0tIGxvb3AgdHdpY2UKCQlpZiAoY3Vy
X3ggPCAwKSBpMCxpMT0xNSwwCgkJCgkJaWYgKGkwKSB0aGVuCgkJCWZvciBpXz1pMCxpMSxzZ24o
aTEtaTApIGRvCgkJCQlsb2NhbCBpID0gaV8lOCAtLSBsb29wIHR3aWNlIHNvIHRoYXQgY2FuIHdy
YXAgYXJvdW5kIGVtcHR5IGNoYW5uZWxzCgkJCQlpZiAocGVlayhwYXRzK2kpID09IGN0KSB0aGVu
CgkJCQkJY2hhbmkgPSBpCgkJCQllbHNlaWYgY2hhbmkgYW5kICgocGVlayhwYXRzKzkpICYgKDEg
PDwgaSkpID4gMCkgdGhlbgoJCQkJCWN1cl95IC09IGN0ICogMzI4CgkJCQkJY3QgPSBwZWVrKHBh
dHMraSkKCQkJCQljdXJfeSArPSBjdCAqIDMyOAoJCQkJCWN1cl94ICU9IDkKCQkJCQlyb3cwX2Fk
ZHIgPSAweDUwMDAwICsgKGN0ICogMzI4KSArIDgKCQkJCQkKCQkJCQl0ZGF0W2N0XSA9IHRkYXRb
Y3RdIG9yIHt9CgkJCQkJdGRhdFtjdF0uc2VsID0gewoJCQkJCQl4MD1jdXJfeCwgeTA9Y3VyX3kg
LSByb3cwX2FkZHIsCgkJCQkJCXgxPWN1cl94LCB5MT1jdXJfeSAtIHJvdzBfYWRkcgoJCQkJCX0K
CQkJCQlsYXN0X2N1cl94ID0gY3VyX3gKCQkJCQlsYXN0X2N1cl95ID0gY3VyX3kKCQkJCQkKLS0J
CQkJCXRyYWNrX3NlZ19lbFtpXTpzZXRfa2V5Ym9hcmRfZm9jdXModHJ1ZSkgLS0gdGVzdAotLQkJ
CQkJcmVmcmVzaF9ndWkgPSB0cnVlIC0tIG5vdCBuZWVkZWQsIGJ1dCB3aHkgZG9lcyBpdCBicmVh
ayBrYmQgaW5wdXQ-CgkJCQkJCgkJCQkJcmV0dXJuCgkJCQllbmQKCQkJZW5kCgkJCWN1cl94ID0g
bWlkKDAsY3VyX3gsOCkgLS0gc3RvcCBtb3ZpbmcKCQllbmQKCQkKCWVuZAoKCS0tIGluIGFueSBj
YXNlOiB3cmFwCgljdXJfeCAlPSA5CgkKCS0tIGVudGVyIGRhdGEKCQoJbG9jYWwgcSA9IDY0IC0t
IHN0cmlkZQoJCgktLSBrZXlfcGl0Y2g6IHVzZSBzY2FuY29kZXMgcmF0aGVyIHRoYW4gdGV4dGlu
cHV0CgkKCWlmIChjdXJfeCA9PSAwIGFuZCBub3Qga2V5ImN0cmwiKSAtLSAwLjIuMWU6IGN0cmwt
eiBldGMgcGFzc2VzIHRocm91Z2ggdG8gaGVyZSBub3cKCXRoZW4KCQlmb3IgaT0xLCNrZXlfcGl0
Y2ggZG8KCQkJaWYga2V5cChzdWIoa2V5X3BpdGNoLGksaSkpIHRoZW4KCQkJCWNoZWNrcG9pbnQo
KQoJCQkJcG9rZShjdXJfeSwgMzUraSArIChjb2N0KjEyLTQ4KSkKCQkJCWlmIChwZWVrKGN1cl95
K3EpICAgPT0gMHhmZikgcG9rZShjdXJfeSArIHEsICAgY2kpICAgLS0gc2V0IGluc3QKCQkJCWlm
IChwZWVrKGN1cl95K3EqMikgPT0gMHhmZikgcG9rZShjdXJfeSArIHEqMiwgY3ZvbCkgLS0gc2V0
IHZvbHVtZQoJCQkJCgkJCQktLSBwbGF5IHRoZSB0cmFjayBmcm9tIHRoYXQgbm90ZQoJCQkJc2Z4
KGN0LCA5LCBjdXJfeS1yb3cwX2FkZHIsIDEpCgkJCQljdXJfeSArPSAxCgkJCWVuZAoJCWVuZAoJ
ZW5kCgkKCWlmIChrZXlwKCJkZWwiKSBvciAoa2V5cCgiYmFja3NwYWNlIikgYW5kIGN1cl95ID4g
cm93MF9hZGRyKSkgdGhlbgoJCWNoZWNrcG9pbnQoKQoJCWlmIChrZXlwKCJiYWNrc3BhY2UiKSkg
Y3VyX3kgLT0gMQoJCWZvciBhZGRyID0gY3VyX3ksIG1heF9hZGRyLTEgZG8KCQkJZm9yIGo9MCw0
IGRvCgkJCQlwb2tlKGFkZHIgKyBqKnN0cmlkZSwgcGVlayhhZGRyK2oqc3RyaWRlKzEpKQoJCQll
bmQKCQllbmQKCQlmb3Igaj0wLDQgZG8KCQkJcG9rZShtYXhfYWRkciArIGogKiBzdHJpZGUsIGog
PiAyIGFuZCAwIG9yIDB4ZmYpIC0tIGJsYW5rIGxhc3QgbGluZQoJCWVuZAoJZW5kCgkKCWlmIChr
ZXlwKCJlbnRlciIpIGFuZCBjdXJfeSA8IG1heF9hZGRyIGFuZCBnZXRfdHJhY2tfc2VsZWN0aW9u
X3NpemUodGRhdFtjdF0pIDwgMikgdGhlbgoJCWNoZWNrcG9pbnQoKQoJCWZvciBhZGRyID0gbWF4
X2FkZHIsIGN1cl95KzEsIC0xIGRvCgkJCWZvciBqPTAsNCBkbwoJCQkJcG9rZShhZGRyICsgaipz
dHJpZGUsIHBlZWsoYWRkcitqKnN0cmlkZS0xKSkKCQkJZW5kCgkJZW5kCgkJZm9yIGo9MCw0IGRv
CgkJCXBva2UoY3VyX3kgKyBqICogc3RyaWRlLCBqID4gMiBhbmQgMCBvciAweGZmKSAtLSBibGFu
ayBjdXJyZW50IGxpbmUKCQllbmQKCQljdXJfeSArPSAxCgllbmQKCQoJLS0tLS0KCQoJd2hpbGUg
cGVla3RleHQoKSBkbwoJCgkJbG9jYWwgYyA9IHJlYWR0ZXh0KCkKCQoJCS0tIGNoZWNrcG9pbnQo
KSAtLSB0b28gYWdyZXNzaXZlIQoJCQkKCQlpZiBrZXkiY3RybCIgdGhlbgoJCQktLSBkaXNyZWdh
cmQgaGVyZQoJCWVsc2VpZiAoY3VyX3ggPT0gNikgdGhlbgoJCQktLSBmeAoJCQkKCQkJLS0gdG8g
ZG86IG1hcCBQOCBudW1iZXJzIHRvIGNoYXJzLgoJCQktLSB0YWJsZSBjYW4gYWxzbyBiZSB1c2Vk
IHRvIGNoZWNrIGlzIGEgdmFsaWQgZWZmZWN0IGNoYXIKCQkJCgkJCWlmIChmeF9pbnB1dFtjXSkg
dGhlbgoJCQkJY2hlY2twb2ludCgpCgkJCQlwb2tlKGN1cl95ICsgcSozLCBvcmQoZnhfaW5wdXRb
Y10pKQoJCQkJY3VyX3kgKz0gMQoJCQkJZW50ZXJlZF9meCA9IHRydWUKCQkJZWxzZQoJCQkJLS1u
b3RpZnkoImVmZmVjdCBub3QgZm91bmQiKSAtLSBjb3VsZCBiZSAiICIgdG8gcGxheQoJCQllbmQK
CQllbHNlCgoJCQlsb2NhbCBudW0gPSBuaWwKCQkJCgkJCWlmIChjID49ICJhIiBhbmQgYyA8PSAi
ZiIpIG51bSA9IDEwICsgb3JkKGMpIC0gb3JkKCJhIikKCQkJaWYgKGMgPj0gIkEiIGFuZCBjIDw9
ICJGIikgbnVtID0gMTAgKyBvcmQoYykgLSBvcmQoIkEiKQoJCQlpZiAoYyA_PSAiMCIgYW5kIGMg
PD0gIjkiKSBudW0gPSAwMCArIG9yZChjKSAtIG9yZCgiMCIpCgkJCQoJCQlpZiAobnVtKSB0aGVu
CgkJCQlpZiAoY3VyX3ggPiAwKSBjaGVja3BvaW50KCkKCQkJCWlmIChjdXJfeCA9PSAxKSBwb2tl
KGN1cl95LCBudW0qMTIgKyBwZWVrKGN1cl95KSAlIDEyKQoJCQoJCQkJaWYgKGN1cl94ID49IDIg
YW5kIGN1cl94IDw9IDMgYW5kIHBlZWsoY3VyX3krcSkgPT0gMHhmZikgcG9rZShjdXJfeStxLDAp
CgkJCQlpZiAoY3VyX3ggPT0gMikgcG9rZShjdXJfeSArIHEsIHBlZWsoY3VyX3kgKyBxKSAlIDE2
ICsgbnVtICogMTYpCgkJCQlpZiAoY3VyX3ggPT0gMykgcG9rZShjdXJfeSArIHEsIHBlZWsoY3Vy
X3kgKyBxKSAmfjE1IHwgbnVtICkKCQkKCQkJCS0tIHZvbHVtZQoJCQkJaWYgKGN1cl94ID49IDQg
YW5kIGN1cl94IDw9IDUgYW5kIHBlZWsoY3VyX3krcSoyKSA9PSAweGZmKSBwb2tlKGN1cl95K3Eq
MiwwKQoJCQkJaWYgKGN1cl94ID09IDQpIHBva2UoY3VyX3kgKyBxKjIsIHBlZWsoY3VyX3kgKyBx
KjIpICUgMTYgKyBudW0gKiAxNikKCQkJCWlmIChjdXJfeCA9PSA1KSBwb2tlKGN1cl95ICsgcSoy
LCBwZWVrKGN1cl95ICsgcSoyKSAmfjE1IHwgbnVtICkKCQkKCQkJCS0tIGZ4cDogY29tbWVudGVk
IHVudGlsIHRoZSBtaXhlciBjYW4gZGVhbCB3aXRoIHRoZW0hCgkJCQkKCQkJCWlmIChjdXJfeCA_
PSA3IGFuZCBjdXJfeCA8PSA4IGFuZCBwZWVrKGN1cl95K3EqNCkgPT0gMHhmZikgcG9rZShjdXJf
eStxKjQsMCkKCQkJCWlmIChjdXJfeCA9PSA3KSBwb2tlKGN1cl95ICsgcSo0LCBwZWVrKGN1cl95
ICsgcSo0KSAlIDE2ICsgbnVtICogMTYpCgkJCQlpZiAoY3VyX3ggPT0gOCkgcG9rZShjdXJfeSAr
IHEqNCwgcGVlayhjdXJfeSArIHEqNCkgJn4xNSB8IG51bSApCgkJCQlpZiAoY3VyX3ggPiAwKSBj
dXJfeSArPSAxCgkJCQkKCQkJCQoJCQkJLS1jdXJfeSArPSAxCgkJCQktLWlmIChjdXJfeCA_IDEp
IGN1cl95ICs9IDEKCQkJZW5kCgkJCQoJCQktLSAuIGJ1dHRvbiB0byBzZXQgd2hvbGUgYnl0ZSBm
b3IgCgkJCWlmIChjID09ICIuIikgdGhlbgoJCQkJY2hlY2twb2ludCgpCgkJCQlpZiAoY3VyX3gg
PT0gMCBvciBjdXJfeCA9PSAxKSBwb2tlKGN1cl95ICsgcSowLCAweGZmKSBjdXJfeSArPSAxCgkJ
CQlpZiAoY3VyX3ggPT0gMiBvciBjdXJfeCA9PSAzKSBwb2tlKGN1cl95ICsgcSoxLCAweGZmKQoJ
CQkJaWYgKGN1cl94ID09IDQgb3IgY3VyX3ggPT0gNSkgcG9rZShjdXJfeSArIHEqMiwgMHhmZikK
CQkJCS0taWYgKGN1cl94ID09IDYpICAgICAgICAgICAgICAgcG9rZShjdXJfeSArIHEqMywgMCkg
LS0gaGFuZGxlZCBhYm92ZQoJCQkJaWYgKGN1cl94ID4gIDYpICAgICAgICAgICAgICAgcG9rZShj
dXJfeSArIHEqNCwgMCkKCQkJCWlmIChjdXJfeCA_IDApIGN1cl95ICs9IDEKCQkJZW5kCgkJCQoJ
CWVuZAoJCgllbmQKCQoJLS0gY3Vyc29yIG1vdmVtZW50IHdyYXBzIHdpdGhpbiB0cmFjawoJd2hp
bGUgKGN1cl95IDwgcm93MF9hZGRyKSBjdXJfeSArPSA2NAoJd2hpbGUgKGN1cl95ID49IHJvdzBf
YWRkciArIDY0KSBjdXJfeSAtPSA2NAoJCgktLSB2ZXJ0aWNhbCBjdXJzb3IgbW92ZW1lbnQgaW4g
cGF0dGVybiBtb2RlOiBhdXRvLXNjcm9sbAoJaWYgKGN1cl95IH49IGxhc3RfY3VyX3kgYW5kIG1v
ZGUgPT0gInBhdHRlcm4iKSB0aGVuCgkJbG9jYWwgcm93ID0gY3VyX3kgLSByb3cwX2FkZHIKCQkK
CQktLSBrZWVwIGN1cnNvciB3aXRoaW4gcmVsYXRpdmUgcm93IDQsMTIgKCo4ID0gMzJweCw5NnB4
KQoJCXBhdHRlcm5fY29udGVudHMueSA9IG1pZCgzMiAtIHJvdyAqIDgsIHBhdHRlcm5fY29udGVu
dHMueSwgOTYgLSByb3cqOCkKCQkKCQktLSBjbGFtcAoJCS0tcGF0dGVybl9jb250ZW50cy55ID0g
bWlkKDAsIDY0IC0gcm93ICogOCwgLS0gcmVmOiBwbGF5YmFjayBmb2xsb3dpbmcKCQlwYXR0ZXJu
X2NvbnRlbnRzLnkgPSBtaWQoMCwgcGF0dGVybl9jb250ZW50cy55LAoJCQkgcGF0dGVybl9jb250
ZW50cy5wYXJlbnQuaGVpZ2h0IC0gcGF0dGVybl9jb250ZW50cy5oZWlnaHQpCgllbmQKCgktLSBj
dXJzb3IgbW92ZW1lbnQgbW9kaWZpZXMgc2VsZWN0aW9uCgkKCWlmIHRkYXRbY3RdIGFuZCAoY3Vy
X3ggfj0gbGFzdF9jdXJfeCBvciBjdXJfeSB_PSBsYXN0X2N1cl95KQoJdGhlbgoJCQoJCS0tIGRl
ZmF1bHQgdG8gc2VsZWN0aW9uIG9mIGxhc3QgY3Vyc29yIHBvc2l0aW9uCgkJdGRhdFtjdF0uc2Vs
ID0gdGRhdFtjdF0uc2VsIG9yCgkJewoJCQl4MCA9IGxhc3RfY3VyX3gsIHgxID0gbGFzdF9jdXJf
eCwKCQkJeTAgPSBsYXN0X2N1cl95IC0gcm93MF9hZGRyLAoJCQl5MSA9IGxhc3RfY3VyX3kgLSBy
b3cwX2FkZHIKCQl9CgoKCQlpZiBrZXkic2hpZnQiIGFuZCBub3QgZW50ZXJlZF9meCB0aGVuCgkJ
CWNoZWNrcG9pbnQoKQoJCQktLSBob2xkaW5nIHNoaWZ0IChhbmQgbm90IGZvciBlbnRlcmluZyBh
biBmeCBsaWtlIDwpCgkJCXRkYXRbY3RdLnNlbC54MSA9IGN1cl94CgkJCXRkYXRbY3RdLnNlbC55
MSArPSAoY3VyX3kgLSBsYXN0X2N1cl95KQoJCWVsc2UKCQoJCQktLSB3aGVuIGN1cnNvciBjaGFu
Z2VzLCBhbmQgc2VsZWN0aW9uIGlzIGEgc2luZ2xlIGNlbCwKCQkJLS0gbW92ZSBzZWxlY3Rpb24g
d2l0aCBjdXJzb3IKCQkKCQkJbG9jYWwgeDAseTAseDEseTEgPSBnZXRfdHJhY2tfc2VsZWN0aW9u
KHRkYXRbY3RdLnNlbCkKCQkJCgkJCWlmIHgwPT14MSBhbmQgeTA9PXkxIHRoZW4KCQkJCXRkYXRb
Y3RdLnNlbD17CgkJCQkJeDAgPSBjdXJfeCwgeDEgPSBjdXJfeCwKCQkJCQktLSB0byBkbzogZml4
IGF3a3dhcmQgY2hhbmdlIGluIG1lYW5pbmcgYmV0d2VlbiBjdXJzb3IgLyBzZWxlY3Rpb25zCgkJ
CQkJLS0gbWF5YmUgbmljZSB0aGF0IGl0IGluY2x1ZGVzIHRyYWNrIHRob3VnaAoJCQkJCXkwID0g
dGRhdFtjdF0uc2VsLnkwICsgKGN1cl95IC0gbGFzdF9jdXJfeSksCgkJCQkJeTEgPSB0ZGF0W2N0
XS5zZWwueTEgKyAoY3VyX3kgLSBsYXN0X2N1cl95KQoJCQkJfQoJCQllbHNlCgkJCQktLSBjbGVh
ciBzZWxlY3Rpb24KCQkJCXRkYXRbY3RdLnNlbCA9IG5pbAoJCQllbmQKCQllbmQKCQkKCWVuZAoJ
CgkKZW5kCgotLSBhcHBsaWVkIGV2ZW4gd2hlbiBmb2N1cyBpcyBvbiB0cmFjawpmdW5jdGlvbiB1
cGRhdGVfcGF0dGVybl9lZGl0b3JfcGxheWJhY2soKQoJbG9jYWwgdHJhY2tfYWRkciA9IDB4NTAw
MDAgKyBjdCAqIDMyOAoJbG9jYWwgcm93MF9hZGRyID0gdHJhY2tfYWRkciArIDgKCWxvY2FsIHNw
ZF9hZGRyID0gdHJhY2tfYWRkciArIDIKCQoJaWYgKGtleXAoInNwYWNlIikpIHRoZW4KCQlpZiAo
c29tZXRoaW5nX2lzX3BsYXlpbmcpIHRoZW4KCQkJLS0gc3RvcCBhbGwgYXVkaW8gd2hlbiBzb21l
dGhpbmcgd2FzIHBsYXlpbmcKCQkJbm90ZSgpCgkJZWxzZQoJCQkKCQkJbG9jYWwgdGlja19vZmZz
ZXQgPSAwCgkJCWlmIGtleSJzaGlmdCIgYW5kIGN1cl95ID49IHJvdzBfYWRkciB0aGVuCgkJCQkt
LSBob2xkIHNoaWZ0IHRvIHBsYXkgZnJvbSBncm91cCBvZiA4LiAKCQkJCWxvY2FsIHN0YXJ0X3Jv
dyA9IChjdXJfeS1yb3cwX2FkZHIpICYgfjB4NwoJCQkJdGlja19vZmZzZXQgPSBzdGFydF9yb3cg
KiAoQHNwZF9hZGRyKQoJCQllbmQKCQkJaWYga2V5ImN0cmwiIGFuZCBjdXJfeSA_PSByb3cwX2Fk
ZHIgdGhlbgoJCQkJLS0gaG9sZCBjdHJsIHRvIHBsYXkgZnJvbSBjdXJyZW50IHJvdwoJCQkJbG9j
YWwgc3RhcnRfcm93ID0gKGN1cl95LXJvdzBfYWRkcikKCQkJCXRpY2tfb2Zmc2V0ID0gc3RhcnRf
cm93ICogKEBzcGRfYWRkcikKCQkJZW5kCgkJCW11c2ljKGNwLCBuaWwsbmlsLG5pbCwgdGlja19v
ZmZzZXQpIAoJCQlmb2xsb3dpbmdfcGxheWJhY2sgPSB0cnVlCgkJZW5kCgllbmQKZW5kCgpmdW5j
dGlvbiB1cGRhdGVfcGF0dGVybl9lZGl0b3IoKQoKCWlmICgga2V5ImN0cmwiIGFuZCAoa2V5cCJj
IiBvciBrZXlwIngiKSkgdGhlbgoJCWxvY2FsIHVkPXVzZXJkYXRhKCJ1OCIsMjAgKiAoY3AxLWNw
MCsxKSk6cGVlaygweDMwMTAwICsgY3AwKjIwKQoJCXNldF9jbGlwYm9hcmQocG9kKHsKCQkJcGF0
dGVybj11ZAoJCX0sNyx7cG9kX3R5cGU9InBhdHRlcm4ifSkpCgkJCgkJaWYga2V5IngiIHRoZW4K
CQkJZm9yIGk9Y3AwLGNwMSBkbyBjbGVhcl9wYXR0ZXJuKGkpIGVuZAoJCQlub3RpZnkoImN1dCAi
Li4oY3AxLWNwMCsxKS4uIiBwYXR0ZXJucyIpCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCWVsc2UK
CQkJbm90aWZ5KCJjb3BpZWQgIi4uKGNwMS1jcDArMSkuLiIgcGF0dGVybnMiKQoJCWVuZAoJZW5k
CgkKCWlmIChrZXkiY3RybCIgYW5kIGtleXAidiIpIHRoZW4KCQljaGVja3BvaW50KCkKCQlsb2Nh
bCBkYXQgPSB1bnBvZChnZXRfY2xpcGJvYXJkKCkpCgkJaWYgKGRhdCBhbmQgdHlwZShkYXQucGF0
dGVybikgPT0gInVzZXJkYXRhIikgdGhlbgoJCQlkYXQucGF0dGVybjpwb2tlKDB4MzAxMDAgKyBj
cDAqMjApCgkJCW5vdGlmeSgicGFzdGVkICIuLigjZGF0LnBhdHRlcm5cMjApLi4iIHBhdHRlcm5z
IikKCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJZWxzZQoJCQlub3RpZnkoImNvdWxkIG5vdCBwYXN0
ZSBwYXR0ZXJuIikKCQllbmQKCWVuZAplbmQKCjo6IHVuZG8ubHVhCi0tW1twb2RfZm9ybWF0PSJy
YXciLGNyZWF0ZWQ9IjIwMjQtMDMtMzAgMTk6MDM6MTkiLG1vZGlmaWVkPSIyMDI1LTEwLTI4IDA4
OjIxOjA1IixyZXZpc2lvbj0yNTc0XV0KLS1bWwoKCXNpbmdsZSB1bmRvIHN0YWNrIGZvciB3aG9s
ZSAuc2Z4IGZpbGUKCl1dCgpmdW5jdGlvbiBpbml0X3VuZG8oKQoKCXVuZG9fc3RhY2sgPSBjcmVh
dGVfdW5kb19zdGFjaygKCQlmdW5jdGlvbigpCgkJCWxvY2FsIG1lbSA9IHVzZXJkYXRhKCJ1OCIs
MHg0MDAwMCk6cGVlaygweDQwMDAwKQoJCQlsb2NhbCByYW5nZXMgPSB7Y2kwLGNpMSxjaTIsIGN0
MCxjdDEsY3QyLCBjcDAsY3AxLGNwMn0KCQkJcmV0dXJuIHttZW0sdGRhdCxtb2RlLGNpLGN0LGNw
LHJhbmdlc30KCQllbmQsCgkJZnVuY3Rpb24oc3RhdGUpCgkJCXN0YXRlWzFdOnBva2UoMHg0MDAw
MCkKCQkJdGRhdCxtb2RlLGNpLGN0LGNwPXN0YXRlWzJdLHN0YXRlWzNdLHN0YXRlWzRdLHN0YXRl
WzVdLHN0YXRlWzZdCgkJCWNpMCxjaTEsY2kyLCBjdDAsY3QxLGN0MiwgY3AwLGNwMSxjcDIgPSB1
bnBhY2soc3RhdGVbN10pCgkJZW5kLAkJCgkJLS0gdXNlIHJhdyBiaW5hcnkgZW5jb2Rpbmcgc3Vp
dGFibGUgZm9yIGZpeGVkIHNpemUgbWVtb3J5IGJsb2NrIChzYW1lIGFzIGdmeCkKCQktLT4gZmFz
dGVyIGVuY29kaW5nLCAgc21hbGxlciBwYXRjaGVzCi0tCQkweDExIC0tICgweDEgYmluYXJ5ICAw
eDEwIHB4dSByYXcpCgkJMHg4MSAtLSAoMHgxIGJpbmFyeSAgMHg4MCBweHUgcmxlKSAtLSBtdWNo
IGZhc3RlciwgdXNlcyBsZXNzIG1lbW9yeQoJCQoJKQoJCmVuZAoKZnVuY3Rpb24gY2hlY2twb2lu
dCgpCgl1bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQplbmQKCmZ1bmN0aW9uIHVuZG8oKQoJdW5kb19z
dGFjazp1bmRvKCkKCXNmeF90aHVtYj17fSAtLSBpbnZhbGlkYXRlIHRodW1icwoJcmVmcmVzaF9n
dWkgPSB0cnVlCmVuZAoKZnVuY3Rpb24gcmVkbygpCgl1bmRvX3N0YWNrOnJlZG8oKQoJc2Z4X3Ro
dW1iPXt9IC0tIGludmFsaWRhdGUgdGh1bWJzCglyZWZyZXNoX2d1aSA9IHRydWUKZW5kCjo6IHVw
ZGF0ZS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yMiAwNzozMjox
MSIsbW9kaWZpZWQ9IjIwMjUtMTAtMjggMDg6Mzg6MjMiLHJldmlzaW9uPTE0MzkxLHN0b3JlZD0i
MjAyMy0zNi0yOSAwNDozNjo0MCJdXQpnbG9iYWxfdCA9IDAKCi0tIG1hcCBrZXlib2FyZCBsZXR0
ZXJzIHRvIHBpdGNoZXMKCmtleV9waXRjaD0ienN4ZGN2Z2JobmptcTJ3M2VyNXQ2eTd1aTlvMHAi
Cgpzb21ldGhpbmdfaXNfcGxheWluZyA9IGZhbHNlCgpmdW5jdGlvbiBmb2xsb3dfcGxheWJhY2so
cGxheWluZ19wYXR0ZXJuKQoKCS0tIGNsaWNrIGFueXdoZXJlIChlLmcuIHNjcm9sbGJhcikgLT4g
dHVybiBvZmYgZm9sbG93aW5nCglsb2NhbCBteCxteSxtYiA9IG1vdXNlKCkKCWlmIChtYiA_IDAg
YW5kIGxhc3RfbWIgfj0gMCkgZm9sbG93aW5nX3BsYXliYWNrID0gZmFsc2UKCWlmIGtleSJsZWZ0
IiBvciBrZXkicmlnaHQiIG9yIGtleSJ1cCIgb3Iga2V5ImRvd24iIG9yCgkJa2V5InBhZ2V1cCIg
b3Iga2V5InBhZ2Vkb3duIgoJdGhlbgoJCWZvbGxvd2luZ19wbGF5YmFjayA9IGZhbHNlCgllbmQK
CQoKCWlmIChub3QgcGxheWluZ19wYXR0ZXJuIG9yIHBsYXlpbmdfcGF0dGVybiA8IDApIGZvbGxv
d2luZ19wbGF5YmFjayA9IGZhbHNlCglpZiAobW9kZSB_PSAicGF0dGVybiIpIGZvbGxvd2luZ19w
bGF5YmFjayA9IGZhbHNlCglpZiAobm90IGZvbGxvd2luZ19wbGF5YmFjaykgcmV0dXJuIC0tZmFs
c2UKCQoJaWYgKGNwIH49IHBsYXlpbmdfcGF0dGVybikgdGhlbgoJCWNwID0gcGxheWluZ19wYXR0
ZXJuCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbHNlCgkJLS0gZm9sbG93IGN1cnNvciByb3cgb2Yg
bGVmdG1vc3Qgbm9uLWxvb3BpbmcgY2hhbm5lbAoJCQoJCWxvY2FsIHJvdyA9IHN0YXQoNDAwICsg
c3RhdCg0NjcpLCA5KQoJCXBhdHRlcm5fY29udGVudHMueSA9IG1pZCgwLCA2NCAtIHJvdyAqIDgs
IAoJCQkgcGF0dGVybl9jb250ZW50cy5wYXJlbnQuaGVpZ2h0IC0gcGF0dGVybl9jb250ZW50cy5o
ZWlnaHQpCgllbmQKCQplbmQKCgpmdW5jdGlvbiBfdXBkYXRlKCkKCglsb2NhbCBwbGF5aW5nX3Bh
dHRlcm4gPSBzdGF0KDQ2NikKCglmb2xsb3dfcGxheWJhY2socGxheWluZ19wYXR0ZXJuKQoJCgkt
LSBmaW5kIG91dCB3aGljaCBjaGFubmVsIGN1cnJlbnQgaW5zdHJ1bWVudCBpcyBiZWluZyBwbGF5
ZWQgb24KCWNpX2NoYW5uZWwgPSAtMQoJZm9yIGk9MCwxNSBkbwoJCWlmIChjaV9jaGFubmVsID09
IC0xIGFuZCBzdGF0KDQwMCtpLDEpID09IGNpKSB0aGVuCgkJCWNpX2NoYW5uZWwgPSBpCgkJZW5k
CgllbmQKCQoJLS0gdXBkYXRlOiBzb21ldGhpbmdfaXNfcGxheWluZwoJc29tZXRoaW5nX2lzX3Bs
YXlpbmcgPSBmYWxzZQoJZm9yIGk9MCwxNSBkbwoJCWlmIChzdGF0KDQwMCtpLDEyKSAhPSAtMSkg
c29tZXRoaW5nX2lzX3BsYXlpbmcgPSB0cnVlIC0tIHNmeAoJCS0taWYgKHN0YXQoNDAwK2ksMSAp
ICE9IC0xKSBzb21ldGhpbmdfaXNfcGxheWluZyA9IHRydWUgLS0gaW5zdAoJZW5kCgkKCS0tIG9y
IGlmIHRoZXJlIGlzIFtyZWNlbnRseV0gc29tZSBnbG9iYWwgb3V0cHV0IChlLmcuIGVjaG8gb3Ig
cm9ndWUgbm9kZSkKCS0tIHdpdGhpbiBsYXN0IDAuMSBzZWNvbmRzICh3YW50IHRvIHJlc3BvbmQg
cXVpdGUgcXVpY2tseSwgYXQgdGhlIGNvc3QKCS0tIG9mIG5vdCB3b3JraW5nIHZlcnkgd2VsbCBm
b3Igc3RvY2F0dG8gc291bmRzIHRoYXQgYXJlIG1vc3RseSAwKQoJbGVuID0gc3RhdCg0NjUsMCww
eGUwMDAwKQoJbG9jYWwgZm91bmRfc2lnbmFsID0gZmFsc2UKCWZvciBpPTAsbGVuLTcsOCBkbwoJ
CWlmIChwZWVrOCgweGUwMDAwK2kpICE9IDApIGZvdW5kX3NpZ25hbCA9IHRydWUKCWVuZAoJaWYg
KGZvdW5kX3NpZ25hbCkgbGFzdF9mb3VuZF9zaWduYWxfdCA9IHQoKQoJaWYgKGxhc3RfZm91bmRf
c2lnbmFsX3QgYW5kIGxhc3RfZm91bmRfc2lnbmFsX3QgPiB0KCkgLSAwLjEpIHRoZW4KCQlzb21l
dGhpbmdfaXNfcGxheWluZyA9IHRydWUKCWVuZAoJCgoJaWYgKGd1aSkgZ3VpOnVwZGF0ZV9hbGwo
KQoJCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJaWYgKGd1
aSBhbmQgZ3VpOmdldF9rZXlib2FyZF9mb2N1c19lbGVtZW50KCkpIHJldHVybgoJLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQoJaWYgKGtleSJjdHJsIikgdGhl
bgoJCS0tIGNhbid0IHBsYXkgbm90ZSB3aGVuIGhvbGRpbmcgY29udHJvbAoJCQoJCWlmIChrZXlw
InoiKSB1bmRvKCkKCQlpZiAoa2V5cCJ5IikgcmVkbygpCgkKCWVsc2VpZiAoa2V5cCJzcGFjZSIp
IHRoZW4KCQktLSBpbnN0IG1vZGUgb25seSAtLSB0cmFjayAvIHBhdCBoYXMgb3duIGhhbmRsaW5n
CgkJaWYgbW9kZSA9PSAiaW5zdHJ1bWVudCIgdGhlbgoJCQlpZiAoc29tZXRoaW5nX2lzX3BsYXlp
bmcpIHRoZW4KCQkJCS0tIGtpbGwgYWxsIGNoYW5uZWxzCgkJCQktLSAoaW5jbHVkZXMgcGxheWlu
ZyBhbiBpbnN0cnVtbmV0IHRoYXQgaXMgc3RpbGwgZ2VuZXJhdGluZyBub24temVybyBzaWduYWwp
CgkJCQlub3RlKCkgCgkJCWVsc2UKCQkJCS0tIHBsYXkgY3VycmVudCBzZnggLyB0cmFjaywgYWx3
YXlzIG9uIGNoYW5uZWwgOQoJCQkJaWYgKGxhc3RfbW9kZSA9PSAidHJhY2siKSBzZngoY3QsIDkp
CgkJCQlpZiAobGFzdF9tb2RlID09ICJwYXR0ZXJuIikgbXVzaWMoY3ApCgkJCWVuZAoJCWVuZAoJ
ZWxzZWlmIG1vZGUgPT0gImluc3RydW1lbnQiIHRoZW4JCgkJCgkJbG9jYWwgcGl0Y2ggPSAtMQoJ
CS0taWYgKGtleXAoInNwYWNlIikpIHBpdGNoID0gNDggLS0gbWlkZGxlIGMKCQlpZiAoa2V5cCgi
LCIpKSBwaXRjaCA9IDYwIC0tIHRvIGRvCgkJCgkJZm9yIGk9MSwja2V5X3BpdGNoIGRvCgkJCWlm
IGtleShzdWIoa2V5X3BpdGNoLGksaSkpIHRoZW4KCQkJCXBpdGNoID0gMzUgKyBpICsgKGNvY3Qq
MTItNDgpCgkJCWVuZAoJCWVuZAoJCQoJCWlmIChwaXRjaCA_PSAwKSB0aGVuCgkJCW5vdGUoCgkJ
CQlwaXRjaCwgLS0gcGl0Y2gKCQkJCXBpdGNoIH49IGxhc3RfcGl0Y2ggYW5kIGNpIG9yIDI1NSwg
LS0gd29ya3Mgd2l0aCBpbnN0IHJldHJpZyBmbGFnIHNldAoJCQkJY3ZvbCwgICAgLS0gdm9sdW1l
CgkJCQkwLDAsICAgLS0gZWZmZWN0LCBlZmZlY3RfcAoJCQkJOCwgICAgIC0tIGNoYW5uZWwgaW5k
ZXggLS0gOCBzbyB0aGF0IGNhbiBwbGF5IHdpdGggbXVzaWMKCQkJCWZhbHNlICAtLSBkb24ndCBm
b3JjZSByZXRyaWdnZXIgKHJldHJpZ2dlciB3aGVuIHBpdGNoL2luc3QgY2hhbmdlcykJCQoJCQkJ
KQoJCWVsc2UKCQkJLS0gcmVsZWFzZSBub3RlIHdoZW4gdGhlcmUgaXMgbm8gbm90ZSBrZXkgaGVs
ZC4uCgkJCQoJCQlsb2NhbCBteCxteSxtYiA9IG1vdXNlKCkKCQkJaWYgKG1iID09IDAgb3IgbXgg
PiA4MCkgLS0gLi4gYW5kIG5vdCBob2xkaW5nIHBsYXkgYnV0dG9uIHcvIG1vdXNlCgkJCXRoZW4K
CQkJCW5vdGUoMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgOCkKCQkJZW5kCgkJCQoJCWVu
ZAoJCQoJCWxhc3RfcGl0Y2ggPSBwaXRjaAoJCQoJZW5kCgkKCglpZiAobW9kZSA9PSAidHJhY2si
IG9yIChtb2RlID09ICJwYXR0ZXJuIiBhbmQgZm9jdXMgPT0gInRyYWNrIikpIHRoZW4KCQl1cGRh
dGVfdHJhY2tfZWRpdG9yKCkKCWVsc2VpZiBtb2RlID09ICJwYXR0ZXJuIiB0aGVuCgkJdXBkYXRl
X3BhdHRlcm5fZWRpdG9yKCkKCWVsc2VpZiBtb2RlID09ICJpbnN0cnVtZW50IiB0aGVuCgkJdXBk
YXRlX2luc3RydW1lbnRfZWRpdG9yKCkKCWVuZAoJCgktLSBhcHBsaWVzIGV2ZW4gd2hlbiBmb2N1
cyBpcyBvbiB0cmFjawoJaWYgKG1vZGUgPT0gInBhdHRlcm4iKSB1cGRhdGVfcGF0dGVybl9lZGl0
b3JfcGxheWJhY2soKQoKCQoJLS0gc3dpdGNoIG1vZGVzCglpZiAoa2V5cCJ0YWIiKSB0aGVuCgkJ
aWYgKG1vZGUgPT0gImluc3RydW1lbnQiKSB0aGVuIG1vZGUgPSAidHJhY2siCgkJZWxzZWlmICht
b2RlID09ICJ0cmFjayIpIHRoZW4gbW9kZSA9ICJwYXR0ZXJuIgoJCWVsc2UgbW9kZSA9ICJpbnN0
cnVtZW50IiBlbmQKCQlzZXRfbW9kZShtb2RlKQoJZW5kCgkKCS0tIG5hdmlnYXRlIGl0ZW1zCgkK
CWlmIChjdXJfeCA9PSA2IGFuZCAobW9kZSA9PSAidHJhY2siIG9yIG1vZGUgPT0gInBhdHRlcm4i
KSkgdGhlbgoJCS0tIGNhbid0IG5hdmlnYXRlIHdoZW4gaW4gZnggY2hhbm5lbCEKCQktLSAtLCsg
bWVhbiBzbGlkZQoJZWxzZWlmIChrZXlwKCItIikgb3Iga2V5cCgiKyIpKSB0aGVuCgoJCWxvY2Fs
IGRkID0ga2V5cCgiLSIpIGFuZCAtMSBvciAxCgkJaWYgKG1vZGUgPT0gImluc3RydW1lbnQiKSBj
aSArPSBkZCBpZiAoa2V5InNoaWZ0IikgdGhlbiBleHRlbmRfaW5zdHJ1bWVudF9zZWxlY3Rpb24o
KSBlbHNlIGNpMCxjaTEsY2kyPWNpLGNpLGNpIGVuZAoJCWlmIChtb2RlID09ICJ0cmFjayIpICAg
ICAgY3QgKz0gZGQgaWYgKGtleSJzaGlmdCIpIHRoZW4gZXh0ZW5kX3RyYWNrX3NlbGVjdGlvbigp
ICAgICAgZWxzZSBjdDAsY3QxLGN0Mj1jdCxjdCxjdCBlbmQKCQlpZiAobW9kZSA9PSAicGF0dGVy
biIpICAgIGNwICs9IGRkIGlmIChrZXkic2hpZnQiKSB0aGVuIGV4dGVuZF9wYXR0ZXJuX3NlbGVj
dGlvbigpICAgIGVsc2UgY3AwLGNwMSxjcDI9Y3AsY3AsY3AgZW5kCgoJCQoKCQlyZWZyZXNoX2d1
aSA9IHRydWUKCWVuZAoJCgkKCQoJCglnbG9iYWxfdCArPSAxCgkKCS0tIGNvbnN1bWUgYW55IGxl
ZnRvdmVyIHRleHQgaW5wdXQKCXJlYWR0ZXh0KHRydWUpCgkKCQplbmQKCgoKOjogLmluZm8ucG9k
Ci0tW1twb2QsYXV0aG9yPSJ6ZXAiLGNyZWF0ZWQ9IjIwMjMtMTAtMTkgMTY6NTA6MDciLGljb249
dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAw
MDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcw
MTAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwNzA3MDcwNzBkMGQwZDBk
MGQwZDBkMDcwMTAxMDcwZDA3MDcwNzA3MGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMDcwZDA3MDcw
NzA3MDcwZDBkMGQwNzA3MDEwMTA3MGQwNzA3MDcwNzBkMGQwZDBkMDcwZDA3MDcwMTAxMDcwZDA3
MDcwZDBkMDcwZDBkMGQwNzBkMDcwNzAxMDEwNzBkMDcwNzBkMGQwZDA3MGQwZDBkMGQwZDA3MDEw
MTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYw
NjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAx
MDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxsb3djb2xfaWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTEy
LTE0IDAwOjQ3OjM4Iixub3Rlcz0iKGMpIExleGFsb2ZmbGUgR2FtZXMgTExQIixyZXZpc2lvbj0w
LHJ1bnRpbWU9MjMsdGl0bGU9IlBpY290cm9uIFRyYWNrZXIiLHZlcnNpb249IjAuMS4xZSIsd29y
a3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSM0NyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2Nh
dGlvbj0iZ3VpLmx1YSM3NzIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imluc3QubHVh
IzY4MCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZW52Lmx1YSMxIix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJ0cmFjay5sdWEjNzEzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJ1cGRhdGUubHVhIzQwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkYXRh
Lmx1YSM1OSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idW5kby5sdWEjMjQiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHts
b2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5z
ZngiLHdvcmtzcGFjZV9pbmRleD00fSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2lu
ZGV4PTR9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9N319XV0KOjogZ2Z4
Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDQtMDkgMDI6MzY6MDEiLG1vZGlmaWVk
PSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixyZXZpc2lvbj0wXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUSXlJREEzT2pNd09qQTBJaXh0YjJScFptbGxa
RDBpTWpBeU5TMHcKTkMweE5TQXdNem94TlRvME5pSXNjbVYyYVhOcGIyNDlNVEkwTXpNc2MzUnZj
bVZrUFNJeU1ESXpMVE0yTFRJNUlEQTBPak0yT2pRdwpJbDFkYkhvMEFQQUZBQUNiTmdBQThRcDdX
ekJkUFh0aWJYQTljSGgxQUVNZ0JRVUVJQWN3QndCSEJnRHhBU3htYkdGbmN6MHdMSEJoCmJsOTRQ
VFlJQU5wNVBTMDBMSHB2YjIwOU9IMHNPd0JYSndBWEFBY0VBQjhuUVFBZHZ3Y0FOekFISUFjd053
QUhPd0FkTUJBSElIOEEKVHljZ0IwQTdBQjktTUFlQUJ6QUhFRGtBR2xzUUVBVHc4RElBRXpBeUFC
OHdNUUFGY0JFWEVCY2dKMERrQVBBREZ6QW5FQmNRSi1BRQpCd0FIRUJjUUIxQW53d0QtQUZBSEFC
Y2dKLUFFSl9BSDRBZndMR0FBR1NBZ0VJRUJBRlFBRVFCVEFESUFCeUFLQVBFREJ5QUhJQmNBCkp4
QUhFQ2NnQndBbkFDY1FLQUVnQUJjUUFELXctNUxGQUIwZjhERUEtdzlTQkFRRUFCZlhBVDhBRndB
NkFCbXhCUVVFQUNjQUJ5QVgKSUJlc0FRODhBQnctb0NlZ01nQWNmMUFuRUNjUUoxQTJBQnhBWUFj
Z0Ixd0NEbTRERHpvQURTLXdDVEVBclA4RENBZ0VzQThRVUM0dwpMakFPQUE1QUh2QUZid0FjQVRr
Qk1VQkhRQWdBRHp3QUhURXdCekRUQXdOa0JROUFBQjBoSUJjT0JBQkhBQTk2QUIwZ0lHZHdBQUE1
CkJCOFFrUUY3Vk1oa0JQRC1BUUR3RUhGUjhMRng4S19SOEFNaDhKYkI4QUZCOEpUaDhBQkI4RDh4
OEVCeEVGRUxBSUlfVWZBX2NUQlIKNEFvQUlHRkFDZ0RBUFdId0lTSHdDVkZ3VWNCUkRRQlJJRUh3
QjJFTkFQQUtQR0h3SVVId0JtR1FRY0JCOENjaDhBTmg4Q0JSOEFaUgpvQkFBVVNaQjhBRnhFQUFp
UWJBUUFDRGdnUThBc0FkQnNFR3dVZkFtUWRDUkR3QXdDQ0hBRHdBZ0pWRVBBTEZCOEJsQnNFSHdK
bEhBCm9RMEFnRkdnUWZBbFljQ1Jad0NRR1ZHUVVmQWxZYkNoTmdBZ0drRU5BQ1JSd0EwQUFEUUFJ
TEN4TkFBYUd3MEFFSUEwQUdTZ1VRQkIKOENFUEFDQlJzQThBQURnQUVWRVBBRFNnVVJBUEFBQTZB
SEtnVVFCUjhCOVJTUUJFSldHUVlROEFBQzBBUjJHUVVSQThBRUZoZ0ZFZwpXZ0FCUEFBa0pYRVBB
Q0FaVVR3QVIzRndVVEFQQUNCaGdBOEFRaGtoVUNIWkFMY2tjWEJSUUVId0dFSHdJUThBOEJjWFVm
QWdVYkJCCjhBbUI4QUp4WUZGUVFmQVdZZkFmOFJMQXNmQUJjVkJoVUVIUUlVQ0JVQk1BOEFjVWtP
SGdnVkJSWUVIQThRTUFrZkFnOFJTQThRRGcKSkFEQVViRHhEdkFoOFJSdzhRSFFJZ0R3RWxHZzhR
N3dJdkVUY0lFd1FkQ0JRRkZ3UWJEeERmQWlVZEJSOEFKaE1HSEFrUk1BRUtBVApBUEFRWWRCQjhB
TkJNSUhBa1RCUmdFR1FZUkR4QWZBbFllQkI4QUpSRUpIQW9SVUFZWUJ4UUtId0tDNEMxUUx4QXND
aElGR1FRV0NCCm9GRVVBRkFCd0ZFQVFSWUFjREN4b0ZId0oxRnBBa0FDMGZBQUZnQ1NRYUJCRU5H
Z1FmQW9GZ0RDd2ZBQVVSQkJFRkdnUVFEUkxBQnkKQWtId0FwSHdBeFlBb2ZFRW9GSHdCeUh3REdF
WUFNQng4QVJSSUVFQVViRHhCSkJJQXZFRzhBcGg4QU5SOEFGaHNERkFVU0N4d0tFZwpRV0NCR0FC
d1VmQUVVZkFDY1hFQnNEQ2g0R0ZRUVVDUjhBZFJHQUR3Q0FWQjhBT0JZRkVnVVRDaDhBQkJZRUVn
c2ZBR1lmQUp0Z0xBCjhBUHhCUkJoTUpId0RmRURMZ0FnQ1dFVkFHQUU4UU1RWVVBVkFCQUJKd0R6
QkFsUjhBaEI4QVh4QVNCUlVKSHdEdEh3QzBFWEFEQUcKMFRCLUFIRVFrZkFQSWZBSlZBRHhKd2lo
VUNHQVVmQVRZZkFzY2ZBS1FmQ1JZZkFMVWZDUVVmQU1VZkNSTWZBT1VmQ3lVZkN6VWZDeQpZZkN5
Y2ZDd2dmQ3djZkN4WVJVQU9qSHctd0VBSDJYM0F3c2VNaWdFRC1jSEhnOHhBUDkxRXpJX0NKTUFC
MUFIRUNjQUowQmJCaUR3CkJRa0FneGNRQjNBSElBY1FGd0JQQUNmd1EwSUdTakFJQ0FTQUMyOHdS
eUJIOEJNNUFCeWZSeUJITUNkUUItQVZOQUVlRHpFQXJNQUgKQndTUURVQU5NQjBRRFdBQ0FBODhB
QjJBQjBBSE1CY1FCMkFDQUEtYUFCNFBNUUQtRDJNSEJ3UWdGekJiRGdRRUFBQVFBQzlBRjc4SgpE
Q3d4TmtrQThRQU9FQjBBRGdBT0RRQU5EZ0FkRGdBUEFDQU5FQW9BRWlBVkFBRVNBQTlXQUIxamtB
ZFFGeEJYb1FBdkI1QS1BQjBpCmdBZlVBSDhBVnhBWFVBZWdQd0FkTTNCSEVBSUFIM0E3QUEwUHVn
RXYtd00wRjlBM3NGZVFkM0IzY0ZlUU43QVg4RHBDQUI0cGQzQUMKQUMtd05ENENIZzh4QVAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTd4UWJUMDRmWDA9Cjo6
IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA5IDAyOjM2OjAxIixtb2Rp
ZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIscmV2aXNpb249MF1dCjo6IG1hcC8wLm1hcApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEl5SURBM09qTXdPakEwSWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB3Ck5DMHhOU0F3TXpveE5UbzBOaUlzY21WMmFYTnBiMjQ5T1RNME55eHpk
Rzl5WldROUlqSXdNak10TXpZdE1qa2dNRFE2TXpZNk5EQWkKWFYxc2VqUUFjQUFBQUY4UUFBRHdD
SHQ3WW0xd1BYVnpaWEprWVhSaEtDSnBNVFlpTERNeUF3QXZJakFCQVAtLS0tLS0tLS0tLS0tLQot
LS0tLS12eEVTSXBMR2hwWkdSbGJqMW1ZV3h6WlN4dVlXMWxQU0ptSWl4d1lXNWZlRDB3Q0FEQ2VU
MHdMSFJwYkdWZmFEMDFDUURBCmR6MDFMSHB2YjIwOU1YMTkKOjogW2VvY10K
:: bios/apps/themed.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTI4IDAyOjQzOjU5Iixtb2RpZmllZD0iMjAyNS0xMC0zMSAxMTowNDoxNiIs
cmV2aXNpb249NjY3LHN0b3JlZD0iMjAyMy0yNS0yOSAwOToyNTo1MCJdXQotLSB0aGVtZWQ6IFRo
ZW1lIEVkaXRvcgotLVtbCglzdHJhZGRsZXMgdHdvIHJvbGVzOiBvcGVyYXRlIGJvdGggYXMgYW4g
ZWRpdG9yICh1c2luZyB0aGUgdXN1YWwKCXdyYW5nbGVyIHBhdHRlcm4pIGJ1dCBhbHNvIGFzIGEg
Y2hvb3NlciAvIHByZXZpZXcsIGVpdGhlciBieSBkb3VibGUgY2xpY2tpbmcgCglvbiB0aGUgLnRo
ZW1lIGZpbGUsIG9yIGRvdWJsZSBjbGlja2luZyBbY3VzdG9tXSBpbiBzZXR0aW5ncyB0aGVtZSBs
aXN0LgoJCgktPiB0aGUgdHdvIGJ1dHRvbnMgW0NhbmNlbF0gYW5kIFtLZWVwXSBoYXZlIGNob29z
ZXIgc29ydCBvZiBzZW1hbnRpY3MgfgoJQ2FuY2VsIGNsb3NlcyB0aGUgd2luZG93IHdpdGhvdXQg
YW55IHByb21wdGluZyBmb3IgdW5zYXZlZCBjaGFuZ2VzLgoJKGZlZWxzIGZhaXIgZW5vdWdoIC0t
IGhhcHBlbnMgdXN1YWxseSB3aGVuIGp1c3QgbWVzc2luZyBhcm91bmQpCgkKCXVzaW5nIHRoZSB3
aW5kb3cgY2xvc2UgYnV0dG9uIHJlZHVjZXMgdG8gc2FtZSBiZWhhdmlvdXI6CgkJMS4gZmlyc3Qg
c2F2aW5nIC0_IHNhbWUgYXMgS2VlcAoJCTIuIGRpc2NhcmRpbmcgY2hhbmdlcyAvIG5vIGNoYW5n
ZXMgLT4gc2FtZSBhcyBDYW5jZWwKCQpdXQoKLS0gdHVybnMgb3V0IGRvbid0IG5lZWQgdG8gdHdl
YWsgYmVoYXZpb3VyIGZvciBzZXR0aW5ncyBjb250ZXh0OyBkZWxldGVtZQotLSBsb2NhbCBpc19l
ZGl0aW5nX2RlZmF1bHRfdGhlbWUgPSBlbnYoKS5hcmd2WzFdID09ICIvYXBwZGF0YS9zeXN0ZW0v
dGhlbWUucG9kIiAKCmxvY2FsIGN1cnJlbnRfayA9ICJkZXNrdG9wMCIKCmZ1bmN0aW9uIF9pbml0
KCkKCXBva2UoMHg0MDAwLCBnZXQoZmV0Y2giL3N5c3RlbS9mb250cy9saWwuZm9udCIpKQoJCgl3
aW5kb3d7CgkJd2lkdGg9MjQwLAoJCWhlaWdodD0xMzIsCgkJcmVzaXplYWJsZT1mYWxzZSwgLS0g
dG8gZG8KCQl0aXRsZT0iVGhlbWUgRWRpdG9yIgoJfQoJCgl0ZGF0ID0gCgkJZmV0Y2giL3JhbS9z
aGFyZWQvdGhlbWUucG9kIiBvcgoJCWZldGNoIi9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QiIG9y
CgkJe30KCQkKCXRkYXRfYXRfaW5pdCA9IHVucG9kKHBvZCh0ZGF0KSkKCQkKCWlmICh0eXBlKHRk
YXQuZGVza3RvcF9wYXR0ZXJuKSE9InVzZXJkYXRhIikgdGhlbgoJCXRkYXQuZGVza3RvcF9wYXR0
ZXJuID0gdXNlcmRhdGEoInU4IiwgOCw4KQoJZW5kCgoJCi0tZnVuY3Rpb24gd3JhbmdsZV93b3Jr
aW5nX2ZpbGUoc2F2ZV9zdGF0ZSwgbG9hZF9zdGF0ZSwgdW50aXRsZWRfZmlsZW5hbWUpCgoJd3Jh
bmdsZV93b3JraW5nX2ZpbGUoCgkJZnVuY3Rpb24oKQoJCQktLSBwcmludGgoIkBAIHNhdmluZyB0
aGVtZSIpCgkJCXJldHVybiB1bnBvZChwb2QodGRhdCkpCgkJZW5kLAoJCQoJCS0tIGxvYWQKCQlm
dW5jdGlvbih0ZGF0MCkKCQkJLS0gcHJpbnRoKCJAQCBsb2FkaW5nIHRoZW1lIikKCQkJdGRhdCA9
IHRkYXQwCgkJCWlmIChub3QgdGRhdCkgdGhlbiB0ZGF0ID0gCgkJCQlmZXRjaCIvcmFtL3NoYXJl
ZC90aGVtZS5wb2QiIG9yCgkJCQlmZXRjaCIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIiBvcgoJ
CQkJe30KCQkJZW5kCgkJCXN0b3JlX2xpdmVfY2hhbmdlcygpCgkJZW5kLAoJCQoJCS0tIGVkaXQg
dGhlIGRlZmF1bHQgY3VzdG9tIHRoZW1lIGJ5IGRlZmF1bHQKCQkiL2FwcGRhdGEvc3lzdGVtL3Ro
ZW1lLnBvZCIsIAoJCQoJCW5pbCxuaWwsIC0tIGhsb2MKCQkKCQktLSBjaGFuZ2VzIGhpbnQKCQlm
dW5jdGlvbigpIAoJCQktLSBvdGhlcndpc2UgdXN1YWwKCQkJcmV0dXJuIHBvZCh0ZGF0KQoJCWVu
ZCAKCSkKCQoJZ2VuZXJhdGVfZ3VpKCkKZW5kCmxvY2FsIGNhdGVnb3J5PXsKCXtbMF09IkRlc2t0
b3AiLCAiZGVza3RvcDAiLCJkZXNrdG9wMSIsImRlc2t0b3Bfc2hhZG93In0sCgl7WzBdPSJJY29u
IiwgICAgImljb24wIiwiaWNvbjEiLCJpY29uMiIsImljb24zIn0sCgl7WzBdPSJXaW5kb3ciLCAg
IndpbmRvd19mcmFtZSIsIndpbmRvd190aXRsZSIsIndpbmRvd19idXR0b24iLCJ3aW5kb3dfYm9y
ZGVyIn0sCgl7WzBdPSJEb3JtYW50IiwgImRvcm1hbnRfZnJhbWUiLCJkb3JtYW50X3RpdGxlIiwi
ZG9ybWFudF9idXR0b24iLCJkb3JtYW50X2JvcmRlciJ9LAoJe1swXT0iVG9vbGJhciIsICJ0b29s
YmFyX2JhY2siLCJ0b29sYmFyX2l0ZW0iLCJ0b29sYmFyX3NlbGVjdGVkIn0sCn0KCQpwY29scyA9
IHtbMF0gPQoJMCwyMCw0LDMxLDE1LDgsMjQsMiwKCTIxLDUsMjIsNiw3LDIzLDE0LDMwLAoJMSwx
NiwxNywxMiwyOCwyOSwxMywxOCwKCTE5LDMsMjcsMTEsMjYsMTAsOSwyNSwKfQpmdW5jdGlvbiBz
dG9yZV9saXZlX2NoYW5nZXMoKQoJc3RvcmUoIi9yYW0vc2hhcmVkL3RoZW1lLnBvZCIsdGRhdCkK
ZW5kCgkJCgkKZnVuY3Rpb24gY3JlYXRlX2NvbGJveChlbCkKCWxvY2FsIGVsID0gZ3VpOmF0dGFj
aChlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxvY2FsIGsgPSBzZWxmLmsKCQlyZWN0ZmlsbCgw
LDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMCkKCQlpZiAoaz09Y3VycmVudF9rIGFuZCBr
KSB0aGVuCgkJCXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDcpCgkJCXJlY3Qo
MSwxLHNlbGYud2lkdGgtMixzZWxmLmhlaWdodC0yLDApCgkJZW5kCgkJCgkJcmVjdGZpbGwoMSwx
LHNlbGYud2lkdGgtMixzZWxmLmhlaWdodC0yLHRvbnVtKHRkYXRba10pIG9yIDApCgllbmQKCQoJ
ZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWN1cnJlbnRfayA9IHNlbGYuawoJZW5kCgkKCXJldHVybiBl
bAplbmQKZnVuY3Rpb24gY3JlYXRlX3BhdHRlcm5fZWRpdG9yKGVsKQoJZnVuY3Rpb24gZWw6ZHJh
dygpCgkJcmVjdGZpbGwoMCwwLDEwMDAsMTAwMCwwKQoJCXNzcHIodGRhdC5kZXNrdG9wX3BhdHRl
cm4sMCwwLG5pbCxuaWwsMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQpCgllbmQKCQoJZnVuY3Rp
b24gZWw6Y2xpY2sobXNnKQoJCWxvY2FsIHggPSBtc2cubXggKiB0ZGF0LmRlc2t0b3BfcGF0dGVy
bjp3aWR0aCgpIC8gc2VsZi53aWR0aAoJCWxvY2FsIHkgPSBtc2cubXkgKiB0ZGF0LmRlc2t0b3Bf
cGF0dGVybjpoZWlnaHQoKSAvIHNlbGYuaGVpZ2h0CgkJZHJhd19jb2wgPSB0ZGF0LmRlc2t0b3Bf
cGF0dGVybjpnZXQoeCx5KSAhPSAwIGFuZCAwIG9yIDcKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFn
KG1zZykKCQlsb2NhbCB4ID0gbXNnLm14ICogdGRhdC5kZXNrdG9wX3BhdHRlcm46d2lkdGgoKSAv
IHNlbGYud2lkdGgKCQlsb2NhbCB5ID0gbXNnLm15ICogdGRhdC5kZXNrdG9wX3BhdHRlcm46aGVp
Z2h0KCkgLyBzZWxmLmhlaWdodAoJCXNldCh0ZGF0LmRlc2t0b3BfcGF0dGVybiwgeCwgeSwgZHJh
d19jb2wpCgkJc3RvcmVfbGl2ZV9jaGFuZ2VzKCkKCQkKCWVuZAoJCgkKCXJldHVybiBlbAplbmQK
ZnVuY3Rpb24gY3JlYXRlX3BhbGV0dGVfY2hvb3NlcihlbCkKCWZ1bmN0aW9uIGVsOmRyYXcobXNn
KQoJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwwKQoJCWxvY2FsIHd3
PXNlbGYud2lkdGhcOAoJCWxvY2FsIGhoPXNlbGYuaGVpZ2h0XDQKCQlmb3IgeT0wLDMgZG8KCQkJ
Zm9yIHg9MCw3IGRvCgkJCQlsb2NhbCBzeD14Knd3CgkJCQlsb2NhbCBzeT15KmhoCgkJCQlyZWN0
ZmlsbChzeCsxLHN5KzEsc3grd3ctMSxzeStoaC0xLHBjb2xzW3greSo4XSkKCQkJZW5kCgkJZW5k
CgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2sobXNnKQoJCWxvY2FsIHh4PW1pZCgwLG1zZy5teCAq
IDggLyBzZWxmLndpZHRoLCAgNylcMQoJCWxvY2FsIHl5PW1pZCgwLG1zZy5teSAqIDQgLyBzZWxm
LmhlaWdodCwgMylcMQoJCWlmIChwY29sc1t4eCArIHl5ICogOF0pIHRkYXRbY3VycmVudF9rXSA9
IHBjb2xzW3h4ICsgeXkgKiA4XQoJCXN0b3JlX2xpdmVfY2hhbmdlcygpCgllbmQKCXJldHVybiBl
bAplbmQKZnVuY3Rpb24gZ2VuZXJhdGVfZ3VpKCkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCgktLSBw
YWxldHRlCglndWk6YXR0YWNoKGNyZWF0ZV9wYWxldHRlX2Nob29zZXJ7CgkJeD0xMjAseT02LHdp
ZHRoPTExMyxoZWlnaHQ9NDEKCX0pCgkKCS0tIHBhdHRlcm4gZWRpdG9yCgkKCWd1aTphdHRhY2go
Y3JlYXRlX3BhdHRlcm5fZWRpdG9yewoJCXggPSAxMjAsIHkgPSA1Miwgd2lkdGggPSA3MiwgaGVp
Z2h0ID0gNzJ9KQoJLS0gY29sb3VyIGJveGVzCglmb3IgaT0xLCNjYXRlZ29yeSBkbwoJCWxvY2Fs
IHN4LHN5PTYsNisoaS0xKSoxMgoJCQoJCWd1aTphdHRhY2h7CgkJCXggPSBzeCwgeSA9IHN5LCB3
aWR0aD01MCwgaGVpZ2h0PTEwLAoJCQlsYWJlbCA9IGNhdGVnb3J5W2ldWzBdLAoJCQlkcmF3ID0g
ZnVuY3Rpb24oc2VsZikgcHJpbnQoc2VsZi5sYWJlbCwgMCwwLDcpIGVuZAoJCX0KCQlmb3Igaj0x
LCNjYXRlZ29yeVtpXSBkbwoJCQljcmVhdGVfY29sYm94e3g9c3grNDAraioxMix5PXN5LHdpZHRo
PTksaGVpZ2h0PTksaz1jYXRlZ29yeVtpXVtqXX0KCQllbmQKCWVuZAoJCgktLSBwYXR0ZXJuIHBy
ZXNldHMKCWZvciB5PTAsNCBkbwoJCWZvciB4PTAsMiBkbwoJCQlsb2NhbCBzeCxzeSA9IDE5NiAr
IHggKiAxMiwgNTIgKyB5ICogMTIKCQkJZ3VpOmF0dGFjaHsKCQkJCXggPSBzeCwgeSA9IHN5LCB3
aWR0aD0xMiwgaGVpZ2h0PTEyLAoJCQkJaW5kZXggPSB4ICsgeSAqIDMsCgkJCQlkcmF3ID0gZnVu
Y3Rpb24oc2VsZiwgbXNnKQoJCQkJCXJlY3RmaWxsKDAsMCwxMSwxMSwwKQoJCQkJCWxvY2FsIGJt
cD1nZXRfc3ByKHNlbGYuaW5kZXgpCgkJCQkJc3ByKHNlbGYuaW5kZXgsIDYtYm1wOndpZHRoKCkv
MiwgNi1ibXA6aGVpZ2h0KCkvMikKCQkJCWVuZCwKCQkJCXRhcCA9IGZ1bmN0aW9uKHNlbGYsIG1z
ZykKCQkJCQl0ZGF0LmRlc2t0b3BfcGF0dGVybiA9IGdldF9zcHIoc2VsZi5pbmRleCk6Y29weSgp
CgkJCQkJc3RvcmVfbGl2ZV9jaGFuZ2VzKCkKCQkJCWVuZAoJCQl9CgkJZW5kCgllbmQKCQoJLS0g
YnV0dG9ucwoJbG9jYWwgeHgsIHl5ID0gMTAsIDExMAoJbG9jYWwgc3BhY2luZyA9IDUKCQoJeHgr
PSBndWk6YXR0YWNoX2J1dHRvbnsKCQl4PXh4LHk9eXksCgkJYmdjb2w9MHgwNzAxLAoJCWZnY29s
PTB4MGUwNiwKCQlib3JkZXI9MHgwZTBkLAoJCWxhYmVsID0gIkNhbmNlbCIsCgkJY2xpY2sgPSBm
dW5jdGlvbigpCgkJCXN0b3JlKCIvcmFtL3NoYXJlZC90aGVtZS5wb2QiLHRkYXRfYXRfaW5pdCkK
CQkJZXhpdCgpIC0tIGFsd2F5cyBleGl0IGV2ZW4gaWYganVzdCBlZGl0aW5nIGEgLnRoZW1lIGZp
bGUKCQllbmQKCX0ud2lkdGgrc3BhY2luZwoJCgl4eCs9IGd1aTphdHRhY2hfYnV0dG9uewoJCXg9
eHgseT15eSwKCQliZ2NvbD0weDA3MDEsCgkJZmdjb2w9MHgwZTA2LAoJCWJvcmRlcj0weDBlMGQs
Ci0tCQlsYWJlbCA9ICJTZXQgYXMgRGVmYXVsdCIsCgkJbGFiZWwgPSAiS2VlcCIsCgkJY2xpY2sg
PSBmdW5jdGlvbigpCgkJCXN0b3JlKCIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIiwgdGRhdCkK
CQkJbG9jYWwgc2RhdCA9IGZldGNoIi9hcHBkYXRhL3N5c3RlbS9zZXR0aW5ncy5wb2QiCgkJCS0t
IGNoYW5nZSBlbnRyeSBpbiBzeXN0ZW0gc2V0dGluZ3MKCQkJaWYgKHNkYXQpIHRoZW4KCQkJCXNk
YXQudGhlbWUgPSAiL2FwcGRhdGEvc3lzdGVtL3RoZW1lLnBvZCIKCQkJCXN0b3JlKCIvYXBwZGF0
YS9zeXN0ZW0vc2V0dGluZ3MucG9kIiwgc2RhdCkKCQkJZW5kCgkJCW5vdGlmeSgic3RvcmVkIHRv
IC9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QiKQoJCQlleGl0KCkgLS0gYWx3YXlzIGV4aXQ7IG5v
IHJpc2sgb2YgbG9zaW5nIGNoYW5nZXMgYW5kIGlzIGNvbnNpc3RlbnQKCQllbmQKCX0ud2lkdGgr
c3BhY2luZwoKCQoJCi0tW1sKCXh4Kz0gZ3VpOmF0dGFjaF9idXR0b257CgkJeD14eCx5PXl5LAoJ
CWJnY29sPTB4MDcwMSwKCQlmZ2NvbD0weDBlMDYsCgkJYm9yZGVyPTB4MGUwZCwKCQlsYWJlbCA9
ICJSZXZlcnQiLAoJCWNsaWNrID0gZnVuY3Rpb24oKQoJCQlmY29weSgiL2FwcGRhdGEvc3lzdGVt
L3RoZW1lLnBvZCIsIi9yYW0vc2hhcmVkL3RoZW1lLnBvZCIpCgkJCXRkYXQgPSBmZXRjaCIvcmFt
L3NoYXJlZC90aGVtZS5wb2QiCgkJCWlmICh0eXBlKHRkYXQuZGVza3RvcF9wYXR0ZXJuKSE9InVz
ZXJkYXRhIikgdGhlbgoJCQkJdGRhdC5kZXNrdG9wX3BhdHRlcm4gPSB1c2VyZGF0YSgidTgiLCA4
LDgpCgkJCWVuZAoJCWVuZAoJfS53aWR0aCtzcGFjaW5nCgkKXV0KCgplbmQKCmZ1bmN0aW9uIF9k
cmF3KCkKCWNscygxKQoJCglndWk6ZHJhd19hbGwoKQplbmQKZnVuY3Rpb24gX3VwZGF0ZSgpCgln
dWk6dXBkYXRlX2FsbCgpCmVuZAoKLS0gcGxhY2Vob2xkZXIgZXZlbnQgdXNlZCB0byBkbyBzb21l
dGhpbmcgd2hlbiB3aW5kb3cgaXMgY2xvc2VkLCBkaXNjYXJkaW5nCi0tIHVuc2F2ZWQgY2hhbmdl
cy4gKiogZG9uJ3QgdXNlIHRoaXMgZXZlbnQgLS0gZGVzaWduIHdpbGwgbGlrZWx5IGJlIHJld29y
a2VkICoqCm9uX2V2ZW50KCJjb25maXJtX2Nsb3NlX3dpbmRvdyIsIGZ1bmN0aW9uKG1zZykKCS0t
IHNhbWUgYXMgW2NhbmNlbF0gYnV0dG9uCglzdG9yZSgiL3JhbS9zaGFyZWQvdGhlbWUucG9kIix0
ZGF0X2F0X2luaXQpCmVuZCkKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0iemVwIixjcmVh
dGVkPSIyMDIzLTEwLTE3IDA1OjE1OjQwIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAw
MDAwMDAwMDAwMTUxNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTUwNzA3MTUwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAxNTA3MDcxNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNTA3MDcwNzA3MTUw
MDAwMDAwMDAwMTUxNTE1MTUxNTE1MDcwNzA3MDcxNTE1MTUxNTE1MTUxNTA3MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcxNTE1MTkwNzA3MDcxZjA3MDcwNzA3MWYwNzA3MDcwOTE1MTUxOTE5MDcw
NzFmMDcwNzA3MDcxZjA3MDcwOTA5MTUwMDE1MTkxOTA3MDcwNzA3MDcwNzA3MDcwOTA5MTUwMDAw
MDAxNTE5MDcwNzA3MWYxZjA3MDcwNzA5MTUwMDAwMDAwMDAwMTUwNzA3MDcwNzA3MDcwNzA3MTUw
MDAwMDAwMDAwMTUwNzA3MDcwNzA5MTkwNzA3MDcwNzE1MDAwMDAwMDAxNTA3MDcwOTA5MDkxOTE5
MTkwNzA3MTUwMDAwMDAwMDE1MDcwOTA5MDkxNTE1MTkxOTE5MDcxNTAwMDAwMDAwMTUwOTA5MTUx
NTAwMDAxNTE1MTkxOTE1MDAwMDAwMDAxNTE1MTUwMDAwMDAwMDAwMDAxNTE1MTUwMDAwIiksbW9k
aWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLG5vdGVzPSIiLHJ1bnRpbWU9MjEsc3RvcmVkPSIy
MDI0LTAzLTA5IDEwOjMyOjEwIix0aXRsZT0iVGhlbWUgRWRpdG9yIix2ZXJzaW9uPSIiLHdvcmtz
cGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTgiLHdvcmtzcGFjZV9pbmRleD0xfX1dXQo6OiBn
ZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0xNyAwNToxNTo0MCIsbW9kaWZp
ZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyMy0xNS0xNyAwNToxNTo0MCJdXQo6
OiBnZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVFF6TFRJNElEQXlP
alF6T2pVNUlpeHRiMlJwWm1sbFpEMGlNakF5TXkwegpNUzB5TWlBeE9Eb3pNVG96TUNJc2NtVjJh
WE5wYjI0OU5EVXpMSE4wYjNKbFpEMGlNakF5TXkweU5TMHlPU0F3T1RveU5UbzFNQ0pkClhXeDZO
QURKQVFBQWdqUUFBUEVHZTFzd1hUMTdZbTF3UFhCNGRRQkRJQWdJQkFjQUFnQVNrQWdBR1pjT0FQ
TUFoeXhtYkdGbmN6MHcKTEhCaGJsOTRDQURxZVQwd0xITmpZV3hsUFRFeWZTeE9BRk1YSUFjUUJ3
UUFKeGNRQkFCUVFCY2dCd0FFQUE5VEFCNy1CQ0FYUUFlZwpCd0FIVUJkUUJ3QUhvQWRBRnlCRUFC
NnpBQWNnQnlBbkFGY0FKeUNlQUFZT0FBX1NBQi0tQkJBSEVBY1FWeUJYSUdjQVJ5QVhZQmRnCkZ4
QkVBQjZWQnlBSFFBY2dCLUFCQ1FBUFF3QWVJQ0FIRVFFUk1Lc0JNeEFIQUFnQUFHY0JYMEFIY0Fk
dzF3QWd2MUFuTUVmd0FRZFEKTnlBM1B3QWZyNEFIY0Fmd0N3ZFFCNUE3QUJ1Z0RBd0U4QW9Ya0Jm
d01BVUFId285QUI0UVotZ0FFbUFBQVE4TUFBVVBIZ0FMQWd3QQpEN1lBSDBBWUI3QVhSUUJRRUFk
d0J4Qk5BRjhYc0Fmd0dFZ0FIdjhENEFlQUo1QW5nQWZ3R1FlZ0ozQW5vQWZRUXdBZVVBQVhBQmRR
CmxnS2hCMEFIUUFkUUJ5QUhjTVlEMy1BQkI0QkhjQ2VBQndBSDhBbFdBQjRRUjFFQUlBQTNCZ0F4
RURjQTlRSUJFZ0JCQnhBSGtBSUEKQ0FnQUg0QmZBQnRmRUJBRThQQXpBUC0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS13dFFQVEV5
ZlgwPQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0xNyAwNToxNTo0
MCIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyMy0xNS0xNyAwNTox
NTo0MCJdXQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVFF6
TFRJNElEQXlPalF6T2pVNUlpeHRiMlJwWm1sbFpEMGlNakF5TXkwMQpOUzB6TVNBd05qbzFOVG8x
T1NJc2NtVjJhWE5wYjI0OU16RXpMSE4wYjNKbFpEMGlNakF5TXkweU5TMHlPU0F3T1RveU5UbzFN
Q0pkClhXeDZOQUJkQUFBQVdBUUFBUEFUZTJ4aGVXVnlQWHRiTUYwOWUySnRjRDExYzJWeVpHRjBZ
U2dpYVRFMklpd3hOZ01BTHlJd0FRRC0KLS0tdm9TSXBMSEJoYmw5NFBUQUlBUElHZVQwd0xITmpZ
V3hsUFRFc2RHbHNaVjlvUFRFMkNnQndkejB4Tm4xOQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2Qs
Y3JlYXRlZD0iMjAyMy0xMC0xNyAwNToxNTo0MCIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6
MzgiLHN0b3JlZD0iMjAyMy0xNS0xNyAwNToxNTo0MCJdXQo6OiBbZW9jXQo=
:: bios/apps/view.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBk
aXRoZXIubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjUtMDctMjkgMTg6MTQ6
MjciLG1vZGlmaWVkPSIyMDI1LTA4LTIzIDA1OjM3OjIxIixyZXZpc2lvbj02M11dCi0tIHRvIGRv
OiBkaXRoZXIKLS0gbWF5YmUgb3V0IG9mIHNjb3BlPyBzbGlwcGVyeSBzbG9wZSB0byBzaW1wbGUg
ZWRpdGluZywgc3ByaXRlIHNoZWV0Ci0tIG1hbmFnZW1lbnQgYW5kIHJlLXNhdmluZyBvcGVyYXRp
b25zPwoKZnVuY3Rpb24gZ2VuZXJhdGVfY2N1YmUoKQoJcD17fQoJZm9yIGk9MCw2MyBkbwoJCXBb
aV0gPSB7fQoJCXBbaV0uYixwW2ldLmcscFtpXS5yID0gcGVlaygweDUwMDAraSo0KzEsMykKCWVu
ZAoJCglsb2NhbCBjY3ViZSA9IHVzZXJkYXRhKCJ1OCIsNDA5NikKCS0tIHRvIGRvOiBzaW11bHRh
bmVvdXMgZmxvb2QgZmlsbCB0aGluZwoJZm9yIGI9MCwxNSBkbwoJCWZvciBnPTAsMTUgZG8KCQkJ
Zm9yIHI9MCwxNSBkbwoJCQkJbG9jYWwgYmVzdF9pID0gOAoJCQkJbG9jYWwgYmVzdF9kaXN0ID0g
MTAwMDAwCgkJCQlmb3IgaT0wLDYzIGRvCgkJCQkJbG9jYWwgZGlzdF9yID0gKHBbaV0uciAtIHIq
MTYpCgkJCQkJbG9jYWwgZGlzdF9nID0gKHBbaV0uZyAtIGcqMTYpCgkJCQkJbG9jYWwgZGlzdF9i
ID0gKHBbaV0uYiAtIGIqMTYpCgkJCQkJbG9jYWwgZGlzdCA9IGRpc3RfcipkaXN0X3IgKyBkaXN0
X2cqZGlzdF9nICsgZGlzdF9iKmRpc3RfYgoJCQkJCWlmIChkaXN0IDwgYmVzdF9kaXN0KSBiZXN0
X2ksYmVzdF9kaXN0ID0gaSxkaXN0CgkJCQllbmQKCQkJCWNjdWJlW2IqMjU2K2cqMTYrcl0gPSBi
ZXN0X2kKCQkJZW5kCgkJZW5kCgllbmQKCXJldHVybiBjY3ViZQplbmQKCi0tIGltZyBpcyBhIDMy
LWJpdCBpbWFnZQpmdW5jdGlvbiBkaXRoZXIoaW1nKQoJCgktLSBnZW5lcmF0ZSBhIDE2eDE2eDE2
IGNvbG91ciBjdWJlICg0aykKCS0tIGNvdWxkIGJlIGxhcmdlciBpZiBjYW4gZ2VuZXJhdGUgZmFz
dGVyCgktLSBidXQgdmFsdWUgc3BlZWQgb3ZlciBwcmVjaXNpb24gaGVyZQoJLS0gW2ZhbmN5OiBj
b3VsZCBkbyBhIHNsb3dlciBkaXRoZXIgaW4gYmFja2dyb3VuZCBhZnRlciBxdWljayBmaXRdCgls
b2NhbCBjY3ViZSA9IGdlbmVyYXRlX2NjdWJlKCkKCQoJb3V0ID0gdXNlcmRhdGEoInU4IiwgaW1n
OndpZHRoKCksIGltZzpoZWlnaHQoKSkKCQoJaW1nOm11dGF0ZSgidTgiKQoJCgktLSBjb2xvdXIg
Zml0CgoJZm9yIHk9MCxvdXQ6aGVpZ2h0KCktMSBkbwoJCWxvY2FsIGVyLCBlZywgZWIgPSAwLDAs
MAoJCWZvciB4PTAsb3V0OndpZHRoKCktMSBkbwoJCQlsb2NhbCByLGcsYiA9IGltZzpnZXQoeCo0
KzEseSwzKQoJCQkKCQkJbG9jYWwgYyA9IGNjdWJlWyhyXDE2KSoyNTYgKyAoZ1wxNikqMTYgKyAo
YlwxNildCgkJCQoJCQktLSB0byBkbzogZXJyb3IgZGlmZnVzaW9uIH4gdXNlIHVzZXJkYXRhIG9w
cwotLQkJCWVyID0gKHIgLSBwW2NdLnIpCi0tCQkJZWcgPSAoZyAtIHBbY10uZykKLS0JCQllYiA9
IChiIC0gcFtjXS5iKQoJCQkKCQkJb3V0OnNldCh4LHksYykKCQllbmQKCWVuZAoKCXJldHVybiBv
dXQKZW5kCjo6IGd1aS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0wNy0y
OSAxNzo1MTo0NiIsbW9kaWZpZWQ9IjIwMjUtMDctMjkgMTc6NTQ6NDMiLHJldmlzaW9uPTVdXQpm
dW5jdGlvbiBnZW5lcmF0ZV9ndWkoKQoJZ3VpID0gY3JlYXRlX2d1aXsKCQl4PTAseT0wLAoJCXdp
ZHRoX3JlbD0xLjAsaGVpZ2h0X3JlbD0xLjAKCX0KCQoJZnVuY3Rpb24gZ3VpOmRyYXcoKQoJCWxp
bmUoMCwwLDIwLDIwLDE0KQoJZW5kCgkKCWNyZWF0ZV9pbWFnZV9lbHsKCQl4PTAseT0wLAoJCXdp
ZHRoX3JlbD0xLjAsaGVpZ2h0X3JlbD0xLjAKCX0KZW5kCjo6IGltYWdlLmx1YQotLVtbcG9kX2Zv
cm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTA3LTI5IDE3OjUwOjMzIixtb2RpZmllZD0iMjAyNS0w
Ny0yOSAxNzo1OTo1MyIscmV2aXNpb249MTVdXQoKZnVuY3Rpb24gY3JlYXRlX2ltYWdlX2VsKGVs
KQoJZWwgPSBndWk6YXR0YWNoKGVsKQoJCglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQlycmVjdGZp
bGwoMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMCwwKQoJCQoJCWxvY2FsIHd3ID0gZzp3aWR0
aCgpICogc2NhbGUKCQlsb2NhbCBoaCA9IGc6aGVpZ2h0KCkgKiBzY2FsZQoJCQoJCXNzcHIoZyww
LDAsbmlsLG5pbCwKCQkJcGFuX3ggKyBzZWxmLndpZHRoLzIgLSB3dy8yLAoJCQlwYW5feSArIHNl
bGYuaGVpZ2h0LzIgLSBoaC8yLAoJCQl3dywgaGgKCQkpCgllbmQKCQoJZnVuY3Rpb24gZWw6bW91
c2V3aGVlbChtc2cpCgkJCgkJaWYgc2NhbGUgPCAwLjk5OSB0aGVuCgkJCXNjYWxlID0gbWlkKDAu
MTI1LCAxIC8gKDEgLyBzY2FsZSAtIG1zZy53aGVlbF95KSwgMSkKCQllbHNlaWYgc2NhbGUgPiAx
LjAwMSB0aGVuCgkJCXNjYWxlID0gbWlkKDEsIHNjYWxlICsgbXNnLndoZWVsX3ksIDgpCgkJZWxz
ZQoJCQlzY2FsZSA9IG1zZy53aGVlbF95IDwgMCBhbmQgMC41IG9yIDIKCQllbmQKCQoJZW5kCgkK
CWZ1bmN0aW9uIGVsOmRvdWJsZWNsaWNrKG1zZykKCQlzY2FsZSA9IDEKCQlwYW5feCwgcGFuX3kg
PSAwLDAKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlwYW5feCArPSBtc2cuZHgKCQlw
YW5feSArPSBtc2cuZHkKCWVuZAoJCmVuZAo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3
IixjcmVhdGVkPSIyMDI1LTA3LTI5IDEwOjEwOjM4Iixtb2RpZmllZD0iMjAyNS0xMC0zMSAwMzo0
NDozMyIscmV2aXNpb249MTU2XV0KLS1bWwoKCWdlbmVyYWwgcHVycG9zZSB2aWV3ZXIKCQoJY29s
b3VyIGZpdCB0byBzeXN0ZW0gcGFsZXR0ZQoJYnV0IG1heWJlIGluIGZ1dHVyZSwgYWxsb3cgc3dp
dGNoIHRvIGZ1bGxzY3JlZW4gd2l0aCBhZGFwdGl2ZSBwYWxldHRlCgpdXQoKaW5jbHVkZSAicDgu
bHVhIgppbmNsdWRlICJpbWFnZS5sdWEiCmluY2x1ZGUgImd1aS5sdWEiCmluY2x1ZGUgImRpdGhl
ci5sdWEiCgpmdW5jdGlvbiBfaW5pdCgpCglnZW5lcmF0ZV9ndWkoKQplbmQKCi0tIGxvYWQgdGhl
IHRoaW5nCgpjZChlbnYoKS5wYXRoKQpmID0gZnVsbHBhdGgoZW52KCkuYXJndlsxXSkgLS0gb3Ig
Ii9kZXYvdmlldy9hc2gucG5nIgoKaWYgKG5vdCBmIG9yIG5vdCBmc3RhdChmKSkgdGhlbgoJaWYg
KGVudigpLnByaW50X3RvX3Byb2NfaWQpIHRoZW4KCQlwcmludCgiZmlsZSBub3QgZm91bmQiKSAt
LSBydW4gZnJvbSB0ZXJtaW5hbAoJCWV4aXQoKQoJZWxzZQoJCS0tIGRvdWJsZSBjbGlja2VkIGZy
b20gZmlsZW5hdjsgdG8gZG86IGFsbG93IHZpZXdpbmcgbm90aGluZwoJCS0tbm90aWZ5KCJub3Ro
aW5nIHRvIHZpZXciKQoJZW5kCgkKZW5kCgp3cmFuZ2xlX3dvcmtpbmdfZmlsZSgKCS0tIG5vIG9w
dGlvbiB0byBzYXZlCgluaWwsCgoJLS0gbG9hZAoJZnVuY3Rpb24oY29udGVudCkKCQoJCWlmIChw
d2YoKSBhbmQgcHdmKCk6ZXh0KCkgPT0gInA4IikgdGhlbgoJCQlnID0gZXh0cmFjdF9wOF9zcHJp
dGVzaGVldChmKQoJCWVsc2UKCQkJLS1nID0gY29udGVudAoJCQlnID0gZmV0Y2goZikgLS0gY29s
b3VyIGZpdHRlZAotLQkJCWlmIChkaXRoZXIpIAlnID0gZGl0aGVyKGZldGNoKGYsIHthcmdiPXRy
dWV9KSkKCQllbmQKCQkKCQlzY2FsZSA9IDEKCQlwYW5feCwgcGFuX3kgPSAwLDAKCQkKCQlpZiAo
dHlwZShnKSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJCXdoaWxlIChnOndpZHRoKCkgKiBzY2FsZSA_
IDQwMCBvciBnOmhlaWdodCgpICogc2NhbGUgPiAyMDApIGRvCgkJCQlzY2FsZSA9IDEgLyAoMS9z
Y2FsZSArIDEpCgkJCWVuZAoJCQkKCQkJd2luZG93ewoJCQkJd2lkdGggPSBnOndpZHRoKCkgKiBz
Y2FsZSwKCQkJCWhlaWdodCA9IGc6aGVpZ2h0KCkgKiBzY2FsZSwKCQkJfQoJCWVsc2UKCQkJZyA9
IAotLVtbcG9kX3R5cGU9ImdmeCJdXXVucG9kKCJiNjQ6YkhvMEFGVUFBQUJZQUFBQThERndlSFVB
UXlBUUVBUUFrVkFCZHdZQlFBRjNGZ0V3QVhjbUFTQUJkellCRUFHM0FSQUJGeEZuQVNBQkJ3RVFB
VWNCTUJFd1FSQUJRQkZnRVRBQkZ3RkFGZ0JERVRkQkZ5b0FrTGNCRUFHM0FSRFJBQT09IikJCQlu
b3RpZnkoImNvdWxkIG5vdCBsb2FkIGltYWdlIikKCQkJd2luZG93KDEyMCw4MCkKCQllbmQKCQkK
CgllbmQKKQoKCgppZiAodHlwZShnKSB_PSAidXNlcmRhdGEiIGFuZCBlbnYoKS5wcmludF90b19w
cm9jX2lkKSB0aGVuCglwcmludCgiY291bGQgbm90IHZpZXcgdGhpcyB0eXBlIikKCWV4aXQoKQpl
bmQKCgoKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygpCglpZiAobm90IGcpIHRoZW4KCQljbHMoNykg
CgkJcHJpbnQoIltub3RoaW5nIHRvIHZpZXddIiwxMCwxMCw2KQoJCXJldHVybgoJZW5kCgoJZ3Vp
OmRyYXdfYWxsKCkKZW5kCgpmdW5jdGlvbiBfdXBkYXRlKCkKCQoJZ3VpOnVwZGF0ZV9hbGwoKQoJ
CgktLSBjb3B5CglpZiBrZXkiY3RybCIgYW5kIGtleXAiYyIgYW5kIGcgdGhlbgoJCWxvY2FsIGcy
ID0gdXNlcmRhdGEoInU4IixnOndpZHRoKCkqc2NhbGUsZzpoZWlnaHQoKSpzY2FsZSkKCQlzZXRf
ZHJhd190YXJnZXQoZzIpCgkJc3NwcihnLCAwLCAwLCBnOndpZHRoKCksIGc6aGVpZ2h0KCksIDAs
IDAsIGcyOndpZHRoKCksIGcyOmhlaWdodCgpKQoJCXNldF9kcmF3X3RhcmdldCgpCgkJc2V0X2Ns
aXBib2FyZCgiLS1bW3BvZF90eXBlPVwiZ2Z4XCJdXSIuLnBvZChnMiwweDcpKQoJCW5vdGlmeSgi
Y29waWVkIHRvIGNsaXBib2FyZCAoc2NhbGUgIi4uZmxyKHNjYWxlXDAuMDEpLi4iJSkiKQoJZW5k
CgkKCS0tIHVwZGF0ZSB3aW5kb3cgdGl0bGUKCWlmIChzY2FsZSB_PSBsYXN0X3NjYWxlKSB0aGVu
CgkJaWYgKGYpIHRoZW4KCQkJd2luZG93e3RpdGxlID0gZjpiYXNlbmFtZSgpLi4iICgiLi5mbHIo
c2NhbGVcMC4wMSkuLiIlKSJ9CgkJZWxzZQoJCQl3aW5kb3d7dGl0bGUgPSAiSW1hZ2UgVmlld2Vy
In0KCQllbmQKCWVuZAoJbGFzdF9zY2FsZSA9IHNjYWxlCgkKZW5kCgoKOjogcDgubHVhCi0tW1tw
b2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjUtMDctMjYgMDk6NDc6NTEiLG1vZGlmaWVkPSIy
MDI1LTA3LTI2IDA5OjQ3OjUxIixyZXZpc2lvbj0wXV0KCmZ1bmN0aW9uIGV4dHJhY3RfcDhfc3By
aXRlc2hlZXQoZm4pCglsb2NhbCBzdHIgPSBmZXRjaChmbikKCWlmICh0eXBlKHN0cikgfj0gInN0
cmluZyIpIHJldHVybgoJbG9jYWwgbGluZXMgPSBzcGxpdChzdHIsIlxuIixmYWxzZSkKCWlmIChs
aW5lc1sxXSB_PSAicGljby04IGNhcnRyaWRnZSAvLyBodHRwOi8vd3d3LnBpY28tOC5jb20iKSBy
ZXR1cm4gbmlsCglmb3IgaT0xLCNsaW5lcy0xIGRvCgkJaWYgKGxpbmVzW2ldID09ICJfX2dmeF9f
IikgdGhlbgoJCQlsb2NhbCBibXAgPSB1c2VyZGF0YSgidTgiLDEyOCwxMjgpCgkJCWxvY2FsIHJv
dyA9IDAKCQkJZm9yIGo9aSsxLCNsaW5lcyBkbwoJCQkJbG9jYWwgZGF0ID0gbGluZXNbal0KCQkJ
CWZvciB4PTAsMTI3IGRvCgkJCQkJYm1wOnNldCh4LHJvdyx0b251bSgiMHgiLi4oZGF0W3grMV0g
b3IgMCkpKQoJCQkJZW5kCgkJCQlyb3cgKz0gMQoJCQllbmQKCQkJcmV0dXJuIGJtcAoJCWVuZAoJ
ZW5kCglyZXR1cm4gbmlsCmVuZAoKCmZ1bmN0aW9uIGV4dHJhY3Rfcm9tKHVkKQoKCWxvY2FsIGQ4
ID0gdWQ6Y29weSgpCglkODptdXRhdGUoInU4IikKCQoJbG9jYWwgb3V0ID0gdXNlcmRhdGEoInU4
IiwgMHg4MDIwKQoJCgktLSB0byBkbzogY291bGQgYmUgZmFzdGVyIHdpdGggZmFuY3kgdXNlcmRh
dGEgb3BzCglmb3IgaT0wLCAweDgwMWYgZG8KCQlvdXRbaV0gPQoJCQkoKGQ4W2kqNCswXSAmIDB4
MykgPDwgMCkgfAoJCQkoKGQ4W2kqNCsxXSAmIDB4MykgPDwgMikgfAoJCQkoKGQ4W2kqNCsyXSAm
IDB4MykgPDwgNCkgfAoJCQkoKGQ4W2kqNCszXSAmIDB4MykgPDwgNikKCWVuZAoKCXJldHVybiBv
dXQKCmVuZAoKZnVuY3Rpb24gZGVjb2RlX3Nwcml0ZXNoZWV0KHJvbSkKCWxvY2FsIG91dCA9IHVz
ZXJkYXRhKCJ1OCIsMTI4LDEyOCkKCWZvciBpPTAsMTYzODMgZG8KCQlvdXRbaV0gPSAocm9tW2lc
Ml0gPj4gKChpJTIpKjQpKSYweGYKCWVuZAoJcmV0dXJuIG91dAplbmQKOjogLmluZm8ucG9kCi0t
W1twb2QsYXV0aG9yPSJ6ZXAiLGNyZWF0ZWQ9IjIwMjUtMDctMjkgMTA6MTA6MDQiLGljb249dXNl
cmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAwMDEwNzA2MDYwNjA2MDYwNjA2MDYwNjA2MDcwMTAw
MDEwNzA2MDYxNjE2MTYxNjE2MTYxNjE2MDYwNjA3MDEwMTA3MDYwNjE2MDcwNzBjMGMwYzBjMTYw
NjA2MDcwMTAxMDcwNjA2MTYwNzA3MDcwYzBjMGMxNjA2MDYwNzAxMDEwNzA2MDYxNjFjMWMxYzFj
MDcwNzE2MDYwNjA3MDEwMTA3MDYwNjE2MWMxYzFjMDcwNzA3MTYwNjA2MDcwMTAxMDcwNjA2MTYw
MzAzMDMwMzAzMDMxNjA2MDYwNzAxMDEwNzA2MDYxNjAzMDMwMzAzMDMwMzE2MDYwNjA3MDEwMTA3
MDYwNjE2MTYxNjE2MTYxNjE2MTYwNjA2MDcwMTAxMWQwNzA2MDYwNjA2MDYwNjA2MDYwNjA2MDcx
ZDAxMDExZDFkMDcwNzA3MDcwNzA3MDcwNzA3MDcxZDFkMDEwMDAxMWQxZDFkMWQxZDFkMWQxZDFk
MWQxZDFkMDEwMDAwMDAwMTFkMWQxZDFkMWQxZDFkMWQxZDFkMDEwMDAwMDAwMDAwMDEwMTAxMDEw
MTAxMDEwMTAxMDEwMDAwMDAiKSxsb3djb2xfaWNvbj1mYWxzZSxtb2RpZmllZD0iMjAyNS0xMi0x
NCAwMDo0NzozOCIsbm90ZXM9IkltYWdlIFZpZXdlciIscnVudGltZT0yMSx0aXRsZT0iVmlldyIs
dmVyc2lvbj0iMC4xIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzY2Iix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJwOC5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249Imd1aS5sdWEjOCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaW1hZ2UubHVhIzEz
Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkaXRoZXIubHVhIzM5Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRp
b249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3
b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogW2VvY10K
:: bios/bios.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTEyLTEzIDIyOjA1OjEyIixtb2RpZmllZD0iMjAyNS0xMi0xMyAyMzoxMzoyMSIs
cmV2aXNpb249OTZdXQpsb2NhbCBkaXN0cm89ZmV0Y2goIi9kaXN0cmlidXRpb25zL2FjdGl2ZS50
eHQiKQp3aW5kb3d7Y3Vyc29yPTAscGF1c2VhYmxlPWZhbHNlfQoKbG9jYWwgcG9pbnRlcj0xCgot
LXJlbG9hZCBwYWdlcwoKZnVuY3Rpb24gcmVsb2FkUGFnZXMoKQoJcGFnZXM9ewoJCW1haW49ewoJ
CQl7dGV4dD0iR28gdG8gZXhpdCBtZW51IixzZWxlY3Q9ZnVuY3Rpb24oKSBsb2FkUGFnZSgiZXhp
dCIpIGVuZH0sCgkJCXt0ZXh0PSJBY3RpdmUgRGlzdHJpYnV0aW9uOiAiLi5kaXN0cm8sc2VsZWN0
PWZ1bmN0aW9uKCkgbG9hZFBhZ2UoImNoYW5nZURpc3RybyIpIGVuZH0KCQl9LAoJCWNoYW5nZURp
c3Rybz17CgkJCXt0ZXh0PSJSZXR1cm4iLHNlbGVjdD1mdW5jdGlvbigpIHJlbG9hZFBhZ2VzKCkg
bG9hZFBhZ2UoIm1haW4iKSBlbmR9LAoJCQl7dGV4dD0iQWN0aXZlIERpc3RyaWJ1dGlvbjogIi4u
ZGlzdHJvfQoJCX0sCgkJCgkJZXhpdD17CgkJCXt0ZXh0PSJHbyB0byBtYWluIG1lbnUiLHNlbGVj
dD1mdW5jdGlvbigpIGxvYWRQYWdlKCJtYWluIikgZW5kfSwKCQkJe3RleHQ9IlNhdmUgY2hhbmdl
cyBhbmQgZXhpdCIsc2VsZWN0PWZ1bmN0aW9uKCkgc2F2ZUNoYW5nZXMoKSBzZW5kX21lc3NhZ2Uo
Mix7ZXZlbnQ9InJlYm9vdCJ9KSBlbmR9LAoJCQl7dGV4dD0iRGlzY2FyZCBjaGFuZ2VzIGFuZCBl
eGl0IixzZWxlY3Q9ZnVuY3Rpb24oKSBzZW5kX21lc3NhZ2UoMix7ZXZlbnQ9InJlYm9vdCJ9KSBl
bmR9CgkJfQoJfQoJLS1sb2FkIGRpc3Ryb3MKCWxvY2FsIGRpc3Ryb3M9bHMoIi9kaXN0cmlidXRp
b25zIikKCWZvciBpPTEsICNkaXN0cm9zIGRvCgkJaWYgKGRpc3Ryb3NbaV06ZXh0KCk9PW5pbCkg
dGhlbiAtLWlzIGEgZm9sZGVyCgkJCWFkZChwYWdlcy5jaGFuZ2VEaXN0cm8se3RleHQ9ZGlzdHJv
c1tpXSxzZWxlY3Q9ZnVuY3Rpb24oKSBkaXN0cm89ZGlzdHJvc1tpXSByZWxvYWRQYWdlcygpIGxv
YWRQYWdlKCJjaGFuZ2VEaXN0cm8iKSBlbmR9KQoJCWVuZAoJZW5kCmVuZAoKZnVuY3Rpb24gc2F2
ZUNoYW5nZXMoKQoJc3RvcmUoIi9kaXN0cmlidXRpb25zL2FjdGl2ZS50eHQiLGRpc3RybykKZW5k
CgpyZWxvYWRQYWdlcygpCgpmdW5jdGlvbiBsb2FkUGFnZShwYWdlKQoJZW50cmllcz1wYWdlc1tw
YWdlXQplbmQKCmxvYWRQYWdlKCJtYWluIikKCmZ1bmN0aW9uIF9pbml0KCkKCQplbmQKCmZ1bmN0
aW9uIF91cGRhdGUoKQoJaWYgKGJ0bnAoNikpIHRoZW4KCQlpZiAoZW50cmllc1twb2ludGVyXS5z
ZWxlY3QpIGVudHJpZXNbcG9pbnRlcl0uc2VsZWN0KCkKCWVuZAoJaWYgKGJ0bnAoMikpIHBvaW50
ZXItPTEKCWlmIChidG5wKDMpKSBwb2ludGVyKz0xCglpZiAocG9pbnRlcj09MCkgcG9pbnRlcj0j
ZW50cmllcwoJaWYgKHBvaW50ZXI9PSNlbnRyaWVzKzEpIHBvaW50ZXI9MQplbmQKCmZ1bmN0aW9u
IF9kcmF3KCkKCWNscygpCglwcmludCgiXF53XF50UGljb3Ryb24gQklPUyIsMiwyLDcpCglwcmlu
dCgiXDAxNHYwLjFcbiIsMiwxOCw3KQoJZm9yIGk9MSwgI2VudHJpZXMgZG8KCQlsb2NhbCB0PWVu
dHJpZXNbaV0udGV4dAoJCWlmIChwb2ludGVyPT1pKSB0PSI_ICIuLnQKCQlwcmludCh0LGVudHJp
ZXNbaV0uY29sb3Igb3IgNykKCWVuZAplbmQKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0i
MjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHJ1bnRp
bWU9MjQsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMyOSIsd29ya3NwYWNlX2luZGV4
PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn19XV0KOjogZ2Z4Ly5p
bmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMTEtMTMgMjE6MDc6NDMiLG1vZGlmaWVkPSIy
MDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRH
VmtQU0l5TURJMUxUQXhMVEUzSURFd09qTTFPalE0SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1p
MHhNeUF5TXpvd05qb3lNU0lzY21WMmFYTnBiMjQ5TjExZGJIbzBBTUFBQUFCME1nQUE4UnQ3V3pC
ZFBYdGliWEE5Y0hoMUFFTWcKRUJBRUx4SUFMaEFlQUM0QUhpQU9FQTRBRGdBT0lBNEFEaEFNQUFF
WUFKRXVBQjRIQUM1Z0J3QUNBQk9BQ0FENUExQW5ZU2RRQVU4UQpBVkFuQVUwQkoxQUJUUW9BTzJF
blVERUFCQWdBOHdBZ0xHWnNZV2R6UFRBc2NHRnVYM2dJQU5wNVBUQXNlbTl2YlQweE5IMHNvUUF2
CjhQQXlBUC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tWFVEMHgKTkgxOQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRl
ZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiXV0K
OjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExURTNJREV3
T2pNMU9qUTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTVMweE55QXhNRG96TnpvME5DSXNjbVYy
YVhOcGIyNDlNVjFkYkhvMEFGUUFBQUJFRUFBQThBaDdlMkp0Y0QxMWMyVnlaR0YwWVNnaQphVEUy
SWl3ek1nTUFMeUl3QVFELS0tLS0tLS0tLS0tLS0tLS0tLS03b1NJcExIQmhibDk0UFRBSUFOSjVQ
VEFzZEdsc1pWOW9QVEUyCkNnQmdkejB4Tm4xOQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3Jl
YXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6Mzgi
XV0KOjogc2Z4LzAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBM0xUTXhJ
REE0T2pNd09qSTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTnkwek1TQXdPRG96TURveU9DSXNj
bVYyYVhOcGIyNDlNRjFkYkhvMEFLQUFBQUFMQ2dBQS16QndlSFVBQXlnQUFBUUFCQTlBRUFJTwpB
QUdnQVNBQ29BNEFEeEFBRGZES0FRSURRQThQa0FRRkJnZEFESkFJQ1FvTFFBeVFEd3dQRFE4T0RF
QU04UDhCQU92LUo2b0JFQVlQCk1CQUJJQUVnQWZBQUFoQUNEaEFCSUE4aElBRXdEMER3d3c4b0Qt
LXd4Zy00Q2ctLUQ0QVA5dzhOQWZBSkFSQUdEakFBLS0tLS0tXzkKSC04QkFLelB5QTlBQUE4UVFQ
LS1zUEQtQVFELTZsRC0tLS0tS1E9PQo6OiBbZW9jXQo=
:: bios/demos/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: bios/demos/bells.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTAwLTMwIDE5OjAwOjIwIixtb2RpZmllZD0iMjAyNC0wMy0yMSAwODo0Mjo1MiIs
cmV2aXNpb249ODQyXV0KLS1bWwoJYmVsbHMgZGVtbyBieSB6ZXAKCWEJCl1dCm5uPXt9CmZ1bmN0
aW9uIHBpY2tfbm90ZSgpCglpZiAoI25uID09IDApIG5uID0gezUwLDUzLDU1LDU3LDYwLCA2Miw2
NSw2Nyw2OSw3Mn0KCXJldHVybiBkZWwobm4scm5kKG5uKSkKZW5kCgpmdW5jdGlvbiBfaW5pdCgp
CgoJCglsb2NhbCBzZnhkYXQgPSBmZXRjaCJzZngvc2Z4MC5zZngiCgkKCW1lbW1hcCgweDMwMDAw
LCBzZnhkYXQpCgotLVtbCgktLSB0byBkbzogbmljZXIgd2F5IHRvIHRyYW5zZmVyIGxhcmdlIGFt
b3VudHMgb2YgZGF0YSBmcm9tIHVzZXJkYXRhIC0_IHJhbQoJLS0gY2FuJ3QgZmV0Y2goZ2V0KGZv
bykpIGxhcmdlIGJsb2NrcyBiZWNhdXNlIG9mIHN0YWNrIGxpbWl0Cglmb3IgaT0wLDIgZG8KCQlw
b2tlKDB4MzAwMDAgKyAoaTw8MTYpLCBnZXQoc2Z4ZGF0LChpPDwxNiksMHgxMDAwMCkpCgllbmQK
XV0KCgliZWxsPXt9Cglmb3IgeT0tMSw1IGRvCgkJZm9yIHg9LTEsNSBkbwoJCQlsb2NhbCBzeCA9
IDE0Mit4KjQwICsgKHkmMSkgKiAyMAoJCQlsb2NhbCBzeSA9IDcwK3kqMzAKCQkJbG9jYWwgb2N0
ID0gMAoJCQlsb2NhbCBpbnN0ID0geSA8IDIgYW5kIDAgb3IgMQoJCQlpZiAoeSA9PSAtMSkgb2N0
ID0gMQoJCQlpZiAoeSA9PSA0KSBvY3QgPSAtMQoJCQlpZiAoeSA9PSA1KSBvY3QgPSAtMSBpbnN0
ID0gMgoJCQkKCQkJYWRkKGJlbGwsewoJCQkJeCA9IHN4LCB5ID0gc3ksCgkJCQlxID0gMCwKCQkJ
CW4gPSBwaWNrX25vdGUoKSArIG9jdCoxMiwKCQkJCWluc3QgPSBpbnN0CgkJCX0pCgkJZW5kCgll
bmQKZW5kCgoKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKCkKCWZvciBiIGluIGFsbChiZWxsKSBkbwoJ
CQoJCWZvciBpPTAsMiBkbwoJCQlsb2NhbCByciA9IGIucSAqIChpLTEpLzIKCQkJY2lyYyhiLngs
IGIueSwgMTUgKyByciwgNytpK2IueS8yMCkKCQllbmQKCQkKCQlsb2NhbCB0dD1iLnEvMzAKCQl0
dCo9dHQKCQljaXJjKGIueCwgYi55LCAxNSArIHR0KjMwLCA3KQoJCQoJZW5kCgktLXByaW50KHN0
YXQoMSksMiwyLDgpCmVuZAoKY2hhbiA9IDAKZnVuY3Rpb24gX3VwZGF0ZSgpCglsb2NhbCBteCwg
bXkgPSBtb3VzZSgpCglmb3IgYiBpbiBhbGwoYmVsbCkgZG8KCQkKCQlsb2NhbCBkeCA9IG14IC0g
Yi54CgkJbG9jYWwgZHkgPSBteSAtIGIueQoJCWlmIHNxcnQoZHgqZHgrZHkqZHkpIDwgMTUgdGhl
bgoJCQktLSBwbGF5IGJlbGwKCQkJaWYgKG5vdCBiLmFjdGl2ZSkgdGhlbgoJCQkJYi5xID0gMzAK
CQkJCS0tIHBpdGNoLCBpbnN0LCB2b2wgKDAuLjY0KSwgZWZmZWN0LCBlZmZlY3RfcCwgY2hhbl9p
bmRleAoJCQkJLS0gKGVmZmVjdHMgbm90IGltcGxlbWVudGVkIHlldCkKCQkJCW5vdGUoYi5uLGIu
aW5zdCw2NCwwLDAsY2hhbikgCgkJCQljaGFuPShjaGFuKzEpJTggLS0gcm90YXRlIGFyb3VuZCBm
aXJzdCA4IGNoYW5uZWxzCgkJCWVuZAoJCQliLmFjdGl2ZSA9IHRydWUKCQllbHNlCgkJCWIuYWN0
aXZlID0gZmFsc2UKCQllbmQKCQlpZiAoYi5xID4gMCkgYi5xIC09IDEKCWVuZAplbmQKCgoKOjog
LmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9
IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyNC0wMy0yMSAwODo0Mjo1MiIsd29ya3Nw
YWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9u
PSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIs
d29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMDAtMzAgMTk6
MDA6MTkiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjMtMDAtMzAg
MTk6MDA6MTkiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6
TFRBd0xUTXdJREU1T2pBd09qSXdJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweU1TQXdPRG8w
TWpvMU1pSXNjbVYyYVhOcGIyNDlOalE1WFYxc2VqUUFiUUFBQUFVeEFBRHpGSHRiTUYwOWUySnRj
RDF3ZUhVQQpReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0Q0FEUGVUMHdMSHB2YjIwOU9IMHNN
UUQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLW5VRzA5T0gxOQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAy
My0wMC0zMCAxOTowMDoxOSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0i
MjAyMy0wMC0zMCAxOTowMDoxOSJdXQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESXpMVEF3TFRNd0lERTVPakF3T2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMw
dwpNeTB5TVNBd09EbzBNam8xTWlJc2NtVjJhWE5wYjI0OU5qVTVYVjFzZWpRQWFBQUFBRmdRQUFE
d0NIdDdZbTF3UFhWelpYSmtZWFJoCktDSnBNVFlpTERNeUF3QXZJakFCQVAtLS0tLS0tLS0tLS0t
LS0tLS0tLXZ4Q0NJcExHaHBaR1JsYmoxbVlXeHpaU3h3WVc1ZmVEMHcKQ0FEU2VUMHdMSFJwYkdW
ZmFEMHhOZ29BRUhjS0FJQjZiMjl0UFRGOWZRPT0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjMtMDAtMzAgMTk6MDA6MTkiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4
IixzdG9yZWQ9IjIwMjMtMDAtMzAgMTk6MDA6MTkiXV0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRBd0xUTXdJREU1T2pBd09qSXdJaXh0YjJScFptbGxa
RDBpTWpBeU5DMHcKTXkweU1TQXdPRG8wTWpvMU1pSXNjbVYyYVhOcGIyNDlOell6WFYxc2VqUUFh
QUVBQUhvSEFBRGZjSGgxQUFNb0FBQURBQVR3LXdFQQo3UEJPOFFFUUJnOGdFQUVnQVF3UUFmQUFB
aEFDRGhBQklBOGhJQUV3RHh1UUR4RUNJQTVRQVE4V0VBSHdud0lBQmtBUDFBX3ZENDhQCmVnOWZE
MG9QT2c4dkR5b2ZIdzhhSHhVUER3WHd1US00Q2ctLUQ0QVA5dzhOQWZBSkFSQUdTd0JKQ1F3RkFG
a0FrQWtQR1EtYUFpQUMKY0YwQS16QVBGbEFCRC1zR0FBRUFEXy1BQVFnZ0QzZGdEeHZ3Z2dJQkNF
QVA5QS1wRDlrUHlRX0VEMm9QV2c5RkR6OGZMeDhsRHhvUApGUThQOEFnQm9BOFk4SlJ5QUFJc0FT
REpBR0JBa0E4UkVoREpBTkgwRUFFd0R5cVFBUUlRQWc4dElBQUFFd0RRRDg0Z0R6YVFEeE1DCklB
OE9VQWtCVUE4UElBNlFqd0NRR21BUEhmQkNBZ0FKX2dBUnVmb0E4QUJrRDFvUFNnOC1EelVQTHc4
bER4X1JBRDhLOExxS0FCV1AKOE1NUEtBLS04TVl3QUxvZi13RUEzUElGX0E5QUFBOFFRQTh3LS04
dkFmMHZEdjB2OEhBVEFDLTlzQW9BLS05Y0gtOEJBSmRRLS0tLQoteDg9Cjo6IFtlb2NdCg==
:: bios/demos/birds.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogYmlyZC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
NC0wOS0wNyAxOTowODowMiIsbW9kaWZpZWQ9IjIwMjQtMDktMDkgMDk6MTQ6MzYiLHJldmlzaW9u
PTk5NV1dCgpiaXJkPXt9CgpmdW5jdGlvbiBtYWtlX2JpcmQoeCx5KQoJbG9jYWwgYiA9IHsKCQl4
ID0geCwgeSA9IHksIGR4ID0gMCwgZHkgPSAwLCBmciA9IDAsIGQgPSAxLAoJCXR4ID0gcm5kKDAu
OCkrMC4xLCB0eSA9IHJuZCgxKSwKCQl0ID0gcm5kKDMwMDApXDEsIHB4ID0gMCwKCQlwYW5pY190
ID0gMAoJfQoJcmV0dXJuIGFkZChiaXJkLCBiKQplbmQKCgpmdW5jdGlvbiBkcmF3X2JpcmQoYSkK
CWxvY2FsIGJpbmRleCA9IDgKCWlmIChub3QgYS5wcm9jX2lkKSBiaW5kZXggPSA5ICsgYS5mcgoJ
c3ByKGJpbmRleCwgYS54LTgsIGEueS0xMiwgYS5kIDwgMCkKCQplbmQKCgpmdW5jdGlvbiBtb3Zl
X2JpcmQoYSkKCglsb2NhbCBteCxteSA9IG1vdXNlKCkKCXByb2RkZWQgPSAoKGEueCAtIG14KV4y
ICsgKChhLnktMyktbXkpXjIgPCA0OSkKCQoJaWYgKHByb2RkZWQgYW5kIG5vdCBhLmxhc3RfcHJv
ZGRlZCkgdGhlbgoJCWxvY2FsIHEgPSBhdGFuMihhLngtbXgsYS55LW15KQoJCWEuZHggPSBjb3Mo
cSkqMgoJCWEuZHkgPSBzaW4ocSkgLSAyCgkJYS50eSA9IHJuZCgpCgkJYS5wcm9jX2lkID0gbmls
CgkJYS5wYW5pY190ID0gOTAgKyBybmQoOTApCgllbmQKCWEubGFzdF9wcm9kZGVkID0gcHJvZGRl
ZAoJCgktLSBmbHlpbmcgYmlyZDogZmx5IHRvIGZyb250IHdpbmRvdyAoaWYgdGhlcmUgaXMgb25l
KQoJaWYgKG5vdCBhLnByb2NfaWQpIHRoZW4JCgoJCS0tIHRhcmdldCBwb3NpdGlvbgoJCWxvY2Fs
IHR4ID0gYS50eCo0ODAKCQlsb2NhbCB0eSA9IDEwMCthLnR5KjEwMCAtLSB1c2UgcmFuZG9tbHkg
YXNzaWduZWQgdmVydGljYWwgcG9zaXRpb24KCgkJbG9jYWwgdyA9IHdpbmRhdFsjd2luZGF0XQoJ
CWlmICh3KSB0aGVuCgkJCXR4ID0gdy54K2EudHgqdy53aWR0aAoJCQl0eSA9IHcueQoJCWVuZAoJ
CQoJCXR4ICs9ICBjb3MoYS50IC8gNTAwKSoyMCArIGNvcyhhLnQvODAwKSo1MAoJCWlmICh3KSB0
aGVuCgkJCXR4ID0gbWlkKHcueCsxMCwgdHgsIHcueCt3LndpZHRoLTIwKQoJCWVuZAoJCQoJCWxv
Y2FsIG1hZyA9IHcgYW5kIDEgb3IgNCAtLSB2YXJ5IG1vcmUgd2hlbiBubyB3aW5kb3cgdGFyZ2V0
CgkJbG9jYWwgdHkxID0gdHkgKyBjb3MoYS50IC8gMjAwKSo0Km1hZyArIGNvcyhhLnQvNTAwKSox
MCptYWcKCQkKCQlsb2NhbCBmbGFwcGVkID0gZmFsc2UKCQlpZiAoYS55ID4gdHkxLTUpIGEuZnIg
Kz0gMC4xCgkJaWYgKGEueSA8IHR5MS01KSBhLmZyICs9IDAuMDIKCQkKCQlpZiAoYS5wYW5pY190
ID4gMCkgdGhlbgoJCQlhLnBhbmljX3QgLT0gMQoJCQlhLmZyICs9IDAuMgoJCWVuZAoJCQoJCS0t
IGZsYXAKCQlpZiAoYS5mcj4yKSB0aGVuCgkJCS0tIG1lYW55IHdlYWsgZmxhcHMgd2hpbGUgZnJl
YWtlZCBvdXQKCQkJbG9jYWwgbWFnID0gYS5wYW5pY190ID4gMCBhbmQgMC40IG9yIDEKCQkJYS5k
eSAtPSAxLjIgKiBtYWcKCQkJaWYgKGEueCA8IHR4LTUpIGEuZHggKz0gLjUgKiBtYWcKCQkJaWYg
KGEueCA_IHR4KzUpIGEuZHggLT0gLjUgKiBtYWcKCQkJYS5mciA9IDAKCQllbmQKCQkKCQlpZiAo
YS5mciA8IDEpIGEuZnIgKz0gMC4wMiAtLSBnZXQgcmVhZCB0byBmbGFwIGFnYWluCgkJYS5mciAl
PSAyCgkJCgkJLS0gY29uc3RhbnQgZmluZSBhZGp1c3RtZW50CgkJaWYgKGEueCA8IHR4ICsgMSkg
YS5keCArPSAuMDIKCQlpZiAoYS54ID4gdHggLSAxKSBhLmR4IC09IC4wMgoJCQoJCQoJCWEueCAr
PSBhLmR4CgkJYS55ICs9IGEuZHkKCQlhLmR4ICo9IDAuOTUKCQlhLmR5ICo9IDAuOTUKCQlhLmR5
ICs9IC4wNCAtLSBncmF2aXR5CgkJCgkJYS5kID0gc2duKGEuZHgpCgkJCgkJbG9jYWwgZHggPSAo
YS54IC0gdHgpLzQgLS0gZG9uJ3QgbmVlZCB0byBiZSBwcmVjaXNlIHdpdGggeCB0YXJnZXQKCQls
b2NhbCBkeSA9IGEueSAtIHR5CgkJCgkJCgoJCS0tIGxhbmQgb24gd2luZG93CgkJCgkJaWYgKGR4
KmR4ICsgZHkqZHkpIDwgOSBhbmQgYS5keSA_IDAgYW5kIHcgdGhlbgoJCQlhLnByb2NfaWQgPSB3
LnByb2NfaWQKCQkJYS5weCA9IChhLnggLSB3LngpIC8gdy53aWR0aAoJCQlhLmR4LGEuZHkgPSAw
LDAKCQllbmQKCQkKCWVuZAoJCglpZiBhLnByb2NfaWQgdGhlbgoJCgkJYS5mciA9IDgKCQktLSBm
aW5kIHRoYXQgd2luZG93CgkJbG9jYWwgZm91bmQgPSBmYWxzZQoJCWxvY2FsIGtpY2tlZF9vZmYg
PSBmYWxzZQoJCWZvciB3IGluIGFsbCh3aW5kYXQpIGRvCgkJCWlmICh3LnByb2NfaWQgPT0gYS5w
cm9jX2lkKSB0aGVuCgkJCQlhLnggPSB3LngrYS5weCp3LndpZHRoCgkJCQlhLnkgPSB3LnkKCQkJ
CWZvdW5kID0gdHJ1ZQoJCQllbHNlaWYgZm91bmQgdGhlbgoJCQkJLS0gd2luZG93IGluIGZyb250
IG9mIHJvb3N0aW5nIHdpbmRvdwoJCQkJaWYgKGEueCA_PSB3LngtNCBhbmQgYS54IDw9IHcueCt3
LndpZHRoKzQgYW5kCgkJCQkJYS55ID49IHcueSBhbmQgYS55IDw9IHcueSt3LmhlaWdodCs3KSB0
aGVuCgkJCQkJa2lja2VkX29mZiA9IHRydWUKCQkJCWVuZAoJCQllbmQKCQllbmQKCQkKCQlpZiAo
bm90IGZvdW5kIG9yIGtpY2tlZF9vZmYpIHRoZW4KCQkJYS5wcm9jX2lkID0gbmlsCgkJCWEuZHgg
PSBybmQoNCktMgoJCQlhLmR5ID0gcm5kKDQpLTQKCQkJYS50eCA9IHJuZCgwLjgpKzAuMSAtLSBj
aG9vc2UgYSBuZXcgdGFyZ2V0CgkJCWEucGFuaWNfdCA9IDYwK3JuZCg0MCkKCQllbmQKCWVuZAoJ
CglhLnQgKz0gMQoJCmVuZAoKOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRl
ZD0iMjAyMy0xMC0yMyAwOTozMDozNiIsbW9kaWZpZWQ9IjIwMjQtMDktMDkgMDk6MTQ6MzYiLHJl
dmlzaW9uPTk3OSxzdG9yZWQ9IjIwMjMtMTItMDQgMTY6MTI6NTEiXV0KLS1bWwoJYmlyZHMucDY0
IGJ5IHplcAoKCSoqIHRoZXJlIGlzIG5vIHdheSB0byBjbG9zZSB0aGlzIGFwcCEgKioKCQoJZnJv
bSB0ZXJtaW5hbCwgdXNlIHRoZSBwcyBjb21tYW5kCgk_IHBzCglsb29rIGZvciAiYmlyZHMiIGFu
ZCBub3RlIHRoZSBwcm9jZXNzIG51bWJlciAoc2F5LCAxNSkKCT4ga2lsbCAxNQoJCgl0aGlzIGFw
cCBjcmVhdGVzIGEgZnVsbHNjcmVlbiB0cmFuc3BhcmVudCBsYXllciwgd2hpY2ggdXNlcyBhIGxv
dCBvZgoJY3B1IGFuZCB3aWxsIGNhdXNlIGZyYW1lIHNraXBwaW5nIHdoZW4gbW9yZSB0aGFuIGEg
ZmV3IHdpbmRvd3MgYXJlCglvcGVuLiAvLyBtYXliZSBpbiBmdXR1cmU6IHdtIGNhbiBvYnNlcnZl
IGRpcnR5IHJlY3RhbmdsZXM-Cl1dCgp3aW5kYXQgPSB7fQoKaW5jbHVkZSAiYmlyZC5sdWEiCgoK
ZnVuY3Rpb24gX2luaXQoKQoJCgktLSBkcmF3IG1hc2sgLS0gZGlzcGxheSBwaXhlbHMgdGhhdCBo
YXZlIG9uZSBvZiB0aGVzZSBiaXRzIHNldCBhcmUgZHJhd24KCS0tIDAgbWVhbnMgZHJhdyBhbGwg
cGl4ZWxzCglwb2tlKDB4NTQ3ZCwgMHgzZikKCQoJLS0gaW50ZXJhY3Rpb24gbWFzayAtLSAgcGl4
ZWxzIHRoYXQgaGF2ZSBvbmUgb2YgdGhlc2UgYml0cyBzZXQgY2FuIGJlIGNsaWNrZWQgb24KCS0t
IDAgbWVhbnMgaW50ZXJhY3Qgd2l0aCBhbGwgcGl4ZWxzCgktLSBub3RlOiBub3QgYWN0dWFsbHkg
dXNlZCBiZWNhdXNlIG9mIHdpbmRvdyBhdHRyaWJ1dGU6IGludGVyYWN0aXZlID09IGZhbHNlCgkt
LSBidXQgb3RoZXJ3aXNlIGNhbiBmb2N1cyB0aGUgYXBwIGJ5IGNsaWNraW5nIG9uIG9uZSBvZiB0
aGUgYmlyZHMKCS0tIChpZiB0aGF0IHdlcmUgcG9zc2libGUpCglwb2tlKDB4NTQ3ZSwgMHhmZikK
CQoJd2luZG93ewoJCXogPSAxMCwgLS0gYWx3YXlzIG9uIHRvcC4gaWYgYmlyZCBnZXRzIGNvdmVy
ZWQsIHN0YXJ0IGZseWluZy4KCQkgICAgICAgIC0tIChvciB1c2Ugd2luZGF0IHRvIG9ic2N1cmU-
KQoJCSAgICAgICAgLS0gY291bGQgcm9vc3Qgb24gYWN0aXZlIHdpbmRvdwoJCQoJCS0tIGNvdmVy
LCBidXQgbm90IC5mdWxsc2NyZWVuIChvcGVuIGluIGEgZGVza3RvcCB3b3Jrc3BhY2UpCgkJd2lk
dGggPSA0ODAsCgkJaGVpZ2h0ID0gMjcwLAoJCXggPSAwLCB5ID0gMCwKCQltb3ZlYWJsZSA9IGZh
bHNlLAoJCWhhc19mcmFtZSA9IGZhbHNlLAoJCXN1YnNjcmliZV90b193aW5kYXQgPSB0cnVlLAoJ
CWludGVyYWN0aXZlID0gZmFsc2UgLS0gZG9uJ3QgYmxvY2sgY2xpY2tzCgl9CgkKZW5kCgpmdW5j
dGlvbiBfdXBkYXRlKCkKCWZvcmVhY2goYmlyZCwgbW92ZV9iaXJkKQoJCgktLSBhZGQgYSBmZXcg
bW9yZSBiaXJkcyBlYWNoIHRpbWUgYSB3aW5kb3cgaXMgb3BlbmVkCgktLSAoYnV0IG5ldmVyIGRl
Y3JlYXNlISkKCXdoaWxlICNiaXJkIDwgI3dpbmRhdCozKzYgZG8KCQltYWtlX2JpcmQoLTEwLXJu
ZCgyMDApLHJuZCgyNDApKzIwKQoJZW5kCmVuZAoKCmZ1bmN0aW9uIF9kcmF3KCkKCQoJY2xzKCkK
CgktLSB0ZXN0OiBzaG91bGRuJ3QgYmxvY2sgaW50ZXJhY3Rpb24gYmVjYXVzZSB3aW5kb3d7aW50
ZXJhY3RpdmUgPSBmYWxzZX0KCS0tCWNpcmNmaWxsKDI0MCwxMzUsMjAsMTIpCgkKCWZvcmVhY2go
YmlyZCwgZHJhd19iaXJkKQoJCmVuZAoKLS0gd2luZG93IHBvc2l0aW9ucyBhcmUgcHVibGlzaGVk
IGV2ZXJ5IGZyYW1lIGJ5IHdtCi0tIChidXQgdW5mb3J0dW5hdGVseSB0aGF0IGZyYW1lIGFscmVh
ZHkgZHJhd24gYnkgd20gYnkgdGhlIHRoZSB0aW1lIHdlIGdldCB0aGlzKQpvbl9ldmVudCgibW9k
aWZpZWQ6L3JhbS9zaGFyZWQvd2luZG93cy5wb2QiLCBmdW5jdGlvbigpCgl3aW5kYXQgPSBmZXRj
aCIvcmFtL3NoYXJlZC93aW5kb3dzLnBvZCIKZW5kKQoKOjogLmluZm8ucG9kCi0tW1twb2QsY3Jl
YXRlZD0iMjAyMy0xMC0yMSAxNjoxNjo1NCIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6Mzgi
LHJ1bnRpbWU9MTAsc3RvcmVkPSIyMDIzLTE3LTIxIDE2OjE3OjEzIix3b3Jrc3BhY2VzPXt7bG9j
YXRpb249Im1haW4ubHVhIzEzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJiaXJkLmx1
YSMxMjIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNl
X2luZGV4PTJ9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIx
IDE2OjE2OjU0Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTE2
LTIxIDE2OjE2OjU0Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJekxURXdMVEl6SURBNU9qTXdPak0ySWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck9TMHdPU0F3
T1RveE5Eb3pOaUlzY21WMmFYTnBiMjQ5T1RFMUxITjBiM0psWkQwaU1qQXlNeTB4TWkwd05DQXhO
am94TWpvMU1TSmQKWFd4Nk5BQnRBUUFBNURFQUFQTWllMXN3WFQxN1ltMXdQWEI0ZFFCRElCQVFC
UEJqRndBZkdBQVhjQmNBSGdBWDhHVXNabXhoWjNNOQpNQ3h3WVc1ZmVBZ0F4M2s5TUN4NmIyOXRQ
VGg5TEQ4QS13MElDQVFRQ0hBdkQwQU9BUTVBTGdvUUNRQVpRQW9wSUJvcFFBSXdTQUFjCi13cWdD
QzhQRUFrUURnRU9FQVFKQUM0S0FCUXBNQVFwUUJsUVNnQWVKUkFJa1FELUFTQVpBakE1QkRBYUNS
UWdBZ29RQklCS0FCa0EKR3dFZjhERUFzUDhlSmc4VjBBNElMckFPTHc4T29BNE5BUTBPa0I0dENn
NXdEZ2tPR1I2UURnb3BEb0FPR2lrT2tCNENIdkEyWFFBZQpWVDhWb0E0SVdnRC1FNkFPTFFvT2dB
NFpBaDZBRGprRURwQU9HZ2tVRG9BT0Fnb2VCQTZRSGhBTzhEVmhBQjFRTno4VmtCNWhBRUJ3CkRn
a2VZd0JBY0E0RUNXWUEtd1ZnRGhRcEhvQU9CQ2tPb0E0WkRyQU9BZzd3TjMwQkhnOHhBUC0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
clVHMDlPSDE5Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIxIDE2
OjE2OjU0Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTE2LTIx
IDE2OjE2OjU0Il1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJ
ekxUTXdMVEl6SURBNU9qTXdPak0ySWl4dGIyUnBabWxsWkQwaU1qQXlNeTB4Ck5DMHpNQ0F4TURv
eE5Eb3dOQ0lzY21WMmFYTnBiMjQ5T1RRc2MzUnZjbVZrUFNJeU1ESXpMVEV5TFRBMElERTJPakV5
T2pVeElsMWQKYkhvMEFGMEFBQUJZQkFBQThCTjdiR0Y1WlhJOWUxc3dYVDE3WW0xd1BYVnpaWEpr
WVhSaEtDSnBNVFlpTERFMkF3QXZJakFCQVAtLQotX19oSWlrc2NHRnVYM2c5TUFnQThnWjVQVEFz
YzJOaGJHVTlNU3gwYVd4bFgyZzlNVFlLQUhCM1BURTJmWDE5Cjo6IFtlb2NdCg==
:: bios/demos/carpet.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTI5LTIyIDA5OjI5OjMz
Iixtb2RpZmllZD0iMjAyNC0wOS0wMiAxNzowOTo1NyIscmV2aXNpb249MjgxN11dCi0tWz1bCgpU
cmFuc2Zvcm1hdGlvbiBtYXRyaWNlcyBpbiBQaWNvdHJvbiBjYW4gYmUgY29uc3RydWN0ZWQgYXMg
M3g0IHVzZXJkYXRhLCBhbmQgdGhlbgphcHBsaWVkIHRvIHZlY3RvcnMgKDN4MSB1c2VyZGF0YSkg
b3Igb3RoZXIgbWF0cmljZXMgdXNpbmcgOm1hdG11bDNkKCkKCnYgICAgICA9IHZlYygxLjAsIDAu
MCwgMC4wKSAgICAgICAgICAgICAgIC0tIGNyZWF0ZSBhbiB4eXogdmVjdG9yIChhIHBvaW50IGlu
IHNwYWNlKQp2ICAgICAgPSB2Om1hdG11bDNkKG0pICAgICAgICAgICAgICAgICAgICAtLSB0cmFu
c2Zvcm0gdiBieSBtYXRyaXggbQp2ICAgICAgPSB2Om1hdG11bDNkKG9wX2EpOm1hdG11bDNkKG9w
X2IpICAtLSB0cmFuc2Zvcm0gdiBieSAyIG1hdHJpY2VzIChhIHRoZW4gYikKb3BfYWIgID0gb3Bf
YTptYXRtdWwzZChvcF9iKSAgICAgICAgICAgICAgLS0gY29tYmluZSB0d28gb3BlcmF0aW9ucyBp
bnRvIG9uZSBtYXRyaXgKClRoZSAxMiB2YWx1ZXMgaW4gYSAzZCB0cmFuc2Zvcm1hdGlvbiBtYXRy
aXggbG9vayBsaWtlIHRoaXM6Ci0tW1twb2RfdHlwZT0iaW1hZ2UiXV11bnBvZCgiYjY0OmJIbzBB
SVVDQUFBQkF3QUE4Q2x3ZUhVQWdBQUFBRTBBQUFBQkFBQUFBd1R3LS1fR19DRHdOUGd1OERENEFQ
QWNXUEF0U1BBclNQQXFPUEFMRmhBVzhBMUk4Q2tvTUFvQUVRSUZBS0JXWUNqd0tSaFFOdkFERHdE
d0JBVVdnQ2p3S0JoZ0Z2QUZSdkFFRnFBWThDZ2NBTUlIRnZBREZyQVk4QVI4OEF3OUFCQUdPd0R4
UElBWThBa2M4QTA0OEF3MjhCSVk4QWdjOEE4NDhEQW84QWNjOEJINE52QUdIUEFUX0RQd0FEd2dI
UEJwSEJCODhHTU1BQXp3Ry1zcjhBWU1FQXp3R3ZzdjhBSU04QjA3OENoYjRBZ0FFQWxhQURBTU85
QU5BQmNRb3dDRlVDdXdEUEFlS3pDbEFJTndHNkFNOEI4YlVLY0FnNEFia0F6d0lCdEFxUUNGa0J1
QURQQWhLeUNvQVBGd1lCdHdEUEFpTy1BTE52QVBLMkFNOENSTDhDczdZQmZ3Skh2d0RQc09jQmM0
OENMN0w0QUxRSGp3QVFqd0RQc1A4QlVMd0hpUUNQQlBDLUFGZUNBSUVCZ3dHUEJFQy1BTlNCQVlF
Qmp3Qy13YjRBdndFQWd3T0tEOEw3QUw4QThJVUJpZy1BYndGbHlRQy1BT0NGQTRnRHp3TEV5QUMt
QVRHQkFZY0N6d0RIY0J1RHh3Qy1BU0dEQVlVQ3hBMmdCbVBHQUw4Q0FzZndFZ2NDd1JBQ01jY05v
QUlaQWNEd0FUWU5vQUVhQVBBQ1lzUU5vQUFTOEFZRHp3RFRid0VBc0FRQ0VzOEM5cUFQRVRJanp3
S2x5QUMtQWp2UEFXLUFDUUMtQWwtQzNBQy1BdC1CbndDUXZ3Ynd2d2NBWUE4QThqLVNqd0JBdndJ
djBzOEFFTE1Cc2dHLUFXUGZBbFhjQUxBQXNBQ3hBUUFJRVZQZkFvWGJBcklBd0FVaTN3SzAyd0tB
QkFGUjN3RFlZQVFBc3Q4QUVRQUNnVUxkY0FoakF0OEFGYjhCUXQyQUNFUUMzd0JSdndGQjNaQUNG
Z0hSQUFGQzFkQWhKd0VBQVdQVjBDVUVBZDhBRkxrQUR3RGd3MjhBMHQ4QzQ5OENsTjhDOWQ4Q0Nk
OERMOUstQTQtU1B3LS1feiIpClRoZSB0b3AgM3gzIGFyZWEgY2FuIGJlIHRob3VnaHQgb2YgYXMg
YSBjb29yZGluYXRlIHNwYWNlIHRoYXQgdHJhbnNmb3JtZWQgcG9pbnQgd2lsbApiZSBzY2FsZWQg
YW5kIHJvdGF0ZWQgaW50by4gU28sIHYueCBtZWFucyAiaG93IGZhciB0byB0cmF2ZWwgYWxvbmcg
dGhlIHJlZCB2ZWN0b3IgaW4KbSIuIFRoZSBsYXN0IHJvdyBpcyBhIHRyYW5zbGF0aW9uIHZlY3Rv
ciBlLmcuIDIsMCwwIG1lYW5zIG1vdmUgdGhlIHJlc3VsdCByaWdodCBieSAyLgoKXT1dCgpmdW5j
dGlvbiBpZGVudGl0eV9tYXRyaXgoKQoJbG9jYWwgbSA9IHVzZXJkYXRhKCJmNjQiLDMsNCkKCXNl
dChtLCAwLCAwLAoJCTEsIDAsIDAsIAoJCTAsIDEsIDAsIAoJCTAsIDAsIDEsIAoJCTAsIDAsIDAK
CSkKCXJldHVybiBtCmVuZAoKCi0tIHJvdGF0ZSBwb2ludCB4LHkgYXJvdW5kIG9yaWdpbiBieSBh
bmdsZSBhCmZ1bmN0aW9uIHJvdDJkKHgseSxhKQoJcmV0dXJuIGNvcyhhKSp4IC0gc2luKGEpKnks
IGNvcyhhKSp5ICsgc2luKGEpKngKZW5kCgotLSBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBtYXRy
aXggdGhhdCByb3RhdGVzIGFyb3VuZCBhIGdpdmVuIGF4aXMgYnkgYW5nbGUKLS0gYXhpcyBpcyBh
IHN0cmluZzogIngiLCAieSIsICJ6IgpmdW5jdGlvbiByb3RhdGlvbl9tYXRyaXgoYXhpcywgYW5n
bGUpCgkKCS0tIGNvbXBvbmVudCBvZmZzZXRzIGRlcGVuZCBvbiB3aGljaCBheGlzIHRvIHJvdGF0
ZSBhcm91bmQKCWxvY2FsIGRhdCA9IHt4PXszLDZ9LCB5PXswLDZ9LCB6PXswLDN9fQoJbG9jYWwg
YzAsYzEgPSBkYXRbYXhpc11bMV0sIGRhdFtheGlzXVsyXQoJCglsb2NhbCBtID0gaWRlbnRpdHlf
bWF0cml4KCkKCQoJLS0gcm90YXRlIHRoZSBjb21wb25lbnQgdmVjdG9ycyAoZWFjaCBvbmUgaXMg
YSBjb2x1bW4gZnJvbSByb3dzIDAuLjIpCglmb3IgY29sdW1uPTAsMiBkbwoJCW1bY29sdW1uICsg
YzBdLCBtW2NvbHVtbiArIGMxXSA9IHJvdDJkKG1bY29sdW1uICsgYzBdLCBtW2NvbHVtbiArIGMx
XSwgYW5nbGUpCgllbmQKCXJldHVybiBtCmVuZAoKCmZ1bmN0aW9uIF9pbml0KCkKCgktLSBtYWtl
IDMxMzYgcG9pbnRzCglwPXt9IG4gPSA0MAoJZm9yIHogPSAtbixuLDIgZG8KCQlmb3IgeCA9IC1u
LG4sMiBkbwoJCQlsb2NhbCB5ID0gc2luKHoqY29zKHgvMTkpLzEwMDApICsgc2luKHovNTIpIC0g
Y29zKHovMzUpKnNpbih4Lzc3KSoyICsgMwoJCQkJLS0geCwgeSwgeiwgY29sb3VyCgkJCQktLSBu
b3RlOiB3ZSBjYW4gc3RvcmUgdGhlIGNvbG91ciBoZXJlLCBiZWNhdXNlIG1hdG11bDNkCgkJCQkt
LSBvbmx5IGNhcmVzIGFib3V0IHRoZSBmaXJzdCAzIHZhbHVlcyBvZiBlYWNoIHJvdyEKCQkJCXBb
I3ArMV0gPSB2ZWMoeCwgeSwgeiwgMTAreSoxLjUpIAoJCWVuZAoJZW5kCgkKCS0tIGNyZWF0ZSBh
IHVzZXJkYXRhIHRoZSBzYW1lIHNpemUsIHVzZWQgZm9yIHotc29ydGluZwoJb3JkZXIgPSB1c2Vy
ZGF0YSgiZjY0IiwgMiwgI3ApCglmb3IgaT0wLCNwLTEgZG8KCQlzZXQob3JkZXIsIDAsIGksIGkr
MSkgLS0gc3RhcnRpbmcgc2NvcmUKCQlzZXQob3JkZXIsIDEsIGksIGkrMSkgLS0gaW5kZXgKCWVu
ZAoJCmVuZAkKCgoKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKCkKCWxvY2FsIHd3ID0gMjQwLjAKCQoJ
LS0gY3JlYXRlIDMgbWF0cmljZXMgdGhhdCBtb2RpZnkgdGhlIG9yaWVudGF0aW9uIGFuZCBwb3Np
dGlvbiBvZgoJLS0gdGhlIGxhbmRzY2FwZSAoaW4gdGhpcyBkZW1vLCB0aGVyZSBpcyBubyBjb25j
ZXB0IG9mIGEgY2FtZXJhKQoJCglzcGluX2Fyb3VuZCA9IHJvdGF0aW9uX21hdHJpeCgieSIsdCgp
LzIwKSAgICAgICAgCgl0aWx0ICAgICAgICA9IHJvdGF0aW9uX21hdHJpeCgieCIsMC4wNikgICAg
ICAgICAgLS0gMCB0byBzdGF5IGZsYXQKCXNoaWZ0X3ogICAgID0gaWRlbnRpdHlfbWF0cml4KCkg
c2hpZnRfelsxMV0gPSA3MCAtLSB0cnkgMjAgZm9yIGNsb3NlIHVwCgkKCS0tIG1hdG11bDNkKCkg
aXMgdXNlZCB0byBtdWx0aXBseSAzeDQgbWF0cmljZXMKCS0tIGhlcmUgdGhlIDMgdHJhbnNmb3Jt
YXRpb25zIHdpbGwgYmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQKCQoJbSA9IHNwaW5fYXJv
dW5kOm1hdG11bDNkKHRpbHQpOm1hdG11bDNkKHNoaWZ0X3opCgkKCS0tICh0aGlzIGdpdmVzIHRo
ZSBzYW1lIHJlc3VsdCBhcyBhcHBseWluZyBlYWNoIG1hdHJpeCBzZXBhcmF0ZWx5IGluIHRoZQoJ
LS0gaW5uZXIgbG9vcDogdiA9IHY6bWF0bXVsM2Qoc3BpbmFyb3VuZCkgdiA9IG1hdG11bDNkKHRp
bHQpIGV0YykKCQoJLS0tLS0tLS0gc29ydCAtLS0tLS0tLS0KCgktLSAodXNpbmcgY2FtZXJhIHog
dmFsdWVzIGZyb20gbGFzdCBmcmFtZSEpCgkKCW9yZGVyOnNvcnQoKQoJCgktLS0tLS0tLSBkcmF3
IC0tLS0tLS0tLQoJCglsb2NhbCB2ID0gdmVjKDAsMCwwKSAtLSByZXVzZWQgZm9yIGV2ZXJ5IHRy
YW5zZm9ybWVkIHBvaW50CgkKCWxvY2FsIHYwID0gdmVjKDAsMCwwLDApCglmb3IgaT0wLCNvcmRl
ci0xLDIgZG8KCQlibGl0KHBbb3JkZXJbaSsxXV0sdjApIC0tIGdyYWIgZnJvbSB0aGUgc29ydGVk
IGxpc3QKCQkKCQl2MC55ICs9IGNvcyh0KCkqLjUrKHYwLngrdjAueSkqLjAxKSo1CgoJCS0tIGFw
cGx5IHRoZSAzIHRyYW5zZm9ybWF0aW9ucyB1c2luZyBhIHNpbmdsZSBtYXRyaXgKCQktLSAobSBt
ZWFucyBzcGluIGFyb3VuZCwgdGlsdCwgYW5kIHRoZW4gc2hpZnQgYWxvbmcgeikKCQktLSB3cml0
ZSB0aGUgb3V0cHV0IHRvIHYgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyB1c2VyZGF0YSAKCQkt
LSAoIGZhc3RlciB0aGFuIGUuZy4gdiA9IG1hdG11bDNkKG0sIHYwKSApCgkJdjA6bWF0bXVsM2Qo
bSwgdikKCQkKCQlsb2NhbCBzeiA9IHYuegoJCQoJCW9yZGVyW2ldID0gLXN6IC0tIHNldCB0aGUg
c2NvcmUgZm9yIHNvcnRpbmcgbmV4dCBmcmFtZSAoZHJhdyBmdXJ0aGVzdCBmaXJzdCkKCgkJaWYg
KHN6ID4gMC4wMSkgdGhlbgoJCQktLSBpbiBmcm9udCBvZiB2aWV3cGxhbmU7IGRyYXcgaXQKCQkJ
bG9jYWwgd3dfZGl2X3N6ID0gd3cgLyBzegkJCgkJCWxvY2FsIHN4ID0gMjQwLjAgKyB2LnggKiB3
d19kaXZfc3oKCQkJbG9jYWwgc3kgPSAxMzUgKyB2LnkgKiB3d19kaXZfc3oKCQkJLS1wc2V0KHN4
LHN5LHYwLnUpCgkJCWNpcmNmaWxsKHN4LHN5LTUwLCAyNTAvc3osIHYwWzNdKQoJCWVuZAoJZW5k
CgkJCgktLXByaW50KHN0cmluZy5mb3JtYXQoImNwdTogJTMuM2YgKCVkZnBzKSIsIHN0YXQoMSks
IHN0YXQoNykpLCAxMCwgMTAsIDEpCgkKZW5kCgoKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0
ZWQ9IjIwMjQtMTAtMDkgMDI6NTA6NDUiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixz
dG9yZWQ9IjIwMjQtMDktMDIgMTc6MDk6NTciLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5s
dWEiLHdvcmtzcGFjZV9pbmRleD0xfX1dXQo6OiBbZW9jXQo=
:: bios/demos/hexopus.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTEwLTI5IDA4OjM1OjA4
Iixtb2RpZmllZD0iMjAyNS0xMC0yOSAwODozNTowOCIscmV2aXNpb249MF1dCi0tIGZsZXhpbmcg
aGV4b3B1cwotLSBieSB6ZXAKZnVuY3Rpb24gZHJhd19zZWdtZW50KHgseSxyLGEsYykKCQoJbGlu
ZSgpCglmb3IgaT0wLDYgZG8KCQlsb2NhbCB4ID0geCArIGNvcyhhK2kvNikgKiByCgkJbG9jYWwg
eSA9IHkgKyBzaW4oYStpLzYpICogcgoJCWxpbmUoeCx5LGMpCgllbmQKCQplbmQKbG9jYWwgZGEg
PSAwCmZ1bmN0aW9uIF9kcmF3KCkKCWRhICs9IDAuMDAyCgljbHMoMSkKCWNsaXAoMTAsMTAsNDYw
LCAyNTApCgljYW1lcmEoKQoJcmVjdGZpbGwoMCwwLDQ4MCwyNzAsMzIpCgkKCWNhbWVyYSgwLDAp
CgkKCS0tIHRvIGRvOiBjbGlwcGluZyAvIGNvb3JkaW5hdGVzIG91dHNpZGUgaTE2IHJhbmdlCgkt
LSBxPTEwMDAwMAoJLS0gbGluZSgyNDAtcSwxMzUtcS8yLDI0MCtxLDEzNStxLzIsMTApCgkKCWZv
ciBqID0gMCw1IGRvCglsb2NhbCB4LHkgPSAyNDAsIDEzNQoJbG9jYWwgciAgID0gMjIKCWxvY2Fs
IGEgICA9IGovNiArIHRpbWUoKS84CgkKCWRhID0gY29zKHRpbWUoKS81KS8xMgoJZm9yIGkgPSAx
LDIwIGRvCgkJZHJhd19zZWdtZW50KHgsIHksIHIqLjksIGEsIDggKyAoaSU5KSkKCQl4ICs9IGNv
cyhhKSAqIHIKCQl5ICs9IHNpbihhKSAqIHIKCQlhICs9IGRhCgkJciAqPSBpIDwgMTAgYW5kIDAu
OCBvciAwLjkKCQl4ICs9IGNvcyhhKSAqIHIKCQl5ICs9IHNpbihhKSAqIHIKCWVuZAoJZW5kCglj
bGlwKCkKCXByaW50KHN0cmluZy5mb3JtYXQoIiUuNWYiLCBzdGF0KDEpKSwgMTIsMiwxNykKZW5k
Cjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMTIgMTg6MTM6NTMiLG1vZGlm
aWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixydW50aW1lPTIxLHN0b3JlZD0iMjAyNC0wMy0xMiAx
ODoxMzo1MyIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxIix3b3Jrc3BhY2VfaW5k
ZXg9MX19XV0KOjogW2VvY10K
:: bios/demos/highway.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTI3LTE1IDA1OjI3OjI0
Iixtb2RpZmllZD0iMjAyMy00Ny0xNSAwNzo0Nzo0MSIscmV2aXNpb249ODUwXV0KLS1bWwoJdGxp
bmUzZCB0ZXN0CgljYW4gZG8gYXJvdW5kIDMgc2NyZWVucyBwZXIgZnJhbWUgYXQgNjBmcHMgd2hl
biB1c2luZyBmYXN0IHBhdGg6CgltYXNrcyBhcmUgYWxsIDB4M2YgYW5kIGZpbGwgcGF0dGVybiBp
cyAwCl1dCmZ1bmN0aW9uIF9pbml0KCkKCXBsPXtkPS4xLCB4PTAsIHk9NSwgej0wLCBkeD0xLCBk
eT0xfQoJCgktLSBjcmVhdGUgYSB0ZXh0dXJlIGJpdG1hcCBhbmQgZHJhdyBzb21ldGhpbmcgb24g
aXQKCXNzID0gdXNlcmRhdGEoInU4IiwzMiwzMikKCQoJc2V0X2RyYXdfdGFyZ2V0KHNzKQoJLS1j
aXJjKDE2LDE2LDQsNykKCWxpbmUoMCwwLDMxLDAsMSkKCWxpbmUoMCwwLDAsMzEsMSkKCXNldF9k
cmF3X3RhcmdldCgpCgkKCWZvciB5ID0gMCw3IGRvCgkJZm9yIHg9MCw3IGRvCgkJCXNldChzcywg
eCwgeSwgOCt4LzMreS8zKQoJCWVuZAoJZW5kCgkKZW5kCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygp
Cglsb2NhbCB2PXt9Cgl2LngwID0gY29zKHBsLmQrMC4xKSAKIAl2LnkwID0gc2luKHBsLmQrMC4x
KQogCXYueDEgPSBjb3MocGwuZC0wLjEpCiAJdi55MSA9IHNpbihwbC5kLTAuMSkKCQoJZm9yIHp6
PTMsMSwtMSBkbwoJCglmb3IgaT0wLDQgZG8KCQlwYWwoOCtpLCA4K2kgKyAoenotMSkqMikKCWVu
ZAoJCglmaWxscCgwKQoKCS0tIHNsb3cKCS0taWYgKHp6PT0yKSBmaWxscCgweDVhNWEpCgktLWlm
ICh6ej09MykgZmlsbHAoMHgxZjRmKQoJCgkKCWxvY2FsIHZ4ID0gdi54MAoJbG9jYWwgdnkgPSB2
LnkwCglsb2NhbCBkdnggPSAodi54MSAtIHYueDApIC8gNDgwLjAKCWxvY2FsIGR2eSA9ICh2Lnkx
IC0gdi55MCkgLyA0ODAuMAoJbG9jYWwgejAgPSB6eiAqIDUwLjAKCWxvY2FsIHoxID0genogKiA1
MDAuMAoJbG9jYWwgeD1wbC54CiAJbG9jYWwgeT1wbC55CiAJbG9jYWwgej1wbC56LTIwIC0tIDEg
dW5pdCBoaWdoCiAJCglmb3Igc3g9MCw0NzksMSBkbwoJCQoJCXRsaW5lM2Qoc3MsICAgc3gsIDI3
MCwgc3gsIDMwLCAgCgkJCSh4K3Z4KnowKS96MCwgKHkrdnkqejApL3owLCAKCQkJKHgrdngqejEp
L3oxLCAoeSt2eSp6MSkvejEsICAKCQkJMS4wL3owLCAxLjAvejEpCgkJCQoJCXZ4ICs9IGR2eAoJ
CXZ5ICs9IGR2eQoJCQoJCS0tbGluZShzeCwgMjY5LCBzeCwgMCwgcm5kKDMpKQoJZW5kCgllbmQK
CQoJZmlsbHAoKQoJcHJpbnQoc3RyaW5nLmZvcm1hdCgiJS40ZiAlZGZwcyIsc3RhdCgxKSwgc3Rh
dCg3KSksMiwyLDUpCgkKZW5kCgpmdW5jdGlvbiBfdXBkYXRlKCkKCWlmIChidG4oMCkpIHRoZW4g
cGwuZD0ocGwuZCswLjAwNSklMSBlbmQKCWlmIChidG4oMSkpIHRoZW4gcGwuZD0ocGwuZCswLjk5
NSklMSBlbmQKCWlmIChidG4oMikgb3IgYnRuKDMpKSB0aGVuCgkJbG9jYWwgYWNjZWwgPSAuMQoJ
CWlmIChidG4oMykpIGFjY2VsID0gLWFjY2VsCgkJcGwuZHggKz0gY29zKHBsLmQpICogYWNjZWwK
CQlwbC5keSArPSBzaW4ocGwuZCkgKiBhY2NlbAoJZW5kCglwbC54ICs9IHBsLmR4CglwbC55ICs9
IHBsLmR5CglwbC5keCAqPSAuOTgKCXBsLmR5ICo9IC45OAplbmQKOjogLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyMy0xMC0xNSAwNToyNzoxNyIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6
NDc6MzgiXV0KOjogW2VvY10K
:: bios/demos/pixeldust.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMjgg
MDA6MjQ6MzYiLG1vZGlmaWVkPSIyMDI0LTEwLTExIDIxOjU2OjUxIixyZXZpc2lvbj0xNzQxXV0K
LS1bWwoJcGl4ZWxkdXN0LnA2NAoKCXVzZSB1c2VyZGF0YSBvcGVyYXRpb24gYW5kIGJhdGNoIHBz
ZXQgY2FsbCB0byBtYW5hZ2UgbW92aW5nCglhbmQgZHJhd2luZyAzMmsgcGl4ZWxzCl1dCgpsb2Nh
bCBtYXhfcGl4ZWxzID0gMzI3NjgKCndpbmRvd3sgY3Vyc29yPSJjcm9zc2hhaXIiIH0KCi0tIHBp
eGVscy4gZWFjaCByb3c6IHgseSxjb2wsZHgsZHkKLS0gbm90ZTogdGhlIGZpcnN0IDMgdmFsdWVz
IGFyZSBpbiB0aGUgc2FtZSBhcyBwYXJhbWV0ZXJzIHRvIHBzZXQoKQpwID0gdXNlcmRhdGEoImY2
NCIsIDUsIG1heF9waXhlbHMpCgoKbG9jYWwgaWR4ID0gMApsb2NhbCBtYXhfaWR4ID0gMAoKZnVu
Y3Rpb24gX2RyYXcoKQoJY2xzKCkKCQoJcG9rZSgweDU1MGIsMHgzZikgLS0gaWYgdXNlIGZpbGxw
LCB3YW50IGJsYWNrIHBpeGVscyB0byBiZSB0cmFuc3BhcmVudAoJCi0tCWZpbGxwKH4weDEyNDgp
IC0tIGtpbmRhIGludGVyZXN0aW5nCglwc2V0KHApCglmaWxscCgpCgkKCXByaW50KCJkb3RzOiIu
Lm1heF9pZHgsMiwyLDEzKQoJcHJpbnQoImNwdTogIi4uc3RyaW5nLmZvcm1hdCgiJS4zZiIsc3Rh
dCgxKSksMiwxMikKCXByaW50KHN0YXQoNykuLiJmcHMiLDIsMjQpCgkKZW5kCgpmdW5jdGlvbiBf
dXBkYXRlKCkgCgoJbG9jYWwgbG14LGxteSA9IG14IG9yIDAsIG15IG9yIDAKCWxvY2FsIGxkeCxs
ZHkgPSBkeCBvciAwLCBkeSBvciAwCglteCxteSxtYiA9IG1vdXNlKCkKCQoJLS0gbWFrZSBkb3Rz
CglkeCA9IChteCAtIGxteCkgKiAwLjE1CglkeSA9IChteSAtIGxteSkgKiAwLjE1CgkKCQoJbG9j
YWwgYWE9YXRhbjIoZHgsZHkpCglpZiAobWIgPT0xKSB0aGVuCgkJCgkJLS0gYWRkIDUwIHBhcnRp
Y2xlcyBwZXIgZnJhbWUKCQktLSAtPiBkb3QgcmVjeWNsZWQgZXZlcnkgNTAwMDAvNTAgZnJhbWVz
ID0gfjE2IHNlY29uZHMKCQkKCQktLSBsZXJwIGJldHdlZW4gcG9zaXRpb25zIC8gdmVsb2NpdGll
cyAvIGNvbG91cnMKCQlmb3IgaT0wLDAuOTksMC4wMiBkbyAKCQkKCQkJc2V0KHAsIDAsIGlkeCwg
IGxteCsobXgtbG14KSppKQoJCQlzZXQocCwgMSwgaWR4LCAgbG15KyhteS1sbXkpKmkpCgkJCXNl
dChwLCAyLCBpZHgsICAxNiArICggKGxhYSsoYWEtbGFhKSppICtybmQoMC4yKSklMSkqMzIpCgkJ
CXNldChwLCAzLCBpZHgsICBsZHgrKGR4LWxkeCkqaStybmQoMC4yKS1ybmQoMC4yKSkKCQkJc2V0
KHAsIDQsIGlkeCwgIGxkeSsoZHktbGR5KSppK3JuZCgwLjIpLXJuZCgwLjIpKQoJCQkKCQkJaWR4
ICs9IDEKCQkJbWF4X2lkeD1tYXgoaWR4LG1heF9pZHgpCgkJCWlkeCAlPSBtYXhfcGl4ZWxzCgkJ
ZW5kCgllbmQKCQoJLS0gYWRkIGR4LGR5IHRvIHgseSBmb3IgZWFjaCBwaXhlbAoJcDphZGQoCgkJ
cCwgcCwgLS0gcmVhZGluZyBhbmQgd3JpdGluZyB0byBzYW1lIHVzZXJkYXRhCgkJMywgICAgLS0g
b2Zmc2V0IHRvIHJlYWQgZnJvbTogZHgsZHkgc3RhcnQgYXQgMwoJCTAsICAgIC0tIG9mZnNldCB0
byB3cml0ZSB0bzogIHgseSBzdGFydHMgYXQgMAoJCTIsICAgIC0tIG51bWJlciBvZiBlbGVtZW50
cwoJCTUsICAgIC0tIGlucHV0IHN0cmlkZSBiZXR3ZWVuIHNwYW5zOiBzYW1lIGFzIHA6d2lkdGgo
KQoJCTUsICAgIC0tIG91dHB1dCBzdHJpZGUgYmV0d2VlbiBzcGFuczogc2FtZSBhcyBwOndpZHRo
KCkKCQltYXhfcGl4ZWxzIC0tIG51bWJlciBvZiBzcGFucyB0byBhZGQgKG9uZSBzcGFuIGZvciBl
YWNoIHBpeGVsKQoJKQoJCgktLSByaXNlIHVwIGEgbGl0dGxlIChzbW9rZXkpCgktLXA6YWRkKC0w
LjAxLCAgICBwLCA0LDQsMSwgNSw1LG1heF9waXhlbHMpCgkKCWxhc3RfbXg9bXggCglsYXN0X215
PW15CglsYWE9YWEKZW5kCgpmdW5jdGlvbiBfaW5pdCgpCgktLSBsb29waW5nIDMyIGNvbG91ciBw
YWxldHRlICh1c2luZyBQSUNPLTggcmFpbmJvdyBjb2xvdXJzIDguLjE1KQoJZm9yIGk9MCwzMSBk
bwoJCWxvY2FsIGIwLGcwLHIwID0gcGVlaygweDUwMDArKDgrKGlcNCkpKjQsMykKCQlsb2NhbCBi
MSxnMSxyMSA9IHBlZWsoMHg1MDAwKyg4KygoKGlcNCkrMSklOCkpKjQsMykKCQkKCQlsb2NhbCB0
dDEgPSAoaSU0KS80CgkJbG9jYWwgdHQwID0gMS10dDEKCQlwb2tlKDB4NTAwMCsxNio0K2kqNCwK
CQkJYjAqdHQwICsgYjEqdHQxLAoJCQlnMCp0dDAgKyBnMSp0dDEsCgkJCXIwKnR0MCArIHIxKnR0
MSkKCWVuZAoJCmVuZAoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wNC0xMCAy
Mjo0NjowNSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHJ1bnRpbWU9MTEsd29ya3Nw
YWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSM4NyIsd29ya3NwYWNlX2luZGV4PTF9fV1dCjo6IGdm
eC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTI4IDAwOjI0OjM1Iixtb2RpZmll
ZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBbZW9jXQo=
:: bios/demos/proggy.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBf
bWV0YS8KOjogc25pcHBldHMvCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0
ZWQ9IjIwMjMtMTAtMTIgMDY6MzA6MDEiLG1vZGlmaWVkPSIyMDI1LTEwLTIwIDE5OjA5OjA2Iixy
ZXZpc2lvbj03MzZdXQotLVtbCglwcm9nZ3k6IGRlbW9uc3RyYXRlIGxpdmUgY29kZSBsb2FkaW5n
IGFuZCBlZGl0b3IgZ3VpCgoJdG8gdmlldyB0aGUgc25pcHBldHM6CgkKCQljZCAvcmFtL2NhcnQv
c25pcHBldHMKCQlscwoJCWVkaXQgZm9vLmx1YQpdXQoKZnVuY3Rpb24gX2luaXQoKQoJZyA9IGNy
ZWF0ZV9ndWkoKQoJY2UgPSBnOmF0dGFjaF90ZXh0X2VkaXRvcnt4PTgseT0yMCx3aWR0aD0yMTUs
aGVpZ2h0PTIwMCwKCQltYXJrdXA9dHJ1ZSxlbWJlZF9wb2RzPXRydWUsc3ludGF4X2hpZ2hsaWdo
dGluZz10cnVlfQoJY2U6YXR0YWNoX3Njcm9sbGJhcnN7YXV0b2hpZGU9dHJ1ZX0KCWNlOnNldF90
ZXh0eyJjbHMoKSIsImNpcmMoMTIwLDEyMCw0MCtjb3ModCgpKSoxMCw3KSJ9CgoJYm1wID0gdXNl
cmRhdGEoInU4IiwyNDAsIDI0MCkKCQoJY3JlYXRlX3NuaXBwZXRfYnV0dG9ucygpCgkKCS0tIHN0
b3AgcGF1c2UgbWVudSBmcm9tIHBvcHBpbmcgdXAgd2hlbiBwcmVzcyBlbnRlcgoJd2luZG93e3Bh
dXNlYWJsZSA9IGZhbHNlfQoJCgktLSBpbnN0ZWFkLCBhZGQgYSBxdWl0IGJ1dHRvbgoJZzphdHRh
Y2hfYnV0dG9uKHt4PTQ0MCx5PTQsbGFiZWw9InF1aXQiLCAKCWJnY29sPTUsIGZnY29sPTB4MDkw
MSwKCWJvcmRlcj0xLAoJdGFwPWZ1bmN0aW9uKCkKCQlleGl0KCkKCWVuZH0pCgkKZW5kCgoKZnVu
Y3Rpb24gX2RyYXcoKQoJY2xzKDUpCgkJCglnOnVwZGF0ZV9hbGwoKQoKCQoJLS0gcmVjb21waWxl
IGJ5dGVjb2RlIGV2ZXJ5IGZyYW1lIQoJLS0gaWYgdGhlcmUgaXMgYSBzeW50YXggZXJyb3IsIG5l
d2Z1bmMgd2lsbCBiZSBuaWwgYW5kIHdlIGNhbiBpZ25vcmUgaXQKCWxvY2FsIHByb2cgPSB0YWJs
ZS5jb25jYXQoY2U6Z2V0X3RleHQoKSwiXG4iKQoJbG9jYWwgbmV3ZnVuYyA9IGxvYWQocHJvZykK
CWlmIChuZXdmdW5jKSBmdW5jID0gbmV3ZnVuYwoJCgktLSBzb21lIGdsb2JhbHMgZm9yIHRoZSBw
cm9nbGV0IHRvIHVzZQoJbXgsbXksbWIgPSBtb3VzZSgpCglteCAtPSAyMzIgIG15IC09IDIwCgkK
CS0tIGRyYXcgY29kZSBlZGl0b3IKCWc6ZHJhd19hbGwoKSAKCQoJLS0gcnVuIHRoZSBwcm9nbGV0
IGFuZCBzaG93IHRoZSBvdXRwdXQKCXNldF9kcmF3X3RhcmdldChibXApCglpZiAoZnVuYykgY29y
ZXN1bWUoY29jcmVhdGUoZnVuYykpCglzZXRfZHJhd190YXJnZXQoKQoJYmxpdChibXAsIG5pbCwg
MCwgMCwgMjMyLCAyMCkKCQoJLS0gc2hvdyBmcHMKCXByaW50KHN0cmluZy5mb3JtYXQoImNwdTol
LjNmIixzdGF0KDEpKSwgOCw3LDEzKQplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9zbmlwcGV0X2J1dHRv
bnMoKQoKCXNuaXBwZXQ9bHMoInNuaXBwZXRzIikKCS0tIHRhYmxlLnNvcnQoc25pcHBldCkgLS0g
cGVyaGFwcyB3b24ndCBiZSBzdXBwb3J0ZWQgKHJlcXVpcmVzIGMgY2FsbCBib3VuZGFyeSkKCQoJ
bG9jYWwgeHggPSAxMAoJbG9jYWwgeXkgPSAyMzAKCWZvciBpPTEsI3NuaXBwZXQgZG8KCQlsb2Nh
bCBlbCA9IGc6YXR0YWNoX2J1dHRvbih7eD14eCx5PXl5LGxhYmVsPXN1YihzbmlwcGV0W2ldLDEs
LTUpLCAKCQkJYmdjb2w9MHgwNzA2LCBmZ2NvbD0weDA5MGQsCgkJCXRhcD1mdW5jdGlvbigpCgkJ
CQlsb2NhbCB0ZXh0ID0gZmV0Y2goInNuaXBwZXRzLyIuLnNuaXBwZXRbaV0pCgkJCQljZTpzZXRf
dGV4dChzcGxpdCh0ZXh0LCJcbiIpKQoJCQllbmR9KQoJCXh4ICs9IGVsLndpZHRoICsgNAoJCWlm
ICh4eCA_IDIwMCkgdGhlbgoJCQl4eCA9IDEwCgkJCXl5ICs9MTYKCQllbmQKCWVuZAoJCmVuZAoK
Ojogc25pcHBldHMvZG9udXQubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMt
NTItMjAgMTA6NTI6MjQiLG1vZGlmaWVkPSIyMDI0LTM1LTAxIDExOjM1OjE0IixyZXZpc2lvbj00
OF1dCmNscygpCgpmb3IgeT0tMjAsMjYwLDEyIGRvCglmb3IgeD0tMjAsMjYwLCA0IGRvCgkJbG9j
YWwgZHggPSB4LTEyMAoJCWxvY2FsIGR5ID0geS0xMjAKCQlsb2NhbCBkZCA9IHNxcnQoZHgqZHgr
ZHkqZHkpCgkJbG9jYWwgcSA9IHNpbihkZC8xNjAtdGltZSgpLzQpKjE2CgkJaWYgKHE_MCkgdGhl
bgoJCQljaXJjZmlsbCh4K3EseS1xLDEsOCsoZGQvOCklOCkKCQllbmQKCWVuZAplbmQKOjogc25p
cHBldHMvZG90czNkLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTM1LTEy
IDA2OjM1OjIxIixtb2RpZmllZD0iMjAyMy0xMi0wMSAwMDoxMjo1NCIscmV2aXNpb249MjI5XV0K
LS0gM2QgZG90IHBhcnR5Ci0tIGJ5IHplcApjbHMoKQoKaWYgKG5vdCBwdCkgdGhlbgoJLS0gbWFr
ZSBzb21lIHBvaW50cwoJcHQ9e30KCWZvciB5PS0xLDEsMS8yIGRvCgkJZm9yIHg9LTEsMSwxLzIg
ZG8KCQkJZm9yIHo9LTEsMSwxLzIgZG8KCQkJCXA9e30KCQkJCXAueD14IHAueT15IHAuej16CgkJ
CQlwLmNvbD04ICsgZmxyKHgqMit5KjMpJTEwCgkJCQlhZGQocHQscCkKCQkJZW5kCgkJZW5kCgll
bmQKZW5kCgotLSByb3RhdGUgcG9pbnQgeCx5IGJ5IGEKLS0gKHJvdGF0ZXMgYXJvdW5kIDAsMCkK
ZnVuY3Rpb24gcm90KHgseSxhKQoJbG9jYWwgeDA9eAoJeCA9IGNvcyhhKSp4IC0gc2luKGEpKnkK
CXkgPSBjb3MoYSkqeSArIHNpbihhKSp4MCAtLSAqeCBpcyB3cm9uZyBidXQga2luZGEgbmljZSB0
b28KCXJldHVybiB4LHkKZW5kCgkKCQoJZm9yIHAgaW4gYWxsKHB0KSBkbwoJCS0tdHJhbnNmb3Jt
OgoJCS0td29ybGQgc3BhY2UgLT4gY2FtZXJhIHNwYWNlCgkJCgkJcC5jeCxwLmN6PXJvdChwLngs
cC56LHQoKS84KQoJCXAuY3kscC5jej1yb3QocC55LHAuY3osdCgpLzcpCgkJCgkJcC5jeiArPSAy
ICsgY29zKHQoKS82KQoJZW5kCgkKCS0tIHNvcnQgZnVydGhlc3QgLT4gY2xvc2VzdAoJLS0gKHNv
IHRoYXQgdGhpbmdzIGluIGRpc3RhbmNlCgktLSBhcmVuJ3QgZHJhd24gb3ZlciB0aGluZ3MKCS0t
IGluIHRoZSBmb3JlZ3JvdW5kKQoJCglmb3IgcGFzcz0xLDQgZG8KCWZvciBpPTEsI3B0LTEgZG8K
CQlpZiBwdFtpXS5jeiA8IHB0W2krMV0uY3ogdGhlbgoJCQktLXN3YXAKCQkJcHRbaV0scHRbaSsx
XT1wdFtpKzFdLHB0W2ldCgkJZW5kCgllbmQKCWZvciBpPSNwdC0xLDEsLTEgZG8KCQlpZiBwdFtp
XS5jeiA8IHB0W2krMV0uY3ogdGhlbgoJCQktLXN3YXAKCQkJcHRbaV0scHRbaSsxXT1wdFtpKzFd
LHB0W2ldCgkJZW5kCgllbmQKCWVuZAoJCglyYWQxID0gNStjb3ModCgpLzQpKjQKCWZvciBwIGlu
IGFsbChwdCkgZG8KCQktLXRyYW5zZm9ybToKCQktLWNhbWVyYSBzcGFjZSAtPiBzY3JlZW4gc3Bh
Y2UKCQlzeCA9IDEyMCArIHAuY3gqNjQvcC5jegoJCXN5ID0gMTIwICsgcC5jeSo2NC9wLmN6CgkJ
cmFkPSByYWQxL3AuY3oKCQktLSBkcmF3CgkJCgkJaWYgKHAuY3ogPiAuMSkgdGhlbgoJCQljaXJj
ZmlsbChzeCxzeSxyYWQscC5jb2wpCgkJCWNpcmNmaWxsKHN4K3JhZC8zLHN5LXJhZC8zLHJhZC8z
LDcpCgkJZW5kCgllbmQKCjo6IHNuaXBwZXRzL2p1bWJsZS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJh
dyIsY3JlYXRlZD0iMjAyMy0zMi0zMSAyMjozMjowMSIsbW9kaWZpZWQ9IjIwMjMtNTUtMzEgMjM6
NTU6NDUiLHJldmlzaW9uPTExXV0KLS0ganVtYmxlIHBpeGVscwoKZm9yIGk9MCwyNTAwIGRvCgoJ
LS0gY2hvb3NlIGEgcmFuZG9tIHBvaW50Cglsb2NhbCB5PXJuZCgyNDApCglsb2NhbCB4PXJuZCgy
NDApCgkKCS0tIGNob29zZSBhIHJhbmRvbSBuZWlnaGJvdXIKCWxvY2FsIGE9KHJuZCg0KVwxKS80
Cglsb2NhbCB4Mix5MiA9IHgrY29zKGEpLHkrc2luKGEpCgkKCS0tIHN3YXAgdGhlIHR3byBwaXhl
bHMKCWxvY2FsIGM9cGdldCh4LHkpCglwc2V0KHgseSxwZ2V0KHgyLHkyKSkKCXBzZXQoeDIseTIs
YykKZW5kCgo6OiBzbmlwcGV0cy9tYWduZXQubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0
ZWQ9IjIwMjMtMjEtMzEgMjI6MjE6MzAiLG1vZGlmaWVkPSIyMDIzLTU2LTMxIDIzOjU2OjAxIixy
ZXZpc2lvbj00OF1dCmNscygpCgpmb3IgeT0wLDI0MCwxMCBkbwpmb3IgeD0wLDI0MCwxMCBkbwoK
CS0tIGFuZ2xlIGJldHdlZW4gbW91c2UgYW5kIHBvaW50Cglsb2NhbCBhID0gYXRhbjIobXggLSB4
LCBteSAtIHkpCgkKCS0tIGRyYXcgYSBsaW5lIGluIHRoYXQgZGlyZWN0aW9uCglsaW5lKHgseSwg
eCtjb3MoYSkqNywgeStzaW4oYSkqNywgMTQpCgplbmQKZW5kCgo6OiBzbmlwcGV0cy9wYWludC5s
dWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0zNC0xMiAwNjozNDo1MyIsbW9k
aWZpZWQ9IjIwMjQtMzUtMDEgMTE6MzU6MTQiLHJldmlzaW9uPTgyXV0KLS0JcGFpbnQgb24gdGhl
IG91dHB1dCBpbWFnZQoKaWYgbWIgPiAwIHRoZW4KCWNpcmNmaWxsKG14LCBteSwgMTAsIDggKyAo
dCgpKjEwKSU4KQplbmQKOjogc25pcHBldHMvcHVsc2UubHVhCi0tW1twb2RfZm9ybWF0PSJyYXci
LGNyZWF0ZWQ9IjIwMjMtMzEtMjAgMTA6MzE6NTEiLG1vZGlmaWVkPSIyMDI0LTM1LTAxIDExOjM1
OjE0IixyZXZpc2lvbj01N11dCmNscygpCmNpcmMoMTIwLDEyMCw0MCtjb3ModCgpKSoxMCw3KQoK
Ojogc25pcHBldHMvc2FuZC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0z
Mi0yMCAxMDozMjowNCIsbW9kaWZpZWQ9IjIwMjMtMTItMDEgMDA6MTI6NTgiLHJldmlzaW9uPTIw
XV0KcSA9IHEgYW5kIChxKzIpJTkgb3IgMAoKZm9yIHk9MjM5LXElMywwLC0zIGRvCmZvciB4PTAr
cVwzLDIzOSwzIGRvCglpZiAocGdldCh4LHkpPT0wKSB0aGVuCiAJCXBzZXQoeCx5LHBnZXQoeCx5
LTEpKQogCQlwc2V0KHgseS0xLDApCiAJZW5kCmVuZAplbmQKCjo6IHNuaXBwZXRzL3ZwYWludC5s
dWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0zNC0xMiAwNjozNDo1MyIsbW9k
aWZpZWQ9IjIwMjQtMzUtMDEgMTE6MzU6MTQiLHJldmlzaW9uPTgyXV0KLS0gdmFwb3JpemUgdGhl
IG91dHB1dCBiaXRtYXAKZm9yIGk9MSwyMDAwIGRvCglsb2NhbCB4LHkgPSBybmQoMjQwKSxybmQo
MjQwKQoJY2lyY2ZpbGwoeCx5LHJuZCgxLjUpXjIsCgkJbWF4KDAscGdldCh4LHkrNSkqLjgpKQpl
bmQKCmNvbCA9IGNvbCBvciAwCmlmIG1iID4gMCB0aGVuCiAJY29sID0gKGNvbCArIDEvMikgJSAx
MAoJLS0gbGVycAoJZm9yIGk9MCwxLDEvMTYgZG8KCQljaXJjZmlsbCgKCQkJbGFzdF9teCppICsg
bXgqKDEtaSksIAoJCQlsYXN0X215KmkgKyBteSooMS1pKSwgCgkJCTEwLCA4ICsgY29sKQoJZW5k
CmVuZApsYXN0X214LCBsYXN0X215LCBsYXN0X21iID0gbXgsbXksbWIKOjogc25pcHBldHMvd2hl
ZWwubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTktMDEgMDA6MTk6Mzgi
LG1vZGlmaWVkPSIyMDI0LTM1LTAxIDExOjM1OjE0IixyZXZpc2lvbj00MV1dCmNscygpCmZvciBp
PTMxLDEsLTEgZG8KCWNpcmNmaWxsKAoJCTEyMCArIGNvcyh0KCkraS81KSo1LAoJCTEyMCArIHNp
bih0KCkraS81KSo1LAoJCWkqMywgaSkKZW5kCgoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRl
ZD0iMjAyNS0xMC0yMCAxOTowMTo1OCIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHJ1
bnRpbWU9MjEsc3RvcmVkPSIyMDI0LTM1LTAxIDExOjM1OjE0Iix3b3Jrc3BhY2VzPXt7bG9jYXRp
b249Im1haW4ubHVhIzIzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzbmlwcGV0cy9w
YWludC5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNuaXBwZXRzL3ZwYWludC5s
dWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNuaXBwZXRzL2RvbnV0Lmx1YSIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic25pcHBldHMvd2hlZWwubHVhIix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJzbmlwcGV0cy9wdWxzZS5sdWEiLHdvcmtzcGFjZV9pbmRleD0x
fX1dXQo6OiBfbWV0YS8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTAxIDExOjM0
OjM3Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTM0LTAxIDEx
OjM0OjM3Il1dCjo6IF9tZXRhL3dvcmtzcGFjZXMucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdW
a1BTSXlNREl6TFRJNUxURXlJREEyT2pJNU9qRXhJaXh0YjJScFptbGxaRDBpTWpBeU15MHcKTXkw
d01pQXlNem93TXpvME5DSXNiVzlrYVdacFpXUmZkSE05SWpJd01EQXRNREV0TURFZ01EQTZNREE2
TURBaUxISmxkbWx6YVc5dQpQVEU0TkRaZFhXeDZOQUI1QUFBQU1BRUFBUGtjZTN0amNISnZhbDlt
YVd4bFBTSnRZV2x1TG14MVlTSXNkMjl5YTNOd1lXTmxYMmx1ClpHVjRQVEY5TENvQTczTnVhWEJ3
WlhSekwzQmhhVzUwTkFBREh6STBBQVVmZGpVQUNCOHpOUUFGVDJSdmJuVTBBQVFmTkRRQUJWOTMK
YUdWbGJEUUFBeDgxMFFBR1QzVnNjMlUwQUFGUWVEMDJmWDA9Cjo6IHNuaXBwZXRzLy5pbmZvLnBv
ZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDEgMTE6MzQ6MzciLG1vZGlmaWVkPSIyMDI1LTEy
LTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMzQtMDEgMTE6MzQ6MzciXV0KOjogW2VvY10K
:: bios/demos/shadows.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTExLTA0IDA1OjA0OjE1Iixtb2RpZmllZD0iMjAyNS0xMS0xMCAwNTo0OTo1NCIs
cmV2aXNpb249MzkzXV0KLS0gc2hhZG93cyBkZW1vIGJ5IHplcAotLSB1c2VzIHN0ZW5jaWwgYml0
cyB0byBhdm9pZCBkcmF3aW5nIHNoYWRvd3MgdHdpY2UgKHByZXNzIHgpCgpudW1fc3BoZXJlcyA9
IDIwCnNoYXBlc190ZXN0ID0gZmFsc2UKdHQ9MAoKZnVuY3Rpb24gX2luaXQoKQoJc3BoZXJlcyA9
IHVzZXJkYXRhKCJmNjQiLDMsbnVtX3NwaGVyZXMpCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoKCXBh
bCgpIC0tIHJlc2V0IGNvbG91ciB0YWJsZXMgKGFuZCBkcmF3IHBhbGV0dGVzOyBidXQgdGhleSBh
cmVuJ3QgdXNlZCBhbnl3YXkpCgljbHMoKSAtLSBhbHNvIGNsZWFycyBzdGVuY2lsIGJpdHMgKDB4
YzApIGluIGVhY2ggZHJhdyB0YXJnZXQgcGl4ZWwKCW1hcCgpCgkKCS0tIHR1cm4gb24gdGFyZ2V0
IG1hc2sgZm9yIHNoYXBlcyAodXNlZCB3aGVuIHNoYXBlc190ZXN0PXRydWUpCglwb2tlNCgweDU1
MDgsIDB4M2YzZjNmM2YpCgkKCS0tIHNldCB1cCBjb2xvdXIgdGFibGUgZm9yIHNoYWRvd3MKCS0t
IChjb3VsZCBwcmVjYWxjdWxhdGUgdGhpcyBvbmNlIGFuZCB0aGVuIG1lbWNweSBvciBtZW1tYXAg
b25jZSBwZXIgZnJhbWUpCglsb2NhbCBzaGFkb3dfY29scyA9IGdldF9zcHIoMSkKCWZvciBpPTAs
MzEgZG8KCQlwb2tlKDB4ODA0MCtpLCBzaGFkb3dfY29sczpnZXQoaSwxKSB8IDB4NDApCgllbmQK
CgktLSBjYWxjdWxhdGUgc3BoZXJlIHBvc2l0aW9ucyAoeCx5LHopCglmb3IgaT0wLG51bV9zcGhl
cmVzLTEgZG8KCQlsb2NhbCB0MSA9IHR0ICsgaSAqIDAuMDcKCQlzcGhlcmVzOnNldCgwLGksCgkJ
CTI0MCArIGNvcyh0MSowLjIpKjE0MCwKCQkJMTUwICsgc2luKHQxKjAuMTIpKjgwLAoJCQkzNSAr
IGNvcyh0MSowLjcpICogMzAKCQkpCgllbmQKCS0tIHNvcnQgYnkgeQoJc3BoZXJlczpzb3J0KDEp
IAoJCgktLSBlbmFibGUgc3RlbmNpbCBiaXQgMHg0MCBpbiBhbGwgbWFza3Mgc28gdGhhdCB3aGVu
IGRyYXdpbmcgc2hhZG93czoKCS0tIDEuIGJpdCAweDQwIGlzIGRyYXduIHRoZSBmaXJzdCB0aW1l
IGEgc2hhZG93IHBpeGVsIGlzIGRyYXduCgktLSAyLiBvbiBzdWJzZXF1ZW50IHNoYWRvdyBwaXhl
bCBkcmF3cywgdGhhdCBwaXhlbCBpcyBza2lwcGVkCgktLSAgICAoYmVjYXVzZSB0aGUgZGVmYXVs
dCB2YWx1ZXMgZm9yIGNvbG91ciB0YWJsZSAxIGFyZSBlcXVpdmFsZW50IHRvIGEgTk9QKQoJCglp
ZiAobm90IGJ0big1KSkgcG9rZTQoMHg1NTA4LDB4N2Y3ZjdmN2YpCgkKCS0tIGRyYXcgc2hhZG93
cwoJZm9yIGk9MCxudW1fc3BoZXJlcy0xIGRvCgkJbG9jYWwgeCx5ID0gc3BoZXJlczpnZXQoMCxp
LDIpCgkJc3ByKDE2LHgseSkKCWVuZAoJCgktLSB0ZXN0OiBkcmF3IGV4dHJhIHNoYWRvdyBhcmVh
cyB1c2luZyBzaGFwZSBmdW5jdGlvbnMKCS0tIHNoYXBlIGZ1bmN0aW9ucyB3b3JrIHRoZSBzYW1l
IHdheSAoYnV0IHVzaW5nIHRhcmdldCBtYXNrIEAweDA1MGIpCglpZiBzaGFwZXNfdGVzdCB0aGVu
CgkJcnJlY3RmaWxsKDIwLDEyMCw4MCw4MCw2LDEpCgkJcnJlY3RmaWxsKDQwLDE0MCw4MCw4MCw2
LDEpCgkJY2lyY2ZpbGwoMTgwLDIyMCw0MCwxKQoJCWNpcmNmaWxsKDIyMCwyMjAsNDAsMSkKCWVu
ZAoJCgktLSByZXNldCBtYXNrcyBhbmQgcGFsZXR0ZSB0byBkcmF3IGNocm9tZSBiYWxsIHNwcml0
ZXMKCXBva2U0KDB4NTUwOCwweDNmM2YzZikKCXBhbCgpIC0tIHJlc2V0IGNvbG91ciB0YWJsZQoJ
cGFsdCgwLGZhbHNlKSAtLSBkcmF3IGNvbG91ciAwIHNvbGlkIChtaWRkbGUgb2YgY2hyb21lYmFs
bCkKCXBhbHQoMyx0cnVlKSAtLSBkcmF3IDMgdHJhbnNwYXJlbnQKCglmb3IgaT0wLG51bV9zcGhl
cmVzLTEgZG8KCQlsb2NhbCB4LHkgPSBzcGhlcmVzOmdldCgwLGksMikKCQlzcHIoMTcseCx5LXNw
aGVyZXM6Z2V0KDIsaSkpCgllbmQKCQoJcHJpbnQoImhvbGQgXDE1MSB0byBkaXNhYmxlIHN0ZW5j
aWwgYml0cyIsMTAsMTAsNykKCXByaW50KCJjcHU6ICIuLmZscihzdGF0KDEpKjEwMCkuLiIlIikK
CQoJdHQrPTEvNjAKZW5kCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMTEtMDQg
MDU6MDA6MzMiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixydW50aW1lPTIzLHdvcmtz
cGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjNyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlv
bj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdv
cmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9
fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA0IDA1OjAwOjMz
Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBnZngvMC5nZngKYjY0JExTMWJX
M0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lERXdPak0xT2pRNElpeHRiMlJwWm1sbFpE
MGlNakF5TlMweApNUzB3T1NBd09UbzFORG96TlNJc2NtVjJhWE5wYjI0OU56RmRYV3g2TkFDcUF3
QUFYVFFBQVBNaGUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUEJXQnhBSHdCZlFGOEFIRUFmd1Zp
eG1iR0ZuY3owd0xIQmhibDk0Q0FESGVUMHdMSHB2YjIwOU9IMHNQZ0QwS1VCQUJBQUIKQWdNRUJR
WUhDQWtLQ3d3TkRnOFBEeEFQRVE4U0R4TVBGQThWRHhZUEZ3OFlEeGtQR2c4YkR4d1BIUThlRHgt
LUFCSUJIZ0FRQmgwQQpfaFFKRHhzUEVBOFNEeDRQRmc4VEF4RVBGUThBQlE4ZUFnUVBHd01NRFE4
WUJQOEEtd0VBRzVfakFGTXRNVFF1TXFjQVppMHlOaTQ1Ck13RUFBcllBT2psOUxQUUE5UUR6Snc4
VDB4NFREcE1lRXg3REhzTUtBQy16VmY4QUdRQkpBS0VzRHhzRER0TU84ellPQndBZlNrQUEKSFJO
VFFBQVNSa0FBSHhOQUFCMy1CRmdQR3VNT0V3NkREaE1PQXc2akRnTU9BdzdGQUItLUZ6VS1GaDhQ
ZzI4V0R3OWpueFpUbmtNUApFNTVERFo1VEJXNEREbE1ORlFNMWN5MFRMZk1sVmdBZHN5WXZGazhQ
WTM4V0h3OVRWZ0RnWGdNdVF3MXVBeDVERFFVdUF4NElBTThECkpRTVZBd1Z6SFNNTjh6UmdBQjBm
OERFQUhQOEFEeGZYRGc4ZURyY2VIYjhPSGgyOEF3QU1YdzNDSHVJT1lnQWN6d3puRHhBTXh3OGMK
SHhDOEh3VUFKYThQRU04U0RBOGM3eElNZlFBYy14enpGeWZESjZNWENSb1hneGNwRjZNbjB3OGJz
eDhhQXc3RERnOGJEZ01lc3c0TgpEc01Pd3g4VER2TW41UUpjLXd6LUV4UURmZ05PQTQ0VExoTWVB
ejRERGhNTzh6UVBHd01OMHcweEF4LXdDalV2Rmg4UG93VS1GZzhQCmt4VUREeFlESGxNdUR4TUZB
d1ZQQW9wT0l4VkREWDROWTdvQ0h5WmtBQjFDUlQ4V1A3b0M4QUJERHhOZkZnTXVRdzhUYmdNZU14
MEYKQU84TkZSNDFBd1ZESFRVdGN6M3pLVnNBR2ZRSklDQUU4UF85Y2ZBRjBmQUE4UUxBOFFTdzhR
U2c4UWFRQXdBUm9CSUF2OER4QXZBQQowZkFGY2ZCOFhRQUxIRGRkQVBFVDh4eHc4d1lRRHhKZkhR
OFNFUE1ERUE0UEhWY05EaER6QVJBT0RYY05EaERqSUFnQVFTRERJQUVKCkFQQmJBU0N6SUFFZURW
Y05IZ0Vnb3pBUkhsMGVFVENUUUJGX0VVQ1RVSkZRazRBeGdKUHdCcE1BQWZBQ0FRQ1RBQkh3QUJF
QWt3QUIKRGdIUUFRNEJBS01CSGdHd0FSNEJzd0FCRGc4TkRoRlFFUTRNRGdFQXd3QUJEaHhfSEE0
QkFPTUFBUXdkWEIwTUFRRHpBUlVBTUEwWApEUmNBMy1NREVBRmNBUkR6Qm5Eei14M2hBQmtBcXdZ
UDh3TU1IamFFQkNBUEZ4Y0Ytd29UQ0JNT2t4Z0NHTE1vMHdMakR4dmpEeHJECkh4TVBHdk5JVUFB
Y0wtRHdNUUQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0KLS04eFVHMDlObjE5Cjo6IGxhYmVsLnFvaQpiNjQkY1c5cFpnQUFBZUFBQUFFT0JB
SF9BSWRSLWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mM1ktZ0N5VVE4bUQ4c21EeVlQCnl5
WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZ
UHl5WVBKZy1MSmc4bUQ4c20KRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhz
bUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bQpEOHNtRHlZUHl5WVBKZy1MSmc4
bUQ4c21EeVlQeXlZUEpnLU1KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1O
CkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1O
SmctTkpnLU5KZy1OSmctTkpnLU4KSmctOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzl3aVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bQpEOHNtRHlZUHl5WVBKZy1M
Smc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBK
Zy1MCkpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5
eVlQSmctTEpnOG1EOHNtRHlZUHl5WVAKSmctTEpnOG1EOHNtRHlZUHpDWVB3djctOGVnUHh6LUFE
OE0tRDhVLXd3LUhQdy1CSmctS1B3LUFQdy1LUHctQUpnOC13QS1LSmctRApQdy1ISmctSFB3LUFQ
OEFQSmctRFB3LURQdy1CUHctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpn
LU5KZy1OCkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctU1B3LUlQdy1EUHctRVA4
QVBQdzgtd0EtR1B3LU9Qdy1OUHctRFB3LVEKUHctVlB3LUZQdy1IUHctOS1mMzktZHctd1EtQlA4
QVB3VDhQd1QtQkQ4US13UTgtd1EtRlA4SVB3RC1BRDhZLXdROC13QS1CUDhFUAp3RC1BRDhBLXdR
LUJQdy1CUDhBUHhqLUJEei1DRDhBLXdBLUFQOEVQd1QtQkR6LUFEOEUtRDhVLXdRLUFQOEFQd0Qt
Q0Q4QS13US05Ci1mMzktZFUtRDhBLUR6OFB3RDhQd0Q4UHdEOFB3RDhQeEQtQUR6OFBQOEFQeGo4
UHdUOFB3RDhQeEQ4UHdEOFB3RDhQd0Q4UHhUOFAKUHctQVB3LUFQdy1BUHctQVB3LUVQdy1EUHct
QlB3LUFQdzgtRDhBLUR6OFB3ejhQd1Q4UHhUOFB3RDhQd0Q4UHdUOFB3VDhQLWYzOQotZjNZUHct
QVB3OC1EOEEtRDhBLUQ4QS1EOEEtRDhVLXd3LUhQdy1CUHctQVB3LUVQdy1BUHctQVB3LUJQOEFQ
d1QtQkR6OFB3RDhQCndEOFB3RC1DRDhVLXdBLUJQdy1CUDhJUFB3LUFQdzgtRDhNLUQ4RS1EOFUt
RDhBLUQ4QS1EOEUtRDhJLXdBLTktZjM5LWRZLUQ4QS0KRHo4UHdEOFB3RDhQd0Q4UHdEOFB4RDhQ
d3o4UHhqOFB3VDhQd0Q4UHhEOFB3RDhQd0Q4UHd6OFBQdy1BUHc4LUQ4QS1EOEEtRDhBLQpEOG8t
RDhBLUQ4RS1EOEktRDhBLUR6OFB3ejhQd1Q4UHhUOFB3RDhQd0Q4UHdUOFB4RDhQLWYzOS1mM1ZQ
dy1BUHctQVA4QVB3VC1BCkQ4QS13US1GUDhNUHlELUFEOEEtd0EtR1A4RVBQOEVQUDhFUHdULUJE
ei1CRDhFLXdBLUFQOEVQeEQtQkQ4SS13QS1BUDhFUFB3LUEKUHctQVA4RVBQOEVQd0QtQUQ4US13
US1BUDhFUHdULUFEei1CRC0zOS1mMzktZjM5LWYzOS1mMzktZjM5MnotQkQtMzktZFltRHlZUAp5
eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ5c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5
WVB5eVlQSmctTEpnOG1EX3NtCkR5WVB5eVlQSmctR1A4RVA0Q1lQSmctTEpnOG1EOHNtRHlZUHl5
WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVAKeXlZUEpnLUxKZzhtRDh3bUQ4
MG1EODBtRDgwbUQ4MG1EODBtRDkwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRF8wbUQ4MG1EOFUtd1A3
LQpvd0RfLV93bndELUFEOThtRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgw
bURfVS1EOEUtd0EtNC1xS0llY0xfCi04eXF3Zy05LWVvLXdDSEJQOEFQLWYzOTdELUFEOEEtRDhB
LUQtWVN4aFRBRC0zcS1wWHdRZy1OTWctc1A4RVAtZjM5MVQtQkR6LUIKRDhBLUQ4QS1EOHMtRDhN
LUR6OFB3RDhQOFA0U1Uxa1N4QThTd1EtOTZqSVB3RElQeWpJUHdESVA2aVlQLWYzOTFUOFB3ajhQ
d0Q4UApQdy1BUHctQVB3LUlQdy1CUDhBUHdqOFA4VGtTeFE4U3dBLTk1eklQd0RJUE1nLUlNZy1B
TWc4eURfZ3l3QTh5RC0zOS1jOG1EeVlQCndUOFB3ajhQd0Q4UFB3OG1Qdy1LSmo4bUQ4SS1EOEEt
RDhNbUR5WVB5eVlQSmctTEpnOG1EOGs1d0JMRkR4TEFEOFFtRHlZUHl5WVAKSmctTEpnOG1EOHNt
RHlZUHl5WVBKZy1MSmc4bUQ4MHlEeklQTWctSk1nOHlEeklQeHlZUEpnLUxKZzhtRDgweUpqSVBN
c0FQMWlZUApKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1E
OHNtRHlZUHl5WVBKZy1MSmc4bUQ4d21EOEktCkQ4SS13US1BUHlZUFB3LUFQdy1JUHctQVB3LUFQ
dzgtRDhBLUQ4SW1EODBtRDgwbUQ4bzUtbDlYVDhBU3dDN0NEeTRQeGlZUHpTWVAKelNZUHpTWVB6
U1lQelNZUDdTWVB6U1lQMERJbU1nLVlKZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpn
LU5KZy1OSmctVApQOEVQUHctRFA4RVB5ai1CRDhBLXdBLTFPY0F1d2puQkQtMzk3eklQLWYzOTJq
OFAtZE01d2ctOS1mRTV3RElQLWYzOS1mMzktZjM5Ci1mMzktY25fQUFBQXhnLTktZjM5LWYzOTRq
WEEtbVZHaVA2OW10LUVPalhBRC0zOS1mMzktZjNmTmNBNkJ6LUVCem8xd0EtOS1mMzkKLWYzOTNU
WEFPZ2MteGdjNk5jQVAtZjM5LWYzOS1kczF3VG9IUDhZSE9qWEJELTM5LWYzOTNTWVBKZy1MSmc4
bUQ4c21EeVlQeXlZUApKZy1HT1EtU0pnOG1EOHNtRHlZUHl5WVBKZy1ETmNIX0hTdFRPZ2MteGdj
NktEWEJEOEltRHlZUHl5WVBKZy03Smc4bUQ4c21EeVlQCi1jMG1EeVlQeXlZUEpnLWJKZzhtRDhz
bUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4d21EODBtRDgwbUQ4MG0KRDhZ
NXdBLUFPUS1RSmctTkpnLU5KZy1FTmNFb09zQUhQOFFIT3NBb05jRVB3eVlQelNZUC1TWVB6U1lQ
LWM4bUQ4MG1EOTBtRDgwbQpEODBtRDgwbUQ4MG1EODBtRDgwbUQtM0hPY0FQd0RuQUQtWTF3aWpB
T3NBSHhEckFLTUExd2ctOS1mMzktZjNaT2NBUDl6WERLTUE2CnhpakFOY01QN1RJUHpUSVAtZDh5
RF8weUQtMzktY0k1d0EtQU9RLTFOY1FveHpYR0Rfd3lEOEF5RDhveUQ4QXlELTNjTWctQU1nLXEK
TWctQU1nLTktZnc1d0EtQU9jQVA5RGsxeHlqQ05jQTZCOFE2TmNBUDV6SVB3RElQTWctSU1nLUFN
Zzh5RC0zYU1nLUFNZzh5RF9neQpEOEF5RHpJUC1ma21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVAw
RG5BRDhjbUR5WVB5eVlQSmctTEpnOG1EOGs1TmN3NkJ6LUVCem8xCndBLUZKZzhtRDkweUR6SVBN
Zy1KTWc4eUR6SVB4eVlQSmctTEpnOG1ELTB5RHpJUE1nLUhKZzhtRDhzbUR5WVB6VElQTWc4eUQ4
Y20KRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB6Q1lQelNZUHpT
WVB6U1lQM1NZUHpTWVB6U1lQeXpVbwpOY2s2QnotR0J6bzF3QS1GSmctOUpnLU5KZy05enlZUHpT
WVAzU1lQelNZUHpTWVB6U1lQelNZUHpTWVB6U1lQLWYzUE5TakFOY2c2CkJ6LUdCem8xd1EtOS1m
MzktZjM5MERVb09pZzF4aWc2QnotR0J6b29OY0VQLWYzOS1mMzktZEFvT3NBb05jVW9Pc0FIUDhR
SE9zQW8KTmNFUC1mMzktZjM5LWRBMUtEcl9nM2FjT2lqQU5jSW93RHJBQjhRNndDakFOY0lQLWYz
OS1mMzktZEExS0RvUXdEbzF3eWpBT3NZbwp3RFhERC0zOS1mMzktZjNSTlNnUUI4QTF4Q2pJTmNR
UC1mMzktZjM5LWRJMUtEb1FOY2Nvd2pYSEQtMzktZjM5LWYzVE5jQW9OZFVQCi1mMzktY3Mtd1Et
OXdpWVBKZy1MSmc4bUQ4c21EeVlQMWprUDBpWVBKZy1MSmc4bUQ5azF3Q2cxeXpvSHhEbzF3QS05
MHY3LXJNVVAKTVEtOTB5WVBKZy1MSmc4bUQ4c21EeVlQMnlZUEpnLUxKZzhtRDhZLXdRLVFKZzht
RDlzbUR5WVB6Q1lQelNZUHpTWVAxam5BRDhBNQpEOUFtRDgwbUQ5czFLTUExeVRvSFA4UUhPalhB
RXNJVXdBLTl5VEVQd1A3LUFFMFB3REVQLWRJbUQ4MG1EODBtRDkwbUQ4MG1EOFUtCndDRWZ3RC1B
RDg4bUQ5MG1ELTNIT2NBUHdEbkFELTNBTlNnNktEWEhPZ2MteGdjNk5jQVN3eFFQLWNrTndQNV9K
Vk1Od0EtOS1lMC0Kd0NIQlA4QVAtZXd5RDgwNXdBLTl3aWc2d0NnMXhqb0hQOFlIT2pYQkVzUVB5
VElQX3czQkQtMzl3VElQN0QtQkQ5d3lELTNQTWctQQpNZy1KT2NBUHdEa1AtY0ExS0RvUU9pakFO
Y0lvT2djLXhnYzZLRFhCRXNNUHlUSVB3RElQX1MwUC1mM0NNZy1BTWctcUpnLWRNZy1BCk1nLTl5
VElQd0RJUE1nLUpPY0FQd0RuQUQtM0JOU2c2RU1BNndEWEJLRHJBQnotRUJ6ckFLRFhCRXNNUHhq
SVB3RElQTWctNkpnLTkKLVRJUHdESVBNZy1vTXNBUE1nLWFNZy1BTWc4eUQ5Y21EeVlQeXlZUEpn
LUxKZzhtRDgweUR6SVBNZy1NT2NBUHh5WVBKZy1MSmc4bQpEX1UxS0JBSHdEWENLTUE2d0FmRU9z
QW93RFhDRXNJUHh6SVBNZzh5RC1veUQtM01KZzhtRDhzbUR5WVB5eVlQSmctTk1nOHlEeklQCnh5
WVBKZy1MSmc4bUQ4MHlKaklQTXNBUHhpWVBKZy1OTWc4eUR6SVB4eVlQSmctTUpnLU5KZy1OSmct
dEpnLU5KZy1uTlNnNkVEWEQKS01BNnhpakFOY01Td0E4U0QtM0lPY0F5RC0zTkpnLU5KZy1OSmct
ZEpnLU5KZy1RTWlZeUQ4Z21EOTBtRC0zOTNEWEFLRFhFS01nMQp4QzdBRC0zOTdTZ1AtZEV5RC0z
OS1jMDF5Q2pDTmNjNXdBLTktZXdvUHlnUC1jNDV3RElQLWYzOXpqWFVELTM5N2lnLXdDZ1AtZjM5
Ci1lQTFLRFhWRC0zOTZ5Zy13U2dQLWYzOS1kODFLTUExekRvSHhEbzF3QS05LWVrb1A4SW9ELTM5
LWYzZU5TZzZLRFhLT2djLXhBYzYKTmNBUC1mM29LRC1BS01BUC1mMzktZUFvT3NBb05jZzZCei1H
QnpvMXdBLTktZWdvd0Q4b0QtMzktZjNnTlNnNkVEb293RFhGT2djLQp4Z2M2TmNFUC1mMzktZjNE
Smc4bUQ4c21EeVlQNnlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctVU5TZzZFTUE2d2pYQktEb0hQ
OFlICk9pZzF3US1TRXNFVXd3LWNKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EX3NtRHlZUHl5WVBK
Zy1MSmc4bUQ5c21EeVlQeXlZUEpnLUwKSmc4bUQ4c21EeVlQMnlZUEpnLU1KZy1OSmctdEpnLU5K
Zy1OSmctTkpnLVdOU2dRQjhBUXdUWEJLRHJBQnotRUJ6ckFLRFhCRDlFUwp4aFRBRDhRU3dSVEFE
OUVtRDgwbUQ4MG1EODBtRF8wbUQ4MG1EODBtRDkwbUQ4MG1EODBtRDgwbUQ5MG1ELTM5MnpVb09o
REFCelhDCktNQTZ3QWZFT3NBb3dEWENEOUFTeUEtRUxoTENGQS05LWYzOTh6SVB6VElQLWQ4MXdD
Z1F3RFhES01BNnhpakFOY01Qd3pJUHloTEkKRDhRdXdBOFNEeExBRC0zOTNqSVAtZjNSTWctQU1n
LUtNZy1BTWctOTNqWEhLTWcxeEEtRE1nLUFNZy1HT1JMRUR4TEJEOEVTd1RrdQpEeTRQRXNBUC1m
M2VNZy1BTWctOS1jc3lEOEF5RHpJUHlESVB3RElQTWctOTRqWEhLTUkxeHctQU1nLUFNZzh5RDhj
NUVzVVBFc0FQCndEa1N3dy1CTHNBUC1mM2JNZy1BTWc4eUQtM3BKZzhtRDhzbUR5WVB6VElQTWc4
eUQ4a3lEeklQTWctSEpnOG1EOHNtRHlZUHl5WVAKSmctTEpnOG1EOXNtRHlZUHhEWFVEOEV5RHpJ
UE1nLUhPUzRTd1E4U3dBOFN3QS1BT1JMR09RLUhKZzhtRDhzbUR5WVB5eVlQSmctTApKZzhtRF9z
bUR5WVB5eVlQSmctTEpnOG1EODB5RHpJUE1nLUhKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOXNt
RHlZUHpDWVB6U1lQCjdTWVB6U1lQelNZUHpTWVAzU1lQeFRVb05kVVB6RGtQTHNFUExzQVBMZy1D
TGhMRkR4SVB4eVlQelNZUHpTWVB6U1lQN1NZUHpTWVAKelNZUDNTWVB6U1lQelNZUHpTWVAzU1lQ
LWYzcE5TakFOY3c2QjhRNk5jQVB6RG5BRDhFNUQ4UTVMc0FQTHNJUC1mMzktZjM5N1RVbwpPaWcx
eWpvSFA4UUhPalhBRDljNXdRLUFPY0VQLWYzOS1mMzk3aWc2d0NnMXlEb0hQOFlIT2pYQUQtMzkt
ZjM5LWYzUU5TZzZFRG9vCndEWEZPZ2MteGdjNk5jRVAtZjM5LWYzOS1kQTFLRG9Rd0RyQ05jRW9P
Z2MteGdjNktEWEJELTM5LWYzOS1mM1FOU2dRQjhBUXdUWEIKS0RyQUJ6LUVCenJBS0RYQkQtMzkt
ZjM5LWYzUk5TZzZFTUFITmNJb3dEckFCOFE2d0NqQU5jSVAtZjM5LWYzOS1kRTF3Q2dRd0RYRApL
TUE2eGlqQU5jTVAtZW8td1EtOS1mM1dKZzhtRDlzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUDJ5
WVBKZy1UTmNjb3lEWEVEeVlQCnl5WVBKZy1iSmc4bUQtWS13US1nSmc4bUQ4c21EeVlQeFRFUE1R
LVJKZzhtRDhzbUR5WVB5eVlQSmctbU9RLVNKZzhtRDl3bUQ5MG0KRDgwbUQ4MG1EODBtRDkwbUQ5
YzF4eWpDTmNjbUQ4MG1EOTBtRC1VLXdDRWZ3RC1BRDk4bUQ4MG1EOFF4RDhBTkQ4QXhEOUFtRDgw
bQpEODBtRF9ZNXdBLUFPUS1RSmctOS1lczExQS05NkQtQUljRS13QS0zRGNBdERjQVAtZHM1d0Et
QU9jQVAtZjN2TWctTU5TZzExUS1SCkpnOG1ELXNtRHlZUHp6LUJELW9Od1EtOU1nLU5NZy1OT2NB
UC1mM3dNZy1BTWctSk5TakFOY3c2QjhRNk5jQVAwQ1lQLVNZUDBTWVAKLUMwUC1jQXlEOEF5RDhv
eUQ4QXlEOGs1d0EtQU9RLTktZXN5RDhBeUR6SVB5RElQTlNnNktEWEtPZ2MteEFjNk5jQVAtZUl5
d0E4eQpELXdtRC1zeUQ4QXlEeklQeURJUHdESVBNZy1KT2NBUHdEbkFEX1ltRHlZUDJ5WVBKZy1M
Smc4bUQ4c21EeVlQeXlZUEpnLWJKZzhtCkQ4MHlEeklQTWctSk1nOG9Pc0FvTmNnNkJ6LUdCem8x
d0NZUEpnLWJKZzhtRC0weUpqSVBNc0FQMWlZUEpnLUxKZzhtRDg0eUQ4b20KRHlZUHl5WVBKZy1M
Smc4bUQ4MHlEeklQTWctSk1nOHlEeklQekRuQUQ4Y21EeVlQM0NZUDNTWVB6U1lQelNZUHpTWVAz
U1lQNERVbwpPaEE2S01BMXhUb0hQOFlIT2pYQkpnLWRKZy05d2pJbU1nLU5OY1lQd1RYR0Q4WW1E
ODA1d0RJUHl5WVB6U1lQelNZUC1TWVAtZjMxCk5TZzZFTUE2d2pYQktEb0hQOFlIT2lnMXdRLTk0
aklQelRYQU9nZkVPalhCT2dmRU9qWElELTM5LWYzNU5TZ1FCOEFRd1RYQktEckEKQnotRUJ6ckFL
RFhCRDlNbUR5WVBfeVlQSmctR09jQXlEOHcxd0RvSFA4UUhOY0E2QnotRUJ6WEFPZ2ZFT2pYQUQt
MzktZjM0TlNnNgpFTUFITmNJb3dEckFCOFE2d0NqQU5jSVAweVlQLVNZUDBEWEhPZ2MteFRYQU9n
Yy14VFhBT2djLXhBYzZOY0FQLWYzOS1mZzF3Q2dRCndEWERLTUE2eGlqQU5jTVAtZVkxd0RvSHd6
WEJPZ2MteERYQk9nYy14RFhBT2djLXhnYzZOY0FQLWYzOS1mazF4eWpJTmNRUC1lVTEKd0RvSFA4
STF3U2c2QnotRE5jRW9PZ2Mtd3pYQk9nYy14Z2M2TmNFUC1mMzktZnMxeHlqQ05jc1AtZUExd0Rv
SFA4TTF3U2c2d0FjLQp3alhCS0RyQUJ6LUJOY0VvT2djLXhnYzZOY1lQLWYzOS1mWTEwRG9IeERv
MXdBLTkzVFhCT2djLXdqWENLTUE2d0FmQk5jSW93RHJBCkI4RTF3U2c2d0FjLXhBYzF3RG9IeERv
MXdBLTktZjM5OURVb05jMDZCei1FQnpvMXdBLTkxVFhIS0RvSFA4STF3eWpBT3NJMXd5akEKT3NF
MXdpakFPc0FIeERYQU9nYy14QWM2TmNBUC1mMzZKZzhtRDhZNUQ5SW1EeVlQMnlZUEpnLVdPUS1O
T1EtSE5TakFOY3M2QnotRwpCem8xd0EtOXpTWVBKZy1BTmNBNkI4TTF3U2c2d0FjLXdUWEVLTU0x
eENqQ05jTW93RHJFTmNBNkJ6LUdCem8xd0EtRkpnOG1EOHNtCkR5WVB5eVlQSmctTEpnOG1EX3Nt
RHlZUHl5WVBKZy04SmctR09jQVB3RGtQMENZUDNTWVAxam5BRDhBNUQ4azV3QS1BT1EtRU5TZzYK
S0RYS09nYy14Z2M2TmNFUDR4TENGTUFQeUJMQ0ZNQVAwQ1lQd0RYQU9nYy13alhDS01BNndBZkJO
Y2Nvd0RYSEtEWEVLTVExd1RvSApQOFlIT2pYQkQ4VW1EODBtRDgwbUQ4MG1EXzBtRDgwbUQtM0hP
Y0FQd0RuQUQtM0tPY0FQd0RuQUQ4ZzV3QS1BT2NBUHhTZzZ3Q2cxCnlDZzZCei1HQnpvb05jRVA0
UkxGRkEtR0VzVVVEOUUxd0RvSFA4TTF3eWpBT3NJMTNDakFOY0VvT2djLXhnYzZLRFhCRC0zOS1j
VTUKd0EtY01nLWZPY1lQeERuQUQ4dzV3QS1HTlNnNkVEb293RFhGS0RyQUJ6LUVCenJBS0RYQkQ4
QW1EeVlQMERJUHlCTElEOFFTeUEtUApOY0U2QnotRE5jUW93elVvTmNnb05kUW9Pc0FIUDhRSE9z
QW9OY0VQLWNFeUQtMzl3RG5BRDhBNUQ5b3lEOEF5RDlrNXpBLUFPY0FQCndEa1B5VG5BRDhBNUQ4
VTFLRG9Rd0RyQ05jSW93RHJBQjhRNndDakFOY0lQd0NZUDBUSVB3RElQeFJMSUQ4UVN5QS1JTmNj
b09nYy0Kd3pYSEtNQTFLTUExeHlqQU5jWW9OY29vd0RyQUI4UTZ3Q2pBTmNJUC1jQXlEOEF5RC0z
Nk9jQVB3RG5BRDljeUQ4QXlEeklQMkRuUApLRGtQd0RuQUQ4ZzV3QS1BT2NBUHhqVW9FQWZBRU1F
MXd5akFPc1lvd0RYREQ5RXlEOEF5RHpJUHhUa1N5QS1ET1JMSUQ4WTF3RG9ICnd6WEJLRHJBQnot
Q05jb29PaWcxeGlnNktEWEZLTUExeWlqQU9zWW93RFhERC1zeUQ4QXlEeklQLWVrbUR5WVAwRG5B
RDhjbUR5WVAKelRJUE1nOHlEOGNtRHlZUHl6blRLRGtQekRuQUQ4Y21OU2c2RU1BSFB6WEVLTWcx
eVEtTk1nOHlEeklQeFRrU3lBLURPUkxJRDhVMQp3RG9IUDhJMXdpakFPc0FId2pVb05jZ29Pc0Fv
TmNVb09zQW9OY1FvT2lnMXlpaklOY1FQeWlZUEpnLUxKZzhtRDhzbUR5WVB6VElQCk1nOHlEOWNt
RHlZUHl5WVBKZy04SmctZEpnLWRKZy1NT2RjUDFpWTF3Q2dRd1RYSEtNSTF4RG9IeERvMXdBLVlM
aExGRHhJUHhDNFMKeFE4U0Q4UTF3RG9IUDhNMXd5akFPc00xS01BMXlDZzZFRG9vd0RYREtEb1FP
aWpBTmNFb09zQW9OY3dvd2pYSEQ4c21EODBtRDgwbQpEXzBtRDgwbUQtMzl6em5hRDljMTFEb0hQ
OFFIT2pYQUQ5YzVMc0FQTHNJUHhqa3V3QTh1d2pYSU9nYy13elhFS01RMUtEb29OY2dvCk9oREFP
c1ExS0RvUXdEckNOU2c2RURvb3dEWFdELTM5LWYzQk9kMFAyRFVvTmMwNkJ6LUdCem8xd0NZUEpn
LVRPY0VQd0RuQkQ4WTUKd1EtQU9UWEFPZ2ZETmNFb09nYy13elhIS01NNndDZzF5Q2dRQjhBUXhE
VW9FQWZBRU1JMUtEb1F3RHJCTlNnMTBDZzFELTM5LWYzQgpPZUFQMVRVb3dEWE1PZ2MteGdjNk5j
RW1EX2sxd0RvSFA4TTF3U2c2d0FjLXdqWE1LRG9RT2lqQU5jUW9OU2c2RU1BSFA4QUhFTUExCktE
b1F3QWMtd0FjMUtCQUh3QkRBTlNqQU5jNG93RFVQLWYzOS1jRTU0Zy1UTlNnNktEWEtLRG9IUDhZ
SE9pZzF4Zy1qTmNBNkJ6LUQKTmNJb3dEckFCOEkxS0RYTEtEb1F3RHJHRURYQUtCREVLRFhCS0JE
RU5TZzZFTUFITlNnNktEWE1LRG9vTlEtOS1mMzl3am5tRDg4bwpPc0FvTmNrb09zQUhQOFFIT2pY
QU9nZkVPalhBRDlrMXlEb0hQOE0xd3lqQU9zTTFLTUExeXlnUUI4QVF4QWZBRUNnMXhnLUJOY2dv
CkVNRW9Pc0FvTmNvb09zQW9ELTM5LWYzRE9la1B6RFVvT2hBNktNQTF4aWpBT3NBSHhEbzF3RG9I
UDhRSE9qWEFEOVkxd0RvSHd6WEIKS0RvSFA4TTF4Q2pFTlNnNktEWExLRG9Rd0FjLXdBY1F3RG9v
TlEtVE5jTW9PaEE2S01BMXhDakFPaEE2S0RVUC1mMzktY1E1NmctTApOU2c2RU1BNnd6WERLTUE2
eFRYQU9nYy14Z2M2TmNnUHd6WEdEelhBT2djLXd6WEJLRHJBQnotQ05jY293enJBS0RYTUtCREVL
RFhBCkQ5azFLRG9Rd0RyR0VNQTZLRFVQLWYzOS1jYzU3US1ITlNnUUI4QVF3alhFS01VMXdUb0hQ
OFlIT2pYQU9nZkVPalhBRHpYQU9nZkUKT2pYQU9nYy13elhDS01BNndBZkNOY3dvT2hBNktNQTF4
Q2pBT2hBNk5jWVAzRFVvRUFmQUVNUUh3QkFvTlEtOS1ka21EeVlQMnlZUApKZy05eXpuYS12OTNx
RGtkT2M0UHdTWVBKZzgxS0RvUXdBYy13RFhIS01FMXdTZzZCei1HQnpYQU9nYy14QWM2TmNFNkJ6
LUVOY0U2CkJ6LUROY01vd0RyRE5TZzF5eWc2RU1BNnhoREFPaWcxRDhvbUR5WVB5eVlQSmctRk5T
ZzZFTUFIUDhBSEVNQTZLRFVQeGlZUEpnLUwKSmc4bUQtc21EeVlQeXlZUEpnLXNKZy1kSmctOXp6
blZIVG5BLXJrQVBqbkFIVG5PRDhBbUQ4RTF3Q2dRd2pYTktEckFCei1FQnpYQQpPZ2MteGdjMXdE
b0hQOFExd1NnNkJ6LUROY1FveERVb3dEWExLQkFId0JERUI4QVFLRFVQekNZUHpTWVB4elhBS0JE
RUtEWEFEOGdtCkQ4MG1EOFhfb29oNXdoVEFELUFtRDgwbUQtMzk0em5VLXJrQVBzQW9Fc0E1MUEt
Qk5jUW9OY3Nvd0RyQUI4UTF3VG9IUDhZMXdUb0gKUDhRMXdTZzZ3QWMtd2pYSEtNRTFLRG9vTmNz
b09oREFCei1BQnhEQU9pZzFEX2sxeGctaC1xS0llY1VVRC0zOTNqSVB6VElQOXpuUwotcmtBUHNF
NTJDWVBKZy1BTlNqQU5jc293RHJFTmNFb09nYy14VFhCS0RvSFA4TTF3aWpBT3NBSHdqWExLRHJB
S0RYTUtCREVLRFhBCkQtM1ctcUtJZWNnUHlUSVAtVElQLWM4eUQ4QXlEOG95RDhBeUQtYzUwQ2c1
MmctQ05TZzZLRFhMS01VMXdTZzZ3QWMteERYQktEckEKQnotQ05jTW93RHJETlNnMXlpZzZFRG9v
d0RYRUtNQTZFRG8xeGhJUC1kY1N5QS1KTWctQU1nLTZNZy1BTWctOXlUSVB3RElQTWctSQpNZy1B
TWc4eUQtbzV6Zzg1M0EtQktEckFLRFhOS01FMXdpakFPc0FId3pYQ0tNQTZ3QWZDTmNRb3hEVW93
RFhLS0RvUXdEckdFTUE2CktEVVN3US1CTHNBUC1kWTVFc2dQeGpJUHdESVBNZy00TWctQU1nOHlE
OWNtRHlZUDJ5WVBKZy1OTWc4eUR6SVB5VElQTWc4eUQtMDUKeXlZNXlnODVEem5RTlNnNkVEb293
RFhTS01BNnhEWERLTUE2d3pYSEtNRTFLRG9vTmNvb0VBZkFFTVFId0JBb05STEZPUS1ISmc4bQpE
OHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeVRrU3lBLUhNZzh5RHpJUDF5WVBKZy1MSmc4bUQ4
MHlEeklQTWctWUpnLWRKZy05CjZUbkVLTUFtT2NzUE9kSTFLRG9Rd0RyQ05TZzF6aWpGTmNRb3hE
WExLRHJBS0RYS0tEb1F3QWMtd0FjUXdEb29OUzRTeFE4U0Q4Y20KRDgwbUQ4MG1EODBtRDgwbUQ4
c3VFc1VQRWctbUpnLU5KZy05LWYwNTZEVW9FQWZBRU1FMUtNQTEwQ2pDTmNjb3dUVW9OY29vT2hB
NgpLTUExeENqQU9qWEFLQkRFS0RYQUR6a3V3QTh1d2ctOTJUa3V3QTh1d2ctOS1mMzlPZVVQTlNn
NkVNQUhQelVvT2lnMTRDakFOY29vCk9oREFPc1lRd0Rvb05jWVB3VG5CRDhBNXdRLTkyVG5CRDhB
NXdRLTktZjM5eERuaER6WEFLQkRDS0RyQUtEWEdLRFhLS0RYSktEb28KTmNvb0VBZkFFTVFId0JB
b05RLTktZjM5LWZ3NTRqWEVLRG9RT2lqQU5jTW93RFhKS01BMXlDZzZ3Q2cxeWlnNkVNQUhQOEFI
RU1BNgpLRFVQLWYzOS1mMzl3am5sTlNnNkVNQTZ3elVvT2lnMXlDZzZLRFhJS0RvUU9pakFOY1Fv
d0RvMXdDZ1F4Q2cxd0EtOS1mMzktZjNJCk9lRTFLQkFId0JEREtEckFLRFhIS0RyQUtEWElLRG9R
d0RyR0VNQTZLRFhHRC0zOS1mMzktY3c1NERVb09oREFCei1BQnpVb09oQTYKS01BMXhTZzZFRG9v
d0RYRUtEVW9FQWZBRU1RSHdCQW9OUS05LWYzOS1mM1hPZDQxd0NnUXhEVW9PaERBT3NZMUtEb1F3
RHJHRURVbwpPaERBQnotQUJ4REFPaWcxRC0zOS1lWW1EeVlQeXlZUEpnLXJKZzhtRC0zZEpnOG1E
OHNtT1E4NTJUWEhLQkFId0JERUI4QTFLQkFICndCREVCOEFRTmNBb0VNUW9OY0FQekRrUDhpWVBK
Zy05LWVBbUQ4MG1EXzBtRC0zZkpnLU5Kam5kRHpuRE5TZzZFTUFIUDhBSEVNQTYKS0RVb09oREFC
ei1BQnhEQU9pZzFEelhHRDgwNXdBLUFPUS1ZRXNJVXdBLVFKZy1GRXNJVXdBLUlFc0lVd0EtSUVz
SVV3QS1JRXNJVQp3QS05LWYzOTJ6bmlOY0FvRU1Rb05jQTVOY0FvRU1Rb05jQVAxam5BRDhBNXdB
LUlFc0lVd2ctRkVzVVVEOVlTeFJRUHhoTEZGQS1HCkVzVVVEOFlTeFJRUC1mMzktZDQ1RHpuZU5j
WTV3elhHRDhzeUQ4MDV3QS1JRXNZVXdBLURFc2dQMUJMSUQ4UVN5QS1FRXNnUHhCTEkKRDhreUQt
MHlELTM5LWM4bUQ4TTU2QS1DTWctQU1nLUtNZy1BTWctSk9jQVB3RGtQeFRrU3hBOFN3US1ERXNn
UDFCTElEOFFTeUEtRQpFc2dQeEJMSUQ4a3lEOEF5RC1veUQ4QXlELTM5LWRRNTV5WTV3Q1k1Smct
SU1nLUFNZzh5RDhrNXdBLUFPY0FQeFRrU3hROFN3QS1DCk9STElEOU01RXNnUHd6a1N5QS1ET1JM
SUQ4TTVFc2dQeGpJUHdESVBNZy00TWctQU1nOHlEOGNtRHlZUHl5WVBKZy1ySmc4bUQtM2QKSmc4
bUQ4c21EeVlQMWpuRER6a1BPY3NQT1E4NXpTWTVKamttT2NFUHhqSVBNZzh5RDh3NXdBLUZPY0FT
eFE4U3dBLUNPUkxJRDhVbQpEeVlQeVRrU3lBLURPUkxJRDhNNUVzZ1B3emtTeUEtSE1nOHlEeklQ
X1RJUE1nOHlEOGdtRDgwbURfMG1ELTNmSmctTkpnLWNPUTg1CnpRODUyQS1nT1M3QUVzQXV3Zzh1
RDhRdUVzVVBFZy1HSmctTExoTEZEeElQeEM0U3hROFNEOFF1RXNVUEVnLUVMaExGRHhJUC1mMzkK
LWU0NTZnLWZPY0F1d2puQkQ4WTVMc0FQTHNJUDFqa3V3QTh1d2ctR09TN0FEeTdDRDhZNUxzQVBM
c0lQeGprdXdBOHV3Zy05LWYzOQo1aVlQSmctSE9lNFAyam5DRDhvNXdRLUFPY0VQMWpuQkQ4QTV3
US1HT2NFUHdEbkJEOFk1d1EtQU9jRVB4am5CRDhBNXdRLTktZjM5CjV5WVB5em51RC0zOS1mMzkt
ZjNDT2VvUC1mMzktZjM5LWNFNTZnLTktZjM5LWYzOXdqbnVELTM5LWYzOS1mMDU3Zy05LWYzOXh6
LUIKRC0zOTlUbnBELTM5LWRnbUR5WVB5eVlQSmctV1A4RVAwQ1lQSmctTEpnOG1ELTNkSmc4bUQ5
c21EeVlQelRuTUR6a1BPY3NQT1E4NQp5QS1CSmc4bUQ4c21EeVlQeXlZUEpnLUZNUTh4RDlFbUR5
WVB4VEVQTVEtUkpnOG1EOHNtRHlZUHhqa1AwaVlQSmctTEpnOG1EOHNtCkR5WVAzQ1lQelNZUDFU
LUFJUi1BUDhBUHp5WVB6U1lQLWQ4bUQ5MG1EOUE1eXc4NXpRODV6UTg1RDh3bUQ4MG1EOFF4RDhB
TkQ4QXgKRDlBbUQ4UXhEOEFORDhBeEQ5QW1EODBtRDhZNXdBLUFPUS1RSmctTkpnLU5KZy05eHot
QUljRS13QS05LWZrNTdRLWhEY0F0RGNBUAoyUTNBTFEzQURfazV3QS1BT2NBUC1mdy13US04TWct
OXlpWVBKZy1nTWctT09la1A0QTNCRDlzTndRLXRPY0FQLURJUC1TWVAtVElQCndESVAtY2dtRF9F
eUQ4QXlEOHc1NlEtZ0xRLWRMUS10T2NBUHdEa1BfaklQd0RJUDl6TEFEeklQX2pJUHdESVBNZy05
NmpJUHdESVAKTWctUE9lMFAyaVlQM1NZUDdEbkFEOEE1d0EtM01nLUFNZzh5RDhjbUR5WVB5eVlQ
SmctZE1pWXlEekxBRDhZbUR5WVB5eVlQSmctZApNZzh5RHpJUDl5WVBKZy1iSmc4bUQ4MHlEeklQ
TWctSEpnOG1EOFk1d3c4NUR6bkxEemtQT2NzUE9RODV4US1FSmc4bUQ4NHlEOG9tCkR5WVB6aklQ
eWlZUEpnLUxKZzhtRDlBNXdBLUhKZzhtRDhzbUR5WVB5eVlQSmctTk1nOHlEeklQeUNZUHpTWVA0
REltTWctSUpnLU4KSmctOTN5WVAzU1lQM1NZUHpqbk5Eem5ORHpuSUQ4TW1EODA1d0RJUHl5WVB6
VG5BTWctTEpnLU5KZy1kSmctTkpnLU5KZy05MGpJUAotZjM5MFRucEQtMzktZWs1d0RJUC1mM1VK
ZzhtRC1nNTdRLTktZjM5LWYwbUQtdzU3US05LWYzOS1mMzl3em5wRC0zOS1mMzktZjNDCk9la1At
ZjM5LWYzOS1jTTU1dy05LWYzOS1mMzl4am5wRC0zOS1mMzktZjNIT2VZUC1mM3BKZzhtRDhzbUR5
WVAyeVlQSmctTEpnOG0KRDhZNUQtMzkxaVlQSmctTEpnOG1EOHNtRHlZUHhURVBNUS1ET2N3UE9R
ODUxZy1ESmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhZNQpEOUltRHlZUHl5WVBKZy1MSmc4bUQ4
c21EeVlQeXlZUEpnLU1KZy1OSmctZEpnLU5KZy1HT2NBUHdEa1AtZjNVSmctTkpnLU5KZy1FCk1R
LUFEUS1BTVEtRE9jc1BPZGdQd3lZUHpTWVB6U1lQelNZUHhqbkFEOEE1RDlBbUQ4MG1EODBtRDgw
bUQ4MG1ELTNYT2NBUHdEbkEKRC0zOS1BM0FMUTNBRDhjNTZBLTJPY0FQd0RuQUQtMzk3em5BRC0z
WkpnOG1EOUF5RDgweUQtc053US1PT2MwbU9kVVA5am5BRC0zOQo3em5BRDhBNUQtM1lKZy1STWct
QU1nLUtNZy1BTWctNUxRLVFPY3dtT2NBbU9kUVA4em5BRDhBNUQtMzk3RG5BRDhBNXdBLTk2VElQ
CndESVBNZy1JTWctQU1nOHlELW9tRDlJNXh5WTV3Q1k1SmpuV0QtRTV3QS1BT2NBUC1kZ21EeVlQ
eXlZUEpnLWJKZzhtRDhzbUR5WVAKMERuQUQtM3JNZzh5RHpJUHlUSVBNZzh5RDhjbUR5WVB5eVlQ
SmctTEpnOG1EODR5RDhvbUR5WVB4am5GSmprbU9TWTV4dzg1RHpuTApEemtQekNZUEpnLUxKZzht
RDlBNXdBLUhKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHpDWVB6U1lQM1NZUHpTWVAt
ZjNoCkpnLU5KZy1OSmctTk9jQXlEOHNtRDh3NXp3ODV6UTg1d2ctSkpnLU5KZy1kSmctTkpnLU5K
Zy1OSmctTkpnLTktZjM5LWNZNTVnLTkKLWYzOS1jY21EeVlQLWZjNTVnLTktZjM5LWNjbUQtMzZP
ZWdQLWYzOS1mMzktY1U1NkEtOS1mMzktZjM5eHpubEQtMzktZjM5LWYzRwpPZVVQLWYzOS1mMzkt
Y2M1NHctOS1mMzktZjM5eWpuaERfMC13US05MGlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctOV9E
a1AtVGtQCjBpWVBKZy1MSmc4bUQ5WTVEODg1d1E4NUR6bkZIVGtkT2N3b0Q4MDVEOUltRHlZUHhq
LUJEOUFtRHlZUHhURVBNUS1NT1EtU0pnOG0KRDh3bUQ4MG1EODBtRDgwbUQtMzRPY0FQd0RrUF9U
bkFEOEE1RDlBbUQ4MG1EOVk1d0EtQU9RLU5PY0VQT2NRZE9jRF91UUFfT2NBZApPY2tvd0EtQU9R
LUpPY0FQd0RrUDBDWVB4VC1BSVItQVA4QVB6eVlQeERFUHdBMFB3REVQeVRuQUQ4QTVEOUFtRC0z
OV9UbkFEOEE1CndBLTRPY0FQd0RuQUQtZzV3QS1BT2NBUHp6bkhFc0FvRXNBNXlTakFPUTg1d0Et
SU9jQVB3RG5BRDlnLXdDSEJQOEFQMXczQUxRM0EKRDhrNXdBLUFPY0FQLWQweUQ4MHlEXzB5RF8w
NXdBLU1NZy1OTWctZE9jQVA3RElQelRuQUQ5TTV4UkxCT2N3UE9jQVB6RG5BRDlzLQp3US1hRGNF
UHpUbkFELTNlTWctQU1nLUtNZy1BTWctcU1nLUFNZy1wT2NBUHdEa1B5aklQd0RJUHlqSVB3RElQ
MlRuQUQ4QTVEX295CkQ4QXlEOGs1d0EtQU9RLVZPY0lvT2M4UHdEa1B5VG5BRDhBNUQ5b21EOXd0
RDgwNXdBLUFPUS05MlRJUHdESVBNZy1JTWctQU1nOHkKRF9neUQ4QXlEeklQNlRuQUQ4QTV3QS1I
TWctQU1nOHlEOGd5RDhBeUR6SVAyVG5BRDhBNXdBLW5NZy1BTWc4eUQ4azV3QS1BT2NBUAoxam5C
RHpuT0Q4QTV3QS1JT2NBUHdEbkFEOWN5d0E4eUQ5d21EOHc1d0EtQU9jQVAxaVlQSmctTEpnOG1E
OHNtRHlZUHl5WVBKZy1OCk1nOHlEeklQeVRJUE1nOHlEX2t5RHpJUE1nLXNPY0FQeVRJUE1nOHlE
OGt5RHpJUE1nLWNPY0FQeHlZUEpnLUxKZzhtRDgweUR6SVAKTWctTU9jQVB4eVlQSmctTk9TWTV5
Zy1ET2NBUHpEbkFEOGNtRHlZUHpUSW1NZzh5d0EtR0pnOG1EODR5RDg4NXdBLUhKZzhtRDh3bQpE
ODBtRDgwbUQ4MG1ELTM5LWRNbUQ4MG1EXzBtRDgwNXdESVBPY1lQNGlZUDBESW1NZy1JSmctTk9j
QXlEOXNtRC0zOS1mMzktZXd5CkQtMzktZjM5LWYzcE9jQXlELTM5LWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mM3kKUDhFUC1mMzk5aVlQSmctTEpn
OG1EOHNtRHlZUDZ5WVBKZy05elNZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctV1A4RVAwQ1lQSmct
TApKZzhtRDlzbUR5WVB4VEVQTVEtUkpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZ
UEpnLUdPUS1TSmc4bUQ4c21EeVlQCnpDWVB6U1lQelNZUDdTWVAtYzhtRDgwbUQ4MG1EODBtRDlV
LXdDRWZ3RC1BRDg4bUQ4MG1EOTBtRDhReEQ4QU5EOEF4RDlBbUQ4MG0KRDgwbUQ4MG1EODBtRDgw
bUQ4WTV3QS1BT1EtUUpnLU5KZy05LWYzN1A4QWh3VC1BRC0zSkRjQXREY0FQLWVzNXdBLUFPY0FQ
LWQweQpEODB5RC0zOThELUJEX3d5RDlzTndRLTk3em5BRC0zZU1nLUFNZy1LTWctQU1nLTktZTRt
RF8weUQ4QXlEOWt0RC0zdk9jQVB3RGtQCi1ka3lEOEF5RHpJUHlESVB3RElQTWctOS1ld3l3QTh5
RF9veUQ4QXlEeklQMmlZUC1lNDV3QS1BT2NBUDVpWVBKZy1MSmc4bUQ4c20KRHlZUHpUSVBNZzh5
RDhreUR6SVBNZy1ISmc4bUQtM05KZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOTB5SmpJUE1zQVB4
aVlQSmctTApKZzhtRDgweUR6SVBNZy1ISmc4bUQ4NHlEOG9tRHlZUHl5WVBKZy1MSmc4bUQ4c21E
eVlQeXlZUEpnLUxKZzhtRDlBNXdBLUhKZzhtCkQ4c21EeVlQekNZUHpTWVB6U1lQN1NZUC1jOG1E
ODBtRDgwbUQ4MG1EX0F5SmpJUHlDWVB6U1lQM1NZUHpUbkFNZy1MSmctTkpnLU4KSmctTkpnLU5K
Zy1OSmctZEpnLU5KZy05LWYzOXlESVAtZjM5LWYzOS1lazV3RElQLWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWRJLXdRLTktZjM5LWYzOEpn
OG1EOHNtRHlZUDFqLUJEOUFtRHlZUHl5WVBKZy05CnpTWVBKZy1MSmc4bUQ5c21EeVlQNnlZUEpn
LUdPUS1TSmc4bUQ4VXhEekVQMFNZUEpnLUZNUTh4RDlFbUR5WVB4amtQMGlZUEpnLUYKTVE4eEQ5
RW1EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB6Q1lQelNZUDFULUFJUi1BUDhBUHp5WVB6U1lQLWM4
bUQ4MG1EOTBtRF8wbQpEOFk1d0EtQU9RLVFKZy1FTVEtQURRLUFNUS1RSmctRU1RLUFEUS1BTVEt
UUpnLUdPY0FQd0RrUDBDWVB4REVQd0EwUHdERVAwQ1lQCnpTWVB6U1lQelNZUDlULUFJY0Utd0Et
OS1jdl9vb2g1d2hUQ0QtM0lPY0FQd0RuQUQ5Z053QzBOd0EtWkRjQXREY0FQMlRuQUQ4QTUKd0Et
WURjQXREY0FQLWU0eUQ4dy13US04TWctOXl4TEdGTUFQMkRJUDdUbkFEOW9Od1EtYkRjRVAzVG5B
RDlvTndRLTk3eklQd0RJUAp5aVlQLVRJUHdESVAtY2M1RXNRUEVzRVAyRElQd0RJUDZUbkFEOEE1
RDlrdEQ5MHREOTA1d0EtQU9RLVpMUS05N1RJUHdESVBNZy1JCk1zQVBNZy02TWctQU1nOHlELTNJ
T1JMRkR4TEFEOVV5RDhBeUR6SVA2VG5BRDhBNXdBLVpKZy1kSmctY09jQVB3RG5BRDlrbUQtM00K
Smc4bUQ4c21EeVlQelRJUE1nOHlEOGt5SmpJUE1zQVB4aVlQSmctTEpnOG1EOTB5RHpJUE1nLW5K
ZzhtRDhzbUR5WVB5VG5BRXNVUApFc0FQeENZUEpnLU5NZzh5RHpJUDF5WVBKZy1RT2NBUHh5WVBK
Zy1PTWctS0pnOG1EODR5RDhvbUR5WVAwRG5BRDhjbUR5WVB6aklQCnlpWVBKZy1MSmc4bUQ4c21E
eVlQeXlZUEpnLU1KZy1OSmctZ01pWXlEOGdtRDgwbUQtM1BKZy1OSmctS09TN0FFc0F1d2c4dUQ4
WW0KRF8wbUQ5MG1EODA1d0RJUHl5WVB6VG5BTWctTEpnLWRKZy1OT2NBeUQ4c21EODBtRDgwbUQ4
MG1ELTNDTWctOS1jczV3QzdDT2NFUAotZjM5LWYzVE9jQXlELTM5ekRuQ0QtMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mM2tQOEVQLWYzOS1m
MzktZDRtRHlZUHhqLUJEX0FtRHlZUHl5WVBKZy03Smc4bUQ4c21EeVlQMVJMQkZNTVB6Q1lQSmct
V09RLVMKSmc4bUQ5c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctRk1ROHhEOUVtRHlZ
UHl5WVBKZy1MSmc4bUQ4c21EeVlQeGprUAp6REVQTVEtUkpnOG1EOHdtRDhVLXdDRWZ3RC1BRDk4
bUQ4MG1ELTBtRDgwbUQ5VVN4aFRBRDh3bUQ5WTV3QS1BT1EtUUpnLWRKZy1OCkpnLU5KZy1OSmct
TkpnLUVNUS1BRFEtQU1RLVFKZy1OSmctTkpnLU5KZy1HT2NBUHdEa1B4ekVQd0EwUHdERVAwQ1lQ
MVQtQUljRS0Kd0EtOS1kc1N5QS1rT2NBUHdEbkFELTM2RGNBdERjQVAtY3M1d0EtQU9jQVB5QTNB
TFEzQURfcy13US1NTWctOS1jNFN5QS1YTWctTgpPY0FQM0RJUC1kME53US05enpuQUQ4b053US10
SmctTk1nLUFNZy05LWNvNUVzUVBFc0VQMXpJUHdESVB5VG5BRDhBNUQ5b3lEOEF5CkQtM2JMUS05
enpuQUQ4QTVEOGt0RF9zeXdBOHlEOG95RDhBeUR6SVAtZjNMT1JMRkR4TEFEOVF5RDhBeUR6SVB5
VG5BRDhBNXdBLVgKTWctQU1nOHlELTNjSmctOXpqbkFEOEE1d0EtSkpnLWFKZzhtRDgweUpqSVBN
c0FQeURJUE1nOHlEOGNtRHlZUHl5WVBKZy03Smc4bQpEOHNtRHlZUDJ6a3VFc0VQRXNBUEVzQVB3
eVlQSmctTk1nOHlEeklQekRuQUQ4Y21EeVlQelRJUE1nOHlEOGNtRHlZUHl5WVBKZy1MCkpnOG1E
OHNtRHlZUHl5WVBKZy1PTWctS0pnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ5QTV3QS1LTWctS0pn
OG1EOHdtRDlBeUpqSVAKMkNZUHpTWVAtU1lQelNZUDNEa1BMc0VQTHNBUExnLUZKZy10SmctZEpn
LU5KZy1OSmctTkpnLU5KZy1OT2NBeUQ4c21EODBtRDgwbQpEODBtRDkwNXdESVB5eVlQNERJUC1m
M2ZPY0FQd1RrUC1mMzktZjNDT2NBeUQtMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzlfeVlQSmctTEpnOG1EOHNtRHlZ
UHl5WVBKZy1ySmc4bUQ4c20KRHlZUF95WVBKZy1ySmc4bUQ4WTVEOUltRHlZUHl5WVBKZy1MSmc4
bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTApKZzhtRDhzbUR5WVB4VEVQTVEt
UkpnOG1EOHNtRHlZUHl5WVBKZy1NSmctTkpnLU5KZy1OSmctdEpnLU5KZy05SmctdEpnLUdPY0FQ
CndEa1AwQ1lQelNZUHpTWVB6U1lQelNZUHpTWVB6U1lQelNZUHpTWVB6U1lQeERFUHdBMFB3REVQ
MENZUHpTWVB6U1lQLWYzWkVzSVUKd2ctOTJEbkFEOEE1d0EtOS1ld053QzBOd0EtOS1mM09Fc1lV
d0EtOTJqbkFELTM5N2czQkQtMzktYzQ1RXNRUEVzRVAtZGs1d0EtQQpPUS05LWUwdEQtMzktYzg1
RXNVUEVzQVAtZGc1d0EtQU9jQVAtZjN0SmctNkpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bURfc21E
eVlQCnl5WVBKZy1aT2NBU3hROFN3QS1VSmc4bURfc21EeVlQMERuQUQ4Y21EeVlQeXlZUEpnLUxK
ZzhtRDhzbUR5WVB5eVlQSmctTEpnOG0KRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHpqSVB5
aVlQSmctTEpnOG1EOHNtRHlZUHpDWVB6U1lQelNZUHpTWVA3U1lQelNZUAoyamt1d0JMQUxzSVBM
Zy1XSmctdEpnLWRKZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OT2NBeUQ4
c21EODBtCkQ4MG1ELTM5M2puQUxzSTV3US05LWYzOS1mMzk1RG5DRC0zOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWZrbUR5
WVB5eVlQSmctTEpnOG1EOXNtRHlZUHl5WVBKZy1MSmc4bUQ4VVN3UlRERDl3bQpEeVlQNnlZUEpn
LUxKZzhtRDhzbUR5WVA2eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1iSmc4bUQ4c21EeVlQeXlZ
UEpnLUxKZzhtCkQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB6Q1lQelNZUHpTWVAzU1lQelNZ
UHpTWVB4UkxHRk1BUDNDWVB4UkxDRk1BUDRDWVAKelNZUHpTWVA3U1lQelNZUHpTWVB6U1lQM1NZ
UHpTWVB6U1lQelNZUHpTWVB6U1lQelNZUHpTWVAtZmNTeUEtakVzVVVELTM5LWYzOQotZk1TeUEt
aUVzZ1AtZjN0TWctOS1mMzl3VGtTeEE4U3dRLWlFc2dQLWYzdE1nLUFNZy05LWYzOE9STEZEeExB
RF9FNUVzZ1AtZjNxCk1nLUFNZzh5RC0zOXl5WVBKZy1MSmc4bUQ4c21EeVlQMnlZUEpnLUxKZzht
RDhzbUR5WVB5emt1RXNFUEVzQVBFc0FQMHlZUEpnLUoKT1JMSUQ5VW1EeVlQeXlZUEpnLUxKZzht
RF9zbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHpUSVBNZzh5RDhjbUR5WVB5eVlQSmctTApKZzht
RDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1NSmctTkpnLU5KZy1kSmctTkpnLU5K
Zy1NT1E4dXdROHV3QTh1CkQ5VW1EOHN1RXNVUEVnLVdKZy1OSmctTkpnLXRKZy1OSmctTkpnLU5K
Zy1kSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLTkKLWNJNXdBLUJPUS1sT1M3QUR5N0NE
LTM5LWYzOS1mM2tPY0VQd0RuQkQtMzktZjM5LWYzOS1mMzktZXNBQUFBQUFBQUFBUT09Cjo6IG1h
cC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA0IDA1OjAwOjMzIixtb2RpZmll
ZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lERXdPak0xT2pRNElpeHRiMlJwWm1sbFpEMGlNakF5TlMw
eApNUzB3TkNBeE1EbzFORG96TlNJc2NtVjJhWE5wYjI0OU1qTmRYV3g2TkFCOUFnQUFPZ1FBQVBF
Z2UzdGliWEE5Y0hoMUFFeUFJQ0FBCkpRTUFBQThBQlFNQUFRVUFBUU1BQUFzQUFBZ0FFQU1BQUFJ
QUFnTUFBQVlWQUJNSUhnQkNBZ2dBQUNjQU1RVUFDd1lBSUFBQ0R3QlEKQVFnQUFRWVBBQUFoQUVF
VEFBTUlQQUFGVVFBQkRBQVJCR01BRVFOT0FCRUFEQUJRQUFjQUFBNFNBQlFCTUFBQ0hnQVVBaVFB
S1FBSQpNQUFBVGdBUkJBd0FFUWdKQUFHckFBQVZBRElUQUFKUkFBRzBBQkVDTUFBakFBSjRBQ0VB
QXljQUFnOEFFUk01QUJBRnJnQVNDQjRBCkIyTUFCV2tBRVFQR0FBQVNBQkVFSGdBQnFBQVJCQTRC
SkFBRmRRQVRCYm9BUWdBREFBUVNBRFFFQUFHSEFDRUFEeTBBTlFNQUF4Y0IKTWdVQUFTY0FFQWk2
QUFNSkFBSWJBQVRZQUFJbUFRTjdBQkVUSkFBQ2hnRVdCUmNCQWhVQUVRUUNBVVVCQlFBQ01BQUNQ
Z0V4QWdBSwpoQUFBbVFBQ0JnQVFBZzhBSXdBSXFnRUFTd0FFQ3dFREZBRVRDdzhBSXdBQ0J3SUF0
d0FGRndFVUN6WUFBU1FBSXdVREp3QWtBQVViCkFBamJBRElQQUFBYkFBTFZBQVJwQUFZR0FBUVNB
QklHZUFBRVZRSURTQUFVQno4QUdRSU9BUUxZQUFJMkFBWkVBUkVQQmdBRWd3RkIKQUFJQUNTMEFG
UWREQWhNSElRQWpBQVlTQUJJQjFRQTBCUUFQRlFBQUJnQUZ2d0VDOXdJQldnQWpDQU9iQVJJTlNB
QVFEendBSXh3RApVUUJIQWdnQUdiY0FKaDBEaWdBWEdnd0FVUTREQUFBS2lnQXhDZ0FIRWdBQWpR
QVJDVlFBRmdnYkFCRUpGUUFqQUFvYkFDRUVDbjRBCk1Ra0FBaElBRkFzdEFDWUFDUVlBQUNFQUZ3
MFNBRFVOQUF3NUFCUUlHd0FSRFU0QU1RMEFDaTBBOFF4WUF3QXNhR2xrWkdWdVBXWmgKYkhObExI
QmhibDk0UFRFd0xqVUxBUElDZVQwdE5qZ3VOU3gwYVd4bFgyZzlNVFlLQUJCM0NnQ0FlbTl2YlQw
eGZYMD0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMTEtMDQgMDU6MDA6
MzMiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IHNmeC8wLnNmeApiNjQkTFMx
YlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQTNMVE14SURBNE9qTXdPakk0SWl4dGIyUnBabWxs
WkQwaU1qQXlOUzB3Ck55MHpNU0F3T0Rvek1Eb3lPQ0lzY21WMmFYTnBiMjQ5TUYxZGJIbzBBS0FB
QUFBTENnQUEtekJ3ZUhVQUF5Z0FBQVFBQkE5QUVBSU8KQUFHZ0FTQUNvQTRBRHhBQURmREtBUUlE
UUE4UGtBUUZCZ2RBREpBSUNRb0xRQXlRRHd3UERROE9ERUFNOFA4QkFPdi1KNm9CRUFZUApNQkFC
SUFFZ0FmQUFBaEFDRGhBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENnLS1ENEFQOXc4TkFmQUpB
UkFHRGpBQS0tLS0tLV85CkgtOEJBS3pQeUE5QUFBOFFRUC0tc1BELUFRRC02bEQtLS0tLUtRPT0K
OjogW2VvY10K
:: bios/demos/spiral.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTEwLTI5IDA4OjQxOjU5
Iixtb2RpZmllZD0iMjAyNS0xMC0yOSAwODo0MTo1OSIscmV2aXNpb249MF1dCi0tIHNwaXJhbAot
LSBieSB6ZXAKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKCkKCWZvciBpPTEsMTUwLDIgZG8KCQlsb2Nh
bCBzeCA9IDI0MCArIGNvcygtdCgpLzIraS8zMCkqOQoJCWxvY2FsIHN5ID0gMTM1ICsgc2luKC10
KCkvMitpLzMwKSo5CgkJbG9jYWwgcj0yK2kqMwoJCQoJCWNpcmMoc3gsIHN5LCByLCAxMikKCWVu
ZAoJcHJpbnQoc3RyaW5nLmZvcm1hdCgiJS41ZiIsc3RhdCgxKSksMiwyLDcpCmVuZAo6OiAuaW5m
by5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTI5IDA4OjQxOjUxIixtb2RpZmllZD0iMjAy
NS0xMi0xNCAwMDo0NzozOCIscnVudGltZT0yMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4u
bHVhIzEzIix3b3Jrc3BhY2VfaW5kZXg9MX19XV0KOjogW2VvY10K
:: bios/demos/squashable.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTEyLTI5IDIyOjI3OjU3Iixtb2RpZmllZD0iMjAyNS0wMS0wMSAxOTo0ODozMSIs
cmV2aXNpb249MTE3XV0KLS1bWwoKCXNxdWFzaGFibGUgd2luZG93cyBkZW1vCgkKCXNldCAic3F1
YXNoYWJsZSA9IHRydWUiIGluIHdpbmRvdygpIHRvIGdldCBhIHdpbmRvdyB0aGF0CglhdXRvbWF0
aWNhbGx5IHJlc2l6ZXMgdG8gc3RheSB3aXRoaW4gdGhlIGNvbmZpbmVzIG9mIHRoZSBkZXNrdG9w
CgpdXQoKZnVuY3Rpb24gX2luaXQoKQoJd2luZG93ewoJCXdpZHRoPTIwMCwKCQloZWlnaHQ9MTAw
LAoJCXNxdWFzaGFibGUgPSB0cnVlCgl9CmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJLS0gc2l6ZSBj
aGFuZ2VzIHdoZW4gc3F1YXNoZWQKCWxvY2FsIGR3LGRoID0gZ2V0X2Rpc3BsYXkoKTphdHRyaWJz
KCkKCWxvY2FsIHd3ID0gbWluKGR3LGRoKQoJCglkdy09MQoJZGgtPTEKCXNzcHIoMSwwLDAsOCw0
LDAsMCxkdyxkaCkKCWZvciB4PTAsOCBkbwoJCWxpbmUoeCpkdy84LDAseCpkdy84LDEwMDAsMCkK
CWVuZAoJZm9yIHk9MCw0IGRvCgkJbGluZSgwLHkqZGgvNCwxMDAwLHkqZGgvNCwwKQoJZW5kCgkK
ZW5kCgotLSBnZW5lcmF0ZWQgd2hlbiB3aW5kb3cgY2hhbmdlcyBzaXplIGR1ZSB0byBzcXVhc2hp
bmcKb25fZXZlbnQoInNxdWFzaCIsIGZ1bmN0aW9uKG1zZykKCS0tcHJpbnRoKHBvZChtc2cpKQpl
bmQpCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEwIDIyOjQ2OjA1Iixt
b2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIscnVudGltZT0xMyx3b3Jrc3BhY2VzPXt7bG9j
YXRpb249Im1haW4ubHVhIzYuMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAu
Z2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9p
bmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdm
eC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTI5IDIyOjMxOjExIixtb2RpZmll
ZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBnZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESTBMVEV5TFRJNUlESXlPakkzT2pVM0lpeHRiMlJwWm1sbFpEMGlNakF5TlMw
dwpNUzB3TVNBeE9UbzBPRG96TVNJc2NtVjJhWE5wYjI0OU9EUmRYV3g2TkFEREFBQUFRekVBQVBN
aGUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUEJXQnhBSHdCZlFGOEFIRUFmd1ZpeG1iR0ZuY3ow
d0xIQmhibDk0Q0FESGVUMHdMSHB2YjIwOU9IMHNQZ0QtSmdnRUJBQVAKRkFRUEh3OFBDQThZQWc4
VkJROFdCZ2NQRnc4T0R4NEJEeEFQRVF3UEhBOGREUThTRHhNRER4c0xEeG9LQ1E4WllRQUxTekUy
ZlN5ZwpBQi13a3dBTUR6RUEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCmgxQnRQVGg5ZlE9PQo6OiBtYXAvLmluZm8ucG9kCi0t
W1twb2QsY3JlYXRlZD0iMjAyNC0xMi0yOSAyMjozMToxMSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQg
MDA6NDc6MzgiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkw
TFRFeUxUSTVJREl5T2pJM09qVTNJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTVMwd01TQXhPVG8w
T0Rvek1TSXNjbVYyYVhOcGIyNDlPRFJkWFd4Nk5BQm9BQUFBV0JBQUFQQUllM3RpYlhBOWRYTmxj
bVJoZEdFbwpJbWt4TmlJc016SURBQzhpTUFFQS0tLS0tLS0tLS0tLS0tLS0tLS0tXy1FSUlpa3Nh
R2xrWkdWdVBXWmhiSE5sTEhCaGJsOTRQVEFJCkFOSjVQVEFzZEdsc1pWOW9QVEUyQ2dBUWR3b0Fn
SHB2YjIwOU1YMTkKOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMTItMjkg
MjI6MzE6MTEiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IHNmeC8wLnNmeApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExURXlMVEk1SURJeU9qSTNPalUzSWl4dGIy
UnBabWxsWkQwaU1qQXlOUzB3Ck1TMHdNU0F4T1RvME9Eb3pNU0lzY21WMmFYTnBiMjQ5T0ROZFhX
eDZOQUNnQUFBQUN3b0FBUDh3Y0hoMUFBTW9BQUFFQUFRUFFCQUMKRGdBQm9BRWdBcUFPQUE4UUFB
M3d5Z0VDQTBBUEQ1QUVCUVlIUUF5UUNBa0tDMEFNa0E4TUR3MFBEZ3hBRFBELUFRRHIteWVxQVJB
RwpEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1j
UERRSHdDUUVRQmc0d0FQLS0tLS0tCnZSLS1BUUNzejhnUFFBQVBFRUQtLTdEdy13RUEtX3BRLS0t
LS15az0KOjogW2VvY10K
:: bios/demos/tinypaint.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTA0LTA4IDA0OjQ4OjM2Iixtb2RpZmllZD0iMjAyNS0wNC0wOCAwNTo0NDozMiIs
cmV2aXNpb249MjU5XV0KLS0gdGlueSBwYWludGluZyBwcm9ncmFtIHRvIGRlbW8gY3JlYXRlX3Vu
ZG9fc3RhY2soKQoKY29sID0gOCArIHJuZCgxMSkgLS0gcmFuZG9tIGJydXNoIGNvbG91cgoKcGFn
ZSA9IHVzZXJkYXRhKCJ1OCIsMTYwLDEyMCkKLS1wYWdlOmNvcHkoNix0cnVlKSAtLSBzdGFydCBz
b2xpZCBncmF5CgpmdW5jdGlvbiBfaW5pdCgpCgl3aW5kb3d7CgkJd2lkdGggPSAxNjAsIGhlaWdo
dCA9IDEyMCwKCQlyZXNpemVhYmxlID0gZmFsc2UsCgkJdGl0bGUgPSAiVGlueSBQYWludCIsCgkJ
Y3Vyc29yID0gMCAtLSBoaWRlIHdpbmRvdyBtYW5hZ2VyIGN1cnNvcgoJfQoJc3RhY2sgPSBjcmVh
dGVfdW5kb19zdGFjaygKCQlmdW5jdGlvbigpIHJldHVybiBwYWdlIGVuZCwgLS0gcmV0dXJuIHRo
ZSB1bmRvYWJsZSBkYXRhCgkJZnVuY3Rpb24oZGF0KSBibGl0KGRhdCxwYWdlKSBlbmQsIC0tIHJl
c3RvcmUgdW5kb2FibGUgZGF0YSBmcm9tIGRhdAoJCTB4MTEsIC0tIG9wdGlvbmFsOyBlZmZpY2ll
bnQgcG9kIGZvcm1hdCBmb3IgZ2VuZXJhdGluZyBpbWFnZSBkZWx0YXMgKHJhdyBiaW5hcnkpCgkJ
bmlsIC0tIG9ubHkgb25lIHVuZG8gc3RhY2sgaW4gdGhpcyBjYXJ0IHNvIGRvbid0IG5lZWQgYW4g
Iml0ZW0iIHBhcmFtZXRlcgoJKQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg3KQoJc3ByKHBh
Z2UpIC0tIGRyYXcgd2l0aCB0cmFuc3BhcmVuY3kKCW14LG15LG1iID0gbW91c2UoKQoJY2lyYyht
eCxteSwzLCBjb2wpCglwcmludCgiXDAxNGN0cmwtei95IHRvIHVuZG8vcmVkbyIsMiwyLDE4KQpl
bmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJbXgsbXksbWIgPSBtb3VzZSgpCglpZiBtYiA_IDAgdGhl
bgoJCWlmIChsYXN0X21iID09IDApIHN0YWNrOmNoZWNrcG9pbnQoKQoJCXNldF9kcmF3X3Rhcmdl
dChwYWdlKQoJCS0tIGRyYXcgYSB0aGljayBsaW5lCgkJbG9jYWwgZHgsZHkgPSAobXgtbGFzdF9t
eCkvMTAsIChteS1sYXN0X215KS8xMAoJCWZvciBpPTEsMTAgZG8KCQkJY2lyY2ZpbGwobGFzdF9t
eCwgbGFzdF9teSwgMiwgY29sKQoJCQlsYXN0X214ICs9IGR4CgkJCWxhc3RfbXkgKz0gZHkKCQll
bmQKCQlzZXRfZHJhd190YXJnZXQoKQoJZW5kCglpZiAobWI9PTAgYW5kIGxhc3RfbWIgPT0gMSkg
Y29sID0gOCArIHJuZCgxMSkgLS0gY2hhbmdlIGNvbG91ciBvbiByZWxlYXNlCglsYXN0X214LGxh
c3RfbXksbGFzdF9tYiA9IG14LG15LG1iCgoJaWYga2V5ImN0cmwiIHRoZW4KCQlpZiAoa2V5cCJ6
Iikgc3RhY2s6dW5kbygpCgkJaWYgKGtleXAieSIpIHN0YWNrOnJlZG8oKQoJCS0tIGNvcHkgdG8g
Y2xpcGJvYXJkIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIGVtYmVkZGVkIGluIGNvZGUgLyB0ZXh0
CgkJLS0gc2VlIGJlbG93CgkJaWYgKGtleXAiYyIpIHNldF9jbGlwYm9hcmQocG9kKHBhZ2UsMHg3
LHtwb2RfdHlwZT0iZ2Z4In0pKQoJZW5kCmVuZAoKLS0gODwgLS0gcGFzdGVkIGZyb20gdGlueXBh
aW50OiAtLSAtLQotLVtbcG9kX3R5cGU9ImdmeCJdXXVucG9kKCJiNjQ6YkhvMEFFTURBQUJwQXdB
QXNYQjRkUUJESUtCNEJQRC1BUUR4TFFaTThJcHM4SWlNOEllTThJYXM4SVRNOElQTThJTHM4SUhz
OElCOEFIendOeXp3Tkl3UWJQQTJYUEF5ZkNCczhEVjg4REI4UUd6d05JendMd2dBOGF1YzhDMThV
R3p3TTd6d0xHeGdmUEF5elBBcWZIQnM4REg4QVBBb2JJQjg4REQ4QXZBZC1BQ1FmUEF2YkFDczhB
ejhFSkI4OEFFLUQtQWFiQkNzOEFNc0FQd1VvR3pnYnZBWmJDQ3NrRndBLUJqQWJNQ084QmhzTUt3
US1DYkFiTENlOEJoc1VQd3cwR3lncnZBWWJHRDhMdUJzZ0w3d0dXeHctQ0h3QzN4Z3Z2QVpmSUQ4
QmdBc0FDendIbXhRcnZBYmJLRDhCUEFuYkVDdThCeHNzTXp3TFd3Z3Z2QWRiTUJjOEROOHp2QWRm
UEJHYkw3d0huendTRXdIQURCSlRLNEhBUEFSU2t5TzhDQjg4RHd0b0V4dThDSnM4RHhOa0Z4TzhD
TnM4RHR0Z0d3dThDUUpBRUtRYlBBbUNBQlNzRThPOEJVTEFFS2dhLUFVQ2dCQ2NLdndFd29BSVZE
TENnRHhJWDJBYkREcjhCTnNzRDN3TEcyQWJCRDdBUEFVYktCZDhDdHRnR3o3QWZBVmJKQjk4Q3B0
Z0Z6N0FQQUlQYUI4Z0E0QWMwenI4QWx0a0d3TkFGRzc4QXZ0SUNnQThSMU5rRXliOEEzOUExeVFm
ZkFyTGFCY2UtQU8tUVJNb0gzd09Hdzc4Qkw5QkR5d2JmQTRiUEFYLVFOTW9Bb0FNQm45QVI4QTBB
b184QmxzOEJ6TlhLQjk4QVZNQWZJYjhDSmRiTEJ0OEFTXzhCZHM4Q2hzd0Uzd0JNN3dGbnp3S0d6
UUxmQUUzdkFXYlBBcGJQQVZ6dkFYQ1FEeHI3N3dHRXhQRWZBa0sxendGbzd3R1V6cThCaHJUUEFY
TGlBLUMtQVhQUG9FOEJDN1RQQWJlZkFVUFBvRjhBM2JUUEFhcWZBU1BQb0c4QW43QVV6d0dma0I4
QXhjX2dYd0NQc0JYUEFZX1FQd0NuejZCUEFIX3dGczhCZjVCZkFJakZESzhBamJJR3p3RnZrRzhB
aDgwRXJ3Q2F0UWJQQVdpUUM1OEFkODhCMTdnR3p3Rllrd21mQUdmUEFmVzVCczhCU0pVSG53Qm96
d0lDdXdmUEFUaVpBcDhBV2M4REY4OEJKNThCR3M4REVwYlBBUmFmQVF2UEF3V1Z6d0Vra0tBRkY1
WFBBU0tRb0FFWW1wQXZOR0w2bDg4REM4OERDcEFKendLdHp3TWFrZzdQQWk3UEF4cVVEOEFQQVkt
QWJ3TVpsdy1BWHdCLXdQOERLWmtQdzU4REtac1B3MjhEU0o0UHd5OERaNThBSDhMZkE3U2ZBSy1D
UHdQeW53RGZ3WjhHNzhCMUFEa1AtLS0tLS0tLS0tRGc9PSIpCi0tIC0tIC0tIC0tIC0tIC0tIC0t
IC0tIC0tIC0tIC0tIC0tID44Cgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0
LTA4IDA0OjQ4OjU2Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIscnVudGltZT0xNyx3
b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzM0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1h
cCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDQtMDggMDU6
MDA6MzciLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IGdmeC8wLmdmeApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQTBMVEE0SURBME9qUTRPak0ySWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB3Ck5DMHdPQ0F3TlRvME5Eb3pNaUlzY21WMmFYTnBiMjQ5TWpBMFhWMXNl
alFBZmdBQUFCSXhBQUR6SVh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHdWZ2NRQjhBWDBCZkFC
eEFIOEZZc1pteGhaM005TUN4d1lXNWZlQWdBeTNrOU1DeDZiMjl0UFRoOUxENEFILUF4QVAtLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tOWRRYlQwNGZYMD0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDQt
MDggMDU6MDA6MzciLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IG1hcC8wLm1h
cApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQTBMVEE0SURBME9qUTRPak0ySWl4
dGIyUnBabWxsWkQwaU1qQXlOUzB3Ck5DMHdPQ0F3TlRvME5Eb3pNaUlzY21WMmFYTnBiMjQ5TWpB
eVhWMXNlalFBYUFBQUFGZ1FBQUR3Q0h0N1ltMXdQWFZ6WlhKa1lYUmgKS0NKcE1UWWlMRE15QXdB
dklqQUJBUC0tLS0tLS0tLS0tLS0tLS0tLS0tdnhDQ0lwTEdocFpHUmxiajFtWVd4elpTeHdZVzVm
ZUQwdwpDQURTZVQwd0xIUnBiR1ZmYUQweE5nb0FFSGNLQUlCNmIyOXRQVEY5ZlE9PQo6OiBzZngv
LmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0wNC0wOCAwNTowMDozNyIsbW9kaWZpZWQ9
IjIwMjUtMTItMTQgMDA6NDc6MzgiXV0KOjogc2Z4LzAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZo
ZEdWa1BTSXlNREkxTFRBMExUQTRJREEwT2pRNE9qTTJJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcK
TkMwd09DQXdOVG8wTkRvek1pSXNjbVYyYVhOcGIyNDlNakF5WFYxc2VqUUFvQUFBQUFzS0FBRC1N
SEI0ZFFBREtBQUFCQUFFRDBBUQpBZzRBQWFBQklBS2dEZ0FQRUFBTjhNb0JBZ05BRHdfUUJBVUdC
MEFNa0FnSkNndEFESkFQREE4TkR3NE1RQXp3LXdFQTYtOG5xZ0VRCkJnOGdFQUVnQVNBQjhBQUNF
QUlPRUFFZ0R5RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JFQVlPTUFELS0t
LS0KLTcwZi13RUFyTS1JRDBBQUR4QkEtLV93OFA4QkFQLXFVUC0tLS04cAo6OiBbZW9jXQo=
:: bios/demos/treegen.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IHNmeC8KOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0xMC0wOSAwMjo1
MDo0NSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHJ1bnRpbWU9MjIsc3RvcmVkPSIy
MDI0LTA5LTAyIDE3OjA5OjU3Iix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzE3OSIs
d29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9
Mn0se2xvY2F0aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMC0xNiAyMDoyNzoyMCIsbW9kaWZpZWQ9IjIw
MjUtMTItMTQgMDA6NDc6MzgiXV0KOjogbWFpbi5sdWEKYjY0JExTMWJXM0J2WkY5bWIzSnRZWFE5
SW5KaGR5SXNZM0psWVhSbFpEMGlNakF5TXkweE1DMHlNaUF3T1RveU9Ub3pNeUlzYlc5awphV1pw
WldROUlqSXdNalV0TVRFdE1ERWdNREE2TkRJNk1qVWlMSEpsZG1semFXOXVQVFF3TmpOZFhRb3RM
U0IwY21WbFoyVnVJR1JsCmJXOGdZbmtnZW1Wd0NpMHRJSFZ6WlhNZ1ltRjBZMmdnYldGMGJYVnNN
MlFvS1NCbWIzSWdkSEpoYm5ObWIzSnRhVzVuSUcxaGJua2cKY0c5cGJuUnpJSFZ6YVc1bklHOXVi
SGtnZFhObGNtUmhkR0VnYjNCbGNtRjBhVzl1Y3dvS1pHbHpkR0Z1WTJVZ1BTQTNNQ0F0TFNCMApj
bmtnTXpBZ1ptOXlJR05zYjNObElIVndDbUp5WVc1amFGOXlZWFJwYnlBOUlEQXVPRFVnTFMwZ2FH
OTNJR0pwWnlCamFHbHNaQ0JpCmNtRnVZMmdnYVhNZ2NtVnNZWFJwZG1VZ2RHOGdjR0Z5Wlc1MENt
UnZkSE1nUFNBeE1qQXdNQ0F0TFNCb2IzY2diV0Z1ZVNCa2IzUnoKSUhSdmRHRnNJR2x1SUhSb1pT
QnpZMlZ1WlFwdVpXRnlYMk5zYVhBZ1BTQXdMalVnTFMwZ1pISmhkeUJrYjNSeklHWjFjblJvWlhJ
ZwpZWGRoZVNCbWNtOXRJSFJvWlNCallXMWxjbUVnZEdoaGJpQjBhR2x6SUNodWFXd2dabTl5SUc1
dklHTnNhWEFwQ21keWIzVnVaRjk1CklEMGdNakFLQ25SMElEMGdNQW9LQ21aMWJtTjBhVzl1SUds
a1pXNTBhWFI1WDIxaGRISnBlQ2dwQ2dsc2IyTmhiQ0J0SUQwZ2RYTmwKY21SaGRHRW9JbVkyTkNJ
c015dzBLUW9KYzJWMEtHMHNJREFzSURBc0Nna0pNU3dnTUN3Z01Dd2dDZ2tKTUN3Z01Td2dNQ3dn
Q2drSgpNQ3dnTUN3Z01Td2dDZ2tKTUN3Z01Dd2dNQW9KS1FvSmNtVjBkWEp1SUcwS1pXNWtDZ290
TFNCeWIzUmhkR1VnY0c5cGJuUWdlQ3g1CklHRnliM1Z1WkNCdmNtbG5hVzRnWW5rZ1lXNW5iR1Vn
WVFwbWRXNWpkR2x2YmlCeWIzUXlaQ2g0TEhrc1lTa0tDWEpsZEhWeWJpQmoKYjNNb1lTa3FlQ0F0
SUhOcGJpaGhLU3A1TENCamIzTW9ZU2txZVNBcklITnBiaWhoS1NwNENtVnVaQW9LTFMwZ1kzSmxZ
WFJsSUdFZwpkSEpoYm5ObWIzSnRZWFJwYjI0Z2JXRjBjbWw0SUhSb1lYUWdjbTkwWVhSbGN5Qmhj
bTkxYm1RZ1lTQm5hWFpsYmlCaGVHbHpJR0o1CklHRnVaMnhsQ2kwdElHRjRhWE1nYVhNZ1lTQnpk
SEpwYm1jNklDSjRJaXdnSW5raUxDQWllaUlLWm5WdVkzUnBiMjRnY205MFlYUnAKYjI1ZmJXRjBj
bWw0S0dGNGFYTXNJR0Z1WjJ4bEtRb0pDZ2t0TFNCamIyMXdiMjVsYm5RZ2IyWm1jMlYwY3lCa1pY
QmxibVFnYjI0ZwpkMmhwWTJnZ1lYaHBjeUIwYnlCeWIzUmhkR1VnWVhKdmRXNWtDZ2xzYjJOaGJD
QmtZWFFnUFNCN2VEMTdNeXcyZlN3Z2VUMTdNQ3cyCmZTd2dlajE3TUN3emZYMEtDV3h2WTJGc0lH
TXdMR014SUQwZ1pHRjBXMkY0YVhOZFd6RmRMQ0JrWVhSYllYaHBjMTFiTWwwS0NRb0oKYkc5allX
d2diU0E5SUdsa1pXNTBhWFI1WDIxaGRISnBlQ2dwQ2drS0NTMHRJSEp2ZEdGMFpTQjBhR1VnWTI5
dGNHOXVaVzUwSUhabApZM1J2Y25NZ0tHVmhZMmdnYjI1bElHbHpJR0VnWTI5c2RXMXVJR1p5YjIw
Z2NtOTNjeUF3TGk0eUtRb0pabTl5SUdOdmJIVnRiajB3CkxESWdaRzhLQ1FsdFcyTnZiSFZ0YmlB
cklHTXdYU3dnYlZ0amIyeDFiVzRnS3lCak1WMGdQU0J5YjNReVpDaHRXMk52YkhWdGJpQXIKSUdN
d1hTd2diVnRqYjJ4MWJXNGdLeUJqTVYwc0lHRnVaMnhsS1FvSlpXNWtDZ2x5WlhSMWNtNGdiUXBs
Ym1RS0NpMHRJR055WldGMApaU0JoSUdKeVlXNWphQ0FvWVNCemRHbGpheUIzYVhSb0lHMXZjbVVn
WW5KaGJtTmxjeUJ2YmlCMGFHVWdaVzVrS1FwbWRXNWpkR2x2CmJpQmljbUZ1WTJnb2VDeDVMSG9z
SUdFd0xHRXhMQ0JzWlc0c1pHVndkR2dwQ2drS0NXbG1JQ2hrWlhCMGFDQV9JRGNwSUhKbGRIVnkK
YmdvSmFXWWdLR0pwYm1SbGVDQV9QU0J3T21obGFXZG9kQ2dwS1NCeVpYUjFjbTRLQ1FvSmJHOWpZ
V3dnWkhnc1pIbzlZMjl6S0dFdwpLU3h6YVc0b1lUQXBDZ2xzYjJOaGJDQmtlVDF6YVc0b1lURXBD
Z2xzYjJOaGJDQmpZVEVnUFNCamIzTW9ZVEVwQ2dsa2VDQXFQU0JqCllURUtDV1I2SUNvOUlHTmhN
UW9KQ2dsbWIzSWdhVDB3TEd4bGJpQmtid29KQ1hBNmMyVjBLREFzSUdKcGJtUmxlQ3dnZUN3Z2VT
d2cKZWl3Z0Nna0pDVFVyS0dKcGJtUmxlQzFpYVc1a1pYaGZjM1JoY25RcEtqQXVNREF4SzNKdVpD
Z3lMalVwTENBdExTQmpiMnh2ZFhJNgpJR0poYzJWa0lHOXVJR1J2ZENCcGJtUmxlQW9KQ1FreE1q
QXdMeWhrWlhCMGFDb3lLelFwSUMwdElISmhaR2wxY3pvZ1oyVjBJSFJvCmFXNXVaWElnWVhRZ1pX
RmphQ0JrWlhCMGFBb0pDU2tLQ1FsNElDczlJR1I0SUhrZ0t6MGdaSGtnZWlBclBTQmtlZ29KQ1dK
cGJtUmwKZUNBclBTQXhDZ2xsYm1RS0NRb0pMUzBnWTNKbFlYUmxJREpfTkNCamFHbHNaSEpsYmlC
M2FYUm9JSFpoY21saGRHbHZiaUJwYmlCaQpjbUZ1WTJnZ1pHbHlaV04wYVc5dUNna3RMU0FyTUM0
d05DQjBieUJrY205dmNDQnRiM0psSUdWaFkyZ2daR1Z3ZEdnS0NXWnZjaUJwClBUQXNNU3d3TGpJ
ekszSnVaQ2d3TGpJcElHUnZDZ2tKWW5KaGJtTm9LSGdzZVN4NkxDQmhNQ3RwSzNKdVpDZ3dMakVw
TENCaE1Tc3cKTGpBMEszSnVaQ2d3TGpFcExYSnVaQ2d3TGpFcExDQnNaVzRxWW5KaGJtTm9YM0po
ZEdsdkxDQmtaWEIwYUNzeEtRb0paVzVrQ2drSwpaVzVrQ2dwbWRXNWpkR2x2YmlCZmFXNXBkQ2dw
Q2dvSmNDQTlJSFZ6WlhKa1lYUmhLQ0ptTmpRaUxDQTFMQ0JrYjNSektTQXRMU0I0CkxIa3NlaXhq
YjJ3c2NtRmthWFZ6Q2dvSmJHOWpZV3dnYVc1a1pYZ2dQU0F3Q2dsaWFXNWtaWGc5TUFvSkNna3RM
U0JuY205MWJtUUsKQ1c0Z1BTQXpNZ29KWm05eUlIb2dQU0F0Yml4dUxERWdaRzhLQ1FsbWIzSWdl
Q0E5SUMxdUxHNHNNU0JrYndvSkNRbHNiMk5oYkNCNQpJRDBnYzJsdUtIb3FZMjl6S0hndk1Ua3BM
ekV3TURBcElDc2djMmx1S0hvdk5USXBJQzBnWTI5ektIb3ZNelVwS25OcGJpaDRMemMzCktTb3lD
Z2tKQ1Fsd09uTmxkQ2d3TENCaWFXNWtaWGdzSUNCNEtqSXNJR2R5YjNWdVpGOTVJQ3NnZVNBcUlE
TWdMQ0I2S2pJc0lBb0oKQ1FrSkNYSnVaSHN4TERNc01UbDlMQW9KQ1FrSkNTMHRJR1J2ZEhNZ2RX
NWtaWElnZEhKbFpTQmhjbVVnYzIxaGJHeGxjaUIwYnlCegpkV2RuWlhOMElHRWdjMmhoWkc5M0Nn
a0pDUWtKYldsdUtESXdLeWg0S25ncmVpcDZLU293TGpjMUszSnVaQ2cxTUNrc01UWXdMWEp1ClpD
Z3hNQ2twSUFvSkNRa0pLUW9KQ1FrSlltbHVaR1Y0SUNzOUlERUtDUWtKQ1FvSkNRa3RMU0JtYkc5
M1pYSUtDUWtKYVdZZ0tISnUKWkNneE5UQXBQREVwSUhSb1pXNEtDUWtKQ1hBNmMyVjBLREFzSUdK
cGJtUmxlQ3dnZUNveUxDQm5jbTkxYm1SZmVTQXJJSGtnS2lBegpJQzB4TFhKdVpDZ3lLU3dnZWlv
eUxISnVaSHM0TERFMExEbDlMREUwTUNrS0NRa0pDV0pwYm1SbGVDczlNUW9KQ1FsbGJtUUtDUWxs
CmJtUUtDV1Z1WkFvSkNnbGlhVzVrWlhoZmMzUmhjblFnUFNCaWFXNWtaWGdLQ1FvSkxTMGdaMlZ1
WlhKaGRHVUtDWE55WVc1a0tESXoKS1NBdExTQnpkR0Z5ZENCM2FYUm9JR0VnYm1salpTQjBjbVZs
Q2dsaWNtRnVZMmdvTUN4bmNtOTFibVJmZVN3d0xDQnlibVFvS1N3dwpMakkxSzNKdVpDZ3dMakEx
S1N3Z01UQXNNQ2tLQ1hOeVlXNWtLQ2tnTFMwZ2VDQm1iM0lnY21GdVpHOXRJSFJ5WldVZ2IyWWda
SFZpCmFXOTFjeUJ4ZFdGc2FYUjVDZ2tLQ1MwdElHOXVaU0J0YjNKbElIVnpaWEprWVhSaElIUm9a
U0J6WVcxbElITnBlbVVnZFhObFpDQjMKYUdWdUlISmxibVJsY21sdVp3b0pjREVnUFNCd09tTnZj
SGtvS1FvSkNna0tDVzExYzJsaktEQXNJRE13TURBcENtVnVaQWtLQ2dvSwpablZ1WTNScGIyNGdY
MlJ5WVhjb0tRb0pZMnh6S0NrS0NXeHZZMkZzSUhkM0lEMGdNalF3TGpBS0NRb0pMUzBnWTNKbFlY
UmxJRE1nCmJXRjBjbWxqWlhNZ2RHaGhkQ0J0YjJScFpua2dkR2hsSUc5eWFXVnVkR0YwYVc5dUlH
OW1JSFJvWlNCMGNtVmxDZ2tLQ1hOd2FXNWYKWVhKdmRXNWtJRDBnY205MFlYUnBiMjVmYldGMGNt
bDRLQ0o1SWl4MGRDb3dMakExS1NBZ0lDQWdJQ0FnQ2dsMGFXeDBJQ0FnSUNBZwpJQ0E5SUhKdmRH
RjBhVzl1WDIxaGRISnBlQ2dpZUNJc01DNHdOaXRqYjNNb2RIUXFNQzR3TlNrcU1DNHdOU2tnTFMw
Z01DQjBieUJ6CmRHRjVJR1pzWVhRS0NYTm9hV1owWDNvZ0lDQWdJRDBnYVdSbGJuUnBkSGxmYldG
MGNtbDRLQ2tnYzJocFpuUmZlbHN4TVYwZ1BTQmsKYVhOMFlXNWpaU3RqYjNNb2RIUXFNQzR3TkNr
cU1UQWdDZ2tLQ1MwdElHMWhkRzExYkROa0tDa2dhWE1nZFhObFpDQjBieUJ0ZFd4MAphWEJzZVNB
emVEUWdiV0YwY21salpYTUtDUzB0SUdobGNtVWdkR2hsSURNZ2RISmhibk5tYjNKdFlYUnBiMjV6
SUhkcGJHd2dZbVVnCllYQndiR2xsWkNCbWNtOXRJR3hsWm5RZ2RHOGdjbWxuYUhRS0NTMHRJQ2gw
YUdseklHZHBkbVZ6SUhSb1pTQnpZVzFsSUhKbGMzVnMKZENCaGN5QmhjSEJzZVdsdVp5QmxZV05v
SUcxaGRISnBlQ0J6WlhCaGNtRjBaV3g1SUdsdUlIUm9aUW9KTFMwZ2FXNXVaWElnYkc5dgpjRG9n
ZGlBOUlIWTZiV0YwYlhWc00yUW9jM0JwYm1GeWIzVnVaQ2tnZGlBOUlHMWhkRzExYkROa0tIUnBi
SFFwSUdWMFl5a0tDZ2x0CklEMGdjM0JwYmw5aGNtOTFibVE2YldGMGJYVnNNMlFvZEdsc2RDazZi
V0YwYlhWc00yUW9jMmhwWm5SZmVpa0tDUW9KTFMwZ1ltRjAKWTJnZ2JXRjBiWFZzSUFvSkxTMGdk
R2hsSUd4aGMzUWdjR0Z5WVcxbGRHVnlJSFJ2SUcxaGRHMTFiRE5rS0NrZ2FYTWdkR2hsSUdobAph
V2RvZENCdlppQmxZV05vSUhKdmR5QjBhR0YwQ2drdExTQnBjeUJ3WVdOclpXUWdhVzUwYnlCd0lD
MHRJR2x1SUhSb2FYTWdZMkZ6ClpTQnBkQ0JwY3lBeElHSmxZMkYxYzJVZ2QyVWdkMkZ1ZENCMGJ5
QmhjSEJzZVFvSkxTMGdkR2hsSUcxaGRISnBlQ0IwYnlCbFlXTm8KSUhKdmR5QW9hR1ZwWjJoMElE
RXBMQ0JoYm1RZ2QzSnBkR1VnYjNWMElIUm9aU0I0ZVhvZ2RtVmpkRzl5TGdvS0NYQXhPbU52Y0hr
bwpjQ3gwY25WbEtTQXRMU0J6ZEdGeWRDQjNhWFJvSUdFZ1kyOXdlU0J2WmlCMGFHVWdiM0pwWjJs
dVlXd2daR0YwWVFvSmNEcHRZWFJ0CmRXd3paQ2h0TENCd01Td2dNU2tnTFMwZ2QzSnBkR1VnZUN4
NUxIb2dkMmwwYUNCMGNtRnVjMlp2Y20xbFpDQjJZV3gxWlhNS0NRb0oKTFMwZ2MyOXlkQ0JpZVNC
NklDaGpiM04wY3lCX05EQWxJR053ZFNBdExTQmpiM1ZzWkNCd1lYSjBhWFJwYjI0Z2MyTmxibVVn
WVc1awpJSE52Y25RZ1lua2dlSG9nWW5WamEyVjBLUW9KY0RFNmMyOXlkQ2d5TENCMGNuVmxLUW9K
Q2drdExTQmlhVzVoY25rZ2MyVmhjbU5vCklHOXVJRzVsWVhJZ1kyeHBjSEJwYm1jZ2NHeGhibVVn
Q2drdExTQW9iM0IwYVc5dVlXd2dMUzBnWTJseVkyeGxjeUIzYVhSb0lHNWwKWjJGMGFYWmxJSEpo
WkdsMWN5QmhjbVVnYm05MElHUnlZWGR1TENCemJ5QUtDUzB0SUhOcmFYQndhVzVuSUhSb2FYTWdh
WE1nZEdobApJSE5oYldVZ1lYTWdkWE5wYm1jZ2JtVmhjbDlqYkdsd1BUQXBDZ2xwWmlBb2JtVmhj
bDlqYkdsd0tTQjBhR1Z1Q2drSmFUQXNhVEVnClBTQXdMQ0J3T21obGFXZG9kQ2dwTFRFS0NRbG1i
M0lnYWoweExERTBJR1J2Q2drSkNXeHZZMkZzSUcxdElEMGdLR2t3SUNzZ2FURXAKSUZ3Z01nb0pD
UWxwWmlCd01UcG5aWFFvTWl4dGJTa2dQQ0J1WldGeVgyTnNhWEFnZEdobGJnb0pDUWtKYVRFZ1BT
QnRiUW9KQ1FsbApiSE5sQ2drSkNRbHBNQ0E5SUcxdENna0pDV1Z1WkFvSkNXVnVaQW9KWlc1a0Nn
a0tDUzB0SUdScGRtbGtaU0I0TEhrc2NpQmllU0I2CkNnbHdNVHBrYVhZb2NERXNkSEoxWlN3Z01p
d3dMREVzSUNCd01UcDNhV1IwYUNncExDQndNVHAzYVdSMGFDZ3BMQ0J3TVRwb1pXbG4KYUhRb0tT
a2dDZ2x3TVRwa2FYWW9jREVzZEhKMVpTd2dNaXd4TERFc0lDQndNVHAzYVdSMGFDZ3BMQ0J3TVRw
M2FXUjBhQ2dwTENCdwpNVHBvWldsbmFIUW9LU2tnQ2dsd01UcGthWFlvY0RFc2RISjFaU3dnTWl3
MExERXNJQ0J3TVRwM2FXUjBhQ2dwTENCd01UcDNhV1IwCmFDZ3BMQ0J3TVRwb1pXbG5hSFFvS1Nr
Z0Nna0tDUzB0SUdOdmJuWmxjblFnZEc4Z2MyTnlaV1Z1SUdOdmIzSmthVzVoZEdWek9pQnQKZFd4
MGFYQnNlU0I0TEhrZ1lua2dkM2NLQ1hBeE9tMTFiQ2gzZHl3Z2RISjFaU3dnTUN3Z01Dd2dNaXdn
SURBc0lIQXhPbmRwWkhSbwpLQ2tzSUhBeE9taGxhV2RvZENncEtRb0pDZ2t0TFNCamIzQjVJSEpo
WkdsMWN5QnBiblJ2SUhCdmMybDBhVzl1SUdWNGNHVmpkR1ZrCklHSjVJR05wY21ObWFXeHNLQ2tn
THk4Z1pXeGxiV1Z1ZENBMElDMF9JREk3SUhkeWFYUmxJRzkyWlhJZ2Vnb0pjREU2WTI5d2VTaHcK
TVN3Z2RISjFaU3dnTkN3Z01pd2dNU3dnSUhBeE9uZHBaSFJvS0Nrc0lIQXhPbmRwWkhSb0tDa3NJ
SEF4T21obGFXZG9kQ2dwS1FvSgpDZ2t0TFNCemFHbG1kQ0J6YnlCMGFHRjBJRzl5YVdkcGJpQnBj
eUJrY21GM2JpQmhkQ0JqWlc1MFpYSWdLR1ZwZEdobGNpQjNZWGtnCmQyOXlhM01wQ2kwdENYQXhP
bUZrWkNoMlpXTW9NalF3TERFek5Ta3NJSFJ5ZFdVc0lDQXdMREFzTWl3Z0lEQXNJSEF4T25kcFpI
Um8KS0Nrc0lIQXhPbWhsYVdkb2RDZ3BLU0FLQ1dOaGJXVnlZU2d0TWpRd0xDMHhNelVwQ2drS0NT
MHRJR0poZEdOb0lHUnlZWGM3SUdWaApZMmdnY205M0lHOW1JSEF4SUdseklHeHBhMlVnWVNCemFX
NW5iR1VnWTJseVkyWnBiR3dvS1NCallXeHNDZ2t0TFdOcGNtTm1hV3hzCktIQXhLU0F0TFNCa2Nt
RjNJR0ZzYkNBb2MzUnBiR3dnZDI5eWEzTWdZbVZqWVhWelpTQnViM1FnWkhKaGQyNGdkMmhsYmlC
eVlXUnAKZFhNZ1BDQXdLUW9KWTJseVkyWnBiR3dvY0RFc0lEQXNJR2t4S1NBdExTQmtjbUYzSUdW
MlpYSjVkR2hwYm1jZ1puVnlkR2hsY2lCMAphR0Z1SUc1bFlYSmZZMnhwY0FvSkNnbGpZVzFsY21F
b0tRb0pjSEpwYm5Rb2MzUnlhVzVuTG1admNtMWhkQ2dpWERBeE5HTndkVG9nCkpUTXVNMllnS0NW
a1puQnpLU0F2THlBaUxpNXRhVzRvY0Rwb1pXbG5hSFFvS1N4aWFXNWtaWGdwTGk0aUlHUnZkSE1p
TENCemRHRjAKS0RFcExDQnpkR0YwS0RjcEtTd2dNVEFzSURFd0xDQTFLUW9KY0hKcGJuUW9JbHg4
YlZ3eE5URWdkRzhnWjJWdVpYSmhkR1VpTERFMgpLUXBsYm1RS0NtWjFibU4wYVc5dUlGOTFjR1Jo
ZEdVb0tRb0pkSFFnS3owZ01TODJNQW9LQ1MwdElIQnlaWE56SUpjZ2RHOGdaMlZ1ClpYSmhkR1VL
Q1dsbUlDaGlkRzV3S0RVcEtTQjBhR1Z1Q2drSlltbHVaR1Y0SUQwZ1ltbHVaR1Y0WDNOMFlYSjBD
Z2tKWW5KaGJtTm8KS0RBc1ozSnZkVzVrWDNrc01Dd2djbTVrS0Nrc01DNHlOU3R5Ym1Rb01DNHdO
U2tzSURFd0xEQXBDZ2xsYm1RS0NRcGxibVE9Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVh
dGVkPSIyMDI1LTEwLTIwIDAzOjU3OjE1Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJd
XQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4aGRYUm9iM0k5SW5wbGNDSXNZM0psWVhSbFpE
MGlNakF5TlMwd055MHdOeUF3TWpveU1Ub3hNeUlzYlc5awphV1pwWldROUlqSXdNalV0TVRBdE1q
TWdNREE2TlRFNk16QWlMRzV2ZEdWelBTSnBibk53YVhKbFpDQmllU0JjSWxCcFkyOTBjbTl1CklG
TjBkV1ptWENJZ2RtbGtaVzljYm05dUlIbHZkWFIxWW1WY2JpSXNjbVYyYVhOcGIyNDlOaklzZEds
MGJHVTlJaUlzZG1WeWMybHYKYmowaUlsMWRiSG8wQUt3Q0FBQk5EQUFBLXpod2VIVUFBeWdBQUFR
QUJBOUFFQUlPQUFHZ0FTQUNvQTRBRHhBQURmREtBUUlETUFFUApENUFFQlFZSFFBeVFDQWtLQzBB
TWtBOE1EdzBQRGd4QURKQU5EeEZRQWdQdy13RUE2LUFibGdFUUJnODhFQUVnQVNBRkQ4c1BGQUxB
CkFoQUNEeVVRQVNBUElTQUJNQTh5a0E4aEFpQVBLRkFCRGdDQVY2QUNFQVlQTEJBdEFQQlFEUS14
RF9FQkR4d1BGUUVBRDBPZ0NpQVAKSUNBUGtpQVBheUFQTE9BSUlBOFdJQTlKRUFZTkQxVUQ4RUFD
QVE4WkJ3Z2dEM29QcWctRUQ4OFAyUS1VRDhRUHVRX2FENG9QYnc5VgpEMFVQS2c4YURBRUlJQThV
VUE4bG9BR2dEMEFGQVBBQ1d2QjhELWdLRC04UGdBLTNEdzBCOEFtdEFCRWdyUUIxQWZBQUFoQUNE
cWdBCm5VRHd3dzhvRC0td3hqRUFIdzR3QVAtLS0tLS1qUi0tQVFDczhRLUlEMEFBRFVBUEstLS1G
dzgwLS04SEFQUVhBUFFIRHZRWER2UUgKOEhBZEFQTUZkQTh0OUJrUE1QUUZBUFFaQVBRRkR2UVpE
c1FiQUhqVUR5ajBHUTh5R3dBVFpCc0F4ZlFRRHpmMEx3RDBMdzcwRDBrQQpZeGowRnc5STlHVUE4
Z0lQT1BRWER4Z2tZRVR3Skc5ejhDbHVRRGdBOUF3QUR5VDBFdzlEOUFzQTlCTUE5QXNQS1BRVERx
VHdKQTg4CjhEdFpBQkZCV1FEekR3MzBELUFSUDNid0R5TVZCdzhKRGZBRkFnOHlEMFlQUnc5UUQy
RHdDWElBZ1ItMER3OUE5QThBQXdCUUNmUVAKRHhqWUFCQUpTQUFVRWtnQThnVXA5QXJ3RWc4OEwz
Ti1MZkFrQVM1LUJQQUNDWW9BRXl0cEFCTWZNd0IwQkE4dDlCTVBQSndBOFFBTgo5Qk11UlBBb0N4
OXo4QzBGSFVBakFCT3dLd0F6Q1E4MS13QVZGajBBRXpJU0FCSWJFZ0R5RDhRUE42UVBSWlFQUThR
TDlBb0FwQUNVCkFNUUE5QW9PcEE2VURzUU94Q1FBTXhRUE9UVUFFaTBSQURGMER5WVJBRUlQR1BR
bkVnQkQ5QWdQTGFnQS13TVg4QnZ2Sy1BaEFnTVAKQkFVV1p3VU04UDhCQVAtVFVQLS0tLS1RCjo6
IFtlb2NdCg==
:: bios/fonts/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: bios/fonts/lil.font
b64$LS1bW3BvZF1ddXNlcmRhdGEoInU4IiwyMDQ4LCJoZXg6MDUwOTBiMDAwMDAzMDAwMDAwMDAw
MDAwMDAwMTAwMDAwMDEwMDAwMDAwMDAwMDA3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNzAwMDEw
MDAwMDAwMDExMDAwMDAwMDAwMDAwMDAwMDA3MDAwMTcwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDBmMGYwZjBmMGYwZjBmMDAwMDAwMGYwZjBmMDAwMDAwMDAwMDBmMDkwZjAwMDAwMDAw
MDAwOTA2MDkwMDAwMDAwMDAwMDkwMDA5MDAwMDAwMDAwMDA5MDkwOTAwMDAwMDAwMGMwZTBmMGUw
YzAwMDAwMDAzMDcwZjA3MDMwMDAwMDcwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDgwODBlMDAxMTFi
MGUxZjA0MWYwNDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwNjBjMDAwMDAwMDAwMDAwMDYw
NjAwMDUwNTAwMDAwMDAwMDAwMDA2MDkwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAy
MDIwMjAwMDIwMDA1MDUwMDAwMDAwMDAwMDAwMDAwMGExZjBhMWYwYTAwMDAwNDBlMDEwNjA4MDcw
NDAwMDAwOTA0MDIwOTAwMDAwMDAyMDUwMjBiMDUwYTAwMDQwNDAwMDAwMDAwMDAwMDA0MDIwMjAy
MDIwMjAyMDQwMjA0MDQwNDA0MDQwNDAyMDAwMDA1MDIwNzAyMDUwMDAwMDAwMDA0MGUwNDAwMDAw
MDAwMDAwMDAwMDAwNDAyMDAwMDAwMDAwZjAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDA0MDQwMjAy
MDEwMTAwMDYwOTBkMGIwOTA5MDYwMDA0MDYwNDA0MDQwNDBlMDAwNjA5MDgwNDAyMDEwZjAwMDYw
OTA4MDYwODA5MDYwMDA0MDYwNTA1MGYwNDA0MDAwZjAxMDEwNzA4MDgwNzAwMDYwMTAxMDcwOTA5
MDYwMDBmMDgwODA0MDIwMjAyMDAwNjA5MDkwNjA5MDkwNjAwMDYwOTA5MGUwODA4MDYwMDAwMDAw
MDAyMDAwMjAwMDAwMDAwMDAwNDAwMDQwMjAwMDAwMDA0MDIwMTAyMDQwMDAwMDAwMDBmMDAwZjAw
MDAwMDAwMDIwNDA4MDQwMjAwMDYwOTA4MDQwMjAwMDIwMDAwMGUwOTBkMGQwMTBlMDAwNjA5MDkw
ZjA5MDkwOTAwMDcwOTA5MDcwOTA5MDcwMDA2MDkwMTAxMDEwOTA2MDAwNzA5MDkwOTA5MDkwNzAw
MGYwMTAxMDcwMTAxMGYwMDBmMDEwMTA3MDEwMTAxMDAwZTAxMDEwZDA5MDkwZTAwMDkwOTA5MGYw
OTA5MDkwMDA3MDIwMjAyMDIwMjA3MDAwZTA4MDgwODA4MDkwNjAwMDkwOTA1MDMwNTA5MDkwMDAx
MDEwMTAxMDEwMTBmMDAxMTFiMTUxNTExMTExMTAwMDkwYjBkMDkwOTA5MDkwMDA2MDkwOTA5MDkw
OTA2MDAwNzA5MDkwNzAxMDEwMTAwMDYwOTA5MDkwOTBiMDYwYzA3MDkwOTA3MDkwOTA5MDAwNjA5
MDEwNjA4MDkwNjAwMWYwNDA0MDQwNDA0MDQwMDA5MDkwOTA5MDkwOTBlMDAwOTA5MDkwOTA5MDUw
MzAwMTExMTExMTUxNTFiMTEwMDA5MDkwOTA2MDkwOTA5MDAwOTA5MDkwZTA4MDgwNzAwMGYwODA0
MDIwMTAxMGYwMDA3MDEwMTAxMDEwMTAxMDcwMDAxMDEwMjAyMDQwNDAwMGUwODA4MDgwODA4MDgw
ZTAyMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjAwMDIwNDAwMDAwMDAwMDAwMDAwMDAwNjA4
MGUwOTBlMDAwMTAxMDcwOTA5MDkwNzAwMDAwMDBlMDEwMTAxMGUwMDA4MDgwZTA5MDkwOTBlMDAw
MDAwMDYwOTBmMDEwZTAwMGMwMjAyMGYwMjAyMDIwMDAwMDAwZTA5MDkwZTA4MDYwMTAxMDcwOTA5
MDkwOTAwMDIwMDAzMDIwMjAyMDcwMDA4MDAwYzA4MDgwODA5MDYwMTAxMDkwNTAzMDUwOTAwMDMw
MjAyMDIwMjAyMDYwMDAwMDAwYjE1MTUxMTExMDAwMDAwMDcwOTA5MDkwOTAwMDAwMDA2MDkwOTA5
MDYwMDAwMDAwNzA5MDkwNzAxMDEwMDAwMGUwOTA5MGUwODA4MDAwMDBkMDMwMTAxMDEwMDAwMDAw
ZTAxMDYwODA3MDAwMjAyMGYwMjAyMDIwYzAwMDAwMDA5MDkwOTA5MGUwMDAwMDAwOTA5MDkwNTAz
MDAwMDAwMTExMTE1MTUwYTAwMDAwMDA5MDkwNjA5MDkwMDAwMDAwOTA5MDkwZTA4MDYwMDAwMGYw
ODA2MDEwZjAwMDYwMjAyMDEwMjAyMDIwNjAwMDIwMjAyMDAwMjAyMDIwNjA0MDQwODA0MDQwNDA2
MDAwYTA1MDAwMDAwMDAwMDAwMDMwMzBjMGMwMDAwMDA3ZjdmN2Y3ZjdmN2Y3ZjAwNTUyYTU1MmE1
NTJhNTUwMDQxNjM3ZjVkNWQ3NzNlMDAzZTYzNjM3NzNlNDEzZTAwMTE0NDExNDQxMTQ0MTEwMDA0
MGM3YzNlMWYxODEwMDAxYzI2NWY1ZjdmM2UxYzAwMjI3NzdmN2YzZTFjMDgwMDJhMWMzNjc3MzYx
YzJhMDAxYzFjM2U1ZDFjMTQxNDAwMDgxYzNlN2YzZTJhM2EwMDNlNjc2MzY3M2U0MTNlMDAzZTdm
NWQ1ZDdmNjMzZTAwMTg3ODA4MDgwODBmMDcwMDNlNjM2YjYzM2U0MTNlMDAwODE0MmE1ZDJhMTQw
ODAwMDAwMDAwNTUwMDAwMDAwMDNlNzM2MzczM2U0MTNlMDAwODFjN2YxYzM2MjIwMDAwN2YyMjE0
MDgxNDIyN2YwMDNlNzc2MzYzM2U0MTNlMDAwMDBhMDQwMDUwMjAwMDAwMTEyYTQ0MDAxMTJhNDQw
MDNlNmI3NzZiM2U0MTNlMDA3ZjAwN2YwMDdmMDA3ZjAwNTU1NTU1NTU1NTU1NTUwMDA0MWYwNDNl
NTU0ZDI2MDAwMDIyNDI0MjQyMGEwNDAwMTgwMDNlNDA0MDIwMWMwMDFjMDAzZjA4MDQ0ZTMzMDAw
NDVmODQzZTQ1NDUyNjAwNDI5ZmEyMjIyMjI5MzEwMDA4M2UxMDdjMjAwMTBlMDA0MDMwMGMwMjBj
MzA0MDAwMTExMTdkMTExMTExMGEwMDAwM2UwMDAwMDAwMTdlMDAwODA4N2UxMDIwMDEwZTAwMDIw
MjAyMDI0MjIyMWMwMDA4N2YwYzBhMGMwODA0MDAyMjIyN2YyMjMyMDIzYzAwM2MxMDA4ZmUxMDA4
MzAwMDA0MWYwNGU0MDQxMmUyMDAwNDNmMDQzNDRjNDAzZjAwMDAzYzQzNDA0MDIwMWUwMDdmMDgw
NDA0MDQwODMwMDAxMDEwNzgwNDAyMDI3YzAwMDQ2ZjA0MjQyNDcyYjIwMDAxM2QwMTAxMDU3OTAy
MDAwODA5MDkzZTRiZWQ2ZTAwMDIwMjNiNDY0MmUzNjIwMDAwM2M1MjkxODk4OTQ2MDAxMTExN2Qx
MTExMzk1ZDAwMDAxMzEyMzE1MTExMGUwMDE4MTAwMDA4MTA1Mjg5MDAwMDBjMTIyMTQwODAwMDAw
N2QxMTdkMTExMTM5NWQwMDNlMDgzZTA4MGUzOTRmMDAwODA0MjQ3ZTI2MjAxMDAwMjQ0ZTA0MDYw
NTQ2MzgwMDEyMTI3Yzk2OGE0NDMwMDAwODFlMDQxZTQ0NDQzODAwMDAxMjdmNDIzMjA0MDQwMDEw
M2Q1MzUzNTEzZDA4MDAwODA4MzgwODBjMWE2YzAwMGMwMDAyM2E0NjQwM2MwMDIwMjIyMjIyMjYy
MDE4MDAzZTE4M2M0NjQxNGMzYzAwMDIwMjNiNDY0MjQzYzIwMDNlMTgzYzQ2NDEyMDE4MDAwMjAy
M2I0NjQyMjMxYTAwMDcwMjZlMTkxNDAyM2MwMDA0MDQwMjBlMTI5MTcxMDAwMDAwMzg0NjQwMjAx
ODAwMDAwMDE0M2UyNDA4MDgwMDAwMDAzYTU2NTIzMDA4MDAwMDAwMDgzODA4M2MwYzAwN2Y0MDI0
MTQwNDAyMDEwMDIwMTAwYzBiMDgwODA4MDAwODdmNDE0MTIwMTAwYzAwM2UwODA4MDgwODA4N2Yw
MDIwMjBmZTMwMjgyNjMwMDAwNDdmNDQ0NDQyNDI3MTAwMDQzZjA4MDg3ZTEwMTAwMDA0N2M0MjQx
MjAxMDBjMDAwNDdjMTIxMTEwMDgwODAwM2YyMDIwMjAyMDNmMjAwMDIyMjI3ZjIyMjIxMDA4MDAw
NjA4MDE0NjQwMjAxZjAwN2Y0MDQwMjAzMDRjODMwMDA0NzQ0ZjI0MDQwNDc4MDA0MTQxNDIyMDIw
MTAwZTAwMDQ3YzQyNDkzMDUwMGMwMDM4MGUwODdmMDgwODA0MDA0NTQ5NGE0MDIwMTAwZTAwM2Uw
MDdmMDgwODA4MDQwMDAyMDIwZTMyMDIwMjAyMDAwODA4N2YwODA4MDgwNDAwMDAzZTAwMDAwMDdm
MDAwMDdmNDA0NDI4MTAyYzAzMDAwODdlNDAzMDBjMmE0OTAwMjAyMDIwMTAxMDA4MDcwMDE0MTQy
NDIyMjI0MTQxMDAwMTAxMTkwNzAxMDExZTAwN2Y0MDQwNDAyMDEwMGMwMDAwMGMxMjIxNDAwMDAw
MDAwODdmMDgyYTJhNDkwYzAwN2Y0MDQwMjIxNDA4MTAwMDFlNjAwNjM4MDAwNzc4MDAwODA4MDQw
NDQyNzI4ZjAwNDA0MDQ0MjgxMDI4NDcwMDNmMDQwNDdmMDQwNDM4MDA3MjRmMjIxMjA0MDQwNDAw
MDAzZTIwMjAxMDEwN2YwMDdmNDA0MDdlNDA0MDdmMDAzZTAwN2Y0MDQwMjAxYzAwMjIyMjIyMjIy
MDEwMGMwMDE0MTQxNDE0MTQ1MjMxMDAwMTAxMDEwMTQxMzEwZjAwN2Y0MTQxNDE0MTdmNDEwMDdm
NDE0MTQwMjAxMDBjMDA3ZjQwNDA3YzIwMTAwYzAwMDEwNjQwNDAyMDEwMGYwMDAwMDAwMDJhMjAx
MDBjMDAwMDAwMDQzZTI0MDQwNDAwMDAwMDAwMWMxMDEwM2UwMDAwMDAxZTEwMWUxMDFlMDAwODA4
MDQ2MzEwMDgwODAwMDgwODEwNjMwNDA4MDgwMCIp
:: bios/fonts/lil_mono.font
b64$LS1bW3BvZF1ddXNlcmRhdGEoInU4IiwyMDQ4LCJoZXg6MDUwYTBiMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDBmMGYwZjBmMGYwZjBmMDAwMDAwMGYwZjBmMDAwMDAwMDAwMDBmMDkwZjAwMDAwMDAw
MDAwOTA2MDkwMDAwMDAwMDAwMDkwMDA5MDAwMDAwMDAwMDA5MDkwOTAwMDAwMDAwMGMwZTBmMGUw
YzAwMDAwMDAzMDcwZjA3MDMwMDAwMDcwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDgwODBlMDAxMTFi
MGUxZjA0MWYwNDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwNjBjMDAwMDAwMDAwMDAwMDYw
NjAwMDUwNTAwMDAwMDAwMDAwMDA2MDkwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAy
MDIwMjAwMDIwMDA1MDUwMDAwMDAwMDAwMDAwMDAwMGEwZjBhMGYwYTAwMDAwNDBlMDEwNjA4MDcw
NDAwMDAwOTA0MDIwOTAwMDAwMDAyMDUwMjBiMDUwYTAwMDQwNDAwMDAwMDAwMDAwMDA0MDIwMjAy
MDIwMjAyMDQwMjA0MDQwNDA0MDQwNDAyMDAwMDA1MDIwNzAyMDUwMDAwMDAwMDA0MGUwNDAwMDAw
MDAwMDAwMDAwMDAwNDAyMDAwMDAwMDAwZjAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDA0MDQwMjAy
MDEwMTAwMDYwOTBkMGIwOTA5MDYwMDA0MDYwNDA0MDQwNDBlMDAwNjA5MDgwNDAyMDEwZjAwMDYw
OTA4MDYwODA5MDYwMDA0MDYwNTA1MGYwNDA0MDAwZjAxMDEwNzA4MDgwNzAwMDYwMTAxMDcwOTA5
MDYwMDBmMDgwODA0MDIwMjAyMDAwNjA5MDkwNjA5MDkwNjAwMDYwOTA5MGUwODA4MDYwMDAwMDAw
MDAyMDAwMjAwMDAwMDAwMDAwNDAwMDQwMjAwMDAwMDA0MDIwMTAyMDQwMDAwMDAwMDBmMDAwZjAw
MDAwMDAwMDIwNDA4MDQwMjAwMDYwOTA4MDQwMjAwMDIwMDAwMGUwOTBkMGQwMTBlMDAwNjA5MDkw
ZjA5MDkwOTAwMDcwOTA5MDcwOTA5MDcwMDA2MDkwMTAxMDEwOTA2MDAwNzA5MDkwOTA5MDkwNzAw
MGYwMTAxMDcwMTAxMGYwMDBmMDEwMTA3MDEwMTAxMDAwZTAxMDEwZDA5MDkwZTAwMDkwOTA5MGYw
OTA5MDkwMDA3MDIwMjAyMDIwMjA3MDAwZTA4MDgwODA4MDkwNjAwMDkwOTA1MDMwNTA5MDkwMDAx
MDEwMTAxMDEwMTBmMDAwOTBmMGYwOTA5MDkwOTAwMDkwYjBkMDkwOTA5MDkwMDA2MDkwOTA5MDkw
OTA2MDAwNzA5MDkwNzAxMDEwMTAwMDYwOTA5MDkwOTBiMDYwYzA3MDkwOTA3MDkwOTA5MDAwNjA5
MDEwNjA4MDkwNjAwMGYwNDA0MDQwNDA0MDQwMDA5MDkwOTA5MDkwOTBlMDAwOTA5MDkwOTA5MDUw
MzAwMDkwOTA5MDkwZjBmMDkwMDA5MDkwOTA2MDkwOTA5MDAwOTA5MDkwZTA4MDgwNzAwMGYwODA0
MDIwMTAxMGYwMDA3MDEwMTAxMDEwMTAxMDcwMDAxMDEwMjAyMDQwNDAwMGUwODA4MDgwODA4MDgw
ZTAyMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjAwMDIwNDAwMDAwMDAwMDAwMDAwMDAwNjA4
MGUwOTBlMDAwMTAxMDcwOTA5MDkwNzAwMDAwMDBlMDEwMTAxMGUwMDA4MDgwZTA5MDkwOTBlMDAw
MDAwMDYwOTBmMDEwZTAwMGMwMjAyMGYwMjAyMDIwMDAwMDAwZTA5MDkwZTA4MDYwMTAxMDcwOTA5
MDkwOTAwMDQwMDA2MDQwNDA0MGUwMDA4MDAwYzA4MDgwODA5MDYwMTAxMDkwNTAzMDUwOTAwMDYw
NDA0MDQwNDA0MGMwMDAwMDAwZjBmMDkwOTA5MDAwMDAwMDcwOTA5MDkwOTAwMDAwMDA2MDkwOTA5
MDYwMDAwMDAwNzA5MDkwNzAxMDEwMDAwMGUwOTA5MGUwODA4MDAwMDBkMDMwMTAxMDEwMDAwMDAw
ZTAxMDYwODA3MDAwMjAyMGYwMjAyMDIwYzAwMDAwMDA5MDkwOTA5MGUwMDAwMDAwOTA5MDkwNTAz
MDAwMDAwMDkwOTA5MGYwZjAwMDAwMDA5MDkwNjA5MDkwMDAwMDAwOTA5MDkwZTA4MDYwMDAwMGYw
ODA2MDEwZjAwMDYwMjAyMDEwMjAyMDIwNjAwMDIwMjAyMDAwMjAyMDIwNjA0MDQwODA0MDQwNDA2
MDAwYTA1MDAwMDAwMDAwMDAwMDMwMzBjMGMwMDAwMDA3ZjdmN2Y3ZjdmN2Y3ZjAwNTUyYTU1MmE1
NTJhNTUwMDQxNjM3ZjVkNWQ3NzNlMDAzZTYzNjM3NzNlNDEzZTAwMTE0NDExNDQxMTQ0MTEwMDA0
MGM3YzNlMWYxODEwMDAxYzI2NWY1ZjdmM2UxYzAwMjI3NzdmN2YzZTFjMDgwMDJhMWMzNjc3MzYx
YzJhMDAxYzFjM2U1ZDFjMTQxNDAwMDgxYzNlN2YzZTJhM2EwMDNlNjc2MzY3M2U0MTNlMDAzZTdm
NWQ1ZDdmNjMzZTAwMTg3ODA4MDgwODBmMDcwMDNlNjM2YjYzM2U0MTNlMDAwODE0MmE1ZDJhMTQw
ODAwMDAwMDAwNTUwMDAwMDAwMDNlNzM2MzczM2U0MTNlMDAwODFjN2YxYzM2MjIwMDAwN2YyMjE0
MDgxNDIyN2YwMDNlNzc2MzYzM2U0MTNlMDAwMDBhMDQwMDUwMjAwMDAwMTEyYTQ0MDAxMTJhNDQw
MDNlNmI3NzZiM2U0MTNlMDA3ZjAwN2YwMDdmMDA3ZjAwNTU1NTU1NTU1NTU1NTUwMDA0MWYwNDNl
NTU0ZDI2MDAwMDIyNDI0MjQyMGEwNDAwMTgwMDNlNDA0MDIwMWMwMDFjMDAzZjA4MDQ0ZTMzMDAw
NDVmODQzZTQ1NDUyNjAwNDI5ZmEyMjIyMjI5MzEwMDA4M2UxMDdjMjAwMTBlMDA0MDMwMGMwMjBj
MzA0MDAwMTExMTdkMTExMTExMGEwMDAwM2UwMDAwMDAwMTdlMDAwODA4N2UxMDIwMDEwZTAwMDIw
MjAyMDI0MjIyMWMwMDA4N2YwYzBhMGMwODA0MDAyMjIyN2YyMjMyMDIzYzAwM2MxMDA4ZmUxMDA4
MzAwMDA0MWYwNGU0MDQxMmUyMDAwNDNmMDQzNDRjNDAzZjAwMDAzYzQzNDA0MDIwMWUwMDdmMDgw
NDA0MDQwODMwMDAxMDEwNzgwNDAyMDI3YzAwMDQ2ZjA0MjQyNDcyYjIwMDAxM2QwMTAxMDU3OTAy
MDAwODA5MDkzZTRiZWQ2ZTAwMDIwMjNiNDY0MmUzNjIwMDAwM2M1MjkxODk4OTQ2MDAxMTExN2Qx
MTExMzk1ZDAwMDAxMzEyMzE1MTExMGUwMDE4MTAwMDA4MTA1Mjg5MDAwMDBjMTIyMTQwODAwMDAw
N2QxMTdkMTExMTM5NWQwMDNlMDgzZTA4MGUzOTRmMDAwODA0MjQ3ZTI2MjAxMDAwMjQ0ZTA0MDYw
NTQ2MzgwMDEyMTI3Yzk2OGE0NDMwMDAwODFlMDQxZTQ0NDQzODAwMDAxMjdmNDIzMjA0MDQwMDEw
M2Q1MzUzNTEzZDA4MDAwODA4MzgwODBjMWE2YzAwMGMwMDAyM2E0NjQwM2MwMDIwMjIyMjIyMjYy
MDE4MDAzZTE4M2M0NjQxNGMzYzAwMDIwMjNiNDY0MjQzYzIwMDNlMTgzYzQ2NDEyMDE4MDAwMjAy
M2I0NjQyMjMxYTAwMDcwMjZlMTkxNDAyM2MwMDA0MDQwMjBlMTI5MTcxMDAwMDAwMzg0NjQwMjAx
ODAwMDAwMDE0M2UyNDA4MDgwMDAwMDAzYTU2NTIzMDA4MDAwMDAwMDgzODA4M2MwYzAwN2Y0MDI0
MTQwNDAyMDEwMDIwMTAwYzBiMDgwODA4MDAwODdmNDE0MTIwMTAwYzAwM2UwODA4MDgwODA4N2Yw
MDIwMjBmZTMwMjgyNjMwMDAwNDdmNDQ0NDQyNDI3MTAwMDQzZjA4MDg3ZTEwMTAwMDA0N2M0MjQx
MjAxMDBjMDAwNDdjMTIxMTEwMDgwODAwM2YyMDIwMjAyMDNmMjAwMDIyMjI3ZjIyMjIxMDA4MDAw
NjA4MDE0NjQwMjAxZjAwN2Y0MDQwMjAzMDRjODMwMDA0NzQ0ZjI0MDQwNDc4MDA0MTQxNDIyMDIw
MTAwZTAwMDQ3YzQyNDkzMDUwMGMwMDM4MGUwODdmMDgwODA0MDA0NTQ5NGE0MDIwMTAwZTAwM2Uw
MDdmMDgwODA4MDQwMDAyMDIwZTMyMDIwMjAyMDAwODA4N2YwODA4MDgwNDAwMDAzZTAwMDAwMDdm
MDAwMDdmNDA0NDI4MTAyYzAzMDAwODdlNDAzMDBjMmE0OTAwMjAyMDIwMTAxMDA4MDcwMDE0MTQy
NDIyMjI0MTQxMDAwMTAxMTkwNzAxMDExZTAwN2Y0MDQwNDAyMDEwMGMwMDAwMGMxMjIxNDAwMDAw
MDAwODdmMDgyYTJhNDkwYzAwN2Y0MDQwMjIxNDA4MTAwMDFlNjAwNjM4MDAwNzc4MDAwODA4MDQw
NDQyNzI4ZjAwNDA0MDQ0MjgxMDI4NDcwMDNmMDQwNDdmMDQwNDM4MDA3MjRmMjIxMjA0MDQwNDAw
MDAzZTIwMjAxMDEwN2YwMDdmNDA0MDdlNDA0MDdmMDAzZTAwN2Y0MDQwMjAxYzAwMjIyMjIyMjIy
MDEwMGMwMDE0MTQxNDE0MTQ1MjMxMDAwMTAxMDEwMTQxMzEwZjAwN2Y0MTQxNDE0MTdmNDEwMDdm
NDE0MTQwMjAxMDBjMDA3ZjQwNDA3YzIwMTAwYzAwMDEwNjQwNDAyMDEwMGYwMDAwMDAwMDJhMjAx
MDBjMDAwMDAwMDQzZTI0MDQwNDAwMDAwMDAwMWMxMDEwM2UwMDAwMDAxZTEwMWUxMDFlMDAwODA4
MDQ2MzEwMDgwODAwMDgwODEwNjMwNDA4MDgwMCIp
:: bios/fonts/p8.font
b64$LS1bW3BvZF1ddXNlcmRhdGEoInU4IiwyMDQ4LCJoZXg6MDQwODA2MDAwMDAzMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDA3MDcwNzA3MDcwMDAwMDAwMDA3MDcwNzAwMDAwMDAwMDAwNzA1MDcwMDAwMDAwMDAw
MDUwMjA1MDAwMDAwMDAwMDA1MDAwNTAwMDAwMDAwMDAwNTA1MDUwMDAwMDAwMDA0MDYwNzA2MDQw
MDAwMDAwMTAzMDcwMzAxMDAwMDAwMDcwMTAxMDEwMDAwMDAwMDAwMDQwNDA0MDcwMDAwMDAwNTA3
MDIwNzAyMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAxMDIwMDAwMDAwMDAwMDAwMzAzMDAw
MDAwMDUwNTAwMDAwMDAwMDAwMDAyMDUwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAy
MDAwMjAwMDAwMDA1MDUwMDAwMDAwMDAwMDAwNTA3MDUwNzA1MDAwMDAwMDcwMzA2MDcwMjAwMDAw
MDA1MDQwMjAxMDUwMDAwMDAwMzAzMDYwNTA3MDAwMDAwMDIwMTAwMDAwMDAwMDAwMDAyMDEwMTAx
MDIwMDAwMDAwMjA0MDQwNDAyMDAwMDAwMDUwMjA3MDIwNTAwMDAwMDAwMDIwNzAyMDAwMDAwMDAw
MDAwMDAwMjAxMDAwMDAwMDAwMDA3MDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwNDAyMDIwMjAx
MDAwMDAwMDcwNTA1MDUwNzAwMDAwMDAzMDIwMjAyMDcwMDAwMDAwNzA0MDcwMTA3MDAwMDAwMDcw
NDA2MDQwNzAwMDAwMDA1MDUwNzA0MDQwMDAwMDAwNzAxMDcwNDA3MDAwMDAwMDEwMTA3MDUwNzAw
MDAwMDA3MDQwNDA0MDQwMDAwMDAwNzA1MDcwNTA3MDAwMDAwMDcwNTA3MDQwNDAwMDAwMDAwMDIw
MDAyMDAwMDAwMDAwMDAyMDAwMjAxMDAwMDAwMDQwMjAxMDIwNDAwMDAwMDAwMDcwMDA3MDAwMDAw
MDAwMTAyMDQwMjAxMDAwMDAwMDcwNDA2MDAwMjAwMDAwMDAyMDUwNTAxMDYwMDAwMDAwMDA2MDUw
NzA1MDAwMDAwMDAwMzAzMDUwNzAwMDAwMDAwMDYwMTAxMDYwMDAwMDAwMDAzMDUwNTAzMDAwMDAw
MDAwNzAzMDEwNjAwMDAwMDAwMDcwMzAxMDEwMDAwMDAwMDA2MDEwNTA3MDAwMDAwMDAwNTA1MDcw
NTAwMDAwMDAwMDcwMjAyMDcwMDAwMDAwMDA3MDIwMjAzMDAwMDAwMDAwNTAzMDUwNTAwMDAwMDAw
MDEwMTAxMDYwMDAwMDAwMDA3MDcwNTA1MDAwMDAwMDAwMzA1MDUwNTAwMDAwMDAwMDYwNTA1MDMw
MDAwMDAwMDA2MDUwNzAxMDAwMDAwMDAwMjA1MDMwNjAwMDAwMDAwMDMwNTAzMDUwMDAwMDAwMDA2
MDEwNDAzMDAwMDAwMDAwNzAyMDIwMjAwMDAwMDAwMDUwNTA1MDYwMDAwMDAwMDA1MDUwNzAyMDAw
MDAwMDAwNTA1MDcwNzAwMDAwMDAwMDUwMjAyMDUwMDAwMDAwMDA1MDcwNDAzMDAwMDAwMDAwNzA0
MDEwNzAwMDAwMDAzMDEwMTAxMDMwMDAwMDAwMTAyMDIwMjA0MDAwMDAwMDYwNDA0MDQwNjAwMDAw
MDAyMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDA3MDAwMDAwMDIwNDAwMDAwMDAwMDAwMDA3MDUwNzA1
MDUwMDAwMDAwNzA1MDMwNTA3MDAwMDAwMDYwMTAxMDEwNjAwMDAwMDAzMDUwNTA1MDcwMDAwMDAw
NzAxMDMwMTA3MDAwMDAwMDcwMTAzMDEwMTAwMDAwMDA2MDEwMTA1MDcwMDAwMDAwNTA1MDcwNTA1
MDAwMDAwMDcwMjAyMDIwNzAwMDAwMDA3MDIwMjAyMDMwMDAwMDAwNTA1MDMwNTA1MDAwMDAwMDEw
MTAxMDEwNzAwMDAwMDA3MDcwNTA1MDUwMDAwMDAwMzA1MDUwNTA1MDAwMDAwMDYwNTA1MDUwMzAw
MDAwMDA3MDUwNzAxMDEwMDAwMDAwMjA1MDUwMzA2MDAwMDAwMDcwNTAzMDUwNTAwMDAwMDA2MDEw
NzA0MDMwMDAwMDAwNzAyMDIwMjAyMDAwMDAwMDUwNTA1MDUwNjAwMDAwMDA1MDUwNTA3MDIwMDAw
MDAwNTA1MDUwNzA3MDAwMDAwMDUwNTAyMDUwNTAwMDAwMDA1MDUwNzA0MDcwMDAwMDAwNzA0MDIw
MTA3MDAwMDAwMDYwMjAzMDIwNjAwMDAwMDAyMDIwMjAyMDIwMDAwMDAwMzAyMDYwMjAzMDAwMDAw
MDAwNDA3MDEwMDAwMDAwMDAwMDIwNTAyMDAwMDAwMDA3ZjdmN2Y3ZjdmMDAwMDAwNTUyYTU1MmE1
NTAwMDAwMDQxN2Y1ZDVkM2UwMDAwMDAzZTYzNjM3NzNlMDAwMDAwMTE0NDExNDQxMTAwMDAwMDA0
M2MxYzFlMTAwMDAwMDAxYzJlM2UzZTFjMDAwMDAwMzYzZTNlMWMwODAwMDAwMDFjMzY3NzM2MWMw
MDAwMDAxYzFjM2UxYzE0MDAwMDAwMWMzZTdmMmEzYTAwMDAwMDNlNjc2MzY3M2UwMDAwMDA3ZjVk
N2Y0MTdmMDAwMDAwMzgwODA4MGUwZTAwMDAwMDNlNjM2YjYzM2UwMDAwMDAwODFjM2UxYzA4MDAw
MDAwMDAwMDU1MDAwMDAwMDAwMDNlNzM2MzczM2UwMDAwMDAwODFjN2YzZTIyMDAwMDAwM2UxYzA4
MWMzZTAwMDAwMDNlNzc2MzYzM2UwMDAwMDAwMDA1NTIyMDAwMDAwMDAwMDAxMTJhNDQwMDAwMDAw
MDNlNmI3NzZiM2UwMDAwMDA3ZjAwN2YwMDdmMDAwMDAwNTU1NTU1NTU1NTAwMDAwMDBlMDQxZTJk
MjYwMDAwMDAxMTIxMjEyNTAyMDAwMDAwMGMxZTIwMjAxYzAwMDAwMDA4MWUwODI0MWEwMDAwMDA0
ZTA0M2U0NTI2MDAwMDAwMjI1ZjEyMTIwYTAwMDAwMDFlMDgzYzExMDYwMDAwMDAxMDBjMDIwYzEw
MDAwMDAwMjI3YTIyMjIxMjAwMDAwMDFlMjAwMDAyM2MwMDAwMDAwODNjMTAwMjBjMDAwMDAwMDIw
MjAyMjIxYzAwMDAwMDA4M2UwODBjMDgwMDAwMDAxMjNmMTIwMjFjMDAwMDAwM2MxMDdlMDQzODAw
MDAwMDAyMDczMjAyMzIwMDAwMDAwZjAyMGUxMDFjMDAwMDAwM2U0MDQwMjAxODAwMDAwMDNlMTAw
ODA4MTAwMDAwMDAwODM4MDQwMjNjMDAwMDAwMzIwNzEyNzgxODAwMDAwMDdhNDIwMjBhNzIwMDAw
MDAwOTNlNGI2ZDY2MDAwMDAwMWEyNzIyNzMzMjAwMDAwMDNjNGE0OTQ5NDYwMDAwMDAxMjNhMTIz
YTFhMDAwMDAwMjM2MjIyMjIxYzAwMDAwMDBjMDAwODJhNGQwMDAwMDAwMDBjMTIyMTQwMDAwMDAw
N2Q3OTExM2Q1ZDAwMDAwMDNlM2MwODFlMmUwMDAwMDAwNjI0N2UyNjEwMDAwMDAwMjQ0ZTA0NDYz
YzAwMDAwMDBhM2M1YTQ2MzAwMDAwMDAxZTA0MWU0NDM4MDAwMDAwMTQzZTI0MDgwODAwMDAwMDNh
NTY1MjMwMDgwMDAwMDAwNDFjMDQxZTA2MDAwMDAwMDgwMjNlMjAxYzAwMDAwMDIyMjIyNjIwMTgw
MDAwMDAzZTE4MjQ3MjMwMDAwMDAwMDQzNjJjMjY2NDAwMDAwMDNlMTgyNDQyMzAwMDAwMDAxYTI3
MjIyMzEyMDAwMDAwMGU2NDFjMjg3ODAwMDAwMDA0MDIwNjJiMTkwMDAwMDAwMDAwMGUxMDA4MDAw
MDAwMDAwYTFmMTIwNDAwMDAwMDAwMDQwZjE1MGQwMDAwMDAwMDA0MGMwNjBlMDAwMDAwM2UyMDE0
MDQwMjAwMDAwMDMwMDgwZTA4MDgwMDAwMDAwODNlMjIyMDE4MDAwMDAwM2UwODA4MDgzZTAwMDAw
MDEwN2UxODE0MTIwMDAwMDAwNDNlMjQyMjMyMDAwMDAwMDgzZTA4M2UwODAwMDAwMDNjMjQyMjEw
MDgwMDAwMDAwNDdjMTIxMDA4MDAwMDAwM2UyMDIwMjAzZTAwMDAwMDI0N2UyNDIwMTAwMDAwMDAw
NjIwMjYxMDBjMDAwMDAwM2UyMDEwMTgyNjAwMDAwMDA0M2UyNDA0MzgwMDAwMDAyMjI0MjAxMDBj
MDAwMDAwM2UyMjJkMzAwYzAwMDAwMDFjMDgzZTA4MDQwMDAwMDAyYTJhMjAxMDBjMDAwMDAwMWMw
MDNlMDgwNDAwMDAwMDA0MDQxYzI0MDQwMDAwMDAwODNlMDgwODA0MDAwMDAwMDAxYzAwMDAzZTAw
MDAwMDNlMjAyODEwMmMwMDAwMDAwODNlMzA1ZTA4MDAwMDAwMjAyMDIwMTAwZTAwMDAwMDEwMjQy
NDQ0NDIwMDAwMDAwMjFlMDIwMjFjMDAwMDAwM2UyMDIwMTAwYzAwMDAwMDBjMTIyMTQwMDAwMDAw
MDAwODNlMDgyYTJhMDAwMDAwM2UyMDE0MDgxMDAwMDAwMDNjMDAzZTAwMWUwMDAwMDAwODA0MjQ0
MjdlMDAwMDAwNDAyODEwNjgwNjAwMDAwMDFlMDQxZTA0M2MwMDAwMDAwNDNlMjQwNDA0MDAwMDAw
MWMxMDEwMTAzZTAwMDAwMDFlMTAxZTEwMWUwMDAwMDAzZTAwM2UyMDE4MDAwMDAwMjQyNDI0MjAx
MDAwMDAwMDE0MTQxNDU0MzIwMDAwMDAwMjAyMjIxMjBlMDAwMDAwM2UyMjIyMjIzZTAwMDAwMDNl
MjIyMDEwMGMwMDAwMDAzZTIwM2MyMDE4MDAwMDAwMDYyMDIwMTAwZTAwMDAwMDAwMTUxMDA4MDYw
MDAwMDAwMDA0MWUxNDA0MDAwMDAwMDAwMDBjMDgxZTAwMDAwMDAwMWMxODEwMWMwMDAwMDAwODA0
NjMxMDA4MDAwMDAwMDgxMDYzMDQwODAwMDAwMCIp
:: bios/lib/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-14 00:47:38"]]
:: bios/lib/head.lua
b64$LS0gKioqKiBoZWFkLmx1YSBzaG91bGQgbm90IGhhdmUgYW55IG1ldGFkYXRhOyBicmVha3Mg
bG9hZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAvLyB0byBkbzogd2h5PyAqKioqCi0tW1sKCgloZWFk
Lmx1YSAtLSBrZXJuYWwgc3BhY2UgaGVhZGVyIGZvciBlYWNoIHByb2Nlc3MKCShjKSBMZXhhbG9m
ZmxlIEdhbWVzIExMUAoKXV0KCmRvCgotLSBzeXN0ZW0gbGlicmFyaWVzIGNhbiBkZWZpbmUgZnVu
Y3Rpb25zIHVzYWJsZSBieSBoZWFkIGJ5IGV4cG9ydGluZyB0byBwb3B1bGF0ZSBoZgotLSAocHJv
dGVjdCBhZ2FpbiByZXdyaXRlIGF0dGFja3MpCmxvY2FsIGhmID0gewoJZnVsbHBhdGggPSBfZnVs
bHBhdGggLS0gYm9vdHN0cmFwCn0KZnVuY3Rpb24gX2V4cG9ydF9mdW5jdGlvbnNfdG9faGVhZChm
KQoJZm9yIGssdiBpbiBwYWlycyhmKSBkbwoJCS0tIHByaW50aCgic2V0dGluZyBoZWFkIGZ1bmN0
aW9uOiAiLi5rKQoJCWhmW2tdID0gdgoJZW5kCmVuZAoKLS0gY29uc3RhbnQgZm9yIGxpZmV0aW1l
IG9mIHByb2Nlc3MKbG9jYWwgX2VudmRhdCA9IGVudigpCmxvY2FsIF9waWR2YWwgPSBwaWQoKQoK
LS0ga2VlcCBhIGxvY2FsIGNvcHkgb2YgYW55IGZ1bmN0aW9ucyB1c2VkIGluIGhlYWQKLS0gdXNl
ZCBieSBjcmVhdGVfcHJvY2VzcyBhbmQgYm9vdC5sdWEgd2l0aG91dCBfRU5WIGR1cGxpY2F0aW9u
IChfaW5jbHVkZV9saWIpCi0tIC0tPiBuZWVkIHRvIHRha2UgY2FyZSBvZiByZXdyaXRlIGF0dGFj
a3MKCmxvY2FsIF9zdG9wID0gX3N0b3AKbG9jYWwgX2xvYWQgPSBsb2FkCmxvY2FsIF9jcmVhdGVf
cHJvY2Vzc19mcm9tX2NvZGUgPSBfY3JlYXRlX3Byb2Nlc3NfZnJvbV9jb2RlCmxvY2FsIF9mZXRj
aF9tZXRhZGF0YV9mcm9tX2ZpbGUgPSBfZmV0Y2hfbWV0YWRhdGFfZnJvbV9maWxlCmxvY2FsIF9w
b2QgPSBfcG9kCgpsb2NhbCBfaGFsdCA9IF9oYWx0CmxvY2FsIF9ta2RpciA9IF9ta2RpcgoKbG9j
YWwgX3NpZ25hbCA9IF9zaWduYWwKbG9jYWwgX3NwbGl0ID0gc3BsaXQKbG9jYWwgX2V4dCA9IF9l
eHQKbG9jYWwgX3BhdGggPSBfcGF0aApsb2NhbCBfaGxvYyA9IF9obG9jCmxvY2FsIF9tZDUgPSBf
bWQ1Cgpsb2NhbCBfc3ViID0gc3RyaW5nLnN1Ygpsb2NhbCBfZmluZCA9IHN0cmluZy5maW5kCmxv
Y2FsIF90b3N0cmluZyAgPSB0b3N0cmluZwoKbG9jYWwgX3NlbmRfbWVzc2FnZSAgPSBfc2VuZF9t
ZXNzYWdlCgpsb2NhbCBfcHJpbnRoID0gX3ByaW50aCAtLSBub3QgdXNlZCBidXQgZm9yIHNhZmV0
eSAob2Z0ZW4gYWRkIGRlYnVnZ2luZyBsaW5lcykKbG9jYWwgX25vdGlmeSAtLSBkZWZpbmVkIGFm
dGVyIHJlZmVyZW5jZWQgYmVsb3cKCmxvY2FsIF9zdGF0ID0gc3RhdAoKLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLS1bWwot
LSBkZWJ1Z2dpbmc7IGxvZyB3aGljaCBnbG9iYWxzIGFyZSBhY2Nlc3NlZApsb2NhbCBHTE9CQUxT
ID0gX0cKCmxvY2FsIGdsb2JhbHNfbXQgPSB7CglfX2luZGV4ID0gZnVuY3Rpb24odCwgaykKLS0J
CXByaW50aCgiR0xPQkFMIEFDQ0VTU0VEOiIuLl90b3N0cmluZyhrKSkKCQlsb2NhbCB2YWwgPSBy
YXdnZXQoR0xPQkFMUywgaykKCQlpZiB2YWwgfj0gbmlsIHRoZW4KCQkJaWYgdHlwZSh2YWwpID09
ICJmdW5jdGlvbiIgdGhlbgoJCQkJcmV0dXJuIGZ1bmN0aW9uKC4uLikKCQkJCQlwcmludGgoIkdM
T0JBTCBDQUxMRUQ6Ii4uX3Rvc3RyaW5nKGspKQoJCQkJCXJldHVybiB2YWwoLi4uKQoJCQkJZW5k
CgkJCWVuZAoJCQlyZXR1cm4gdmFsIC0tIHJldHVybiBub24gZnVuY3Rpb24gdmFsdWUKCQllbmQK
CQlpZiAoR0xPQkFMUykgcHJpbnRoKCJHTE9CQUwgQUNDRVNTRUQgQlVUIE5PVCBGT1VORDoiLi5f
dG9zdHJpbmcoaykpCgkJcmV0dXJuIG5pbAoJZW5kCn0KCmlmIChfcGlkdmFsID4gMykgdGhlbgkK
CV9HID0ge30KCXNldG1ldGF0YWJsZShfRywgZ2xvYmFsc19tdCkKZW5kCi0tXV0KCgoKCi0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0KCi0tIGxvY2FsIGhlbHBlcnMgYmVjYXVzZSBkb24ndCB3YW50IHRvIGNhbGwgZnVuY3Rp
b25zIGZyb20gdGhlIHN0cmluZyBtZXRhdGFibGUgKHNhbmRib3ggc2VjdXJpdHkpCgpsb2NhbCBm
dW5jdGlvbiBfaXNfY2FydF9leHQoc3RyKQoJcmV0dXJuIHN0cj09InA2NCIgb3Igc3RyPT0icDY0
LnBuZyIgb3Igc3RyPT0icDY0LnJvbSIKZW5kCmxvY2FsIGZ1bmN0aW9uIF9pc19iYnNfY2FydChs
b2MpCglyZXR1cm4gX3N1Yihsb2MsMSw2KSA9PSAiYmJzOi8vIgplbmQKCi0tW1sKCTAuMi4xZTog
Zm9sbG93IGMgc3RkbGliIGNvbnZlbnRpb246CgoJZGlybmFtZSBwcmludHMgYWxsIGJ1dCB0aGUg
ZmluYWwgc2xhc2gtZGVsaW1pdGVkIGNvbXBvbmVudCBvZiBlYWNoIG5hbWUuIAoJU2xhc2hlcyBv
biBlaXRoZXIgc2lkZSBvZiB0aGUgZmluYWwgY29tcG9uZW50IGFyZSBhbHNvIHJlbW92ZWQuIElm
IHRoZSBzdHJpbmcgY29udGFpbnMgbm8gc2xhc2gsIGRpcm5hbWUgcHJpbnRzIOKAmC7igJkKCgli
YXNlbmFtZSAtIHN0cmlwIGRpcmVjdG9yeSBhbmQgc3VmZml4IGZyb20gZmlsZW5hbWVzCgoJCXBh
dGggICAgICAgICBkaXJuYW1lICAgIGJhc2VuYW1lCgkJIi91c3IvbGliIiAgICAiL3VzciIgICAg
ImxpYiIKCQkiL3Vzci8iICAgICAgICIvIiAgICAgICAidXNyIgoJCSJ1c3IiICAgICAgICAgIi4i
ICAgICAgICJ1c3IiCgkJIi8iICAgICAgICAgICAiLyIgICAgICAgIi8iCgoJLS0gcHJlLTAuMi4x
ZSBpbmNsdWRlZCB0aGUgZW5kaW5nIHNsYXNoOyBkaXJuYW1lKCIvZm9vLzEudHh0IikgLT4gL2Zv
by8KXV0KCmxvY2FsIGZ1bmN0aW9uIF9iYXNlbmFtZShzdHIpCglsb2NhbCBzZWdzID0gX3NwbGl0
KF9wYXRoKHN0ciksIi8iLGZhbHNlKQoJaWYgKHNlZ3NbI3NlZ3NdPT0iIiBhbmQgI3NlZ3MgPiAx
KSBzZWdzWyNzZWdzXSA9IG5pbCAtLSBkaXNjYXJkIGVtcHR5IHNlZ21lbnQgY2F1c2VkIGJ5IHRy
YWlsaW5nIHNsYXNoCglpZiAoI3NlZ3MgPT0gMSkgcmV0dXJuIHN0cgoJcmV0dXJuIHNlZ3NbI3Nl
Z3NdCmVuZAoKbG9jYWwgZnVuY3Rpb24gX2Rpcm5hbWUoc3RyKQoJaWYgKHN0ciA9PSAiLyIpIHJl
dHVybiAiLyIKCWxvY2FsIHBhdGggPSBfcGF0aChzdHIpIC0tIHJlbW92ZSBobG9jCglsb2NhbCBz
ZWdzID0gX3NwbGl0KHBhdGgsIi8iLGZhbHNlKQoJaWYgKCNzZWdzIDw9IDEpIHJldHVybiAiLiIK
CWlmIChzZWdzWyNzZWdzXT09IiIgYW5kICNzZWdzID4gMSkgc2Vnc1sjc2Vnc10gPSBuaWwgLS0g
ZGlzY2FyZCBlbXB0eSBzZWdtZW50IGNhdXNlZCBieSB0cmFpbGluZyBzbGFzaAoJbG9jYWwgcmVz
ID0gX3N1YihwYXRoLDEsLSgjc2Vnc1sjc2Vnc10gKyAyKSkKCXJldHVybiByZXMKZW5kCgotLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLQotLSBmb3IgYmJzOi8vZm9vLTAucDY0L3N1YmNhcnQvaG9nZS5wNjQgLS0_IGlk
IHNob3VsZCBiZSBmb28tMCwgbm90IGhvZ2UKLS0gYmJzX2lkIGluY2x1ZGVzIHRoZSB2ZXJzaW9u
LCBidXQgaXMgc3RyaXBwZWQgd2hlbiBjcmVhdGluZyBmaWxldmlldyAoYWxsIHZlcnNpb25zIHNo
YXJlIC9hcHBkYXRhL2ZvbykKbG9jYWwgZnVuY3Rpb24gZ2V0X2Jic19pZF9mcm9tX2xvY2F0aW9u
KGxvYykKCWlmIChfc3ViKGxvYywxLDYpIH49ICJiYnM6Ly8iKSByZXR1cm4gbmlsCglsb2NhbCBw
b3MgPSBfZmluZChsb2MsICIucDY0IiwgMSwgdHJ1ZSkKCWlmIChub3QgcG9zKSByZXR1cm4gbmls
CglyZXR1cm4gX2Jhc2VuYW1lKF9zdWIobG9jLCAxLCBwb3MtMSkpCmVuZAoKLS0gYmJzOi8vbmV3
LzAvZm9vLTAucDY0L3N1YmNhcnQvaG9nZS5wNjQgLT4gYmJzOi8vZm9vLTAucDY0L3N1YmNhcnQv
aG9nZS5wNjQKLS0gdG8gZG86IGFsc28gbmVlZCB0aGlzIGZvciBmYXZvdXJpdGVzOyBob3cgdG8g
Z2V0IGVhc2lseSBleHRyYWN0IGJicyBpZCBmcm9tIHVzZXJsYW5kPwpsb2NhbCBmdW5jdGlvbiBu
b3JtYWxpc2VfYmJzX3BhdGgocGF0aCkKCWxvY2FsIGJic19pZCA9IGdldF9iYnNfaWRfZnJvbV9s
b2NhdGlvbihwYXRoKQoJaWYgKG5vdCBiYnNfaWQpIHJldHVybiBuaWwKCglsb2NhbCBwb3MgPSBf
ZmluZChwYXRoLCAiLnA2NCIsIDEsIHRydWUpCglpZiAobm90IHBvcykgcmV0dXJuIG5pbAoKCXJl
dHVybiAiYmJzOi8vIi4uYmJzX2lkLi5fc3ViKHBhdGgsIHBvcykKZW5kCi0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
CgoKbG9jYWwgZnVuY3Rpb24gZ2V0X3Nob3J0X3Byb2dfbmFtZShwKQoJaWYgKG5vdCBwKSB0aGVu
IHJldHVybiAibm9fcHJvZ19uYW1lIiBlbmQKCXAgPSBfc3BsaXQocCwgIi8iLCBmYWxzZSkKCXAg
PSBfc3BsaXQocFsjcF0sICIuIiwgZmFsc2UpWzFdCglyZXR1cm4gcAplbmQKCi0tIGZvciByYXRl
IGxpbWl0aW5nCmxvY2FsIGNyZWF0ZV9wcm9jZXNzX3QgPSAwCmxvY2FsIGNyZWF0ZV9wcm9jZXNz
X24gPSAwCgotLVtbCgoJY3JlYXRlX3Byb2Nlc3MocHJvZywgZW52KQoKCXJldHVybnMgcHJvY2Vz
cyBpZCBvbiBzdWNjZXNzLCBvdGhlcndpc2U6IG5pbCwgZXJyX21zZwoKCXByb2c6IHRoZSBjYXJ0
cmlkZ2Ugb3IgbHVhIGZpbGUgdG8gcnVuCgllbnY6IGEgdGFibGUgb2YgZW52aXJvbm1lbnQgYXR0
cmlidXRlcyB0aGF0IGlzIG1lcmdlZCB3aXRoIHRoZSBuZXcgcHJvY2VzcyBlbnZpcm9ubWVudAoK
XV0KLS0gCmZ1bmN0aW9uIGNyZWF0ZV9wcm9jZXNzKHByb2dfbmFtZV9wLCBlbnZfcGF0Y2gpCgoJ
ZW52X3BhdGNoID0gZW52X3BhdGNoIG9yIHt9CgoJLS0gMS4gc2FuZGJveGVkIHByb2dyYW1zIGNh
biBub3QgY3JlYXRlIHByb2Nlc3NlcwoKCWlmIF9lbnZkYXQuc2FuZGJveCBhbmQgKChfc3RhdCgz
MDcpICYgMHgxKSA9PSAwKSB0aGVuIC0tIHNhbmRib3hlZCBwcm9ncmFtIHRoYXQgaXMgbm90IGEg
dHJ1c3RlZCBzeXN0ZW0gYXBwCgoJCWxvY2FsIGdyYW50X2V4Y2VwdGlvbiA9IGZhbHNlCgoJCS0t
IDEuYSBjYW4gcnVuIC9zeXN0ZW0gYXBwcyBhcyBhICJiYnNfY29tcGFuaW9uIiAgLS0gICoqIGhh
cyBmdWxsIGZpbGV2aWV3ICoqIChleGNlcHQgZm9yIC9hcHBkYXRhKQoKCQlpZiAoewoJCQlbIi9z
eXN0ZW0vYXBwcy9maWxlbmF2LnA2NCJdID0gdHJ1ZSwgLS0gYmJzIGNhcnRzIGNhbiB1c2UgZmls
ZW5hdiB0byBnYWluIGFjY2VzcyB0byBvcGVuIGFueSBmaWxlIG9uIGRpc2sgKGUuZy4gc3RyYXdi
ZXJyeV9zcmMKCQkJWyIvc3lzdGVtL2FwcHMvbm90ZWJvb2sucDY0Il0gPSB0cnVlLCAtLSBzb21l
IGNhcnRzIGFscmVhZHkgdXNlIHRoaXMgZm9yIG9wZW5pbmcgZG9jdW1lbnRhdGlvbiwgSSB0aGlu
ay4gY291bGQgb3BlbigpIGluc3RlYWQKCQkJWyIvc3lzdGVtL3V0aWwvb3Blbi5sdWEiXSA9IHRy
dWUsIC0tICNwaWNvY2FsZW5kYXIgdXNlcyB0aGlzIHRvIG9wZW4gdGV4dCBmaWxlcwoJCQlbIi9z
eXN0ZW0vdXRpbC9scy5sdWEiXSA9IHRydWUgLS0gZm9yIHNhbmRib3hlZCB0ZXJtaW5hbDsgZG9l
c24ndCBtb2RpZnkgc3lzdGVtIGFuZCBwYXJlbnQgY2FuJ3QgZ2V0IGluZm9ybWF0aW9uIGJhY2sK
CQl9KVtwcm9nX25hbWVfcF0gdGhlbgoJCQlncmFudF9leGNlcHRpb24gPSB0cnVlCgkJCWVudl9w
YXRjaC5zYW5kYm94ID0gImJic19jb21wYW5pb24iCgkJCWVudl9wYXRjaC5iYnNfaWQgPSBfZW52
ZGF0LmJic19pZAoJCWVuZAoKCQktLSAxLmIgY2FuIHJ1biBidW5kbGVkIGNhcnRzIGluIHNhbWUg
c2FuZGJveAoKCQlsb2NhbCBwcCA9IF9lbnZkYXQuY29ydW5fcHJvZ3JhbSBhbmQgX2Rpcm5hbWUo
X2VudmRhdC5jb3J1bl9wcm9ncmFtKSBvciBfZW52ZGF0LmFyZ3ZbMF0KCQlsb2NhbCBwcDEgPSBo
Zi5mdWxscGF0aChwcm9nX25hbWVfcCkKCQlpZiAocHAgYW5kIF9zdWIocHAxLDEsI3BwKSA9PSBw
cCBhbmQgcHAxWyNwcCsxXSA9PSAiLyIpIHRoZW4KCQkJZ3JhbnRfZXhjZXB0aW9uID0gdHJ1ZQoJ
CQllbnZfcGF0Y2guc2FuZGJveCA9ICJiYnMiCgkJCWVudl9wYXRjaC5iYnNfaWQgPSBfZW52ZGF0
LmJic19pZAoJCWVuZAoJCQoJCS0tIDEuYyBjYW4gcnVuIGFueXRoaW5nIGZyb20gYmJzOi8vIChp
bmNsdWRpbmcgc3ViLWNhcnRzKQoKCQlpZiAoZ2V0X2Jic19pZF9mcm9tX2xvY2F0aW9uKHByb2df
bmFtZV9wKSkgdGhlbgoJCQlncmFudF9leGNlcHRpb24gPSB0cnVlIAoJCQllbnZfcGF0Y2guc2Fu
ZGJveCA9ICJiYnMiCgkJCWVudl9wYXRjaC5iYnNfaWQgPSBnZXRfYmJzX2lkX2Zyb21fbG9jYXRp
b24ocHJvZ19uYW1lX3ApCgkJZW5kCgoJCS0tPiBmYWlsIGlmIG5vIGdyb3VuZHMgdG8gYWxsb3cg
Y3JlYXRpbmcgcHJvY2VzcyB3aGlsZSBzYW5kYm94ZWQKCgkJaWYgKG5vdCBncmFudF9leGNlcHRp
b24pIHRoZW4KCQkJLS0gcHJpbnRoKCJbY3JlYXRlX3Byb2Nlc3NdIGRlbmllZCBmcm9tIHNhbmRi
b3hlZCBwcm9ncmFtOiAiLi5wcm9nX25hbWVfcCkKCQkJcmV0dXJuIG5pbCwgInNhbmRib3hlZCBw
cm9jZXNzIGNhbiBub3QgY3JlYXRlX3Byb2Nlc3MoKSIKCQllbmQKCQktLSBwcmludGgoIltjcmVh
dGVfcHJvY2Vzc10gZ3JhbnRpbmcgZXhjZXB0aW9uIGluIHNhbmRib3g6ICIuLnByb2dfbmFtZV9w
KQoKCgkJLS0gcmF0ZSBsaW1pdGluZyAvLyBwcmV2ZW50IGJicyBjYXJ0IGZyb20gcHJvY2Vzcy1i
b21iaW5nCgkJaWYgKHRpbWUoKSA_IGNyZWF0ZV9wcm9jZXNzX3QgKyA2MCkgY3JlYXRlX3Byb2Nl
c3NfdCwgY3JlYXRlX3Byb2Nlc3NfbiA9IHRpbWUoKSwgMCAtLSByZXNldCBldmVyeSBtaW51dGUK
CQlpZiAoY3JlYXRlX3Byb2Nlc3NfbiA_PSAyMCkgcmV0dXJuIG5pbCwgInNhbmRib3hlZCBwcm9j
ZXNzIGNhbiBub3QgY3JlYXRlX3Byb2Nlc3MoKSBtb3JlIHRoYW4gMjAgLyBtaW51dGUiCgkJY3Jl
YXRlX3Byb2Nlc3NfbiArPSAxCgoJCS0tIHJhdGUgbGltaXRpbmcgZm9yIHBpY29jYWxlbmRhciAo
YnVnIGluIGNhcnQgdGhhdCBkaWRuJ3Qgc2hvdyB1cCBlYXJsaWVyIHdoZW4gZmluZF9leGlzdGlu
Z193aW5kb3cgd2FzIGFsd2F5cyBpbXBsaWNpdGx5IHRydWUpCgkJLS0gdG8gZG86IHN0ZWFsdGgg
cGF0Y2ggY2FydCBhbmQgZGVsZXRlIHRoaXMKCQlpZiAoX2VudmRhdC5hcmd2WzBdOnN1YigxLDE4
KSA9PSAiYmJzOi8vcGljb2NhbGVuZGFyIikgdGhlbgoJCQlpZiAobGFzdF9waWNvY2FsZW5kYXJf
dCBhbmQgdGltZSgpIDwgbGFzdF9waWNvY2FsZW5kYXJfdCArIDAuNSkgcmV0dXJuIG5pbCwgInBp
Y29jYWxlbmRhciB3aW5kb3cgc3BhbSB3b3JrYXJvdW5kIgoJCQlsYXN0X3BpY29jYWxlbmRhcl90
ID0gdGltZSgpCgkJZW5kCgoJZW5kCgoKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLSByZXNvbHZlIHByb2dyYW0gcGF0aCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tCgoJbG9jYWwgcHJvZ19uYW1lID0gaGYuZnVsbHBhdGgocHJvZ19uYW1lX3Ap
CgoJLS0gbm9ybWFsaXNlIGJicyBwYXRoczogcmVtb3ZlICJuZXcvMC8iIGV0YwoJaWYgZ2V0X2Ji
c19pZF9mcm9tX2xvY2F0aW9uKHByb2dfbmFtZSkgdGhlbgoJCS0tIHByaW50aCgibm9ybWFsaXNp
bmcgYmJzIHByb2c6ICIuLnBvZHtwcm9nX25hbWUsIG5vcm1hbGlzZV9iYnNfcGF0aChwcm9nX25h
bWUpLCBnZXRfYmJzX2lkX2Zyb21fbG9jYXRpb24ocHJvZ19uYW1lKX0pCgkJcHJvZ19uYW1lID0g
bm9ybWFsaXNlX2Jic19wYXRoKHByb2dfbmFtZSkKCWVuZAoKCS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBsb2NhdGUgYm9vdCBmaWxlIC0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkKCS0tIC5wNjQgZmlsZXM6IGZpbmQgYm9vdCBmaWxl
IGluIHJvb3Qgb2YgLnA2NCAoYW5kIHRodXMgc2V0IGRlZmF1bHQgcGF0aCB0aGVyZSB0b28pCgls
b2NhbCBib290X2ZpbGUgPSBwcm9nX25hbWUKCWlmIChfaXNfY2FydF9leHQoX2V4dChwcm9nX25h
bWUpKSkgYm9vdF9maWxlIC4uPSAiL21haW4ubHVhIgoKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLSBsb2NhdGUgbWV0YWRhdGEgLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tCgoJLS0gbG9vayBmb3IgbWV0YWRhdGEgaW5zaWRlIHA2NCAv
IGZvbGRlciAgKG5ldmVyIHVzZSBtZXRhZGF0YSBmcm9tIGEgc2luZ2xlIC5sdWEgZmlsZSBpbiB0
aGlzIGNvbnRleHQpCglsb2NhbCBtZXRhZGF0YSA9IF9mZXRjaF9tZXRhZGF0YV9mcm9tX2ZpbGUo
cHJvZ19uYW1lLi4iLy5pbmZvLnBvZCIpCgoJLS0gc3BlY2lhbCBjYXNlOiBjby1ydW5uaW5nIC9y
YW0vY2FydCBmcm9tIHRlcm1pbmFsCglpZiBlbnZfcGF0Y2guY29ydW5fcHJvZ3JhbSA9PSAiL3Jh
bS9jYXJ0L21haW4ubHVhIiB0aGVuCgkJbWV0YWRhdGEgPSBfZmV0Y2hfbWV0YWRhdGFfZnJvbV9m
aWxlKCIvcmFtL2NhcnQvLmluZm8ucG9kIikKCWVuZAoJCgktLSBydW5uaW5nIG1haW4ubHVhIGRp
cmVjdGx5IGZyb20gaW5zaWRlIGEgY2FydCAtPiBzaG91bGQgbG9vayBhdCBhdHRyaWJ1dGVzIG9m
IHBhcmVudCBkaXJlY3RvcnkKCWlmIChub3QgbWV0YWRhdGEgYW5kIF9iYXNlbmFtZShwcm9nX25h
bWUpID09ICJtYWluLmx1YSIpIHRoZW4KCQltZXRhZGF0YSA9IF9mZXRjaF9tZXRhZGF0YV9mcm9t
X2ZpbGUoX2Rpcm5hbWUoYm9vdF9maWxlKS4uIi8uaW5mby5wb2QiKQoJZW5kCgoJLS0gbm8gbWV0
YWRhdGEgZm91bmQgLT4gZGVmYXVsdCBpcyB7fQoJaWYgKG5vdCBtZXRhZGF0YSkgbWV0YWRhdGEg
PSB7fQoKCS0tIGNoZWNrIGZvciBmdXR1cmUgY2FydHJpZGdlIChhcHBsaWVzIHRvIGNhcnRzIC8g
Zm9sZGVycyAtLSBsdWEgZmlsZXMgZG9uJ3QgaGF2ZSB0aGlzIG1ldGFkYXRhKQoJaWYgKHR5cGUo
bWV0YWRhdGEucnVudGltZSkgPT0gIm51bWJlciIgYW5kIG1ldGFkYXRhLnJ1bnRpbWUgPiBfc3Rh
dCg1KSkgdGhlbgoJCV9ub3RpZnkoIioqIGNhcnRyaWRnZSBoYXMgZnV0dXJlIHJ1bnRpbWUgdmVy
c2lvbjogIi4ucHJvZ19uYW1lX3ApCgkJcmV0dXJuIC0tIHRvIGRvOiBzZXR0aW5ncy5hbGxvd19m
dXR1cmUKCWVuZAoKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBj
b25zdHJ1Y3QgbmV3X2VudiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KCglsb2NhbCBuZXdfZW52ID0ge30gLS0gZG9uJ3QgaW5oZXJpdCBhbnl0aGluZyBmcm9tIHBh
cmVudCAKCgktLSAuLiBidXQgYWRkIG5ldyBhdHRyaWJ1dGVzIGZyb20gZW52X3BhdGNoIChub3Rl
OiBjYW4gY29weSB0cmVlcykKCWZvciBrLHYgaW4gcGFpcnMoZW52X3BhdGNoKSBkbwoJCW5ld19l
bnZba10gPSB2CgllbmQKCgktLSBkZWNpZGUgcHJvZ3JhbSBwYXRoOiBzYW1lIGFzIGJvb3QgZmls
ZSwgb3IgY29ydW4gcHJvZ3JhbQoJbG9jYWwgcHJvZ3JhbV9wYXRoID0gbmV3X2Vudi5jb3J1bl9w
cm9ncmFtIGFuZCAKCQlfZGlybmFtZShoZi5mdWxscGF0aChuZXdfZW52LmNvcnVuX3Byb2dyYW0p
KSBvcgoJCV9kaXJuYW1lKGJvb3RfZmlsZSkKCgktLSBzdGFuZGFyZCBlbnZpcm9ubWVudCB2YWx1
ZXM6IHBpZCwgYXJndiwgYXJndlswXQoJbmV3X2Vudi5wYXJlbnRfcGlkID0gX3BpZHZhbAoJbmV3
X2Vudi5hcmd2ID0gdHlwZShuZXdfZW52LmFyZ3YpID09ICJ0YWJsZSIgYW5kIG5ld19lbnYuYXJn
diBvciB7fSAtLSBndWFyYW50ZWVkIHRvIGV4aXN0IGF0IGxlYXN0IGFzIGFuIGVtcHR5IHRhYmxl
CgluZXdfZW52LmFyZ3ZbMF0gPSBwcm9nX25hbWUgLS0gZS5nLiAvc3lzdGVtL2FwcHMvZ2Z4LnA2
NAoKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJLS0gc2FuZGJveCB2YWxpZGF0aW9u
CgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgktLSBzYWZldHk6IHByb2cgdGhhdCBz
dGFydHMgd2l0aCBiYnM6Ly8gTVVTVCBiZSBiYnMtc2FuZGJveGVkIHcvIGNhcnRfaWQgZGVyaXZl
ZCBmcm9tIHRoYXQgbG9jYXRpb24KCS0tIGZvciBiYnM6Ly9mb28tMC5wNjQvc3ViY2FydC9ob2dl
LnA2NCAtLT4gaWQgc2hvdWxkIGJlIGZvbywgbm90IGhvZ2UKCWlmIGdldF9iYnNfaWRfZnJvbV9s
b2NhdGlvbihwcm9nX25hbWUpIHRoZW4KCQluZXdfZW52LnNhbmRib3ggPSAiYmJzIgoJCW5ld19l
bnYuYmJzX2lkID0gZ2V0X2Jic19pZF9mcm9tX2xvY2F0aW9uKHByb2dfbmFtZSkKCWVuZAoKCS0t
IGdyYWIgc2FuZGJveCBmcm9tIGNhcnRyaWRnZSBtZXRhZGF0YSBpZiBub3QgYWxyZWFkeSBzZXQg
aW4gZW52aXJvbm1lbnQKCS0tIChjYW4gb3B0IHRvIHR1cm4gc2FuZGJveGluZyBvZmYgaW4gZW52
X3BhdGNoIHdpdGgge3NhbmRib3g9ZmFsc2V9OyBvciBvdGhlcndpc2Ugb3ZlcnJpZGUgc2FuZGJv
eCBzcGVjaWZpZWQgaW4gbWV0YWRhdGEpCglpZiAobm90IG5ld19lbnYuc2FuZGJveCBhbmQgbWV0
YWRhdGEuc2FuZGJveCBhbmQgbWV0YWRhdGEuYmJzX2lkKSB0aGVuCgkJbmV3X2Vudi5zYW5kYm94
ID0gbWV0YWRhdGEuc2FuZGJveCAtLSAiYmJzIgoJCW5ld19lbnYuYmJzX2lkID0gbWV0YWRhdGEu
YmJzX2lkCgllbmQKCi0tW1sKCWRlbGV0ZW1lIH4gc2V0IHdoZW4gZ3JhbnRpbmcKCgktLSBjcmVh
dGVkIGJ5IHNhbmRib3hlZCBwcm9ncmFtIC0_IE1VU1QgYmUgYmJzX2NvbXBhbmlvbiB3aXRoIHRo
ZSBzYW1lIGJic19pZCAodW5sZXNzIGFscmVhZHkgZGV0ZXJtaW5lZCB0byBiZSBhIGJicyBjYXJ0
KQoJLS0gLS0_IGlnbm9yZSBtZXRhZGF0YSBvciBuZXdfZW52LnNhbmRveAoJLS0gbWVhbnMgaW5o
ZXJpdCBmaWxldmlldyAgKGUuZy4gb3BlbiBmaWxlbmF2IC0_IHNob3VsZCBoYXZlIHNhbWUgL2Fw
cGRhdGEgbWFwcGluZykKCWlmIChuZXdfZW52LnNhbmRib3ggfj0gImJicyIgYW5kIF9lbnZkYXQu
c2FuZGJveCA9PSAiYmJzIikgdGhlbgoJCW5ld19lbnYuc2FuZGJveCA9ICJiYnNfY29tcGFuaW9u
IgoJCW5ld19lbnYuYmJzX2lkID0gX2VudmRhdC5iYnNfaWQKLS0JCXByaW50aCgiY3JlYXRlX3By
b2Nlc3MgYmJzX2NvbXBhbmlvbjogIi4uX2VudmRhdC5iYnNfaWQpCgllbmQKXV0KCgktLSBzYW5k
Ym94ZXMgc2hvdWxkIGJlIG9ubHkgYmJzIC8gYmJzX2NvbXBhbmlvbiwgYW5kIG11c3QgaGF2ZSBh
IGJic19pZAoJaWYgbmV3X2Vudi5zYW5kYm94IGFuZCBuZXdfZW52LnNhbmRib3ggfj0gImJicyIg
YW5kIG5ld19lbnYuc2FuZGJveCB_PSAiYmJzX2NvbXBhbmlvbiIgdGhlbgoJCXJldHVybiBuaWws
ICJvbmx5IGJicywgYmJzX2NvbXBhbmlvbiBzYW5kYm94IHByb2ZpbGVzIGFyZSBjdXJyZW50bHkg
c3VwcG9ydGVkIgoJZW5kCgoJaWYgKG5ld19lbnYuc2FuZGJveCBhbmQgbm90IG5ld19lbnYuYmJz
X2lkKSB0aGVuCgkJcmV0dXJuIG5pbCwgImJhZCBiYnNfaWQgLS0gY2FuIG5vdCBzYW5kYm94IgoJ
ZW5kCgoKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJLS0gY29uc3RydWN0IGZpbGV2
aWV3CgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCglpZiAoX3N0YXQoMzA3KSAmIDB4
MSkgPiAwIHRoZW4KCQktLSB0cnVzdGVkIGFwcHMgKC9zeXN0ZW0vKikgY2FuIGdyYW50IGEgY3Vz
dG9tIGZpbGV2aWV3IChpbmNsdWRpbmcgdG8gYSBzYW5kYm94ZWQgcHJvY2VzcykKCQluZXdfZW52
LmZpbGV2aWV3ID0gbmV3X2Vudi5maWxldmlldyBvciB7fQoJZWxzZQoJCS0tIG90aGVyd2lzZSB0
aGUgZmlsZXZpZXcgaXMgZGVyaXZlZCBlbnRpcmVseSBmcm9tIG5ld19lbnYuc2FuZGJveCAvIG5l
d19lbnYuYmJzX2lkCgkJbmV3X2Vudi5maWxldmlldyA9IHt9CgllbmQKCgktLSAwLjIuMGU6IGZp
bGV2aWV3IHJ1bGVzIHNob3VsZCBub3QgaW5jbHVkZSBoYXNoIHBhcnQuIGJ1dCBjYWxsZWQgImxv
Y2F0aW9uIiAoYW5kIG5vdCAicGF0aCIpIGJlY2F1c2Ugc2hvdWxkIGJlIGFsbG93ZWQgdG8gcGFz
cyBpbiBhIGxvY2F0aW9uCgktLSAoZS5nLiBvcGVuLmx1YSBkb2VzIGl0IC0tIHNvbWV0aW1lcyBp
bmNsdWRlcyB0aGUgaGFzaCBwYXJ0LiBjYWxsZXJzIHNob3VsZG4ndCBuZWVkIHRvIGtub3cgLyBy
ZW1lbWJlciB0byBkbyB0aGF0KQoKCWZvciBpPSNuZXdfZW52LmZpbGV2aWV3LDEsLTEgZG8KCQlp
ZiB0eXBlKG5ld19lbnYuZmlsZXZpZXdbaV0ubG9jYXRpb24pID09ICJzdHJpbmciIGFuZCB0eXBl
KG5ld19lbnYuZmlsZXZpZXdbaV0ubW9kZSkgPT0gInN0cmluZyIgdGhlbgoJCQktLSByZW1vdmUg
dGhlIGhhc2ggcGFydCAtLSBqdXN0IHdhbnQgdGhlIHBhdGgKCQkJbmV3X2Vudi5maWxldmlld1tp
XS5sb2NhdGlvbiA9IF9wYXRoKG5ld19lbnYuZmlsZXZpZXdbaV0ubG9jYXRpb24pIAoJCWVsc2UK
CQkJLS0gaW52YWxpZCBydWxlCgkJCWRlbChuZXdfZW52LmZpbGV2aWV3LG5ld19lbnYuZmlsZXZp
ZXdbaV0pCgkJZW5kCgllbmQKCgktLSBwcmludGgoImNyZWF0aW5nIHByb2Nlc3MgIi4ucHJvZ19u
YW1lX3AuLiIgd2l0aCBzdGFydGluZyBmaWxldmlldzogIi4ucG9ke25ld19lbnYuZmlsZXZpZXd9
KQoJLS0gcHJpbnRoKCJjcmVhdGluZyBwcm9jZXNzICIuLnByb2dfbmFtZV9wLi4iIHdpdGggc2Fu
ZGJveDogIi4ucG9ke25ld19lbnYuc2FuZGJveH0pCgkKCS0tIGNyZWF0ZSBmaWxldmlldyAvIHJ1
bGVzIGZvciBzYW5kYm94CgoJaWYgKG5ld19lbnYuc2FuZGJveCA9PSAiYmJzIikgdGhlbgoKCQkt
LSByZWFkIHN5c3RlbSBsaWJyYXJpZXMgYW5kIHJlc291cmNlcwoJCWFkZChuZXdfZW52LmZpbGV2
aWV3LCB7bG9jYXRpb24gPSAiL3N5c3RlbSIsIG1vZGUgPSAiUiJ9KQoKCQktLSBjYXJ0L3Byb2dy
YW0gY2FuIHJlYWQgaXRzZWxmOyBpbmNsdWRlcyBydW5uaW5nIG1haW4ubHVhIGRpcmVjdGx5LCBh
bmQgY28tcnVuIHByb2dyYW1zLiBwcm9ncmFtX3BhdGggaXMgc2FtZSBhcyBpbml0aWFsIHB3ZAoJ
CS0tIG5vdGU6IHRoaXMgbmV2ZXIgaGFwcGVucyBmb3Igc3RhbmQtYWxvbmUgLmx1YSBmaWxlcyBh
cyBpdCBpcyBub3QgcG9zc2libGUgdG8gc2FuZGJveCB0aGVtIHNlcGFyYXRlbHkgKG9ubHkgcGFy
ZW50IC5pbmZvLnBvZCBpcyBvYnNlcnZlZCBpbiB0aGlzIGNvbnRleHQpCgkJYWRkKG5ld19lbnYu
ZmlsZXZpZXcsIHtsb2NhdGlvbiA9IHByb2dyYW1fcGF0aCwgbW9kZSA9ICJSIn0pCgoJCS0tIHBh
cnRpYWwgdmlldyBvZiBwcm9jZXNzZXMucG9kIGFuZCAvZGVza3RvcCBtZXRhZGF0YSAob25seSBp
Y29uIHgseSBhdmFpbGFibGU7IHJlZjogYmJzOi8vZGVza3RvcF9wZXQucDY0KQoJCWFkZChuZXdf
ZW52LmZpbGV2aWV3LCB7bG9jYXRpb24gPSAiL3JhbS9zeXN0ZW0vcHJvY2Vzc2VzLnBvZCIsIG1v
ZGUgPSAiWCJ9KQoJCWFkZChuZXdfZW52LmZpbGV2aWV3LCB7bG9jYXRpb24gPSAiL2Rlc2t0b3Av
LmluZm8ucG9kIiwgbW9kZSA9ICJYIn0pCgkJCgkJLS0gKGRldikgcmVhZC93cml0ZSBtb3VudGVk
IGJiczovLyBjYXJ0IHdoaWxlIHNhbmRib3hlZAoJCS0tIGRlbGV0ZW1lIC0tIG9ubHkgbmVlZGVk
IGluIGtlcm5hbCBzcGFjZSBpbiBmcy5sdWEKLS0JCWFkZChuZXdfZW52LmZpbGV2aWV3LCB7bG9j
YXRpb24gPSAiL3JhbS9iYnMvIi4ubmV3X2Vudi5iYnNfaWQuLiIucDY0LnBuZyIsIG1vZGUgPSAi
UlcifSkKCQktLSBleHBlcmltZW50YWw6IHNob3VsZCBiZSBhbGxvd2VkIHRvIHJlYWQgbW91bnQ-
IHNlZW1zIGhhcm1sZXNzIGJ1dCBzaG91bGRuJ3QgZXZlciBiZSBuZWVkZWQgc28gZG8gbm90IGFs
bG93CgkJLS1hZGQobmV3X2Vudi5maWxldmlldywge2xvY2F0aW9uID0gIi9yYW0vYmJzLyIuLm5l
d19lbnYuYmJzX2lkLi4iLnA2NC5wbmciLCBtb2RlID0gIlIifSkgCgoJCS0tIGFueSBjYXJ0cyBj
YW4gcmVhZC93cml0ZSAvYXBwZGF0YS9zaGFyZWQgXG0vCgkJYWRkKG5ld19lbnYuZmlsZXZpZXcs
IHtsb2NhdGlvbiA9ICIvcmFtL3NoYXJlZCIsIG1vZGUgPSAiUiJ9KQoJCWFkZChuZXdfZW52LmZp
bGV2aWV3LCB7bG9jYXRpb24gPSAiL2FwcGRhdGEvc2hhcmVkIiwgbW9kZSA9ICJSVyJ9KQoKCQkt
LSBhbnkgb3RoZXIgL2FwcGRhdGEgcGF0aCBzaG91bGQgYmUgbWFwcGVkIHRvIC9hcHBkYXRhL2Ji
cy9iYnNfaWQKCQlsb2NhbCBiYnNfaWRfYmFzZSA9IHNwbGl0KG5ld19lbnYuYmJzX2lkLCAiLSIs
IGZhbHNlKVsxXSAtLSBkb24ndCBpbmNsdWRlIHRoZSB2ZXJzaW9uIHBhcnQKCQlfbWtkaXIoIi9h
cHBkYXRhL2JicyIpIC0tIHNhZmV0eTsgc2hvdWxkIGFscmVhZHkgZXhpc3QgKGJvb3QgY3JlYXRl
cykKCQktLV9ta2RpcigiL2FwcGRhdGEvYmJzLyIuLmJic19pZF9iYXNlKSAtLSB0byBkbzogb25s
eSBjcmVhdGUgd2hlbiBhY3R1YWxseSBhYm91dCB0byB3cml0ZSBzb21ldGhpbmc-CgkJYWRkKG5l
d19lbnYuZmlsZXZpZXcsIHtsb2NhdGlvbiA9ICIvYXBwZGF0YSIsIG1vZGUgPSAiUlciLCB0YXJn
ZXQ9Ii9hcHBkYXRhL2Jicy8iLi5iYnNfaWRfYmFzZX0pCgoJZW5kCgoJLS0gYmJzX2NvbWFwbmlv
biBlLmcuIG9wZW4gZmlsZW5hdiAvIG5vdGVib29rIGZyb20gYmJzIGNhcnQuIGFsd2F5cyBhIHRy
dXN0ZWQgYXBwIGZyb20gL3N5c3RlbQoJLS0gdGhlIGNvbXBhbmlvbiBwcm9ncmFtIGhhcyBmdWxs
IGFjY2VzcywgZXhjZXB0IHNob3VsZCBoYXZlIHNhbWUgL2FwcGRhdGEgbWFwcGluZyBhcyBwYXJl
bnQgcHJvY2VzcwoJaWYgKG5ld19lbnYuc2FuZGJveCA9PSAiYmJzX2NvbXBhbmlvbiIpIHRoZW4K
CgkJbmV3X2Vudi5maWxldmlldz17fQoKCQktLSBzYW1lIC9hcHBkYXRhIG1hcHBpbmcgYXMgcGFy
ZW50IHByb2Nlc3MKCQlsb2NhbCBiYnNfaWRfYmFzZSA9IHNwbGl0KF9lbnZkYXQuYmJzX2lkLCAi
LSIsIGZhbHNlKVsxXSAtLSBkb24ndCBpbmNsdWRlIHRoZSB2ZXJzaW9uIHBhcnQKCQlfbWtkaXIo
Ii9hcHBkYXRhL2JicyIpCgkJX21rZGlyKCIvYXBwZGF0YS9iYnMvIi4uYmJzX2lkX2Jhc2UpIC0t
IGNyZWF0ZSBvbiBsYXVuY2ggaW4gY2FzZSB3YW50IHRvIGJyb3dzZSBpdCB3aXRoIGZpbGVuYXYK
CQlhZGQobmV3X2Vudi5maWxldmlldywge2xvY2F0aW9uID0gIi9hcHBkYXRhIiwgbW9kZSA9ICJS
VyIsIHRhcmdldD0iL2FwcGRhdGEvYmJzLyIuLmJic19pZF9iYXNlfSkKCgkJLS0gcHJpbnRoKCJj
cmVhdGVkIGNvbXBhbmlvbiBtYXBwaW5nIGZvciAvYXBwZGF0YTogIi4uIi9hcHBkYXRhL2Jicy8i
Li5iYnNfaWRfYmFzZSkKCgkJLS0gZXZlcnl0aGluZyBlbHNlIGlzIGFsbG93ZWQgKGUuZy4gZmls
ZW5hdiBjYW4gZnJlZWx5IGJyb3dzZSBkcml2ZSBhbmQgY2hvb3NlIHdoZXJlIHRvIGxvYWQgLyBz
YXZlIGZpbGUpCgkJYWRkKG5ld19lbnYuZmlsZXZpZXcsIHtsb2NhdGlvbiA9ICIqIiwgbW9kZSA9
ICJSVyJ9KQoJZW5kCgoJLS1wcmludGgoIm5ld19lbnYuZmlsZXZpZXc6ICIuLnBvZHtuZXdfZW52
LmZpbGV2aWV3fSkKCgkKCQoJLS0tLQoKCglsb2NhbCBzdHIgPSBbWwoKCQktLSBlbnZpcm9ubWVu
dCBmb3IgbmV3IHByb2Nlc3M7IHVzZSBfcG9kIHRvIGdlbmVyYXRlIGltbXV0YWJsZSB2ZXJzaW9u
CgkJLS0gKGdlbmVyYXRlcyBuZXcgdGFibGUgZXZlcnkgdGltZSBpdCBpcyBjYWxsZWQpCgkJZW52
ID0gZnVuY3Rpb24oKSAKCQkJcmV0dXJuIF1dLi5fcG9kKG5ld19lbnYsMHgwKS4uW1sKCQllbmQK
CQlfZW52ID0gZW52CgoJCWxvY2FsIGhlYWRfY29kZSA9IGxvYWQoZmV0Y2goIi9zeXN0ZW0vbGli
L2hlYWQubHVhIiksICJAL3N5c3RlbS9saWIvaGVhZC5sdWEiLCAidCIsIF9FTlYpCgkJaWYgKG5v
dCBoZWFkX2NvZGUpIHRoZW4gcHJpbnRoIioqKiBFUlJPUjogY291bGQgbm90IGxvYWQgaGVhZC4g
Ym9ya2VkIGZpbGUgc3lzdGVtIC8gb3V0IG9mIHBmaWxlIHNsb3RzPyAqKioiIGVuZAoJCWhlYWRf
Y29kZSgpCgoJCS0tIG9yZGVyIG1hdHRlcnMgLy8gZnMubHVhIHVzZXMgb25fZXZlbnQKCQlfaW5j
bHVkZV9saWIoIi9zeXN0ZW0vbGliL2FwaS5sdWEiKQoJCV9pbmNsdWRlX2xpYigiL3N5c3RlbS9s
aWIvbWVtLmx1YSIpCgkJX2luY2x1ZGVfbGliKCIvc3lzdGVtL2xpYi93aW5kb3cubHVhIikKCQlf
aW5jbHVkZV9saWIoIi9zeXN0ZW0vbGliL2Nvcm91dGluZS5sdWEiKQoJCV9pbmNsdWRlX2xpYigi
L3N5c3RlbS9saWIvcHJpbnQubHVhIikKCQlfaW5jbHVkZV9saWIoIi9zeXN0ZW0vbGliL2V2ZW50
cy5sdWEiKQoJCV9pbmNsdWRlX2xpYigiL3N5c3RlbS9saWIvZnMubHVhIikKCQlfaW5jbHVkZV9s
aWIoIi9zeXN0ZW0vbGliL3NvY2tldC5sdWEiKQoJCV9pbmNsdWRlX2xpYigiL3N5c3RlbS9saWIv
Z3VpLmx1YSIpCgkJX2luY2x1ZGVfbGliKCIvc3lzdGVtL2xpYi9hcHBfbWVudS5sdWEiKQoJCV9p
bmNsdWRlX2xpYigiL3N5c3RlbS9saWIvd3JhbmdsZS5sdWEiKQoJCV9pbmNsdWRlX2xpYigiL3N5
c3RlbS9saWIvdW5kby5sdWEiKQoJCV9pbmNsdWRlX2xpYigiL3N5c3RlbS9saWIvdGhlbWUubHVh
IikKCgkJX3NpZ25hbCgzOCkgLS0gc3RhcnQgb2YgdXNlcmxhbmQgY29kZSAoZm9yIG1lbW9yeSBh
Y2NvdW50aW5nKQoJCV9zaWduYWwoMTUpIC0tIGdpdmUgYXVkaW8gcHJpb3JpdHkgdG8gdGhpcyBw
cm9jZXNzOyBjYW4gc3RlYWwgUEZYNjQxNiBjb250cm9sIG9uIG5vdGUoKSAvIHNmeCgpIC8gbXVz
aWMoKQoKCQktLSBjbGVhciBvdXQgZ2xvYmFscyB0aGF0IHNob3VsZG4ndCBiZSBleHBvc2VkIHRv
IHVzZXJsYW5kCgkJaW5jbHVkZSgiL3N5c3RlbS9saWIvamV0dGlzb24ubHVhIikKCQkKCQktLSBh
bHdheXMgc3RhcnQgaW4gcHJvZ3JhbSBwYXRoCgkJY2QoIl1dLi5wcm9ncmFtX3BhdGguLltbIikK
CgkJLS0gYXV0b2xvYWQgcmVzb3VyY2VzIChtdXN0IGJlIGFmdGVyIHNldHRpbmcgcHdkKQoJCS0t
IDAuMi4wZTogd2hlbiBydW5uaW5nIC9yYW0vY2FydCwgdGhpcyBhbHNvIGJsb2NrcyB0byBzYXZl
IGFueSBmaWxlcyBvcGVuIGluIGVkaXRvcnMKCQlpbmNsdWRlKCIvc3lzdGVtL2xpYi9yZXNvdXJj
ZXMubHVhIikKCgkJLS0gdG8gZG86IHByZXByb2Nlc3NfZmlsZSgpIGhlcmUgLy8gdXBkYXRlOiBu
byBuZWVkIQoJCWluY2x1ZGUoIl1dLi5ib290X2ZpbGUuLltbIikKCgkJLS0gZm9vdGVyOyBpbmNs
dWRlcyBtYWlubG9vcAoJCWluY2x1ZGUoIi9zeXN0ZW0vbGliL2Zvb3QubHVhIikKCgldXQoKCgls
b2NhbCBwcm9jX2lkID0gX2NyZWF0ZV9wcm9jZXNzX2Zyb21fY29kZShzdHIsIGdldF9zaG9ydF9w
cm9nX25hbWUocHJvZ19uYW1lKSwgcHJvZ19uYW1lLCBuZXdfZW52LnNhbmRib3gpCgoJaWYgKG5v
dCBwcm9jX2lkKSB0aGVuCgkJcmV0dXJuIG5pbAoJZW5kCgoJaWYgKGVudl9wYXRjaC53aW5kb3df
YXR0cmlicyBhbmQgZW52X3BhdGNoLndpbmRvd19hdHRyaWJzLnB3Y19vdXRwdXQpIHRoZW4KCQlo
Zi5zdG9yZSgiL3JhbS9zeXN0ZW0vcG9wLnBvZCIsIHByb2NfaWQpIC0tIHByZXNlbnQgb3V0cHV0
IHByb2Nlc3MKCWVuZAoKCWlmIChlbnZfcGF0Y2guYmxvY2tpbmcpIHRoZW4KCQktLSB0aGlzIHBy
b2Nlc3Mgc2hvdWxkIHN0b3AgcnVubmluZyB1bnRpbCBwcm9jX2lkIGlzIGNvbXBsZXRlZAoJCS0t
ICh1cGRhdGU6IGlzIHRoYXQgYWN0dWFsbHkgdXNlZnVsPykKCWVuZAoKCi0tCXByaW50aCgiJCBj
cmVhdGVkIHByb2Nlc3MgIi4ucHJvY19pZC4uIjogIi4ucHJvZ19uYW1lLi4iIHBwYXRoOiIuLnBy
b2dyYW1fcGF0aCkKLS0JcHJpbnRoKCIgIG5ld19lbnY6ICIuLnBvZChuZXdfZW52KSkKCglyZXR1
cm4gcHJvY19pZAoKZW5kCgoKbG9jYWwgX2NyZWF0ZV9wcm9jZXNzID0gY3JlYXRlX3Byb2Nlc3MK
ZnVuY3Rpb24gb3Blbihsb2MpCglpZiAodHlwZShsb2Mpfj0ic3RyaW5nIikgcmV0dXJuCgoJLS0g
d29ya3MgZm9yIHNhbmRib3hlZCBjYXJ0cywgYnV0IG9wZW4ubHVhIHdpbGwgYmUgcnVuIGluIGEg
YmJzX2NvbXBhbmlvbiBzYW5kYm94CgktLT4gY2FuIG9wZW4gYW55dGhpbmcgdGhhdCBpcyBhY2Nl
c3NpYmxlIHRvIGNhbGxpbmcgcHJvY2Vzc2VzJ3MgZmlsZXZpZXcKCV9jcmVhdGVfcHJvY2Vzcygi
L3N5c3RlbS91dGlsL29wZW4ubHVhIix7YXJndj17bG9jfX0pCmVuZAoKCi0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgot
LSBtYW5hZ2UgcHJvY2Vzcy1sZXZlbCBkYXRhOiBkaXNwYXksIGVudgoKCgktLSBleGl0KCkKCS0t
IGltbWVkaWF0ZWx5IGNsb3NlIHByb2dyYW0gJiB3aW5kb3cgCgktLSBleGl0X2NvZGUgY3VycmVu
dGx5IG5vdCB1c2VkIGJ5IGFueXRoaW5nISB0byBkbzogbWF5YmUgdGhhdCdzIGEgZ29vZCB0aGlu
Zz8KCS0tIGRvZXMgcGljb3Ryb24gcmVhbGx5IG5lZWQgc29tZXRoaW5nIGxpa2UgYmFzaCBzdHls
ZSBzY3JpcHRzLWFzLWZ1bmN0aW9ucz8gaXMgbWVhbnQgdG8gdmFsdWUgc2VsZi1jb250YWluZWQg
bHVhIHByb2dyYW1zIQoJLS0gdGhlIG9ubHkgcmVzdWx0IHRoYXQgbmVlZHMgdG8gYmUgY29tbXVu
aWNhdGVkIGlzIGRpcmVjdGx5IHRvIHRoZSBlbmQgdXNlciAodmlhIHByaW50KCkgb3Igbm90aWZ5
KCkgb3IgZHJhd24gdG8gc2NyZWVuKQoJZnVuY3Rpb24gZXhpdChleGl0X2NvZGUpCgkJLS0gZXhp
dF9jb2RlID0gZXhpdF9jb2RlIG9yIDAgCgkJX3NlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9ImtpbGxf
cHJvY2VzcyIsIHByb2NfaWQ9X3BpZHZhbH0pCgkJX2hhbHQoKSAtLSBzdG9wIGV4ZWN1dGluZyBp
bW1lZGlhdGVseQoJZW5kCgoJLS0gc3RvcCBleGVjdXRpbmcgaW4gYSByZXN1bWFibGUgd2F5IAoJ
LS0gdXNlIGZvciBkZWJ1Z2dpbmcgdmlhIHRlcm1pbmFsOiBzdG9wIHdoZW4gc29tZXRoaW5nIG9m
IGludGVyZXN0IGhhcHBlbnMgYW5kIHRoZW4gaW5zcGVjdCBzdGF0ZQoJLS0gdW5saWtlIFBJQ08t
OCwgYWx3YXlzIHByaW50cyB0byB0ZXJtaW5hbCAoY2FuJ3QgdXNlIHRvIHByaW50IHRvIGRpc3Bs
YXkgfiBubyBuZWVkKQoJZnVuY3Rpb24gc3RvcCh0eHQpCi0tCQlpZiAodHh0KSBwcmludCh0eHQs
Li4uKSAtLSBwYXJhbWV0ZXJzIGFyZSBzYW1lIGFzIGEgcmVndWxhciBwcmludCgpIC0tIGNhbiBz
ZXQgY29sb3VyIG9yIGRyYXcgdG8gYmFjayBwYWdlCgoJCWlmIChfZW52ZGF0LmNvcnVuX3Byb2dy
YW0pIHRoZW4KCQkJX3NlbmRfbWVzc2FnZShfcGlkdmFsLCB7ZXZlbnQ9ImhhbHQiLCBkZXNjcmlw
dGlvbj10eHR9KSAtLSBzYW1lIGFzIHByZXNzaW5nIGVzY2FwZTsgZ29lcyB0byB0ZXJtaW5hbAoJ
CQloZi5mbGlwKCkgLS0gaGFsdCBpbW1lZGlhdGVseQoJCWVsc2VpZiBfZHJhdyB0aGVuCgkJCS0t
IHVudXN1YWwgY2FzZToKCQkJLS0gZm9yIGEgZ3JhcGhpY2FsIHByb2dyYW0sIG5vdGhpbmcgdG8g
cHJpbnQgdG8gYnV0IHNob3VsZCBzdGlsbCBzdG9wLiAtPiB1c2Ugbm90aWZ5KCkKCQkJLS0gaXMg
dW5saWtlbHkgdGhlIGF1dGhvciBtZWFudCB0aGlzIHRvIGhhcHBlbiBvdXRzaWRlIG9mIGEgZGVi
dWdnaW5nIGNvbnRleHQsIGJ1dCBzZWVtcwoJCQktLSB3b3JzZSB0byBldmVyIGRpc3JlZ2FyZCB0
aGUgcmVxdWVzdCB0byBoYWx0IChtYXliZSBhYm91dCB0byBkbyBzb21ldGhpbmcgZGFuZ2Vyb3Vz
PykKCQkJX25vdGlmeSh0eHQpCgkJCV9oYWx0KCkKCQllbHNlCgkJCS0tIHNpbWlsYXI7IHNob3Vs
ZG4ndCBiZSB1c2luZyBzdG9wKCkgYXMgYSB3YXkgdG8gZW5kIGNhcnRzIChub3RlZCBpbiBtYW51
YWwpCgkJCS0tIGluc3RlYWQgdXNlIHByaW50KCJtZXNzYWdlIikgZXJyb3IoZXJyX2NvZGUpCgkJ
CXByaW50KHR4dCkKCQkJX3NlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9ImtpbGxfcHJvY2VzcyIsIHBy
b2NfaWQ9X3BpZHZhbH0pCgkJCV9oYWx0KCkgLS0gc3RvcCBleGVjdXRpbmcgaW1tZWRpYXRlbHkK
CQllbmQKCQkKCWVuZAoKCV9zdG9wID0gc3RvcAoKCS0tIGFueSBwcm9jZXNzIGNhbiBraWxsIGFu
eSBvdGhlciBwcm9jZXNzIQoJLS0gZGVsZXRlbWUgLS0gc2VuZCBhIG1lc3NhZ2UgdG8gcHJvY2Vz
cyBtYW5hZ2VyIGluc3RlYWQuIHByb2Nlc3MgbWFuYWdlciBtaWdodCB3YW50IHRvIGRlY2xpbmUu
CgktLVtbCglmdW5jdGlvbiBraWxsX3Byb2Nlc3MocHJvY19pZCwgZXhpdF9jb2RlKQoJCV9zZW5k
X21lc3NhZ2UoMiwge2V2ZW50PSJraWxsX3Byb2Nlc3MiLCBwcm9jX2lkPXByb2NfaWQsIGV4aXRf
Y29kZSA9IGV4aXRfY29kZX0pCgllbmQKCV1dCgoJCgoKCQoJLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgoKCS0tW1sKCQlpbmNsdWRlKCkKCgkJc2hv
cnRoYW5kIGZvcjogZmV0Y2goZmlsZW5hbWUpKCkgIC8vICBzbyBhbHdheXMgcmVsYXRpdmUgdG8g
cHdkKCkKCgkJLy8gbm90IHJlYWxseSBhbiBpbmNsdWRlLCBidXQgZm9yIHVzZXJzIHdobyBkb24n
dCBjYXJlIGFib3V0IHRoZSBkaWZmZXJlbmNlLCBzZXJ2ZXMgdGhlIHNhbWUgcHVycG9zZQoJCS8v
IGFuZCBpcyB1c2VkIGluIHRoZSBzYW1lIHdheTogYSBidW5jaCBvZiBpbmNsdWRlKCJmb28ubHVh
IikgYXQgdGhlIHN0YXJ0IG9mIG1haW4ubHVhCgoJCXJlbGF0ZWQgcmVhZGluZzogTHVhIE1vZHVs
ZSBGdW5jdGlvbiBDcml0aXF1ZWQgLy8gb2xkIG1vZHVsZSBzeXN0ZW0gZGVwcmVjYXRlZCBpbiA1
LjIgaW4gZmF2b3Igb2YgcmVxdWlyZSgpCgkJCS8vIGF2b2lkcyBtdWx0aXBsZSBtb2R1bGUgYXV0
aG9ycyB3cml0aW5nIHRvIHRoZSBzYW1lIGdsb2JhbCBlbnZpcm9ubWVudAoJCQlodHRwOi8vbHVh
LXVzZXJzLm9yZy93aWtpL0x1YU1vZHVsZUZ1bmN0aW9uQ3JpdGlxdWVkCgkJCWh0dHBzOi8vd2Vi
LmFyY2hpdmUub3JnL3dlYi8yMDE3MDcwMzE2NTUwNi9odHRwczovL2x1YS11c2Vycy5vcmcvd2lr
aS9MdWFNb2R1bGVGdW5jdGlvbkNyaXRpcXVlZAoKCV1dCgoJbG9jYWwgaW5jbHVkZWRfZmlsZXMg
PSB7fQoKCgoJZnVuY3Rpb24gaW5jbHVkZShmaWxlbmFtZV9wKQoJCWxvY2FsIGZpbGVuYW1lID0g
aGYuZnVsbHBhdGgoZmlsZW5hbWVfcCkKCQlsb2NhbCBzcmMgPSBmaWxlbmFtZSBhbmQgaGYuZmV0
Y2goZmlsZW5hbWUpIG9yIG5pbAoJCWlmIChub3Qgc3JjKSB0aGVuCgkJCV9ub3RpZnkoImNvdWxk
IG5vdCBpbmNsdWRlICIuLnRvc3RyaW5nKGZpbGVuYW1lX3ApKQoJCQlfc3RvcCgpCgkJZW5kCgoJ
CS0tIHRlbXBvcmFyeSBzYWZldHk6IGVhY2ggZmlsZSBjYW4gb25seSBiZSBpbmNsdWRlZCB1cCB0
byAyNTYgdGltZXMKCQktLSB0byBkbzogd2h5IGRvIHJlY3Vyc2l2ZSBpbmNsdWRlcyBjYXVzZSBh
IHN5c3RlbS1sZXZlbCBvdXQgb2YgbWVtb3J5IGJlZm9yZSBhIHByb2Nlc3MgbWVtb3J5IGVycm9y
PwoJCWlmIChpbmNsdWRlZF9maWxlc1tmaWxlbmFtZV0gYW5kIGluY2x1ZGVkX2ZpbGVzW2ZpbGVu
YW1lXSA_IDI1NikgdGhlbgoJCQlfbm90aWZ5KCJ0b28gbWFueSBpbmNsdWRlcyAiLi50b3N0cmlu
ZyhmaWxlbmFtZV9wKS4uIiAobWF4OjI1NikgLy8gY2lyY3VsYXIgcmVmZXJlbmNlPyIpCgkJCV9z
dG9wKCkKCQllbmQKCQlpbmNsdWRlZF9maWxlc1tmaWxlbmFtZV0gPSBpbmNsdWRlZF9maWxlc1tm
aWxlbmFtZV0gYW5kIGluY2x1ZGVkX2ZpbGVzW2ZpbGVuYW1lXSsxIG9yIDEKCgkJaWYgKHR5cGUo
c3JjKSB_PSAic3RyaW5nIikgdGhlbiAKCQkJaWYgKF9waWR2YWwgPD0gMykgcHJpbnRoKCIqKiBj
b3VsZCBub3QgaW5jbHVkZSAiLi5maWxlbmFtZSkKCQkJX25vdGlmeSgiY291bGQgbm90IGluY2x1
ZGUgIi4uZmlsZW5hbWUuLiIgKGZldGNoIGZhaWxlZCkiKQoJCQlfc3RvcCgpCgkJZW5kCgoJCS0t
IGh0dHBzOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUuNC9tYW51YWwuaHRtbCNwZGYtbG9hZAoJCS0t
IGNodW5rIG5hbWUgKGZvciBlcnJvciByZXBvcnRpbmcpLCBtb2RlICgidCIgZm9yIHRleHQgb25s
eSAtLSBubyBiaW5hcnkgY2h1bmsgbG9hZGluZyksIF9FTlYgdXB2YWx1ZQoJCS0tIEAgaXMgYSBz
cGVjaWFsIGNoYXJhY3RlciB0aGF0IHRlbGxzIGRlYnVnZ2VyIHRoZSBzdHJpbmcgaXMgYSBmaWxl
bmFtZQoJCWxvY2FsIGZ1bmMsZXJyID0gX2xvYWQoc3JjLCAiQCIuLmZpbGVuYW1lLCAidCIsIF9F
TlYpCgoJCS0tIHN5bnRheCBlcnJvciB3aGlsZSBsb2FkaW5nCgkJaWYgKG5vdCBmdW5jKSB0aGVu
IAoJCQlfc2VuZF9tZXNzYWdlKDMsIHtldmVudD0icmVwb3J0X2Vycm9yIiwgY29udGVudCA9ICIq
c3ludGF4IGVycm9yIn0pCgkJCV9zZW5kX21lc3NhZ2UoMywge2V2ZW50PSJyZXBvcnRfZXJyb3Ii
LCBjb250ZW50ID0gIihjb3VsZCBub3QgaW5jbHVkZTogIi4uZmlsZW5hbWUuLiIpIn0pCgkJCV9z
ZW5kX21lc3NhZ2UoMywge2V2ZW50PSJyZXBvcnRfZXJyb3IiLCBjb250ZW50ID0gX3Rvc3RyaW5n
KGVycil9KQoJCQlfc3RvcCgpCgkJZW5kCgoJCXJldHVybiBmdW5jKCkgLS0gMC4xLjFlOiBhbGxv
dyBwcml2YXRlIG1vZHVsZXMgKHVzZWQgdG8gcmV0dXJuIHRydWUpCgllbmQKCQoKCgktLVtbCgkJ
MC4yLjFjOiAKCQl3aGVuIGluY2x1ZGluZyAvc3lzdGVtL2xpYi8qLCBtYWtlIGEgY29weSBvZiBl
bnZpcm9ubWVudCB0aGF0IGlzIGluYWNjZXNzaWJsZSB0byB1c2VybGFuZCBjb2RlIHRvCgkJcHJv
dGVjdCBhZ2FpbnN0IHJld3JpdGluZyBmdW5jdGlvbnMgKGFuZCBtZXRhbWV0aG9kcykgdXNlZCBp
bnNpZGUgc3lzdGVtIGxpYnJhcmllcy4gb3RoZXJ3aXNlIGNhbgoJCXVzZSBhcyBhIGZvb3Rob2xk
IGZvciBlc2NhcGluZyBzYW5kYm94LiB0ZXN0OgoKCQkJbG9jYWwgcHJvdDAgPSBzdHJpbmcucHJv
dAoJCQlmdW5jdGlvbiBzdHJpbmc6cHJvdCguLi4pIHByaW50aCgiaGkgZnJvbSB1c2VybGFuZCIp
IHJldHVybiBwcm90MCguLi4pIGVuZAoJCQlmdWxscGF0aCgiLyIpIC0tIGNhbGxzIDpwcm90KCkK
CgkJLS0gcHJldmlvdXMgc3RyYXRlZ3kgd2FzIHRvIG1ha2UgYSBsb2NhbCBjb3B5IG9mIGVhY2gg
ZnVuY3Rpb24gdXNlZCBpbiBrZXJuYWwgY29kZQoJCS0tIGNhdXNlcyBjaXJjdWxhciBkZXBlbmRl
bmNpZXMsIGRvZXNuJ3Qgd29yayBmb3Igc3RyaW5nIG1ldGFtZXRob2RzIGFuZCBlYXN5IHRvIG1p
c3Mgb3RoZXJ3aXNlCgkJLS0_IHNob3VsZCBoYXZlIGEgYmxhbmtldCBzYWZldHkgbWVhc3VyZSBs
aWtlIHRoaXMgaW4gYW55IGNhc2U7IHVzZSBvbiB0b3Agb2YgbG9jYWwgZnVuY3Rpb24gcmVmZXJl
bmNlcwoJXV0KCglsb2NhbCBmdW5jdGlvbiBjb3B5X2Vudl9mdW5jcyh0YmwsIGRlcHRoKQoJCWlm
IChkZXB0aCA_IDMpIHJldHVybiBuaWwKCQlsb2NhbCBvdXQgPSB7fQoJCWZvciBrLHYgaW4gcGFp
cnModGJsKSBkbwoJCQlpZiBrIH49ICJfRyIgYW5kIGsgfj0gIl9FTlYiIHRoZW4gCgkJCQlpZiB0
eXBlKHYpID09ICJ0YWJsZSIgdGhlbgoJCQkJCW91dFtrXSA9IGNvcHlfZW52X2Z1bmNzKHYsIGRl
cHRoKzEpCgkJCQllbHNlCgkJCQkJb3V0W2tdID0gdgoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJCXJl
dHVybiBvdXQKCWVuZAoKCWZ1bmN0aW9uIF9pbmNsdWRlX2xpYihmaWxlbmFtZSkKCgkJbG9jYWwg
c3JjID0gZmV0Y2goZmlsZW5hbWUpIC0tIGhmLmZldGNoIG5vdCBkZWZpbmVkIHlldCwgYnV0IF9p
bmNsdWRlX2xpYiBvbmx5IHVzZWQgYmVmb3JlIHVzZXJsYW5kIGVudHJ5CgkJbG9jYWwgZW52MiA9
IGNvcHlfZW52X2Z1bmNzKF9HLCAwKQoJCWxvY2FsIGZ1bmMsZXJyID0gX2xvYWQoc3JjLCAiQCIu
LmZpbGVuYW1lLCAidCIsIGVudjIpCgoJCS0tIHN5bnRheCBlcnJvciB3aGlsZSBsb2FkaW5nCgkJ
aWYgKG5vdCBmdW5jKSB0aGVuIAoJCQlwcmludGgoIl9pbmNsdWRlX2xpYiBlcnJvcjogIi4ucG9k
e2ZpbGVuYW1lLCBfdG9zdHJpbmcoZXJyKX0pCgkJCV9zdG9wKCkKCQllbmQKCgkJZnVuYygpCgoJ
CS0tIHNwaWxsIGNoYW5nZXMgYmFjayBpbnRvIG1haW4gZ2xvYmFsIHNjb3BlLiB1c2VybGFuZCBj
YW4gc3RpbGwgcmVkZWZpbmUgdGhvc2UgbmV3IGZ1bmN0aW9ucyBpZiBkZXNpcmVkCgkJLS0gKGJ1
dCB0aGUgbW9kaWZpZWQgdmVyc2lvbnMgd2lsbCBub3QgYmUgdXNlZCBmcm9tIGluc2lkZSBsaWJy
YXJ5IGNvZGUpCgkJLS0gaW5jbHVkZXMgX0VOVi5zdHJpbmcsIHNvIGNhbid0IG92ZXJ3cml0ZSBz
dHJpbmcgbWV0YW1ldGhvZHMgdXNlZCBpbiBsaWJyYXJ5IGNvZGUgKHNlZSBleGFtcGxlIGFib3Zl
KQoJCQktLSB0byBkbzogdW5kZXJzdGFuZCB0aGlzIGJldHRlcjsgY2FuIGl0IHN0aWxsIGJlIGNp
cmN1bXZlbnRlZD8KCgkJZm9yIGssdiBpbiBwYWlycyhlbnYyKSBkbwoJCQlpZiB2IH49IF9HW2td
IGFuZCBrIH49ICJfRyIgYW5kIGsgfj0gIl9FTlYiIHRoZW4KCQkJCS0tIHByaW50KCJAQCBkZWZp
bmVkOiAiLi5maWxlbmFtZS4uIiA6OiAiLi5fdG9zdHJpbmcoaykpCgkJCQlfR1trXSA9IHYgLS0g
Y29weSBiYWNrCgkJCWVuZAoJCWVuZAoKCWVuZAoKCS0tIF9pbmNsdWRlX2xpYiA9IGluY2x1ZGUg
LS0gdGVzdDogCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLS1bWwoJCgl0byBkbzogCglub3RpZnkoInN5bnRh
eCBlcnJvcjogLi4uIiwgImVycm9yIikgLT4gc2hvd3MgdXAgaW4gL3JhbS9sb2cvZXJyb3IsIGFz
IGEgdGFiIGluIGluZm9iYXIgKHNob3duIGluIGNvZGUgZWRpdG9yIHdvcmtzcGFjZSkKCQoJY2Fu
IGFsc28gdXNlIGxvZ2dlci5wNjQgdG8gdmlldyAvIG1hbmFnZSBsb2dzCglob3cgdG8gZG8gcmVh
bHRpbWUgZmVlZCB3aXRoIGF0b21pYyBmaWxlIGFjY2Vzcz8gcGVyaGFwcyB2aWEgbWVzc2FnZXMg
dG8gbG9nZ2VyPyBbc2VudCBieSBwcm9ncmFtIG1hbmFnZXJdCgpdXQpmdW5jdGlvbiBub3RpZnko
bXNnX3N0cikKCgktLSBub3RpZnkgdXNlciBhbmQgYWRkIHRvIGluZm9iYXIgaGlzdG9yeQoJX3Nl
bmRfbWVzc2FnZSgzLCB7ZXZlbnQ9InVzZXJfbm90aWZpY2F0aW9uIiwgY29udGVudCA9IG1zZ19z
dHJ9KQoKCS0tIGxvZ2dlZCBieSB3aW5kb3cgbWFuYWdlcgoJLS0gX3NlbmRfbWVzc2FnZSgzLCB7
ZXZlbnQ9ImxvZyIsIGNvbnRlbnQgPSBtc2dfc3RyfSkKCQoJLS0gd2ViIGRlYnVnCglpZiAoX3N0
YXQoMzE4KT09MSkgcHJpbnRoKCJAbm90aWZ5OiAiLi5tc2dfc3RyLi4iXG4iKQplbmQKX25vdGlm
eSA9IG5vdGlmeQoKCi0tW1sKCXNlbmRfbWVzc2FnZSgpCgoJc2VjdXJpdHkgY29uY2VybjogCgl1
c2VybGFuZCBhcHBzIG1heSBwZXJmb3JtIGRhbmdlcm91cyBhY3Rpb25zIGluIHJlc3BvbnNlIHRv
IG1lc3NhZ2VzLCBub3QgcmVhbGlzaW5nIHRoZXkgY2FuIGJlIHRyaWdnZXJlZCBieSBhcmJpdHJh
cnkgYmJzIGNhcnRzCgkJLy8gYWxzbzogdXNlcmxhbmQgYXBwcyBjdXJyZW50bHkgb2JzZXJ2ZSAi
bW91c2UiLCAidGV4dGlucHV0IiBldGMgaW4gZXZlbnRzLmx1YSB3aXRob3V0IGZpbHRlcmluZyAo
ZGVzaXJhYmxlLCBidXQgbm90IGZvciBzYW5kYm94ZWQgYXBwcykKCS0_IHNhbmRib3hlZCBwcm9j
ZXNzZXMgY2FuIG9ubHkgc2VuZCBtZXNzYWdlcyB0byBzZWxmLCBvciB0byAvc3lzdGVtIHByb2Nl
c3NlcyAoMC4xLjFlKQoJCS0tIGUuZy4gc2FuZGJveGVkIHRlcm1pbmFsIGNhbiBzZW5kIHRlcm1p
bmFsIHNldF9oYWx0YWJsZV9wcm9jX2lkIHRvIHdtLCBvciByZXF1ZXN0IGEgc2NyZWVuc2hvdCBj
YXB0dXJlCgkJLS0gYXNzdW1wdGlvbjogL3N5c3RlbSBwcm9ncmFtcyBjYW4gYWxsIGhhbmRsZSBh
cmJpdHJhcnkgbWVzc2FnZXMgc2FmZWx5CgkJLS0gdG8gZG86IHNob3VsZCBhY2NlcHQgbWVzc2Fn
ZSBnb2luZyB0byBwcm9jZXNzIDIsIGJ1dCB0aGVuIHJlamVjdCBtb3N0L2FsbCBvZiB0aGVtIGZy
b20gdGhvc2UgaGFuZGxlcnMuIGNsZWFyZXIKXV0KZnVuY3Rpb24gc2VuZF9tZXNzYWdlKHByb2Nf
aWQsIG1zZywgb25fcmVzcG9uY2UpCgoJaWYgCgkJbm90IF9lbnZkYXQuc2FuZGJveCBvciAgICAg
ICAgICAgICAgICAgICAgICAgICAtLSB1c2VybGFuZCBwcm9jZXNzZXMgY2FuIHNlbmQgbWVzc2Fn
ZXMgYW55d2hlcmUKCQlwcm9jX2lkID09IF9waWR2YWwgb3IgICAgICAgICAgICAgICAgICAgICAg
ICAgIC0tIGNhbiBhbHdheXMgc2VuZCBtZXNzYWdlIHRvIHNlbGYKCQkoX3N0YXQoMzA3KSAmIDB4
MSkgPT0gMSBvciAgICAgICAgICAgICAgICAgICAgIC0tIGNhbiBhbHdheXMgc2VuZCBtZXNzYWdl
IGlmIGlzIGJ1bmRsZWQgL3N5c3RlbSBhcHAgKGUuZy4gc2FuZGJveGVkIGZpbGVuYXYpCgkJcHJv
Y19pZCA9PSAzIG9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIGNhbiBhbHdheXMg
c2VuZCBtZXNzYWdlIHRvIHdtCgkJLS0gc3BlY2lhbCBjYXNlOiBzYW5kYm94ZWQgYXBwIGNhbiBz
ZXQgbWFwL2dmeCBwYWxldHRlIHZpYSBwbTsgKHRvIGRvOiBob3cgdG8gZ2VuZXJhbGlzZSB0aGlz
IHNhZmVseT8pCgkJbXNnLmV2ZW50ID09ICJzZXRfcGFsZXR0ZSIgb3IgLS0gdXNlZCBieSAjb2tw
YWwKCQkobXNnLmV2ZW50ID09ICJicm9hZGNhc3QiIGFuZCBtc2cubXNnIGFuZCBtc2cubXNnLmV2
ZW50ID09ICJzZXRfcGFsZXR0ZSIpIC0tIG5vdCBzdXJlIGlmIHVzZWQgaW4gdGhlIHdpbGQKCXRo
ZW4KCgkJaWYgdHlwZShvbl9yZXNwb25jZSkgPT0gImZ1bmN0aW9uIiB0aGVuCgkJCWxvY2FsIHJl
cHlfaWQgPSAibXNnIi4uZmxyKF9zdGF0KDMzMykpIC0tIHVuaXF1ZSBpZAoJCQloZi5vbl9ldmVu
dChyZXB5X2lkLCBmdW5jdGlvbihtc2cxKQoJCQkJb25fcmVzcG9uY2UobXNnMSkKCQkJCWhmLm9u
X2V2ZW50KHJlcHlfaWQsIG5pbCkgLS0gcmVtb3ZlIHRoZSBjYWxsYmFjayAKCQkJZW5kKQoJCQlt
c2cuX3JlcGx5X2lkID0gcmVweV9pZAoJCQlfc2VuZF9tZXNzYWdlKHByb2NfaWQsIG1zZykKCQll
bHNlaWYgb25fcmVzcG9uY2UgdGhlbgoJCQktLSBibG9ja2luZwkJCQoJCQlpZiAocHJvY19pZCA9
PSBfcGlkKSByZXR1cm4gbmlsLCAiY2FuIG5vdCBzZW5kIGEgYmxvY2tpbmcgbWVzc2FnZSB0byBz
ZWxmIiAKCQkJbG9jYWwgcmV0CgkJCWxvY2FsIHJlcHlfaWQgPSAibXNnIi4uZmxyKF9zdGF0KDMz
MykpIC0tIHVuaXF1ZSBpZAoJCQloZi5vbl9ldmVudChyZXB5X2lkLCBmdW5jdGlvbihtc2cxKQoJ
CQkJcmV0ID0gbXNnMQoJCQkJaGYub25fZXZlbnQocmVweV9pZCwgbmlsKSAtLSByZW1vdmUgdGhl
IGNhbGxiYWNrIAoJCQllbmQpCgkJCW1zZy5fcmVwbHlfaWQgPSByZXB5X2lkCgkJCV9zZW5kX21l
c3NhZ2UocHJvY19pZCwgbXNnKQoJCQl3aGlsZSAocmV0ID09IG5pbCkgZG8gaGYuZmxpcCgweDUp
IGVuZCAtLSBzYW1lIGFzIGlucHV0KCk6IDB4MSBzdXBlcnlpZWxkIChubyB0aW1lIGFkdmFuY2Ug
b3IgZnJhbWUgZW5kKSAgMHg0IHRvIHByb2Nlc3MgbWVzc2FnZXMKCQkJcmV0dXJuIHJldAoJCWVs
c2UKCQkJLS0gZmlyZSBhbmQgZm9yZ2V0CgkJCV9zZW5kX21lc3NhZ2UocHJvY19pZCwgbXNnKQoJ
CWVuZAoJZWxzZQoJCS0tcHJpbnRoKCJzZW5kX21lc3NhZ2UoKSBkZWNsaW5lZDogIi4ucG9kKG1z
ZykpCgllbmQKCmVuZAoKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLSBzdHJpbmcgZnVuY3Rpb25zIAotLSBu
ZWVkIHRvIGJlIGF0IHRvcCBsZXZlbCB0byBmdW5jdGlvbiBhcyBtZXRhbWV0aG9kcyB1c2VkIGJ5
IG90aGVyIGxpYnJhcnkgZmlsZXMgKGVzcCBmcy5sdWEpCi0tIHRvIGRvOiBtb3ZlIHRvIGMgIC8v
IG5vdCBwZXJmb3JtYW5jZSBjcmljaWFsIHRob3VnaCwgYW5kIGtpbmQgb2YgbmljZSB0byBzZWUg
aW4gY29kZSB3aGF0IGl0J3MgZG9pbmcKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnN0cmluZy5zcGxpdCA9IF9z
cGxpdApzdHJpbmcuZXh0ID0gX2V4dCAgIC0tIF9leHQoImZvby5wNjQucG5nIikgLT4gInA2NC5w
bmciCnN0cmluZy5wYXRoID0gX3BhdGggLS0gZXZlcnl0aGluZyBiZWZvcmUgZmlyc3QgIwpzdHJp
bmcuaGxvYyA9IF9obG9jIC0tIGV2ZXJ5dGhpbmcgYWZ0ZXIgZmlyc3QgIyAob3IgbmlsIHdoZW4g
bm8gIyBmb3VuZCkKc3RyaW5nLm1kNSA9IF9tZDUKCgpzdHJpbmcuYmFzZW5hbWUgPSBfYmFzZW5h
bWUKc3RyaW5nLmRpcm5hbWUgPSBfZGlybmFtZQoKLS0gbWF4IDggY2hhcnMgLy8gdG8gZG86IG1v
dmUgdG8gYzsgb25seSBhY2NlcHQgd2hlbiBsb3dlcmNhc2UgYWxwaGFudW1lcmljIGNoYXJhY3Rl
cnMKZnVuY3Rpb24gc3RyaW5nOnByb3Qob25seV9wcmVmaXgpCglpZiAobm90IG9ubHlfcHJlZml4
IGFuZCBfZmluZChfcGF0aChzZWxmKSwgIkAiLCAxLCB0cnVlKSkgcmV0dXJuICJhbnl3aGVuIgoJ
bG9jYWwgc2VncyA9IF9zcGxpdChfcGF0aChzZWxmKSwiOiIsZmFsc2UpCglyZXR1cm4gKHR5cGUo
c2Vnc1syXSkgPT0gInN0cmluZyIgYW5kIF9zdWIoc2Vnc1syXSwxLDIpID09ICIvLyIpIGFuZCAj
c2Vnc1sxXSA8PSA4IGFuZCBzZWdzWzFdIG9yIG5pbAplbmQKCmZ1bmN0aW9uIHN0cmluZzppc19j
YXJ0KCkKCXJldHVybiBzZWxmPT0icDY0IiBvciBzZWxmPT0icDY0LnBuZyIgb3Igc2VsZj09InA2
NC5yb20iCmVuZAoKCi0tIFBJQ08tOCBzdHlsZSBzdHJpbmcgaW5kZXhpbmc7ICAoImFiY2RlIilb
Ml0gLS0_ICJiIiAgIC8vIHRvIGRvOiBpbXBsZW1lbnQgaW4gbHZtLmM-CmxvY2FsIHN0cmluZ19t
dF9pbmRleD1nZXRtZXRhdGFibGUoJycpLl9faW5kZXgKbG9jYWwgX3N0cmluZGV4ID0gX3N0cmlu
ZGV4CmdldG1ldGF0YWJsZSgnJykuX19pbmRleCA9IGZ1bmN0aW9uKHN0cixpKSAKCXJldHVybiBz
dHJpbmdfbXRfaW5kZXhbaV0gb3IgX3N0cmluZGV4KHN0cixpKQplbmQKCgotLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tIGluaXRpYWwgc3Rh
dGUgLy8gdG8gZG86IG1vdmUgdG8gcHJvY2Vzcy5jCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCi0tIGRlZmF1bHQgaW5zdHJ1bWVudCBkZWZp
bml0aW9ucyAvLyBsYXRlcjogc3RhbmRhcmQgc2V0IG9mIH4xNj8KCmxvY2FsIGZ1bmN0aW9uIGNs
ZWFyX2luc3RydW1lbnQoaSkKCWxvY2FsIGFkZHIgPSAweDQwMDAwICsgaSAqIDB4MjAwCgltZW1z
ZXQoYWRkciwgMCwgMHgyMDApCgkKCS0tIG5vZGUgMDogcm9vdAoJcG9rZShhZGRyICsgKDAgKiAz
MiksIC0tIG5vZGUgMAoJCgkJCTAsICAgIC0tIHBhcmVudCAoMHg3KSAgb3AgKDB4ZjApCgkJCTEs
ICAgIC0tIGtpbmQgKDB4MGYpOiAxIHJvb3QgIGtpbmRfcCAoMHhmMCk6IDAgIC0tIHdhdmV0YWJs
ZV9pbmRleAoJCQkwLCAgICAtLSBmbGFncwoJCQkwLCAgICAtLSB1bnVzZWQgZXh0cmEKCQkJCQoJ
CQktLSBNVkFMczogIGtpbmQvZmxhZ3MsICB2YWwwLCB2YWwxLCBlbnZlbG9wZV9pbmRleAoJCQkK
CQkJMHgyfDB4NCwweDIwLDAsMCwgIC0tIHZvbHVtZTogbXVsdC4gMHg0MCBpcyBtYXggKC0weDQw
IHRvIGludmVydCwgMHg3ZiB0byBvdmVyYW1wKQoJCQkweDEsMCwwLDAsICAgICAtLSBwYW46ICAg
YWRkLiBjZW50ZXIKCQkJMHgxLDAsMCwwLCAgICAgLS0gdHVuZTogKzAgLS0gMCw0OCwwLDAgYWJz
b2x1dGUgZm9yIG1pZGRsZSBjIChjNCkgMjYxLjYgSHoKCQkJMHgxLDAsMCwwLCAgICAgLS0gYmVu
ZDogbm9uZQoJCQktLSBmb2xsb3dpbmcgc2hvdWxkbid0IGJlIGluIHJvb3QKCQkJMHgwLDAsMCww
LCAgICAgLS0gd2F2ZTogdXNlIHdhdmUgMCAKCQkJMHgwLDAsMCwwICAgICAgLS0gcGhhc2UgCgkp
CgkKCQoJLS0gbm9kZSAxOiB0cmlhbmdsZSB3YXZlCglwb2tlKGFkZHIgKyAoMSAqIDMyKSwgLS0g
aW5zdHJ1bWVudCAwLCBub2RlIDEKCQoJCQkwLCAgICAtLSBwYXJlbnQgKDB4NykgIG9wICgweGYw
KQoJCQkyLCAgICAtLSBraW5kICgweDBmKTogMiBvc2MgIGtpbmRfcCAoMHhmMCk6IDAgIC0tIHdh
dmV0YWJsZV9pbmRleAoJCQkwLCAgICAtLSBmbGFncwoJCQkwLCAgICAtLSB1bnVzZWQgZXh0cmEK
CQkJCQoJCQktLSBNVkFMczogIGtpbmQvZmxhZ3MsICB2YWwwLCB2YWwxLCBlbnZlbG9wZV9pbmRl
eAoJCQkKCQkJMHgyLDB4MjAsMCwwLCAgLS0gdm9sdW1lOiBtdWx0LiAweDQwIGlzIG1heCAoLTB4
NDAgdG8gaW52ZXJ0LCAweDdmIHRvIG92ZXJhbXApCgkJCTB4MSwwLDAsMCwgICAgIC0tIHBhbjog
ICBhZGQuIGNlbnRlcgoJCQkweDIxLDAsMCwwLCAgICAtLSB0dW5lOiArMCAtLSAwLDQ4LDAsMCBh
YnNvbHV0ZSBmb3IgbWlkZGxlIGMgKGM0KSAyNjEuNiBIegoJCQkgICAgICAgICAgICAgICAtLSB0
dW5lIGlzIHF1YW50aXplZCB0byBzZW1pdG9uZXMgd2l0aCAweDIwCgkJCTB4MSwwLDAsMCwgICAg
IC0tIGJlbmQ6IG5vbmUKCQkJMHgwLDB4NDAsMCwwLCAgLS0gd2F2ZTogdHJpYW5nbGUKCQkJMHgw
LDAsMCwwICAgICAgLS0gcGhhc2UgCgkpCgplbmQKCgotLSB0byBkbzogbW92ZSB0byBwcm9jZXNz
LmMKbG9jYWwgcGFsLG1lbXNldCxwb2tlLGNvbG9yLGZpbGxwLHNyYW5kID0gcGFsLG1lbXNldCxw
b2tlLGNvbG9yLGZpbGxwLHNyYW5kCgpmdW5jdGlvbiByZXNldCgpCgoJLS0gcmVzZXQgcGFsZXR0
ZSAoaW5jbHVkaW5nIHNjYW5saW5lIHBhbGV0dGUgc2VsZWN0aW9uLCByZ2IgcGFsZXR0ZSkKCglw
YWwoKSAgLS0gCglwYWwoMikgLS0gcmVzZXQgZGlzcGxheSBwYWxldHRlCgoJLS0gbGluZSBkcmF3
aW5nIHN0YXRlCgoJbWVtc2V0KDB4NTUxZiwgMCwgOSkKCgktLSBiaXRwbGFuZSBtYXNrcwoKCXBv
a2UoMHg1NTA4LCAweDNmKSAtLSByZWFkIG1hc2sgICAgLy8gIG1hc2tzIHJhdyBkcmF3IGNvbG91
ciAoOC1iaXQgc3ByaXRlIHBpeGVsIG9yIHBhcmFtZXRlcikKCXBva2UoMHg1NTA5LCAweDNmKSAt
LSB3cml0ZSBtYXNrICAgLy8gIGRldGVybWluZXMgd2hpY2ggYml0cyB0byB3cml0ZSB0bwoJcG9r
ZSgweDU1MGEsIDB4M2YpIC0tIHRhcmdldCBtYXNrICAvLyAgKHNwcml0ZXMpICBhcHBsaWVzIHRv
IGNvbG91ciB0YWJsZSBsb29rdXAgJiBzZWxlY3Rpb24KCXBva2UoMHg1NTBiLCAweDAwKSAtLSB0
YXJnZXQgbWFzayAgLy8gIChzaGFwZXMpICAgYXBwbGllcyB0byBjb2xvdXIgdGFibGUgbG9va3Vw
ICYgc2VsZWN0aW9uCgoKCS0tIGRyYXcgY29sb3VyCgoJY29sb3IoNikKCgktLSBmaWxsIHBhdHRl
cm4gMHg1NTAwCgoJZmlsbHAoKQoKCS0tIGZvbnRzIChyZXNldCByZWFsbHkgZG9lcyByZXNldCBl
dmVydGhpbmchKQoKCXBva2UoMHg1ZjU2LCAweDQwKSAtLSBwcmltYXJ5IGZvbnQKCXBva2UoMHg1
ZjU3LCAweDU2KSAtLSBzZWNvbmRhcnkgZm9udAoJcG9rZSgweDQwMDAsZ2V0KGZldGNoIi9zeXN0
ZW0vZm9udHMvbGlsLmZvbnQiKSkKCXBva2UoMHg1NjAwLGdldChmZXRjaCIvc3lzdGVtL2ZvbnRz
L3A4LmZvbnQiKSkKCgktLSBzZXQgdGFiIHdpZHRoIHRvIGJlIGEgbXVsdGlwbGUgb2YgY2hhciB3
aWR0aAoKCXBva2UoMHg1NjA2LCAoQDB4NTYwMCkgKiA0KQoJcG9rZSgweDU2MDUsIDB4MikgICAg
ICAgICAgICAgLS0gYXBwbHkgdGFicyByZWxhdGl2ZSB0byBob21lCgoJLS0gbW91c2Vsb2NrIGV2
ZW50IHNlbnNpdGl2aXR5LCBtb3ZlIHNlbnNpdGl2aXR5ICg2NCBtZWFucyB4MS4wKQoJcG9rZSgw
eDVmMjgsIDY0KQoJcG9rZSgweDVmMjksIDY0KQoKCS0tIHdpbmRvdyBkcmF3IG1hc2ssIGludGVy
YWN0aW9uIG1hc2sgCglwb2tlKDB4NTQ3ZCwweDAsMHgwKQoKCS0tIGF1ZGlvIAoJcG9rZSgweDU1
MzgsCgkJMHg0MCwweDQwLCAtLSAoMS4wKSBnbG9iYWwgdm9sdW1lIGZvciBzZngsIG11c2ljCgkJ
MHg0MCwweDQwLCAtLSAoMS4wKSBkZWZhdWx0IHZvbHVtZSBwYXJhbWV0ZXJzIHdoZW4gbm90IGdp
dmVuIHRvIHNmeCgpLCBtdXNpYygpCgkJMHgwMywweDAzICAtLSBiYXNlIGFkZHJlc3MgZm9yIHNm
eCwgbXVzaWMgKDB4MzAwMDAsIDB4MzAwMDApCgkpCgplbmQKCgoKc3JhbmQoKQoKLS0gbmVlZHMg
dG8gYmUgaW4gaGVhZCB0byB3YWtlIHVwIGF1ZGlvIHN5c3RlbSBmb3IgYm9vdCBzb3VuZApjbGVh
cl9pbnN0cnVtZW50KDApCgotLSByZXNldCgpIGRvZXMgbW9zdCBvZiB0aGUgd29yayBidXQgaXMg
c3BlY2lmaWMgdG8gZHJhdyBzdGF0ZTsgc29tZXRpbWVzIHdhbnQgdG8gcmVzZXQoKSBhdCBzdGFy
dCBvZiBfZHJhdygpISAgKHJlZjogamVscGkpCnJlc2V0KCkKCgplbmQ=
:: bios/misc/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-14 00:47:38"]]
:: bios/misc/boot.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDEyOjM3OjA5Iixtb2RpZmllZD0iMjAyNC0w
My0xNCAxMjozNzowOSIscmV2aXNpb249MF1dbHo0AGkBAAAQBwAA8CdweHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwEP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8tDy4P
LxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AQ--8P8BAOvwI1oBEAYPIBAB
IAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJMQAXLzEAIw8rMgBwEAIA
DyyQARMABEUA-REAAhAPj5ABCQIQDxogDfAHCCAPeSAPZvBvDwzwHwTwl1oAHwyKAAsPMADqH-8B
ANz-GPgPQAAIQA9BDzoPPw9GD03--ytB-is-MA3_K-BwD0AADUD_sPBwAwgA-9wf-wEAl1D-----
Hw==
:: bios/misc/confirm.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTA5LTA5IDIxOjA2OjMwIixtb2RpZmllZD0iMjAyNS0wOS0wOSAyMjozNTo1NyIs
cmV2aXNpb249NjFdXQotLVtbCgkKCUxvYWQgQ2FydHJpZGdlIC8gTmV3IENhcnRyaWRnZSAvIFNo
dXRkb3duIC8gUmVib290CgkKCS0_IHdoZW4gdW5zYXZlZCBjaGFuZ2VzIGV4aXN0LCBuZWVkIHRv
IGNvbmZpcm0gdGhhdCBhY3Rpb24KCQoJY29uZmlybS5wNjQgbWlnaHQgaGFuZGxlIG90aGVyIGNv
bmZpcm1hdGlvbnMgbGF0ZXIsIGJ1dAoJZ2VuZXJhbGx5IHdhbnQgdG8gaGFuZGxlIHRoZW0gaW5z
aWRlIHRoZSBwcm9ncmFtIGRvaW5nCgl0aGUgb3BlcmF0aW9uLgoKCWZvbGxvdyBjb252ZW50aW9u
OiBjb25maXJtYXRpb24gYWx3YXlzIG9uIHRoZSByaWdodCAoY2FuY2VsIG9uIGxlZnQpCglhbHNv
OiBzaG91bGQgb25seSBldmVyIGJlIHR3byBjaG9pY2VzCgpdXQoKb25fZXZlbnQoInNhdmVfd29y
a2luZ19jYXJ0X2ZpbGVzX2NvbXBsZXRlZCIsIGZ1bmN0aW9uKG1zZykKCXByaW50aCgiQEBAIFtj
b25maXJtLnA2NF0gc2F2ZV93b3JraW5nX2NhcnRfZmlsZXNfY29tcGxldGVkICIuLnBvZChtc2cp
KQoJaWYgbm90IG1zZy5wd2NfdW5zYXZlZF9jaGFuZ2VzIHRoZW4KCQlpZiAoZW52X3RpdGxlID09
ICJSZWJvb3QiKSBzZW5kX21lc3NhZ2UoMiwge2V2ZW50PSJyZWJvb3QifSkKCQlpZiAoZW52X3Rp
dGxlID09ICJTaHV0ZG93biIpIHNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9InNodXRkb3duIn0pCgkJ
ZXhpdCgpIC0tIHNoaXAgaXMgZ29pbmcgZG93biwgYnV0IGdvIGRvd24gbGlrZSBhIGdlbnRsZW1h
bgoJZW5kCmVuZCkKCmZ1bmN0aW9uIHBlcmZvcm1fY29uZmlybWVkX2FjdGlvbigpCi0tCXByaW50
aCgicGVyZm9ybWluZyAiLi5lbnZfdGl0bGUpCi0tCXByaW50aChwb2QoZW52KCkpKQoJaWYgKGVu
dl90aXRsZSA9PSAiUmVib290Iikgc2VuZF9tZXNzYWdlKDIsIHtldmVudD0icmVib290In0pCglp
ZiAoZW52X3RpdGxlID09ICJTaHV0ZG93biIpIHNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9InNodXRk
b3duIn0pCglpZiAoZW52X3RpdGxlID09ICJMb2FkIikgY3JlYXRlX3Byb2Nlc3MoIi9zeXN0ZW0v
dXRpbC9sb2FkLmx1YSIsIHsgYXJndiA9IHtlbnYoKS5jYXJ0X3RvX2xvYWR9fSkKCWlmIChlbnZf
dGl0bGUgPT0gIk5ldyBDYXJ0IikgdGhlbgoJCWNyZWF0ZV9wcm9jZXNzKCIvc3lzdGVtL2FwcHMv
ZmlsZW5hdi5wNjQiLAoJCXsgCgkJCWFyZ3YgPSB7ZW52KCkuY2FydF9wYXRofSwKCQkJaW50ZW50
aW9uID0gIm5ld19jYXJ0cmlkZ2UiLAoJCQktLSBpbnRlbnRpb25fZmlsZW5hbWUgPSBwMiwgLS0g
cGFzcyBhbG9uZyBpZiB0aGVyZSBpcyBvbmUKCQkJd2luZG93X2F0dHJpYnM9e2F1dG9jbG9zZT10
cnVlfSAtLSBjbG9zZSBhZnRlciBwcm9jZXNzaW5nIGludGVudGlvbjsgdGhlIHdtIHdpbmRvdyBz
dGFjayBpcyB0aGUgaW50ZW50aW9uIHN0YWNrIQoJCX0pCgllbmQKCWlmIChlbnZfdGl0bGUgPT0g
IkNsb3NlIikgdGhlbgoJCS0tIHRvIGRvOiByZW1vdmUgbmVlZCBmb3IgdGhlc2UgMiBzZXBhcmF0
ZSBtZXNzYWdlcyAocmVsaWVzIG9uIG1lc3NhZ2UgcHJvY2Vzc2luZyBvcmRlciBzbyB0aGF0IGNv
bmZpcm1fY2xvc2Vfd2luZG93IGNhbiBjb21wbGV0ZSkKCQlzZW5kX21lc3NhZ2UoZW52KCkucHJv
Y19pZCwge2V2ZW50PSJjb25maXJtX2Nsb3NlX3dpbmRvdyJ9KSAtLSBwbGFjZWhvbGRlciBldmVu
dAoJCXNlbmRfbWVzc2FnZShlbnYoKS5wcm9jX2lkLCB7ZXZlbnQ9ImV4aXQifSkKCQktLXNlbmRf
bWVzc2FnZSgzLCB7ZXZlbnQ9ImNsb3NlX3dpbmRvdyIsIHByb2NfaWQgPSBlbnYoKS5wcm9jX2lk
fSkKCWVuZAoKCWV4aXQoKQplbmQKCgpmdW5jdGlvbiBfaW5pdCgpCgoJZW52X3RpdGxlID0gZW52
KCkudGl0bGUgb3IgIiIKCWVudl9wcm9tcHQgPSBlbnYoKS5wcm9tcHQgb3IgIkRvIE5vdGhpbmc-
IgoJCglpZiAoZW52X3RpdGxlID09ICJSZWJvb3QiIG9yIGVudl90aXRsZSA9PSAiU2h1dGRvd24i
IG9yIGVudl90aXRsZSA9PSAiTG9hZCIgb3IgZW52X3RpdGxlID09ICJOZXcgQ2FydCIpIHRoZW4K
CgkJLS0gY2hlY2sgaWYgdGhlcmUgYXJlIHVuc2F2ZWQgY2hhbmdlczsgYm90aCBhcmUgYmxvY2tp
bmcKCQlzZW5kX21lc3NhZ2UoMywge2V2ZW50PSJzYXZlX3dvcmtpbmdfY2FydF9maWxlcyJ9LCB0
cnVlKSAtLSBibG9ja2luZwoKCQlsb2NhbCB1bnNhdmVkX2NoYW5nZXMgPSBzZW5kX21lc3NhZ2Uo
MywgewoJCQktLSByZWJvb3QgLyBzaHV0ZG93biBwcm9tcHQgYXNrIGZvciBjb25maXJtYXRpb24g
d2hlbiBhbnkgc2luZ2xlIGZpbGUgZWRpdG9ycyBoYXZlIHVuc2F2ZWQgY2hhbmdlcwoJCQktLSBs
b2FkIC8gbmV3IGNhcnQgb25seSBuZWVkcyBjb25maXJtYXRpb24gd2hlbiBwd2MgaGFzIHVuc2F2
ZWQgY2hhbmdlcyAoL3JhbS9jYXJ0IGZpbGUgZWRpdGVkIHNpbmNlIGxhc3Qgc2F2ZSkgCgkJCWV2
ZW50ID0gKGVudl90aXRsZSA9PSAiUmVib290IiBvciBlbnZfdGl0bGUgPT0gIlNodXRkb3duIikg
YW5kICJhbnlfdW5zYXZlZF9jaGFuZ2VzIiBvciAicHdjX3Vuc2F2ZWRfY2hhbmdlcyIKCQl9LCB0
cnVlKS5yZXN1bHQKCgkJaWYgbm90IHVuc2F2ZWRfY2hhbmdlcyB0aGVuCgkJCXBlcmZvcm1fY29u
ZmlybWVkX2FjdGlvbigpCgkJZW5kCgoJZW5kCgkKCXdpbmRvd3sKCQl3aWR0aD0xNDAsaGVpZ2h0
PTUwLAoJCXRpdGxlPSJDb25maXJtICIuLmVudl90aXRsZSwKCQl4ID0gMjQwLTcwLAoJCXkgPSAx
MzUtMjUKCX0KCQoJZ3VpID0gY3JlYXRlX2d1aSgpCgkKCWd1aTphdHRhY2hfYnV0dG9uewoJCXg9
MTYseT0tNixqdXN0aWZ5PSJsZWZ0Iix2anVzdGlmeT0iYm90dG9tIiwKCQlsYWJlbD0iQ2FuY2Vs
IiwKCQlib3JkZXI9MHgwZTBkLAotLQkJaGlnaGxpZ2h0ID0gMHgwNzA3LAoJCXRhcD1mdW5jdGlv
bigpCgkJCWV4aXQoKQoJCWVuZAoJfQoJCglndWk6YXR0YWNoX2J1dHRvbnsKCQl4PS0xNix5PS02
LGp1c3RpZnk9InJpZ2h0Iix2anVzdGlmeT0iYm90dG9tIiwKCQlsYWJlbD0iICBPSyAgIiwKCQli
b3JkZXI9MHgwZTBkLAotLQkJaGlnaGxpZ2h0ID0gMHgwNzA3LAoJCXRhcCA9IHBlcmZvcm1fY29u
ZmlybWVkX2FjdGlvbgoJCQoJfQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg2KQoJcHJpbnQo
ZW52X3Byb21wdCwxMCwxMCwxKQoJZ3VpOmRyYXdfYWxsKCkKZW5kCgpmdW5jdGlvbiBfdXBkYXRl
KCkKCWd1aTp1cGRhdGVfYWxsKCkKZW5kCjo6IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0iemVw
IixjcmVhdGVkPSIyMDI1LTA5LTA5IDIxOjA2OjA2IixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYs
IjAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3
MDcwMTAwMDAwMDAxMDcxMjEyMTIxMjEyMTIxMjEyMTIxMjA3MDEwMDAxMDcxMjEyMTIxNzE3MTcx
NzE3MTcxMjEyMTIwNzAxMDEwNzEyMTIxNzE3MTcxNzE3MTcxNzE3MTIxMjA3MDEwMTA3MTIxMjE3
MTcxMjEyMTIxNzE3MTcxMjEyMDcwMTAxMDcxMjEyMTIxMjEyMTcxNzE3MTcxMjEyMTIwNzAxMDEw
NzEyMTIxMjEyMTIxNzE3MTIxMjEyMTIxMjA3MDEwMTA3MTIxMjEyMTIxMjEyMTIxMjEyMTIxMjEy
MDcwMTAxMDcxMjEyMTIxMjEyMTcxNzEyMTIxMjEyMTIwNzAxMDEwNzEyMTIxMjEyMTIxNzE3MTIx
MjEyMTIxMjA3MDEwMTFkMDcxMjEyMTIxMjEyMTIxMjEyMTIxMjA3MWQwMTAxMWQxZDA3MDcwNzA3
MDcwNzA3MDcwNzA3MWQxZDAxMDAwMTFkMWQxZDFkMWQxZDFkMWQxZDFkMWQxZDAxMDAwMDAwMDEx
ZDFkMWQxZDFkMWQxZDFkMWQxZDAxMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAw
IiksbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLG5vdGVzPSJDaG9vc2Ugd2lzZWx5XG5c
bkkgd2lsbCBub3QgYXNrIHlvdSBhIHNlY29uZCB0aW1lIixydW50aW1lPTIxLHRpdGxlPSJDb25m
aXJtIix2ZXJzaW9uPSIiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMjMiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHts
b2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5z
ZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRl
ZD0iMjAyNS0wOS0wOSAyMTowNjowNiIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiXV0K
OjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExURTNJREV3
T2pNMU9qUTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTVMweE55QXhNRG96TnpvME5DSXNjbVYy
YVhOcGIyNDlNbDFkYkhvMEFINEFBQUFTTVFBQTh5RjdXekJkUFh0aWJYQTljSGgxQUVNZwpFQkFF
OEZZSEVBZkFGOUFYd0FjUUItQldMR1pzWVdkelBUQXNjR0Z1WDNnSUFNdDVQVEFzZW05dmJUMDRm
U3dfQUItd01RRC0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tWFVHMDlPSDE5Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVh
dGVkPSIyMDI1LTA5LTA5IDIxOjA2OjA2Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJd
XQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lE
RXdPak0xT2pRNElpeHRiMlJwWm1sbFpEMGlNakF5TlMwdwpPUzB3T1NBeU1Ub3dOam93TmlJc2Nt
VjJhWE5wYjI0OU1sMWRiSG8wQUV3QUFBQlFBQUFBOFJ4N2UySnRjRDF3ZUhVQVRJQWdJQUQtCkFB
RC0tLThETEdocFpHUmxiajFtWVd4elpTeHdZVzVmZUQwd0NBRFNlVDB3TEhScGJHVmZhRDB4Tmdv
QUVIY0tBSUI2YjI5dFBURjkKZlE9PQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0i
MjAyNS0wOS0wOSAyMTowNjowNiIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiXV0KOjog
c2Z4LzAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBM0xUTXhJREE0T2pN
d09qSTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTnkwek1TQXdPRG96TURveU9DSXNjbVYyYVhO
cGIyNDlNRjFkYkhvMEFLQUFBQUFMQ2dBQS16QndlSFVBQXlnQUFBUUFCQTlBRUFJTwpBQUdnQVNB
Q29BNEFEeEFBRGZES0FRSURRQThQa0FRRkJnZEFESkFJQ1FvTFFBeVFEd3dQRFE4T0RFQU04UDhC
QU92LUo2b0JFQVlQCk1CQUJJQUVnQWZBQUFoQUNEaEFCSUE4aElBRXdEMER3d3c4b0QtLXd4Zy00
Q2ctLUQ0QVA5dzhOQWZBSkFSQUdEakFBLS0tLS0tXzkKSC04QkFLelB5QTlBQUE4UVFQLS1zUEQt
QVFELTZsRC0tLS0tS1E9PQo6OiBbZW9jXQo=
:: bios/misc/cursors.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTA3IDA4OjQ3OjEyIixtb2RpZmllZD0iMjAyNS0w
My0yNyAwMDozNjowMSIscmV2aXNpb249MzRdXWx6NAC6AQAAwzMAAPMUe1swXT17Ym1wPXB4dQBD
IBAQBPDwLGZsYWdzPTAscGFuX3gIANt5PTAsem9vbT0xMX0sMgD-DWgB0AEHAcABFwGwAScBoAE3
AZABFxGwEQcB8BRNAB4RSE0A-wewASABkAEHIAcBkAEgAbABBwHQAfA3TQAeMTYBAD0AUQcRkAEH
AgATgAgA-wdwEUcBYAEHAUcBcAFXAYABNwGgMfAmYQAeN1ZBkFEAAEsAD08AKhNYSgFfBxEAAZCq
AAkfBKUBIQ9XAEHCOAGwIQcBAAFwARcRVwAABgBwBwFgAQABN2EALxE3EwErMSNBoFUCIQcRyQFh
AaARAAEHJwExABGgEgAAaQIBJAA-QfAjXwAeEShfAAJDAABNABGQWQAzUBEADAATB3sAAV8AHyhf
AB4wRAFQBQFAUQcBQAsBEREIABBRHwFPUAHwVE8AHhMXHQMAmAAysCHALAIGBAATIRoAASEBL-AY
XwAeEypfAFUnAZABJ-8AbxcBsCHwV00AHh-wMgD-------------------------------------
-------------------------31QPTExfX0=
:: bios/misc/default_settings.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTA5LTA0IDA3OjA5OjM4Iixtb2RpZmllZD0iMjAyNC0w
My0xNCAwNDoxMTo0NiIscmV2aXNpb249NDYwNV1dbHo0AAkBAABxAQAA9BR7YmF0dGVyeV9zYXZl
cj1mYWxzZSxiZWphbmdsZV9jdXJzbxYA5GZsb3BweV93aW5kb3dzFQDzCnVsbHNjcmVlbj10cnVl
LG11dGVfYXVkaW8hAOJuZXR3b3JrX2FjY2VzcyUA0nBpeGVsX3BlcmZlY3QTAONyc2hpZnRfbWFn
bmlmeTwADxQAAmRwYXJrbGWAAGxzcXVpc2iWAHpzdHJldGNoDgAzX3RvJwAEGACUd2FwX3N0ZXJl
rQDTc3lzdGVtX3ZvbHVtZRQAgnRoZW1lPSIvHAARLw8AcXMvYXF1YS4MALYiLHdhbGxwYXBlciYA
BRMA8AJzL3BhdGNod29yay5wNjQifQ==
:: bios/misc/default_widgets.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTA2IDIzOjE5OjQwIixtb2RpZmllZD0iMjAyNS0w
MS0wNiAyMzoyMDo1NSIscmV2aXNpb249MjFdXWx6NABEAAAAWgAAAP8de3twcm9nPSIvc3lzdGVt
L3dpZGdldHMvb3dsLnA2NCIseD00NTQseT00fSwrAARUY2xvY2stAKAzNzgseT0xMH19
:: bios/misc/drive.loc
b64$LS1bW3BvZCxhdXRob3I9IiIsY3JlYXRlZD0iMjAyMy0xMC0wNSAxNTo0NDozNyIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDEwNzA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAx
MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjAxMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYw
NjA2MDEwMTA2MDYwZDBkMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9IjIwMjUtMDMt
MjYgMDA6MjA6MTYiLG5vdGVzPSJTaG9ydGN1dCB0byAvIixyZXZpc2lvbj0xLHN0b3JlZD0iMjAy
NC0wMy0xNCAwNDoxNjowMSIsdGl0bGU9IlBpY290cm9uIERyaXZlIix2ZXJzaW9uPSIiXV1sejQA
DwAAAA4AAADge2xvY2F0aW9uPSIvIn0=
:: bios/misc/new_cart.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3Il1dCgo6
OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmll
ZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBnZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRl
ZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiXV0K
OjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExURTNJREV3
T2pNMU9qUTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTVMweE55QXhNRG96TnpvME5DSXNjbVYy
YVhOcGIyNDlNbDFkYkhvMEFINEFBQUFTTVFBQTh5RjdXekJkUFh0aWJYQTljSGgxQUVNZwpFQkFF
OEZZSEVBZkFGOUFYd0FjUUItQldMR1pzWVdkelBUQXNjR0Z1WDNnSUFNdDVQVEFzZW05dmJUMDRm
U3dfQUItd01RRC0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tWFVHMDlPSDE5Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVh
dGVkPSIyMDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJd
XQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lE
RXdPak0xT2pRNElpeHRiMlJwWm1sbFpEMGlNakF5TlMwdwpNUzB4TnlBeE1Eb3pOem8wTkNJc2Nt
VjJhWE5wYjI0OU1WMWRiSG8wQUZRQUFBQkVFQUFBOEFoN2UySnRjRDExYzJWeVpHRjBZU2dpCmFU
RTJJaXd6TWdNQUx5SXdBUUQtLS0tLS0tLS0tLS0tLS0tLS0tLTdvU0lwTEhCaGJsOTRQVEFJQU5K
NVBUQXNkR2xzWlY5b1BURTIKQ2dCZ2R6MHhObjE5Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxj
cmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0Nzoz
OCJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEEzTFRN
eElEQTRPak13T2pJNElpeHRiMlJwWm1sbFpEMGlNakF5TlMwdwpOeTB6TVNBd09Eb3pNRG95T0NJ
c2NtVjJhWE5wYjI0OU1GMWRiSG8wQUtBQUFBQUxDZ0FBLXpCd2VIVUFBeWdBQUFRQUJBOUFFQUlP
CkFBR2dBU0FDb0E0QUR4QUFEZkRLQVFJRFFBOFBrQVFGQmdkQURKQUlDUW9MUUF5UUR3d1BEUThP
REVBTThQOEJBT3YtSjZvQkVBWVAKTUJBQklBRWdBZkFBQWhBQ0RoQUJJQThoSUFFd0QwRHd3dzhv
RC0td3hnLTRDZy0tRDRBUDl3OE5BZkFKQVJBR0RqQUEtLS0tLS1fOQpILThCQUt6UHlBOUFBQThR
UVAtLXNQRC1BUUQtNmxELS0tLS1LUT09Cjo6IFtlb2NdCg==
:: bios/misc/nocart.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTA4LTE2IDAzOjMxOjM0Iixtb2RpZmllZD0iMjAyNC0wOC0xNiAwMzozNDo1MCIs
cmV2aXNpb249MzddXQpmdW5jdGlvbiBfZHJhdygpCmNscygpCnN0cj0iXF46MDBmZjgxODFmZmMx
N2YwMCA-Igp3dz1wcmludChzdHIsMCwtMTAwKQpwcmludChzdHIsMjQwLXd3LzIsMTIwLDcpCgpz
dHI9Im5vIGNhcnRyaWRnZSBmb3VuZCIKd3c9cHJpbnQoc3RyLDAsLTEwMCkKcHJpbnQoc3RyLDI0
MC13dy8yLDE0MCwxMykKCmVuZAoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0w
OC0xNiAwMzozNDo1MSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHJ1bnRpbWU9OCx3
b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzEwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1h
cCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgtMTYgMDM6
MzQ6NTEiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IGdmeC8wLmdmeApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQTRMVEUySURBek9qTXhPak0wSWl4dGIyUnBa
bWxsWkQwaU1qQXlOQzB3Ck9DMHhOaUF3TXpvek5EbzFNQ0lzY21WMmFYTnBiMjQ5TWpKZFhXeDZO
QUJfQUFBQUVqRUFBUE1oZTFzd1hUMTdZbTF3UFhCNGRRQkQKSUJBUUJQQldCeEFId0JmUUY4QUhF
QWZ3Vml4bWJHRm5jejB3TEhCaGJsOTRDQURMZVQwd0xIcHZiMjA5T0gwc1BnQWY4REVBLS0tLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0xMUJ0UFRoOWZRPT0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgt
MTYgMDM6MzQ6NTEiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IG1hcC8wLm1h
cApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQTRMVEUySURBek9qTXhPak0wSWl4
dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck9DMHhOaUF3TXpvek5EbzFNQ0lzY21WMmFYTnBiMjQ5TWpK
ZFhXeDZOQUJVQUFBQVJCQUFBUEFJZTN0aWJYQTlkWE5sY21SaGRHRW8KSW1reE5pSXNNeklEQUM4
aU1BRUEtLS0tLS0tLS0tLS0tLS0tLS0tLV82RWlLU3h3WVc1ZmVEMHdDQURTZVQwd0xIUnBiR1Zm
YUQweApOZ29BWUhjOU1UWjlmUT09Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDI0LTA4LTE2IDAzOjM0OjUxIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBz
ZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEE0TFRFMklEQXpPak14
T2pNMElpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpPQzB4TmlBd016b3pORG8xTUNJc2NtVjJhWE5w
YjI0OU1qTmRYV3g2TkFDZ0FBQUFDd29BQVA4d2NIaDFBQU1vQUFBRUFBUVBRQkFDCkRnQUJvQUVn
QXFBT0FBOFFBQTN3eWdFQ0EwQVBENUFFQlFZSFFBeVFDQWtLQzBBTWtBOE1EdzBQRGd4QURQRC1B
UURyLXllcUFSQUcKRHlBUUFTQUJJQUh3QUFJUUFnNFFBU0FQSVNBQk1BOUE4TU1QS0EtLThNWVBf
QW9QLXdfQUQtY1BEUUh3Q1FFUUJnNHdBUC0tLS0tLQp2Ui0tQVFDc3o4Z1BRQUFQRUVELS03RHct
d0VBLV9wUS0tLS0teWs9Cjo6IFtlb2NdCg==
:: bios/misc/p64_cart.png
b64$iVBORw0KGgoAAAANSUhEUgAAAgAAAAGACAYAAADbINq-AAAKO0lEQVR4Ae3dPW6bB77F4b8P
uIdk3iWkchYwgIsAt6F2YAOuorsBNW4MN9N4A1epDNg7iJoLTBFgFjCpsgTOZBW6d5BREHlkfdmk
RJ7naSSS7wf1I6HTPplbWJbl-DbHAQAPb7PZ3Ljv1x5g_AFgf202m0-u-JUvfDz86-WRigCwJ87O
frz0eLPZ-MfeX3rC8APA4Tg7_-HS481m8-vu56oT1usj4w8Ae_66Pc-FL8uynF8cDAAcjottv9j6
mZnIAgB9MjOzLMv5zMx6faQIABygi42-2PxIAgB9sizL_czMen2kBgAcsIutX5blPHIAQJ9IAAB9
Vtu8_OnbN3c6-vjktU8EAHYgEgBAn9VjejOnb9-MzMzxyet7nfcpF9e77XE3Xfe2x933-jcdt6v3
AbDvnr94eavjPrx-9yDH3-T8NsXXAwD6rLZ58eOT1zMz87f-_p8rX--lu19-__UvP-3289WzO13-
9O2bK_-38fM3vX7x-E3X3dX9b3vefd-HTde-_HnT_wJ47D68f3fl889fvPys87-U8Q8pvh4A0Ge1
zYufvn3z799_vfT8N3-96vKBr5594fsdlo--ruOT1765ALfw-MXLrZz-4f27rRz-qeO2Ib4eANBn
tZO7-OWn336_enbp6W-__tWlx3-_3--_rNscn7w_yA-p4u86ffvm0s9D-XsBtuXD_3f3ev35i5d3
uv59j7-4edP7-BLi6wAAfVY7ucurZ5ce-vLdr1cf992bmZk5Pnm9lbdx_va363-q_U-d9_PzPve4
bXss7wPgsXn_4uWVz394-_7a1z-3_o9RfB0AoM_TZVnOZ2bW66Ot3eT07Zs7HX988tonAwBbcHb2
48zMRAoA6LPaxU2OT14rDQCPSCQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_
q-ue_MMPp_oBwAP7-vvje50X6QCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8k
AIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA
_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgT
CQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQA
gD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6
RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJ
AKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACA
PpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpE
AgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkA
oE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_
kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQC
AOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCg
TyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6R
AAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA
6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBP
JACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEA
APpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDo
EwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8k
AIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA
_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgT
CQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoM-qvid_--2xegCwpyIBAPSJBADQ
JxIAQJ9IAAB9IgEA9IkEANAnEgBAn0gAAH1WEvynn3-_uwgAB_Tp029F_EgkMP4A-rf3iQQA0CcS
AECfSAAAfSIBAPRZPaY3889--uPa17-__k8_MQD4Alb7Mv4AsG9u2ravv-7Tg7237Mv4P2QkANjG
tj2k7Pv4P-bAABj-u27bLuQQxv821wGAfdq2bcuhBNpVMADY9rbtYtNyCON-l_sCwD5s27Y3LYcy
-rsKBgC72rZtbloOafxvOh8A9m3bbnP9_4jxB4C_bYtAANC3bREIAPq2LQIBQN_2rQ410MX5u4gI
gPHfp-GfmVkd8vgDwKFt23XH3EWMPwD0bVsEAoC_bYtAANC3bdlVROMPgPF-PNsW4w8AfdsWgQCg
b9tyyIGuOx8AWsd-ZibGHwD6ti0CAUDftkUgAOjbttUu4hh-AIz-49q21S7iGX8ADmn4D2HbYvwB
oG-bIhAA9G1bBAKAvm2LQADQt23ZxkVv_gOMPwDG-2G3Ldu68Kf_EOMPwL65aXv2cduyy2DGH4B9
9akN2tdty66CGX8A9t3HW7TP25aHCGb8AdhXF5u079uWh7y58QdgH_37_M-MZF8DA8Bj89jH-_zs
x99-Xxl4ADj83fvj_G82mycrHwcA7P-A32X8Z2bi4wKAw3XV_M-MRBoA6Br-mZnIAwBd4z8zE4kA
oGv8Z2YiEwB0jf-MTKQCgK7xn5mJXADQNf4zM5HssqdPvxUBwP-2gx7-mZmVr0XfFwWA7vGfmYl0
ANA1-jMzT2ZmlmU5n5lZr4-UBIADH-_ZmUgIAF3jPzPz_0nLspzPzKzXR8oCwAGP-8xMpASArvGf
mbl08rIs5zMz6-WRygBwoOM-M7O67ibr9ZHiAHBg4---_z9XXmRZlvM-Pl6vj9QHgAMZ-5mZay_0
LMu59ADwMDabzSzL8sfH1_72XdzqQsuynPsYAODhfMnx-5f-A--AE4_lscm7AAAAEHRFWHRMb2Rl
UE5HADIwMTEwMjIx41m2wQAAAABJRU5ErkJggg==
:: bios/misc/ram_info.pod
b64$LS1bW3BvZCxhdXRob3I9IiIsY3JlYXRlZD0iMjAyNC0wNC0wMyAwMDozMToyOSIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAw
MTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDYwNjBkMDYwNjBkMDYw
NjBkMGQwNzAxMDEwNzBkMGQwNjA2MGQwNjA2MGQwNjA2MGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBk
MGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDYwNjBkMDYwNjBkMDYwNjBkMGQwNzAxMDEwNzBkMGQw
ZDBkMGQwZDBkMGQwNjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDA2MDYwZDA2MDYwZDBkMDcwMTAx
MDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQw
NzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEw
MTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVkPSIyMDI0LTA0LTE0IDAxOjQzOjQ1Iixub3Rl
cz0iVGhpcyBmb2xkZXIgZXhpc3RzIG9ubHkgaW4gbWVtb3J5XG5hbmQgd2lsbCBkaXNhcHBlYXIg
YWZ0ZXIgc2h1dGRvd24uIixzdG9yZWQ9IjIwMjQtMDQtMDMgMDA6NTE6MTYiLHRpdGxlPSIiLHZl
cnNpb249IiJdXWx6NAAEAAAAAwAAADBuaWw=
:: bios/misc/tooltray.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTEwIDAzOjU0OjA4Iixtb2RpZmllZD0iMjAyNC0wMy0xMCAwMzo1OTozMiIs
cmV2aXNpb249MTRdXQotLSBwbGFjZWhvbGRlciBiYWNrZ3JvdW5kIGZvciB0b29sdHJheQotLSB0
byBkbzogdG9vbHRyYXkgdGhlbWUgaXMgdXNlZCBmb3IgImRlc2t0b3AqIiBpbiB0aGF0IGNvbnRl
eHQ-CmZ1bmN0aW9uIF9kcmF3KCkKCWNscygxKQplbmQKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjUtMTEtMTMgMjE6MDc6NDMiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4
IixzdG9yZWQ9IjIwMjQtMDMtMTAgMDM6NTk6MzIiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFp
bi5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNl
X2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwL21hcDAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xv
Y2F0aW9uPSJzZngvc2Z4MC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8u
cG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wMy0xMCAwMzo1NDowOCIsbW9kaWZpZWQ9IjIwMjUt
MTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyNC0wMy0xMCAwMzo1NDowOCJdXQo6OiBnZngvMC5n
ZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRFd0lEQXpPalUwT2pBNElp
eHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB4TUNBd016bzFPVG96TWlJc2NtVjJhWE5wYjI0OU1U
QmRYV3g2TkFCdEFBQUFCVEVBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lX
ZHpQVEFzY0dGdVgzZ0lBTTk1UFRBc2VtOXZiVDA0ZlN3eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUWJUMDRmWDA9Cjo6
IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTEwIDAzOjU0OjA4Iixtb2Rp
ZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTAzLTEwIDAzOjU0OjA4Il1d
Cjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEV3
SURBek9qVTBPakE0SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHhNQ0F3TXpvMU9Ub3pNaUlz
Y21WMmFYTnBiMjQ5TVRCZFhXeDZOQUJTQUFBQVR3UUFBUEFNZTFzd1hUMTdZbTF3UFhWelpYSmsK
WVhSaEtDSnBNVFlpTERFMkF3QXZJakFCQVAtLS1fX2hJaWtzY0dGdVgzZzlNQWdBMG5rOU1DeDBh
V3hsWDJnOU1UWUtBQkIzQ2dDQQplbTl2YlQweGZYMD0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9k
LGNyZWF0ZWQ9IjIwMjQtMDMtMTAgMDM6NTQ6MDgiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3
OjM4IixzdG9yZWQ9IjIwMjQtMDMtMTAgMDM6NTQ6MDgiXV0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRM
UzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxURXdJREF6T2pVME9qQTRJaXh0YjJScFpt
bGxaRDBpTWpBeU5DMHcKTXkweE1DQXdNem8xT1Rvek1pSXNjbVYyYVhOcGIyNDlOMTFkYkhvMEFC
QUJBQUJSQndBQThDZHdlSFVBQXlnQUFBTUFCQTlBRUFJTwpBQUdnQVNBQ29BNEFEeEFBRGZES0FR
SURCQVVHQndFUC01QUlDUW9MRHd3UERROE9EdzhRQVBBQURROFJEeElQRXc4VUR4VVBGZzhYCkV3
RHhBUThZRHhrUEdnOGJEeHdQSFE4ZUR4OFVBUEVBSUE4aER5SVBJdzhrRHlVUEpnOG5GQUR4QUNn
UEtROHFEeXNQTEE4dER5NFAKTHhRQThRQXdEekVQTWc4ekR6UVBOUTgyRHpjVUFQOEZPQTg1RHpv
UE93ODhEejBQUGc4LUFRLS04UDhCQU92LUoxb0JFQVlQSUJBQgpJQUVnQWZBQUFoQUNEQkFCSUE4
aElBRXdEMER3d3c4b0QtLXd4Zy00Q2ctLUQ0QVA5dzhOQWZBSkFSQUdEREFBLXprZi13RUEzTC00
CkQwQUFEVUQtLTdEd2NBb0EtLTlrSC04QkFKZFEtLS0tLXg4PQo6OiBbZW9jXQo=
:: bios/pm/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-14 00:47:38"]]
:: bios/screensavers/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: bios/screensavers/breach.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTM1LTAyIDIwOjM1OjIxIixtb2RpZmllZD0iMjAyNC01Mi0wMiAyMDo1MjoyNyIs
cmV2aXNpb249MTkxXV0KCmxvY2FsIHR0PTAKCgpmdW5jdGlvbiBfZHJhdygpCgljbHMoKQoJbG9j
YWwgcnI9IDMwCgkKCWZvciBpPTAsOCwyIGRvIHR0Kz0wLjAxCgkKCW14ID0gMjQwK2Nvcyh0dC8x
NykqMTIwCglteSA9IDEzNStzaW4odHQvMTIpKjgwICsgc2luKHR0LzE3KSo1MAoJCgkKCWZvciB4
PTAsMjMgZG8KCQlmb3IgeT0yMiw0NSBkbwkKCQkJbG9jYWwgc3ggPSAgeCo2KjMgKyAoeSUyKSo5
CgkJCWxvY2FsIHN5ID0gIHkqNAoJCQlsb2NhbCBkeCxkeSA9IG14LXN4LCBteS1zeQoJCQlkeC89
OCBkeS89OAoJCQlsb2NhbCBhYSA9IGF0YW4yKGR4LCBkeSkKCQkJbG9jYWwgcSA9IHNxcnQoZHgq
ZHgsZHkqZHkpCgkJCQoJCQlzeCAtPSBjb3MoYWEpKjQ1CgkJCXN5IC09IHNpbihhYSkqNDUKCQkJ
cHNldChzeCxzeSwxMitpKQoJCWVuZAoJCWxvY2FsIGFhPXgvMjQtdHQvOAoJCQoJCXBzZXQobXgr
Y29zKGFhKSpycixteStzaW4oYWEpKnJyLDgrKCh4K2FhKjEyKSU5KSkKCWVuZAoKCWVuZAoJCgkt
LXByaW50KHN0YXQoMSksNDAwLDIsNykKCS0tY2lyYyhteCxteSxyci8yLDcpCmVuZAoKOjogLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIw
MjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyNC01Mi0wMiAyMDo1MjoyNyIsd29ya3NwYWNl
cz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4
LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvbWFwMC5tYXAiLHdvcmtz
cGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC9zZngwLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9
fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTAyIDIwOjM1OjIx
Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTM1LTAyIDIwOjM1
OjIxIl1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUTTFM
VEF5SURJd09qTTFPakl4SWl4dGIyUnBabWxsWkQwaU1qQXlOQzAxCk1pMHdNaUF5TURvMU1qb3lO
eUlzY21WMmFYTnBiMjQ5TVRFMVhWMXNlalFBY1FBQUFBVXpBQUR6Rkh0Yk1GMDllMkp0Y0Qxd2VI
VUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NENBRHZlVDB3TEhOallXeGxQVEV5ZlN3ekFQ
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLTUxQTlNVEo5ZlE9PQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0i
MjAyNC0xMC0wMiAyMDozNToyMSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3Jl
ZD0iMjAyNC0zNS0wMiAyMDozNToyMSJdXQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4
amNtVmhkR1ZrUFNJeU1ESTBMVE0xTFRBeUlESXdPak0xT2pJeElpeHRiMlJwWm1sbFpEMGlNakF5
TkMwMQpNaTB3TWlBeU1EbzFNam95TnlJc2NtVjJhWE5wYjI0OU1URTBYVjFzZWpRQWFRQUFBS01J
QUFEd0UzdHNZWGxsY2oxN1d6QmRQWHRpCmJYQTlkWE5sY21SaGRHRW9JbWt4TmlJc01UWURBQzhp
TUFFQS0tLS03NkVpS1N4d1lXNWZlRDB3Q0FEeUJuazlNQ3h6WTJGc1pUMHgKTEhScGJHVmZhRDB4
TmdvQWIzYzlNVFo5TEVzRS0tLS0temhRTVRaOWZYMD0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9k
LGNyZWF0ZWQ9IjIwMjQtMTAtMDIgMjA6MzU6MjEiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3
OjM4IixzdG9yZWQ9IjIwMjQtMzUtMDIgMjA6MzU6MjEiXV0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRM
UzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRNMUxUQXlJREl3T2pNMU9qSXlJaXh0YjJScFpt
bGxaRDBpTWpBeU5DMDEKTWkwd01pQXlNRG8xTWpveU55SXNjbVYyYVhOcGIyNDlNVEV6WFYxc2Vq
UUFFQUVBQUZFSEFBRHdKM0I0ZFFBREtBQUFBd0FFRDBBUQpBZzRBQWFBQklBS2dEZ0FQRUFBTjhN
b0JBZ01FQlFZSEFRLS1rQWdKQ2dzUERBOE5EdzRQRHhBQThBQU5EeEVQRWc4VER4UVBGUThXCkR4
Y1RBUEVCRHhnUEdROGFEeHNQSEE4ZER4NFBIeFFBOFFBZ0R5RVBJZzhqRHlRUEpROG1EeWNVQVBF
QUtBOHBEeW9QS3c4c0R5MFAKTGc4dkZBRHhBREFQTVE4eUR6TVBOQTgxRHpZUE54UUEtd1U0RHpr
UE9nODdEendQUFE4X0R6OEJELS13LXdFQTYtOG5XZ0VRQmc4ZwpFQUVnQVNBQjhBQUNFQUlNRUFF
Z0R5RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JFQVlNTUFELU9SLS1BUURj
CnYtZ1BRQUFOUVAtLXNQQndDZ0QtLTJRZi13RUFsMUQtLS0tLUh3PT0KOjogW2VvY10K
:: bios/screensavers/bunny.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBib25lcy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3Jl
YXRlZD0iMjAyNC0zMi0wNSAwNzozMjozOCIsbW9kaWZpZWQ9IjIwMjQtMjUtMDUgMDg6MjU6NDUi
LHJldmlzaW9uPTI0NF1dCi0tW1sKCgkKCl1dCgpmdW5jdGlvbiBib25lKHgseSxhKQogbG9jYWwg
bCA9NwogbG9jYWwgYj02NgogCiBhKz0xLzI4CiBhJT0xCiBsb2NhbCBxPSBmbHIoYSo0KSAtLSAw
Li4zIC0tIHdoaWNoIGdyb3VwIG9mIDcKIGxvY2FsIG9mcz17WzBdPQogIDEsNSwgNSw1LCA1LDEs
IDEsMQogfQogCiAtLWxpbmUoeCx5LHgrY29zKGEpKmwseStzaW4oYSkqbCwgMTQpCgogbG9jYWwg
aT1mbHIoKGElMC4yNSkqMjgpCiBiID0gZmxyKGEqMjgpCiB4LT1vZnNbcSoyKzBdCiB5LT1vZnNb
cSoyKzFdCgogc3ByKGIseCx5KQogCmVuZAoKCmZ1bmN0aW9uIGRyYXdfc2tlbGx5KHMpCgoJbG9j
YWwgYT1zLnBvc2UKCWxvY2FsIHN4PTAKCWxvY2FsIHN5PTAKCWxvY2FsIHgseQoJbG9jYWwgbD03
Cglsb2NhbCBsbD04IC0tIGxlZyBsZW5ndGgKCglwZGF0PXtbMF09CgkJezcsLTYsN30sCgkJey04
LC02LDd9LAoJCXszLDYsOH0sCgkJey00LDYsOH0KCX0KCgktLWNpcmNmaWxsKHMueCwgcy55LCAy
LDgpCgkKCS0tIGNhbGMgbG93ZXN0IGZvb3QKCglseCA9IDAKCWx5ID0gc3kgKyAxMCAtLSBoaXAg
Ym9uZQoJbGkgPSAwCglmb3IgaT0yLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQlsb2NhbCB4PXN4
K2RbMV0gCgkJbG9jYWwgeT1zeStkWzJdKzAgLS0gaGlwCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10g
CgkJeSs9c2luKGFbaSoyXSkqZFszXQoJCXgrPWNvcyhhW2kqMisxXSkqZFszXSAKCQl5Kz1zaW4o
YVtpKjIrMV0pKmRbM10KCgkJbHkgPSBtYXgobHkseSkKCQlpZiAoaT09MiBvciBseT09eSkgdGhl
bgoJCQlseD14CgkJCWxpPWkKCQllbmQKCWVuZAogCgktLSBhZGp1c3QKCXN5IC09IChseSAtIDIy
KQoKCglpZiAobm90IHMubGx4KSBzLmxseD0wCglpZiAocy5jaSAhPSBsaSkgdGhlbgoJCS0tIHBs
YW50IGFuY2hvciBmb290IAoJCS0tIC5jeCBtZWFucyBhbmNob3IgcmVsYXRpdmUgdG8gc3RhcnRp
bmcgcG9zaXRpb24gKG5vdCAnY2VudGVyJykKCQlzLmN4ID0gbHggKyAocy5jeCAtIHMubGx4KQoJ
CXMuY2kgPSBsaQoJZW5kCgkgCglzLmxseD1seCAtLSBsYXN0IGxvd2VzdCB4CglzeCAtPSAobHgg
LSBzLmN4KQoJc3ggKz0gcy54CglzeSArPSBzLnkKIAoKCS0tIGJvZHkKCXNwcig0MCxzeC04LCBz
eS04KQoKCS0tIHJlZ3VsYXIgaGVhZAoJc3ByKDMyLHN4LTMrcy5oeCxzeS0xNCtzLmh5KQoKCS0t
IGJ1bm55IGhlYWQgKGVhc3RlcikKCS0tc3ByKDQzLHN4LTMrcy5oeCxzeS0xNCtzLmh5LTgsMS4y
NSwyKQoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQl4PXN4K2RbMV0geT1zeStk
WzJdCgoJCWJvbmUoeCx5LGFbaSoyXSxpKjIrMCkKCgkJeCs9Y29zKGFbaSoyXSkqZFszXSAKCQl5
Kz1zaW4oYVtpKjJdKSpkWzNdCgoJCWJvbmUoeCx5LGFbaSoyKzFdLGkqMisxKQoKCWVuZAoKZW5k
CgoKCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDUtMjgg
MDc6MDU6MTIiLG1vZGlmaWVkPSIyMDI1LTA3LTA5IDAwOjE4OjU2IixyZXZpc2lvbj0xODNdXQot
LSBkaXNjbyBza3VsbCAyCi0tIGJ5IHplcAotLSBza3VsbCBzcHJpdGUKZGF0YT17MjUyLDI1NCwy
NTUsMjU1LDIzMSwxOTUsMTk1LDE5NSwxOTksMjU1LDEyNywxMjYsMjQ4LDI0OCwxNTIsMTUyfQot
LSAyZCByb3RhdGlvbgpsb2NhbCBmdW5jdGlvbiByb3QoeCx5LGEpCglyZXR1cm4gY29zKGEpKngt
c2luKGEpKnksIGNvcyhhKSp5K3gqc2luKGEpCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJLS1wcmlu
dGgoIl9kcmF3KCkgc3RhcnQgIi4uc3RhdCgxKSkKCWNscygpCgkKCWxvY2FsIHR0PXQoKQoJbG9j
YWwgcjAgPSA1K2Nvcyh0dC81KSo0Cglsb2NhbCB5X29mZnNldCA9IC41K2Nvcyh0dCouMTEpKi41
CgkJCglmb3IgaT0wLDUgZG8KCQlwPWlcMwoJCQoJCS0tIGRlY2lkZSB3aGljaCBiaXRwbGFuZXMg
dG8gcmVhZC93cml0ZQoJCS0tcG9rZSgweDU1MDksICgxPDxpJTMpIHwgKDB4MTAgKiBwKSkKCQls
b2NhbCBwbGFuZXMgPSAgKDE8PGklMykgfCAoMHgxMCAqIHApCgkJCgkJYTI9dCgpLWklNi8yMAoJ
CQoJCWxvY2FsIGJtcCA9IGdldF9zcHIoMCkKCQlmb3IgaT0wLDI1NSBkbwoJCQlsb2NhbCB4PWkm
MTUKCQkJbG9jYWwgeT1pXDE2CgkJCS0tIGklMTYgaXMgdGhlIHNwciBwaXhlbCB4CgkJCS0tIGkv
MTYgaXMgdGhlIHNwciBwaXhlbCB5CgkJCS0taWYoeD43KSB4PSAxNS14IC0tIHJocyBvZiBzcHJp
dGUKCQkJLS1pZiBkYXRhWzEraVwxNl0mKDE8PHgpPjAgdGhlbgoJCQkKCQkJbG9jYWwgY29sID0g
Ym1wOmdldCh4LHkpCgkJCWlmIChjb2wgPT0gMTQpIHRoZW4KCQkJCXBva2UoMHg1NTA5LCBwbGFu
ZXMgfCAweDgpCgkJCWVsc2UKCQkJCXBva2UoMHg1NTA5LCBwbGFuZXMpCgkJCWVuZAoJCQkKCQkJ
aWYgY29sID4gMCB0aGVuCgkJCQktLSByb3RhdGUgaW4gb2JqZWN0IHNwYWNlCgkJCQlsb2NhbCB4
LHo9cm90KGklMTYvOC0xLDAsYTIvNCkKCQkJCWxvY2FsIHgseT1yb3QoeCxpLzEyOC0xLGNvcyh0
dCouMSkqLjA4MzMpCgkJCQl5LT0geV9vZmZzZXQKCQkJCS0tIG1vdmUgCgkJCQl6ICs9IDIrY29z
KHR0Ki4xNDIpCgkJCQkKCQkJCS0tIGRvdCBpcyBhYm92ZSBzdXJmYWNlCgkJCQlpZiB5PC41IHRo
ZW4KCQkJCQoJCQkJCS0tIG9uIHJlZmxlY3Rpb24gcGFzcywgcmVmbGVjdAoJCQkJCS0tIHRocm91
Z2ggZ3JvdW5kIHBsYW5lIChhdCAxKQoJCQkJCWlmIChwPT0wKSB5ID0gMS15CgkJCQkJCgkJCQkJ
LS0gcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBpbnRvIHNjcmVlbnNwYWNlIChzeCxzeSkKCQkJCQls
b2NhbCBzeCA9IDI0MCArIHggKiAxMjggLyB6CgkJCQkJbG9jYWwgc3kgPSAxMzUgKyB5ICogMTI4
IC8gegoJCQkJCQoJCQkJCS0tIHI6IHJhZGl1cyBvZiBkb3QKCQkJCQktLSBpJTE2LzkraS85OSBm
b3Igc3RyaXBlcwoJCQkJCS0tICthMiB0byB2YXJ5IHN0cmlwZXMgb2Zmc2V0CgkJCQkJbG9jYWwg
ciA9IChyMCtjb3MoaSUxNi85K2kvOTkrYTIpKjIpIC8gegoJCQkJCQoJCQkJCS0tIGRyYXcgdGhl
IGRvdAoJCQkJCWlmIChyID4gNCkgdGhlbgoJCQkJCQljaXJjZmlsbChzeCxzeSxyLDMxKQoJCQkJ
CWVsc2UKCQkJCQkJY2lyYyhzeCxzeSxyLDMxKQoJCQkJCWVuZAoJCQkJCS0tY2lyYyhzeCxzeSxy
KjEuNSwxNSkKCQkJCWVuZAoJCQllbmQgCgkJZW5kCgllbmQKCS0tcmVjdGZpbGwoMCwwLDUwLDEw
LDE2KQoJLS1wcmludChzdHJpbmcuZm9ybWF0KCIlLjNmICglZCBmcHMpIixzdGF0KDEpLCBzdGF0
KDcpKSwyLDIsMTUpCgktLXByaW50aCgiX2RyYXcoKSBlbmQgIi4uc3RhdCgxKSkKZW5kCmZ1bmN0
aW9uIF9pbml0KCkKCS0tIHBhbGV0dGUKCWZvciBpPTAsMzEgZG8KCQoJCWxvY2FsIHIgPSAoaT4_
MCkmMQoJCWxvY2FsIGcgPSAoaT4_MSkmMQoJCWxvY2FsIGIgPSAoaT4_MikmMQoJCWxvY2FsIHAg
PSAoaT4_MykmMQoJCWxvY2FsIHEgPSAoaT4_NCkmMQoJCQoJCXEwID0gKHEgKiAxLjUpICsgMC41
ICAtLSAwLjUgb3IgMi4wCgkJcTEgPSAocSAqIDEuMCkgKyAxLjAgIC0tIDEuMCBvciAyLjAKCQkK
CQlpZiAocCA_IDApIHRoZW4KCQkJbG9jYWwgdHQgPSAwLjMKCQkJciA9IDEuMCAqIHR0ICsgciAq
ICgxLXR0KQoJCQlnID0gMC4zICogdHQgKyBnICogKDEtdHQpCgkJCWIgPSAwLjggKiB0dCArIGIg
KiAoMS10dCkJCgkJZW5kCgkJCgkJCgkJdmFsID0gIGZscihiICogMTI3ICogcTEpCgkJdmFsICs9
IGZscihnICogMTI3ICogcTApIDw8IDgKCQl2YWwgKz0gZmxyKHIgKiAxMjcgKiBxMCkgPDwgMTYK
CQkKCQlwb2tlNCgweDUwMDAgKyBpICogNCwgdmFsKQoJCQoJCS0tIHNjYW5saW5lIGNvbG91cgoJ
CXZhbCA9ICBmbHIoYiAqIDExMCAqIHExKQoJCXZhbCArPSBmbHIoZyAqIDEwMCAqIHEwKSA8PCA4
CgkJdmFsICs9IGZscihyICogMTAwICogcTApIDw8IDE2CgkJCgkJcG9rZTQoMHg1MTAwICsgaSAq
IDQsdmFsKQoJCQoJZW5kCgkKCS0tIHNjYW5saW5lcwoJZm9yIGk9MCw2OCBkbwotLQkJcG9rZSgw
eDU0MDAraSwweDExKQoJZW5kCgkKZW5kCgoKCjo6IHBvc2UubHVhCi0tW1twb2RfZm9ybWF0PSJy
YXciLGNyZWF0ZWQ9IjIwMjQtNDktMDUgMDc6NDk6NTciLG1vZGlmaWVkPSIyMDI0LTI1LTA1IDA4
OjI1OjUwIixyZXZpc2lvbj0xODBdXQoKCmZ1bmN0aW9uIGRlZnBvc2UoKQoJcmV0dXJuIHtbMF09
CgkgIDAuNywwLjksCgkgIC0wLjMsLTAuNCwKCSAgMC44NSwwLjc1LAoJICAwLjY1LDAuNzUsCgkg
IDAKCSB9CmVuZAoKZnVuY3Rpb24gbWFrZXBvc2UobikKCiBuPWZscihuKQogCgoJbG9jYWwgcGRh
dD17WzBdPQoJCgkgLS0gZGVmCgkge1swXT0KCQkgIDAuODUsMC43NSwKCQkgIC0wLjMsMC43NSwK
CQkgIDAuODUsMC43LAoJCSAgMC42NSwwLjcsCgkJICAwCgkJIH0sCgkJIAoJIC0tIDEuIGFybXMg
ZG93bgoJCXtbMF09CgkJICAwLjgwLDAuOTAsCgkJICAwLjcwLDAuNjAsCgkJICAwLjk1LDAuOTUs
CgkJICAwLjU1LDAuODUsCgkJICAwCgkJIH0sIAoJCSAKCQktLSAyIHJ1c3NpYW4KCQktLSAoYXJt
cyB3YXZlKQoJCXtbMF09CgkJICAwLjIwLDAuMzUsCgkJICAwLjQ1LDAuNjAsCgkJICAwLjk1LDAu
OTUsCgkJICAwLjU1LDAuODUsCgkJICAwCgkJIH0sIAoJCQoJCS0tIDMgc3RvbXB5CgkJLS0gKGFy
bXMgb3BlbiAtLSBoZXkgaG8pCgkJe1swXT0KCQkgIDAuMCwwLjE1LAoJCSAgMC4zNSwwLjI1LAoJ
CSAgMC43NSwwLjc1LAoJCSAgMC40NSwwLjY1LAoJCSAgMAoJCSB9LAoJCSAKCQktLSA0IGFybXMg
dXAKCQl7WzBdPQoJCSAgMC4yNSwwLjM1LAoJCSAgMC4yNSwwLjE1LAoJCSAgMC43NSwwLjc1LAoJ
CSAgMC42LDAuNiwKCQkgIDAKCQkgfSwKCQkgCgkJCgl9CgkKCW49biUoI3BkYXQrMSkKCiBsb2Nh
bCBwPXt9CiBmb3IgaT0wLDggZG8KICBwW2ldPXBkYXRbbl1baV0KIGVuZAoKCXJldHVybiBwCmVu
ZAoKCgotLSBjaGFzZSBwb3NlCmZ1bmN0aW9uIGNocG9zZShwMCxwMSxxKQogZm9yIGk9MCw3IGRv
CiAgbG9jYWwgYTA9cDBbaV0KICBsb2NhbCBhMT1wMVtpXQogIGEwJT0xIGExJT0xCiAgaWYgKGFi
cyhhMC1hMSk_MC41KSB0aGVuCiAgIGEwKz1zZ24oYTEtYTApCiAgZW5kCiAgYTA9YTAqKDEtcSkr
YTEqcQogIHAwW2ldPWEwJTEKIGVuZAogCiAtLSBoZWFkCiBwMFs4XT1wMFs4XSooMS1xKStwMVs4
XSpxCmVuZAoKCmZ1bmN0aW9uIGZsaXBfcG9zZShwKQogZm9yIGo9MCwxIGRvCiAgZm9yIGk9MCwx
IGRvCiAgIHBbaio0K2krMF0scFtqKjQraSsyXT0KICAgcFtqKjQraSsyXSxwW2oqNCtpKzBdCiAg
ZW5kCiBlbmQKIGZvciBpPTAsNyBkbwogIHBbaV09KDAuNS1wW2ldKSUxCiBlbmQKIAotLSBwWzhd
Kj0tMQogcFs4XT0weDAuZmZmZi1wWzhdCiAKZW5kCgoKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjMtMTAtMDIgMjI6NTU6NDUiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4
IixydW50aW1lPTE5LHN0b3JlZD0iMjAyNC00OC0wNSAwODo0ODowOCIsd29ya3NwYWNlcz17e2xv
Y2F0aW9uPSJtYWluLmx1YSMxMjAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8w
LmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVh
dGVkPSIyMDI0LTEwLTA1IDA3OjI4OjIwIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIs
c3RvcmVkPSIyMDI0LTI4LTA1IDA3OjI4OjIwIl1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZa
Q3hqY21WaGRHVmtQU0l5TURJMExURXdMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1q
QXlOUzB3Ck55MHdPU0F3TURveE5qb3dNaUlzY21WMmFYTnBiMjQ5TXpVeFhWMXNlalFBc0FBQUFG
b3hBQUQtRkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBUVFKMUFuSUVjd1J4QUhMZ2N3Qnk0SENB
QVdtZGNRMXhBWEVGY1FGd1lBOHdmWElFY1FSMENYSUN4bWJHRm5jejB3TEhCaApibDk0Q0FESGVU
MHdMSHB2YjIwOU9IMHNoZ0JmQ0FnRThEQXhBUC0tLS0tLUdGOFFFQVR3OERFQXJBLTFBSVVQaUFI
LUZBOHhBUC0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS1LRkJ0UFRoOWZRPT0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQt
MTAtMDUgMDc6Mjg6MjAiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIw
MjQtMjgtMDUgMDc6Mjg6MjAiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdW
a1BTSXlNREl6TFRVMExUQXpJREEwT2pVME9qSTNJaXh0YjJScFptbGxaRDBpTWpBeU15MDEKT0Mw
d015QXdORG8xT0Rvd01TSXNjbVYyYVhOcGIyNDlNelZkWFd4Nk5BQnBBQUFBb3dnQUFQQVRlMnho
ZVdWeVBYdGJNRjA5ZTJKdApjRDExYzJWeVpHRjBZU2dpYVRFMklpd3hOZ01BTHlJd0FRRC0tLS12
b1NJcExIQmhibDk0UFRBSUFQSUdlVDB3TEhOallXeGxQVEVzCmRHbHNaVjlvUFRFMkNnQnZkejB4
Tm4wc1N3VC0tLS0tT0ZBeE5uMTlmUT09Cjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExUSTRMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB5Ck5TMHdOU0F3T0RveU5UbzBOU0lzY21WMmFYTnBiMjQ5TWpFNFhWMXNlalFBWFFBQUFGZ0VB
QUR3RTN0c1lYbGxjajE3V3pCZFBYdGkKYlhBOWRYTmxjbVJoZEdFb0lta3hOaUlzTVRZREFDOGlN
QUVBLS0tLTc2RWlLU3h3WVc1ZmVEMHdDQUR5Qm5rOU1DeHpZMkZzWlQweApMSFJwYkdWZmFEMHhO
Z29BY0hjOU1UWjlmWDA9Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEw
LTA1IDA3OjI4OjIwIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0
LTI4LTA1IDA3OjI4OjIwIl1dCjo6IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQ
U0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4dGIyUnBabWxsWkQwaU1qQXlNeTAxCk55MHdN
eUF3TkRvMU56bzBNaUlzY21WMmFYTnBiMjQ5TXpSZFhXeDZOQUJ2QUFBQTdRWUFBTjl3ZUhVQUF5
Z0FBQU1BQlBELUFRRHMKLXlmeEFSQUdEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThN
TVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVRQmc0dwpBUDg1SC04QkFOelBfQTlBQUE4UVFQ
LS1zUEJ3Q3dELS02TWYtd0VBbDFELS0tLS1Idz09Cjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlcz
QnZaQ3hqY21WaGRHVmtQU0l5TURJMExUSTRMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQw
aU1qQXlOQzB5Ck5TMHdOU0F3T0RveU5UbzBOU0lzY21WMmFYTnBiMjQ5TWpFMVhWMXNlalFBRUFF
QUFGRUhBQUR3SjNCNGRRQURLQUFBQXdBRUQwQVEKQWc0QUFhQUJJQUtnRGdBUEVBQU44TW9CQWdN
RUJRWUhBUS0ta0FnSkNnc1BEQThORHc0UER4QUE4QUFORHhFUEVnOFREeFFQRlE4VwpEeGNUQVBF
QkR4Z1BHUThhRHhzUEhBOGREeDRQSHhRQThRQWdEeUVQSWc4akR5UVBKUThtRHljVUFQRUFLQThw
RHlvUEt3OHNEeTBQCkxnOHZGQUR4QURBUE1ROHlEek1QTkE4MUR6WVBOeFFBLXdVNER6a1BPZzg3
RHp3UFBROF9EejhCRC0tdy13RUE2LThuV2dFUUJnOGcKRUFFZ0FTQUI4QUFDRUFJTUVBRWdEeUVn
QVRBUFFQREREeWdQLS1ER0QtZ0tELThQZ0EtM0R3MEI4QWtCRUFZTU1BRC1PUi0tQVFEYwp2LWdQ
UUFBTlFQLS1zUEJ3Q2dELS0yUWYtd0VBbDFELS0tLS1Idz09Cjo6IFtlb2NdCg==
:: bios/screensavers/dizzy.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBf
bWV0YS8KOjogZ2Z4Lwo6OiBzZngvCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNy
ZWF0ZWQ9IjIwMjMtMTAtMjIgMDk6Mjk6MzMiLG1vZGlmaWVkPSIyMDI1LTExLTEzIDE4OjAwOjU1
IixyZXZpc2lvbj00NDYxXV0KLS0gZGl6enkgc2NyZWVuc2F2ZXIgYnkgemVwCi0tIHYyIHdpdGgg
Y29sb3VyIHRhYmxlcwoKZG90cyA9IDQwMDAKZGlzdGFuY2UgPSA1MApuZWFyX2NsaXAgPSAwLjUK
bW9vZHkgPSB0cnVlCgp0dCA9IHJuZCgxMDAwKQoKZnVuY3Rpb24gaWRlbnRpdHlfbWF0cml4KCkK
CWxvY2FsIG0gPSB1c2VyZGF0YSgiZjY0IiwzLDQpCglzZXQobSwgMCwgMCwKCQkxLCAwLCAwLCAK
CQkwLCAxLCAwLCAKCQkwLCAwLCAxLCAKCQkwLCAwLCAwCgkpCglyZXR1cm4gbQplbmQKCi0tIHJv
dGF0ZSBwb2ludCB4LHkgYXJvdW5kIG9yaWdpbiBieSBhbmdsZSBhCmZ1bmN0aW9uIHJvdDJkKHgs
eSxhKQoJcmV0dXJuIGNvcyhhKSp4IC0gc2luKGEpKnksIGNvcyhhKSp5ICsgc2luKGEpKngKZW5k
CgotLSBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdGhhdCByb3RhdGVzIGFyb3VuZCBh
IGdpdmVuIGF4aXMgYnkgYW5nbGUKLS0gYXhpcyBpcyBhIHN0cmluZzogIngiLCAieSIsICJ6Igpm
dW5jdGlvbiByb3RhdGlvbl9tYXRyaXgoYXhpcywgYW5nbGUpCgkKCS0tIGNvbXBvbmVudCBvZmZz
ZXRzIGRlcGVuZCBvbiB3aGljaCBheGlzIHRvIHJvdGF0ZSBhcm91bmQKCWxvY2FsIGRhdCA9IHt4
PXszLDZ9LCB5PXswLDZ9LCB6PXswLDN9fQoJbG9jYWwgYzAsYzEgPSBkYXRbYXhpc11bMV0sIGRh
dFtheGlzXVsyXQoJCglsb2NhbCBtID0gaWRlbnRpdHlfbWF0cml4KCkKCQoJLS0gcm90YXRlIHRo
ZSBjb21wb25lbnQgdmVjdG9ycyAoZWFjaCBvbmUgaXMgYSBjb2x1bW4gZnJvbSByb3dzIDAuLjIp
Cglmb3IgY29sdW1uPTAsMiBkbwoJCW1bY29sdW1uICsgYzBdLCBtW2NvbHVtbiArIGMxXSA9IHJv
dDJkKG1bY29sdW1uICsgYzBdLCBtW2NvbHVtbiArIGMxXSwgYW5nbGUpCgllbmQKCXJldHVybiBt
CmVuZAoKZnVuY3Rpb24gX2luaXQoKQoKCXAgPSB1c2VyZGF0YSgiZjY0IiwgNSwgZG90cykgLS0g
eCx5LHosY29sLHJhZGl1cwoKCWxvY2FsIGluZGV4ID0gMAoJYmluZGV4PTAKCQoJbG9jYWwgcXEg
PSAwLjAwMitybmQoMC4wMDQpCglsb2NhbCBxcTA9IDAuMDA0K3JuZCgwLjAwMSkKCWxvY2FsIHFx
MT0gcXErcm5kKDAuMDA0KQoJbG9jYWwgcXEyPSBxcStybmQoMC4wMDQpCgkKCWZvciBpPTAsZG90
cy0xIGRvCgkJbG9jYWwgeCx5LHosYyxyID0KCQkJY29zKGkqcXEwKSoyMDMsCgkJCWNvcyhpKnFx
MSkqMzEsCgkJCWNvcyhpKnFxMikqMzIsCgkJCSgxICsgKGklNykpKjgsIC0tIGNvbG91cgoJCQkx
MDArY29zKGkqMC4wMDEpKjI1MCAtLSByYWRpdXMKCQlwOnNldCgwLGkseCx5LHosYyxyKQoJCQoJ
ZW5kCgkKCQoJCgoJLS0gY29sb3VyIHRhYmxlCglmb3IgeT0wLDYzIGRvCgkJZm9yIHg9MCw2MyBk
bwoJCQlsb2NhbCBjb2wgPSB5IFwgOAoJCQlsb2NhbCB2ID0geCAlIDgKCQkJdiA9IG1pbig3LCB2
Kyh5JTgpKzEpCgkJCS0tIGRyYXcgb24gYmxhY2sgLT4gdXNlIHN0YXJpbmcgaW50ZW5zaXR5CgkJ
CWlmICh4PDgpIHY9MSAtLSBzdWJ0bGUgLyBjbG9zZSB0byBvcmlnaW5hbAoJCQlpZiAoeDw4IGFu
ZCBtb29keSkgdj0wCgkJCQoJCQlwb2tlKDB4ODAwMCt5KjY0K3gsY29sKjgrdikKCQllbmQKCWVu
ZAoJCgktLSBwYWxldHRlCgltZW1jcHkoMHg5NTAwMCwgMHg1MDAwLCAxMDI0KQoJZm9yIGk9MCw2
MyBkbwoJCWxvY2FsIGNvbCA9IGkgXCA4CgkJaWYgKGNvbD4wKSBjb2wrPTcKCQlsb2NhbCBxID0g
aSAlIDggCgkJbG9jYWwgcixnLGIgPSBwZWVrKDB4OTUwMDArY29sKjQsMykKCQkKCQlpZiAocTwx
KSB0aGVuCgkJCXEgPSAwLjQgKyBxICogMC4yNAoJCQkKCQkJciAqPSBxCgkJCWcgKj0gcQoJCQli
ICo9IHEKCQkJCgkJZWxzZQoJCQlxLT0xCgkJCS0tIHJhbXAgdG8gd2hpdGUKCQkJcT03LXEgIHE9
KHEqcSlcNyBxPTctcQoJCQlyID0gKDI1NSpxICsgciooNy1xKSlcNwoJCQlnID0gKDI1NSpxICsg
ZyooNy1xKSlcNwoJCQliID0gKDI1NSpxICsgYiooNy1xKSlcNwoJCWVuZAoJCXBva2UoMHg1MDAw
K2kqNCxyLGcsYikKCWVuZAoKCS0tIG9uZSBtb3JlIHVzZXJkYXRhIHRoZSBzYW1lIHNpemUgdXNl
ZCB3aGVuIHJlbmRlcmluZwoJcDEgPSBwOmNvcHkoKQoJCmVuZAkKCgoKZnVuY3Rpb24gX2RyYXco
KQoJY2xzKCkKCWxvY2FsIHd3ID0gMjQwLjAKCQoJc3Bpbl9hcm91bmQgPSByb3RhdGlvbl9tYXRy
aXgoInkiLHR0KjAuMDUpICAgICAgICAKCXRpbHQgICAgICAgID0gcm90YXRpb25fbWF0cml4KCJ4
IiwwLjA2K2Nvcyh0dCowLjA1KSowLjA1KSAtLSAwIHRvIHN0YXkgZmxhdAoJc2hpZnRfeiAgICAg
PSBpZGVudGl0eV9tYXRyaXgoKSBzaGlmdF96WzExXSA9IGRpc3RhbmNlK2Nvcyh0dCowLjA0KSox
MCAKCQoJLS0gbWF0bXVsM2QoKSBpcyB1c2VkIHRvIG11bHRpcGx5IDN4NCBtYXRyaWNlcwoJLS0g
aGVyZSB0aGUgMyB0cmFuc2Zvcm1hdGlvbnMgd2lsbCBiZSBhcHBsaWVkIGZyb20gbGVmdCB0byBy
aWdodAoJbSA9IHNwaW5fYXJvdW5kOm1hdG11bDNkKHRpbHQpOm1hdG11bDNkKHNoaWZ0X3opCgkK
CS0tIHRyYW5zZm9ybSBlYWNoIGRvdCBwb3NpdGlvbiBieSBjb21wb3VuZCBtYXRyaXgKCXAxOmNv
cHkocCx0cnVlKSAtLSBzdGFydCB3aXRoIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgZGF0YQoJcDpt
YXRtdWwzZChtLCBwMSwgMSkgLS0gd3JpdGUgeCx5LHogd2l0aCB0cmFuc2Zvcm1lZCB2YWx1ZXMK
CQoJLS0gc29ydCBieSB6IChjb3N0cyB_NDAlIGNwdSAtLSBjb3VsZCBwYXJ0aXRpb24gc2NlbmUg
YW5kIHNvcnQgYnkgeHogYnVja2V0KQoJcDE6c29ydCgyLCB0cnVlKQoJCgktLSBiaW5hcnkgc2Vh
cmNoIG9uIG5lYXIgY2xpcHBpbmcgcGxhbmUgCgktLSAob3B0aW9uYWwgLS0gY2lyY2xlcyB3aXRo
IG5lZ2F0aXZlIHJhZGl1cyBhcmUgbm90IGRyYXduLCBzbyAKCS0tIHNraXBwaW5nIHRoaXMgaXMg
dGhlIHNhbWUgYXMgdXNpbmcgbmVhcl9jbGlwPTApCglpZiAobmVhcl9jbGlwKSB0aGVuCgkJaTAs
aTEgPSAwLCBwOmhlaWdodCgpLTEKCQlmb3Igaj0xLDE0IGRvCgkJCWxvY2FsIG1tID0gKGkwICsg
aTEpIFwgMgoJCQlpZiBwMTpnZXQoMixtbSkgPCBuZWFyX2NsaXAgdGhlbgoJCQkJaTEgPSBtbQoJ
CQllbHNlCgkJCQlpMCA9IG1tCgkJCWVuZAoJCWVuZAoJZW5kCgkKCS0tIGRpdmlkZSB4LHksciBi
eSB6CglwMTpkaXYocDEsdHJ1ZSwgMiwwLDEsICBwMTp3aWR0aCgpLCBwMTp3aWR0aCgpLCBwMTpo
ZWlnaHQoKSkgCglwMTpkaXYocDEsdHJ1ZSwgMiwxLDEsICBwMTp3aWR0aCgpLCBwMTp3aWR0aCgp
LCBwMTpoZWlnaHQoKSkgCglwMTpkaXYocDEsdHJ1ZSwgMiw0LDEsICBwMTp3aWR0aCgpLCBwMTp3
aWR0aCgpLCBwMTpoZWlnaHQoKSkgCgkKCS0tIGNvbnZlcnQgdG8gc2NyZWVuIGNvb3JkaW5hdGVz
OiBtdWx0aXBseSB4LHkgYnkgd3cKCXAxOm11bCh3dywgdHJ1ZSwgMCwgMCwgMiwgIDAsIHAxOndp
ZHRoKCksIHAxOmhlaWdodCgpKQoJCgktLSBjb3B5IHJhZGl1cyBpbnRvIHBvc2l0aW9uIGV4cGVj
dGVkIGJ5IGNpcmNmaWxsKCkgLy8gZWxlbWVudCA0IC0_IDI7IHdyaXRlIG92ZXIgegoJcDE6Y29w
eShwMSwgdHJ1ZSwgNCwgMiwgMSwgIHAxOndpZHRoKCksIHAxOndpZHRoKCksIHAxOmhlaWdodCgp
KQoJCgktLSBzaGlmdCBzbyB0aGF0IG9yaWdpbiBpcyBkcmF3biBhdCBjZW50ZXIKCWNhbWVyYSgt
MjQwLC0xMzUpCgkKCS0tIGJhdGNoIGRyYXc7IGVhY2ggcm93IG9mIHAxIGlzIGxpa2UgYSBzaW5n
bGUgY2lyY2ZpbGwoKSBjYWxsCglwb2tlKDB4NTUwYiwweDNmKSAtLSBlbmFibGUgYmxlbmRpbmcg
Zm9yIHNoYXBlcwkKCWNpcmNmaWxsKHAxLCAwLCBpMSkKCQoJLS0gdmlldyBwYWxldHRlICgqKiBo
YXZlIHRvIGNsb2JiZXIgY29sb3VyIHRhYmxlcyB0byB2aWV3IHJhdyBwYWxldHRlIGVhc2lseSEg
KiopCglpZiBmYWxzZSB0aGVuIAoJCXBhbCgwKSAtLSBkZWZhdWx0IGNvbG91ciB0YWJsZQoJCXBv
a2UoMHg1NTBiLDB4MCkgLS0gdHVybiBvZmYgYmxlbmRpbmcKCQljYW1lcmEoKQoJCXByaW50KHN0
cmluZy5mb3JtYXQoIlwwMTRjcHU6ICUzLjNmICglZGZwcykiLCBzdGF0KDEpLCBzdGF0KDcpKSwg
MTAsIDEwLCA4KQoJCgkJZm9yIHk9MCw3IGRvCgkJCWZvciB4PTAsNyBkbwoJCQkJY2lyY2ZpbGwo
NSt4KjUsIDQwK3kqNSwgMiwgeSo4ICsgeCkKCQkJZW5kCgkJZW5kCgllbmQKLS0JcHJpbnRoKHN0
cmluZy5mb3JtYXQoIlwwMTRjcHU6ICUzLjNmICglZGZwcykiLCBzdGF0KDEpLCBzdGF0KDcpKSwg
MTAsIDEwLCA4KQoJCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgpCgoJdHQgKz0gMS82MAoJCgkKZW5k
Cjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDkgMDI6NTA6NDUiLG1vZGlm
aWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixydW50aW1lPTIzLHN0b3JlZD0iMjAyNC0wOS0wMiAx
NzowOTo1NyIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxIix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249
InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IF9tZXRhLy5pbmZvLnBvZAotLVtb
cG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDkgMDI6NTA6NDUiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAw
OjQ3OjM4IixzdG9yZWQ9IjIwMjQtNTAtMDkgMDI6NTA6NDUiXV0KOjogX21ldGEvd29ya3NwYWNl
cy5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEk0TFRJeUlEQTVPakk0T2pN
eUlpeHRiMlJwWm1sbFpEMGlNakF5TXkwegpOaTB3TkNBd05qb3pOam95T0NJc2NtVjJhWE5wYjI0
OU5EVTNObDFkYkhvMEFDMEFBQUFyQUFBQThCeDdlMk53Y205cVgyWnBiR1U5CkltMWhhVzR1YkhW
aElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMTkKOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjUtMTAtMTYgMjA6Mjc6MjAiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4
Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxURXhMVEV4
SURFMU9qVXlPakl6SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1TMHhNU0F4TlRvMU1qb3lNeUlz
Y21WMmFYTnBiMjQ5TUYxZGJIbzBBS0lBQUFBd01RQUE4eUY3V3pCZFBYdGliWEE5Y0hoMUFFTWcK
RUJBRThGWUhFQWZBRjlBWHdBY1FCLUJXTEdac1lXZHpQVEFzY0dGdVgzZ0lBTXQ1UFRBc2VtOXZi
VDAyZlN3X0FCdndNUUJITFRRdQpOZ0VBRXpkQUFJVXRNamd1TURReE5oY0FBVThBSGpoUEFBX0FB
QXdQTVFELS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLV9IVUcwOU5uMTkKOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9
IjIwMjUtMTAtMjAgMDM6NTc6MTUiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6
IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hoZFhSb2IzSTlJaUlzWTNKbFlYUmxaRDBpTWpBeU5T
MHdOeTB3TnlBd01qb3lNVG94TXlJc2JXOWthV1pwClpXUTlJakl3TWpVdE1UQXRNakFnTURRNk1E
STZNellpTEc1dmRHVnpQU0pwYm5Od2FYSmxaQ0JpZVNCY0lsQnBZMjkwY205dUlGTjAKZFdabVhD
SWdkbWxrWlc5Y2JtOXVJSGx2ZFhSMVltVmNiaUlzY21WMmFYTnBiMjQ5Tnl4MGFYUnNaVDBpSWl4
MlpYSnphVzl1UFNJaQpYVjFzZWpRQUp3SUFBTnNMQUFELU1uQjRkUUFES0FBQUJBQUVEMEFRQWc0
QUFhQUJJQUtnRGdBUEVBQU44TW9CQWdNd0FROFBrQVFGCkJnZEFESkFJQ1FvTFFBeVFEd3dQRFE4
T0REQUNEUEQtQVFEcjhDV3FBUkFHRHp3UUFTQUJJQVVQNXc4VUFzQUNFQUlQSlJBQklBOGgKSUFF
d0QyYVFEeUVDSUE4b1VBRWdBZkFBQWhBR0R5d1FLd0R3VWcwUDhRLWhBUThjRHhVQkFBOURvQW9n
RHlBZ0Q1SWdEMnNnRHl6dwpYZ0lCRHhrSENDQVBlZ19xRDhRUHp3LVpEOVFQeEFfNUQ1b1BpZzl2
RDFVUFJROHFEeG9NQVFnZ0R4UlFEeVdnQWFBUEl2Q1VELWdLCkQtOFBnQS0zRHcwQjhBbVlBQkVn
bUFBQmVBQWxBZzZUQUoxQThNTVBLQS0tOE1ZeEFCOE9NQUQtLS0tLS00MGYtd0VBclBJUXlBOUEK
QUE4UVFBOHItLThYRHpULS13Y0EtUmNBLVFjTy1SY08tUWZ3Y0I0QTlBVjlEeTM5R1E4dy1RVUEt
UmtBLVFVTy1Sa096UndBZU4wUApLUDBaRHpJY0FCUnRIQURHLVJBUE4tMHZBUDB2RHYwUFRBQmpH
UDBYRDBqOWFRQUJEZ0FsS08weUFQY0dBQThrLVJNUFEtMExBUDBUCkFQMExEeWo5RXdPdFVBQVJU
VkFBRmdOUUFFUDlHQTlNRkFBRnNBQkItUklQUVJRQWh3NGREekFPRHhBQUd3QXlGZzlBR3dCUS1R
bncKY0FRVEFQTUNEelQ5Snc4OGJRRDlKd0J0RHYwbkRtMFlBQlZkdlFBVEtSSUFRLTBKRHpVVEFC
UVdFd0F6QkE4eUV3QVRHeE1BOHhETgpEemV0RDBXZEQwUE5Eeno5Q2dDdEFKMEF6UUQ5Q2c2dERw
ME96UTdOSmdBekhRODVPQUEtTGZELUFRRC0xbEQtLS0tLTNRPT0KOjogW2VvY10K
:: bios/screensavers/snake.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTA2IDE1OjA0OjQzIixtb2RpZmllZD0iMjAyNC0wMy0xMiAxNzo0ODozMCIs
cmV2aXNpb249NTEyXV0KCgpmdW5jdGlvbiBtYWtlX2FjdG9yKGsseCx5KQoJbG9jYWwgYSA9IHsK
CQlrID0gaywgeCA9IHgsIHkgPSB5LAoJCWEgPSAwLjQKCX0KCXJldHVybiBhZGQoYWN0b3IsIGEp
CgkKZW5kCgpmdW5jdGlvbiBfaW5pdCgpCglhY3Rvcj17fQoJCglmb3IgaT0xLDEwIGRvCgkJbG9j
YWwgYSA9IG1ha2VfYWN0b3IoMSwyNDAsMTM1KQoJCWlmIChpID09IDEpIGEuaGVhZCA9IHRydWUg
aGVhZCA9IGEgYS5hID0gcm5kKCkKCQlpZiAoaSA_IDEpIHRoZW4KCQkJYS5wYXJlbnQgPSBhY3Rv
clsjYWN0b3ItMV0KCQkJYWN0b3JbI2FjdG9yLTFdLmNoaWxkID0gYQoJCQlhLmsgPSAyCgkJZW5k
CgllbmQKCQoJZm9yIGk9MSwxIGRvCgkJbWFrZV9hY3RvcihybmR7MzIsMzN9LHJuZCg0NDApKzIw
LHJuZCgyMzApKzIwKS5pc19mb29kID0gdHJ1ZQoJZW5kCgkKZW5kCgpmdW5jdGlvbiBkcmF3X2Fj
dG9yKGEpCglsb2NhbCBiaW5kZXggPSBhLmsKCQoJaWYgKGEuayA9PSAxKSB0aGVuCgkJbG9jYWwg
YWEgPSBhLmEKCQlhYSA9IChhYSArIC4yNSkgJSAxCgkJYmluZGV4ID0gMTYgKyAoYWEqNClcMQoJ
CS0tcHJpbnQoYWEuLiIgLS0_ICIuLmJpbmRleCw0LDMwLDcpCgllbmQKCQoJc3ByKGJpbmRleCxh
LngtOCxhLnktOCkKCQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygpCgkKCWZvciB5eT0wLDI3
MCBkbwoJCWZvciBpPTEsI2FjdG9yIGRvCgkJCWlmIChhY3RvcltpXS55XDEgPT0geXkpIGRyYXdf
YWN0b3IoYWN0b3JbaV0pCgkJZW5kCgllbmQKCS0tZm9yZWFjaChhY3RvciwgZHJhd19hY3RvcikK
CQplbmQKCmZ1bmN0aW9uIG1vdmVfYWN0b3IoYSkKCWxvY2FsIHNlZ2xlbiA9IDEwCglpZiAoYS5w
YXJlbnQpIHRoZW4KCQlsb2NhbCBwID0gYS5wYXJlbnQKCQlsb2NhbCBkeCA9IGEueCAtIHAueAoJ
CWxvY2FsIGR5ID0gYS55IC0gcC55CgkJbG9jYWwgZGQgPSBzcXJ0KGR4KmR4K2R5KmR5KQoJCWlm
IChkZCA_IHNlZ2xlbikgdGhlbgoJCQlsb2NhbCBhYSA9IGF0YW4yKGR4LGR5KQoJCQlhLnggPSBw
LnggKyBjb3MoYWEpKnNlZ2xlbgoJCQlhLnkgPSBwLnkgKyBzaW4oYWEpKnNlZ2xlbgoJCQkKCQll
bmQKCQkKCWVuZAoJCglpZiAoYS5pc19mb29kKSB0aGVuCgkJbG9jYWwgZHgsZHkgPSBhLnggLSBo
ZWFkLngsIGEueSAtIGhlYWQueQoJCWlmIChkeCpkeCtkeSpkeSA8IDIwMCkgdGhlbgoJCQlkZWwo
YWN0b3IsYSkKCQkJbG9jYWwgbnMgPSBtYWtlX2FjdG9yKGEuayxoZWFkLngsIGhlYWQueSkKCQkJ
bG9jYWwgczIgPSBoZWFkLmNoaWxkCgkJCWhlYWQuY2hpbGQgPSBucyBucy5wYXJlbnQgPSBoZWFk
CgkJCXMyLnBhcmVudCA9IG5zIG5zLmNoaWxkID0gczIKCQkJCgkJCW1ha2VfYWN0b3Iocm5kezMy
LDMzfSxybmQoNDQwKSsyMCxybmQoMjMwKSsyMCkuaXNfZm9vZCA9IHRydWUKCQoJCWVuZAoJZW5k
CgkKZW5kCgpmdW5jdGlvbiBtb3ZlX2hlYWQoYSkKCglsb2NhbCBkeCA9IGNvcyhhLmEpICogMgoJ
bG9jYWwgZHkgPSBzaW4oYS5hKSAqIDIKCQoJYS5hKz1jb3ModCgpLzIwKSouMDAxCglhLnggKz0g
ZHgKCQoJaWYgKGEueCA8PSAxMCBvciBhLnggPj0gNDcwKSB0aGVuCgkJYS54IC09IGR4CgkJZHgg
Kj0gMQoJCWEuYSA9IGF0YW4yKC1keCxkeSkKCQlhLmEgKz0gcm5kKDAuMDUpLXJuZCgwLjA1KQoJ
ZW5kCgkKCWR5ID0gc2luKGEuYSkgKiAyCglhLnkgKz0gZHkKCWlmIChhLnkgPD0gMTAgb3IgYS55
ID49IDI2MCkgdGhlbgoJCWEueSAtPSBkeSAKCQlhLmEgPSBhdGFuMihkeCwgLWR5KQoJCWEuYSAr
PSBybmQoMC4wNSktcm5kKDAuMDUpCgllbmQKCQplbmQKCgpmdW5jdGlvbiBfdXBkYXRlKCkKCQoJ
bW92ZV9oZWFkKGFjdG9yWzFdKQoJZm9yZWFjaChhY3RvciwgbW92ZV9hY3RvcikKZW5kCgo6OiAu
aW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmllZD0i
MjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTAzLTEyIDE3OjQ4OjMxIix3b3Jrc3Bh
Y2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzgxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9u
PSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIs
d29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTU6
MDQ6NDMiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMDMtMDYg
MTU6MDQ6NDMiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkw
TFRBekxUQTJJREUxT2pBME9qUXpJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweE1pQXhOem8w
T0Rvek1DSXNjbVYyYVhOcGIyNDlORE00WFYxc2VqUUFYZ0lBQU9ZekFBRHpGSHRiTUYwOWUySnRj
RDF3ZUhVQQpReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0Q0FETGVUMHdMSHB2YjIwOU9IMHNN
UUQtR1JZNWtIbGdtVkJaRnhsQWFSY3BNTGt3CkR4bVpEakFlZVI1QW5sQU9MdzVlWUE0dFBwQV84
QlpZQURmLUF3OE9Iamt1VUE0UEZ3OE9ibUFPRFE4WERXRUFFdy1xQUVjLUxqa3UKN0FCRUFGb0Fq
eDRmSFY1Z0RoMU81UUJTRHpFQUh2OGtFUjZRSGhBZWtCNHdYaGNlUUc0WExqQ19NQjRCWGdFZU1B
OFREZ0ZlQVE0TgpNQTJlRFRBZGZoMUFIVjRkWUgyQVhmQVZsQUFlRHpFQS0wUC1LeUFhWUJwQUtr
QXFZQW81QUFwd0NRcEpDbUNaVUpsQXVUQTVCd0U1CkJ3RXdEeGtwRVRrUk1BNHBBUThRT1FFTlFB
NkpVQTU1RG1BT1dRNkpBaUF3TUJwQWJ3QWhHbkJ0QUEtdEFnVnZTUjVRbm1CX1h3QWcKRlNCZkFF
OEFPUXFBWHdBRVB4NUpMbDhBSkJVUUt3RUFYd0JEQ2trS0NTc0IteFlCQnprQkJ6a3dFVGtSS1E4
Wk1BOFFBVGtPQVNrUApHVUNKRFZDSkRXQU5XUTJRUGZBV19nRWVEekVBc0FQU0JBNVBBaU1lR1U4
Q0l5NXBNd1VlTERNRkQzY0dnZzlZQURJUE5RSUYtd0FaCkh4bEFhUzFRRFM4T1hXQU5MRDAzQXVU
LU5xQWZHNUFVQUE0REhvQUVEeFFQRXdNdWtBOFVrQThZS0I4VUtBOFlRQTE0Qnc4T0RUQjQKSndn
d2VBd0hHREM0TUEwSURJaEFDQnhvRFVBWUhGaGdlSUFZSFJqd0ZYUUFNZjhjQXlzZEt3TkFBM3NI
RHhvRE1Ic25DekI3REFjYgpNTHN3QXdzTWkwQUxIR3NEUUJzY1cyQjdnQnNURzg4R0lBOHhBUC0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tNEJR
YlQwNGZYMD0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTU6
MDQ6NDMiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMDMtMDYg
MTU6MDQ6NDMiXV0KOjogbWFwL21hcDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlN
REkwTFRBekxUQTJJREUxT2pBME9qUXpJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweE1pQXhO
em8wT0Rvek1DSXNjbVYyYVhOcGIyNDlNemc0WFYxc2VqUUFWQUFBQUVRUUFBRHdDSHQ3WW0xd1BY
VnpaWEprWVhSaApLQ0pwTVRZaUxETXlBd0F2SWpBQkFQLS0tLS0tLS0tLS0tLS0tLS0tLS11aElp
a3NjR0Z1WDNnOU1BZ0Ewbms5TUN4MGFXeGxYMmc5Ck1UWUtBR0IzUFRFMmZYMD0KOjogc2Z4Ly5p
bmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTU6MDQ6NDMiLG1vZGlmaWVkPSIy
MDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMDMtMDYgMTU6MDQ6NDMiXV0KOjogc2Z4
L3NmeDAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREUxT2pB
ME9qUXpJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweE1pQXhOem8wT0Rvek1TSXNjbVYyYVhO
cGIyNDlNemcxWFYxc2VqUUFFQUVBQUZFSEFBRHdKM0I0ZFFBREtBQUFBd0FFRDBBUQpBZzRBQWFB
QklBS2dEZ0FQRUFBTjhNb0JBZ01FQlFZSEFRLS1rQWdKQ2dzUERBOE5EdzRQRHhBQThBQU5EeEVQ
RWc4VER4UVBGUThXCkR4Y1RBUEVCRHhnUEdROGFEeHNQSEE4ZER4NFBIeFFBOFFBZ0R5RVBJZzhq
RHlRUEpROG1EeWNVQVBFQUtBOHBEeW9QS3c4c0R5MFAKTGc4dkZBRHhBREFQTVE4eUR6TVBOQTgx
RHpZUE54UUEtd1U0RHprUE9nODdEendQUFE4X0R6OEJELS13LXdFQTYtOG5XZ0VRQmc4ZwpFQUVn
QVNBQjhBQUNFQUlNRUFFZ0R5RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JF
QVlNTUFELU9SLS1BUURjCnYtZ1BRQUFOUVAtLXNQQndDZ0QtLTJRZi13RUFsMUQtLS0tLUh3PT0K
OjogW2VvY10K
:: bios/screensavers/swoosh.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTQwLTMxIDE0OjQwOjQ5
IixyZXZpc2lvbj0xLHN0b3JlZD0iMjAyMy00MS0zMSAxNDo0MToxNSJdXQpxPTAKcG9rZSgweDU1
MGIsIDB4ZmYpCgpmdW5jdGlvbiBfaW5pdCgpCgktLSBzZXQgdXAgZGlzcGxheSBwYWxldHRlCglm
b3IgaTA9MCw2MyBkbwoJCWxvY2FsIGk9aTAtLTYzLWkwCgkJCgkJcG9rZTQoMHg1MDAwICsgaTAg
KiA0LAoJCQkobWlkKDAsIGkgKiA4LDI1NSkgPDwxNikgKwoJCQkobWlkKDAsIGkgKiAxMiwyNTUp
IDw8IDgpICsKCQkJKG1pZCgwLCBpICogMTgsMjU1KSA8PCAwKQoJCSkKCWVuZAoJLS0gY29sb3Vy
IHRhYmxlcwoJLS0gb25seSBkcmF3aW5nIHcvIGNvbG9yIDcsIHNvIG9ubHkgbmVlZCB0byBzZXQg
dGhhdCB1cAoJZm9yIGk9Nyw3IGRvIC0tIGRyYXcgY29sb3IKCQlmb3Igaj0wLDYzIGRvIC0tIHRh
cmdldCBwaXhlbCBjb2xvcgoJCQlwb2tlKDB4ODAwMCtpKjY0K2osIG1pZCgwLCAoNjMgKiAxICsg
aiAqIDE1KSAvLyAxNiwgNjMpKQoJCWVuZAoJZW5kCmVuZApmdW5jdGlvbiBfZHJhdygpCglsb2Nh
bCByID0gMjQKCXEgPSBxICsgMS84MDAwCgljbHMoKQotLQlmb3IgaT0wLDYzIGRvIGNpcmNmaWxs
KDgraSo3LCA4LCAzLCBpKSBlbmQKLS0JcmVjdGZpbGwoMCwwLDQ3OSw3LDcpCglmb3IgaT0wLDEs
MS8yMDAwIGRvCgkJaSA9IGkgKyBxCgkJbG9jYWwgeCA9IDI0MCArIGNvcyhpKSAqIDEyMAoJCWxv
Y2FsIHkgPSAxMzUgKyBzaW4gKGkqMi45NCkgKiA1MAoJCXggPSB4ICsgY29zKGkgKiAyLjc3KSAq
IDMwCgkJeSA9IHkgKyBzaW4oaSAqIDEuNDYpICogMzAKCQlsb2NhbCByID0gdCgpIC0tKyBjb3Mo
aSo0LjMzKSAqIDEwCgkJbG9jYWwgYSA9IGkqNCArIHEqMwoJCWxvY2FsIGR4ID0gY29zKGEpICog
cgoJCWxvY2FsIGR5ID0gc2luKGEpICogcgoJCWxpbmUoeCAtIGR4LCB5IC0gZHksIHggKyBkeCwg
eSArIGR5LCA3KQoJCgllbmQKCXByaW50KHN0cmluZy5mb3JtYXQoImNwdTolLjNmIixzdGF0KDEp
KSwyLDIpCmVuZAo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTAyIDIxOjM5
OjUyIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTM5LTAyIDIx
OjM5OjUyIl1dCjo6IFtlb2NdCg==
:: bios/screensavers/xyzine.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTAxLTE4IDAzOjQ4OjA0Iixtb2RpZmllZD0iMjAyNS0wMi0xOCAwMjowODozNCIs
cmV2aXNpb249ODM5NF1dCi0tW1sKCgl4eXppbmUgYnkgemVwCgkKCWVhY2ggcGFnZSBudW1iZXIg
YWN0cyBhcyBhIHJhbmRvbSBzZWVkCgl0aGVyZSBhcmUgdHdvIGFkZGl0aW9uYWwgcGFyYW1ldGVy
cyAocHgscHkpIHRoYXQgY2FuIGJlIGNvbnRyb2xsZWQKCXdpdGggdGhlIGRwYWQgLyBjdXJzb3Jz
IC8gbW91c2UKCglrZXlzOgoJCXMgdGFrZSBhIDUxMng1MTIgc2NyZWVuc2hvdAoJCWcgcmVjb3Jk
IGEgNTEyeDUxMiBnaWYKCQlyIHRvZ2dsZSByaXNvZ3JhcGggbW9kZQoJCWwgY2FwdHVyZSByaXNv
Z3JhcGggbGF5ZXJzIGZvciBwcmludGluZyAod2hlbiBpbiByaXNvZ3JhcGggbW9kZSkKCQliIGJv
b2ttYXJrIHBhZ2UgJiBwYXJhbWV0ZXJzCgkJCgkJY3RybC1jL3YgdG8gY29weSBhbmQgcGFzdGUg
YSBwYWdlIHNuaXBwZXQKCQkoY2FuIHVzZSB0aGlzIHRvIHNlZSB0aGUgY29kZSB1c2VkIHRvIGdl
bmVyYXRlIHRoYXQgcGFnZSkKCl1dCgppbmNsdWRlICJ0aXRsZS5sdWEiCgotLSB1bmNvbW1lbnQg
dG8gdmlldyBhIHBhcnRpY3VsYXIgcGFnZSAoZWFjaCBwYWdlIGlzIGEgcmFuZG9tIGdlbiBzZWVk
KQotLXN0YXJ0X3BhZ2UgPSA2NzE5NzI2MTE1Ci0tc3RhcnRfcHggPSAwIC0tICAtMTI3Li4xMjcK
LS1zdGFydF9weSA9IDAKCgpwYWdlX2NvbCA9IDAKcGFnZV9tYXggPSAxMDAwMDAwMDAwMAoKLS0g
YWx0IHBhbGV0dGUgdXNpbmcgc3lzdGVtIGNvbG91cnMKLS0gbm8gd2F5IGluayBjb21iaW5lIHRv
IGZvcm0gY29sb3VyIDMwIHRob3VnaCEKLS1yaXNvZ3JhcGhfZGlzcGxheV9wYWwgPSB7WzMyXT03
LFszM109MTQsWzM0XT0xMixbMzVdPTMwfQoKcmlzb2dyYXBoX2NvbHMgPSB7WzBdID0gMzIsMzMs
MzQsMzV9CgotLSB0byBkbzogbWF0Y2ggd2l0aCBhdmFpbGFibGUgaW5rCi0tIHNob3VsZG4ndCBi
ZSB0b28gaGVhdnk7IG1heWJlIHVzZSBhIGJsdWUgbGlnaHRlciB0aGFuIDEyCnJpc29ncmFwaF9y
Z2IgPSB7CgkweGZmZmZmZiwgLS0gd2hpdGUgKGJ1dCBqdXN0IHVzZSBzdGFuZGFyZCB3aGl0ZSkK
CTB4ZmYyMDgwLCAtLSBwaW5rIChzb21ld2hlcmUgaW5zaWRlIDE0LDIzLDgpCgkweDEwYzBmZiwg
LS0gbGlnaHQgYmx1ZQoJMHg2MDAwNzAsIC0tIGRhcmssIHNhdHVyYXRlZCBwdXJwbGUgbGVhbmlu
ZyBvbiBibHVlIHNpZGUKfQoKZnVuY3Rpb24gZW50ZXJfYm9va21hcmtfYnJvd3NpbmcoKQoJaWYg
KCNib29rbWFya3MgPT0gMCkgdGhlbgoJCW5vdGlmeSgiTm8gYm9va21hcmtzIGZvdW5kIikKCQly
ZXR1cm4KCWVuZAoJbW9kZSA9ICJnYWxsZXJ5IgoJYnJvd3NlX2Jvb2ttYXJrcyA9IHRydWUKCWJv
b2ttYXJrX2luZGV4ID0gMQoJbG9hZF9wYWdlX3N0cihib29rbWFya3NbYm9va21hcmtfaW5kZXhd
KQoJYnA6Y2xlYXIoKQplbmQKCmZ1bmN0aW9uIGV4aXRfYm9va21hcmtfYnJvd3NpbmcoKQoJbW9k
ZSA9ICJnYWxsZXJ5IgoJYnJvd3NlX2Jvb2ttYXJrcyA9IGZhbHNlCglsb2FkX3BhZ2Uocm5kKHBh
Z2VfbWF4KVwxKQplbmQKCmZ1bmN0aW9uIHN0b3JlX3NldHRpbmdzKCkKCXN0b3JlKHNldHRpbmdz
X2ZpbGUsewoJCWF1dG9wbGF5ID0gYXV0b3BsYXksCgkJcmlzb2dyYXBoID0gcmlzb2dyYXBoCgl9
KQplbmQKCmZ1bmN0aW9uIF9pbml0KCkKCglhdXRvcGxheSA9IGZhbHNlCglyaXNvZ3JhcGggPSBm
YWxzZQoJCglzZXR0aW5nc19maWxlID0gIi9hcHBkYXRhL3h5emluZS9zZXR0aW5ncy5wb2QiCglz
ZGF0ID0gZmV0Y2goc2V0dGluZ3NfZmlsZSkgb3Ige30KCWF1dG9wbGF5ID0gc2RhdC5hdXRvcGxh
eQoJcmlzb2dyYXBoID0gc2RhdC5yaXNvZ3JhcGgKCglta2RpcigiL2FwcGRhdGEveHl6aW5lIikK
CXNjcmVlbnNob3RzX3BhdGggPSAiL2FwcGRhdGEveHl6aW5lL3Jpc29ncmFwaCIKCW1rZGlyKHNj
cmVlbnNob3RzX3BhdGgpCgkKCWJvb2ttYXJrc19maWxlID0gIi9hcHBkYXRhL3h5emluZS9ib29r
bWFya3MudHh0IgoJYm9va21hcmtzX3N0ciA9IGZldGNoKGJvb2ttYXJrc19maWxlKQoJYm9va21h
cmtzID0gc3BsaXQoYm9va21hcmtzX3N0ciwgIlxuIiwgZmFsc2UpIG9yIHt9CglpZiAoYm9va21h
cmtzWzFdID09ICIiKSBib29rbWFya3MgPSB7fQoJbG9hZF9wYWdlKHJuZChwYWdlX21heClcMSkg
LS0gZm9yIHRpdGxlCgoJdmlkKDApCgl3aW5kb3d7CgkJY3Vyc29yPTAKCX0KCgltZW51aXRlbXsK
CQlpZD0xLAoJCWxhYmVsID0gZnVuY3Rpb24oKQoJCQlyZXR1cm4gYnJvd3NlX2Jvb2ttYXJrcyBh
bmQKCQkJCSJEZWxldGUgQm9va21hcmsgW0RFTF0iIG9yCgkJCQkgIkJvb2ttYXJrIFBhZ2UgW0Jd
IgoJCWVuZCwKCQlhY3Rpb24gPSBmdW5jdGlvbigpCgkJCWlmIGJyb3dzZV9ib29rbWFya3MgdGhl
bgoJCQkJZGVsZXRlX2Jvb2ttYXJrKCkKCQkJZWxzZQoJCQkJYWRkX2Jvb2ttYXJrKCkKCQkJZW5k
CgkJZW5kCgl9CgoJCgltZW51aXRlbXsKCQlpZD0yLAoJCWxhYmVsID0gZnVuY3Rpb24oKQoJCQly
ZXR1cm4gYnJvd3NlX2Jvb2ttYXJrcyBhbmQgIkV4aXQgQm9va21hcmtzIiBvciAiQnJvd3NlIEJv
b2ttYXJrcyIKCQllbmQsCgkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQlpZiAoYnJvd3NlX2Jvb2tt
YXJrcykgdGhlbgoJCQkJZXhpdF9ib29rbWFya19icm93c2luZygpCgkJCWVsc2UKCQkJCWVudGVy
X2Jvb2ttYXJrX2Jyb3dzaW5nKCkKCQkJZW5kCgkJZW5kCgl9CgoJbWVudWl0ZW17CgkJaWQ9MywK
CQlsYWJlbCA9IGZ1bmN0aW9uKCkKCQkJcmV0dXJuICJBdXRvcGxheTogIi4uKGF1dG9wbGF5IGFu
ZCAiT24iIG9yICJPZmYiKQoJCWVuZCwKCQlhY3Rpb24gPSBmdW5jdGlvbiAoKQoJCQlhdXRvcGxh
eSA9IG5vdCBhdXRvcGxheQoJCQlzdG9yZV9zZXR0aW5ncygpCgkJCXJldHVybiB0cnVlCgkJZW5k
Cgl9CgkKCW1lbnVpdGVtewoJCWlkPTQsCgkJbGFiZWwgPSBmdW5jdGlvbigpCgkJCXJldHVybiAi
Umlzb2dyYXBoOiAiLi4ocmlzb2dyYXBoIGFuZCAiT24iIG9yICJPZmYiKQoJCWVuZCwKCQlhY3Rp
b24gPSBmdW5jdGlvbiAoKQoJCQlyaXNvZ3JhcGggPSBub3Qgcmlzb2dyYXBoCgkJCXN3aXRjaF9w
YWdlKDApCgkJCXJldHVybiB0cnVlCgkJZW5kCgl9CgkKCWJwID0gdXNlcmRhdGEoInU4IiwyNTYs
MjU2KQoJCglpZiAoZW52KCkuc2NyZWVuc2F2ZXIpIHRoZW4KCQltb2RlID0gImdhbGxlcnkiCgkJ
YXV0b3BsYXkgPSB0cnVlCgllbHNlCgkJaW5pdF90aXRsZSgpCgllbmQKCQplbmQKCgkJCmxvY2Fs
IG9wLHZhbCxleHBmLGJmcmVxPXt9LHt9LHt9LHt9CgpmdW5jdGlvbiBnZXRfb3AoKQoJaWYgKCNv
cCA9PSAwKSBvcCA9IHsiKyIsIisiLCItIiwiKiIsIlxcIiwifiIsIiYiLCJ8IiwgIiUifQoJcmV0
dXJuIGRlbChvcCxybmQob3ApKQplbmQKCmxvY2FsIHZhbD17fQoKZnVuY3Rpb24gZ2V0X3ZhbCgp
CglpZiAoI3ZhbCA9PSAwKSB0aGVuIAoJCgkJLS0gYnJlYWQgYW5kIGJ1dHRlciB2YWx1ZXMKCQl2
YWwgPSB7CgkJCSIoeC1weCkiLCIoeS1weSkiLAoJCQkiYWJzKHgpIiwgImFicyh5KSIsCgkJCSJ4
IiwieSIsIngiLCJ5IiwKCQkJIjMiLCAtLSBpbnRlcmVzdGluZyBudW1iZXI7IHNob3VsZCBhcHBl
YXIgbW9yZSBvZnRlbgoJCQlmbHIoMStybmQoNCkpLGZscigxK3JuZCg4KSksZmxyKDErcm5kKDE2
KSksZmxyKDErcm5kKDY0KSkKCQl9CgkJCgkJLS0gd2lsZGNhcmRzOyBub3JtYWxseSBkb24ndCB3
YW50IG1vcmUgdGhhbiBhIGNvdXBsZSBpbiBzYW1lIHRyZWUKCQktLSB0aGV5IHRlbmQgdG8gZ2Vu
ZXJhdGUgYSBwcm9taW5hbnQgZmVhdHVyZSB0aGF0IG1pZ2h0IGNvbWJpbmUKCQktLSB3aXRoIGFu
b3RoZXIgZmVhdHVyZSwgYnV0IGJleW9uZCB0aGF0IHRvbyBtYW55IGxheWVyZWQgY29uY2VwdHMK
CQktLSB0aGF0IHN0YXJ0IGNvbXBldGluZyB3aXRoIGVhY2ggb3RoZXIKCQlsb2NhbCBmcmVxID0g
MTIgLS0gMTIgaXMgZ29vZAoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwgImZscihzcXJ0KHgq
eCt5KnkpKSIpCgkJaWYgKHJuZChmcmVxKTwxKSBhZGQodmFsLCAiKHgqeCt5KnkpIikKCQlpZiAo
cm5kKGZyZXEpPDEpIGFkZCh2YWwsICJmbHIoc3FydCgoeC1weCleMisoeS1weSleMikpIikKCQlp
ZiAocm5kKGZyZXEpPDEpIGFkZCh2YWwsICJtYXgoYWJzKHgpLGFicyh5KSkiKSAtLSBwbHVzCgkJ
aWYgKHJuZChmcmVxKTwxKSBhZGQodmFsLCAibWluKGFicyh4KSxhYnMoeSkpIikgLS0gc3F1YXJl
cwoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwgIihhYnMoeCkrYWJzKHkpKSIpIC0tIGRpYW1v
bmQKCQlpZiAocm5kKGZyZXEpPDEpIGFkZCh2YWwsICIobWF4KGFicyh4KSxhYnMoeSkpK21pbihh
YnMoeCksYWJzKHkpKVxcMikiKSAtLSBvY3QKCQlpZiAocm5kKGZyZXEpPDEpIGFkZCh2YWwsICIo
eCZ5KSIpCgkJaWYgKHJuZChmcmVxKTwxKSBhZGQodmFsLCAiKHh8eSkiKQoJCWlmIChybmQoZnJl
cSk8MSkgYWRkKHZhbCwgIigoeCp4KT4_NykiKQoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwg
IigoeSp5KT4_NykiKQoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwgInNnbih4KSIpCgkJaWYg
KHJuZChmcmVxKTwxKSBhZGQodmFsLCAic2duKHkpIikKCQkKCQkKCWVuZAoJcmV0dXJuIGRlbCh2
YWwscm5kKHZhbCkpCmVuZAoKZnVuY3Rpb24gZ2V0X2JmcmVxKCkKCWlmICgjYmZyZXEgPT0gMCkg
YmZyZXEgPSB7MSwyLDIsM30KCXJldHVybiBkZWwoYmZyZXEscm5kKGJmcmVxKSkKZW5kCgotLS0K
ZnVuY3Rpb24gZXhwX2Ffb3BfYihhLCBiKSAKCXJldHVybiBhLi5nZXRfb3AoKS4uYgplbmQKCmZ1
bmN0aW9uIGV4cF9tYXgoYSwgYikgCglyZXR1cm4gIm1heCgiLi5hLi4iLCIuLmIuLiIpIgplbmQK
CmZ1bmN0aW9uIGV4cF9taW4oYSwgYikgCglyZXR1cm4gIm1pbigiLi5hLi4iLCIuLmIuLiIpIgpl
bmQKCmZ1bmN0aW9uIGV4cF9jb3MoYSxiKQoJcmV0dXJuICJmbHIoY29zKCIuLmEuLiIvIi4uYi4u
IikqIi4uZ2V0X3ZhbCgpLi4iKSIKZW5kCgpmdW5jdGlvbiBleHBfYXRhbihhLGIpCglyZXR1cm4g
ImZscihhdGFuMigiLi5hLi4iLCIuLmIuLiIpKiIuLmdldF92YWwoKS4uIikiCmVuZAoKZnVuY3Rp
b24gZ2V0X2V4cGYoKQoJaWYgKCNleHBmID09IDApIHRoZW4gZXhwZiA9IHsKCQlleHBfYV9vcF9i
LGV4cF9hX29wX2IsZXhwX2Ffb3BfYixleHBfYV9vcF9iLCAtLSBicmVhZCBhbmQgYnV0dGVyCgkJ
ZXhwX21heCxleHBfbWluLGV4cF9jb3MsZXhwX2F0YW4KCX0gZW5kCglyZXR1cm4gZGVsKGV4cGYs
IHJuZChleHBmKSkKZW5kCgoKZnVuY3Rpb24gZXhwKGRlcHRoKQoJCgktLSBzb21ldGltZXMgd2Fu
dCBzaG9ydCBicmFuY2hlcwoJaWYgZGVwdGggPiBnZXRfYmZyZXEoKSB0aGVuCgkJcmV0dXJuIGdl
dF92YWwoKQoJZW5kCgkKCWxvY2FsIGEgPSBleHAoZGVwdGgrMSkKCWxvY2FsIGIgPSBleHAoZGVw
dGgrMSkKCQoJbG9jYWwgZmYgPSBnZXRfZXhwZigpCgkKCXJldHVybiAiKCIuLmZmKGEsIGIpLi4i
KSIKCQplbmQKCgpmdW5jdGlvbiBwYWdlX3RvX3N0cigpCglyZXR1cm4gcG9kKHsKCQkJcGFnZT1w
YWdlLAoJCQlweD1weCxweT1weSwKCQkJY29scz1jb2xzLAoJCQlzcmM9c3JjCgkJfSwwLHtwb2Rf
dHlwZT0ieHl6aW5lIn0pCmVuZAoKCmZ1bmN0aW9uIGluaXRfcGFnZSgpCgkKCXB4MSwgcHkxID0g
cHgsIHB5CgkKCWRweCwgZHB5ID0gMCwgMAoJbGFzdF9teCwgbGFzdF9teSA9IG1vdXNlKCkKCWxv
Y2FsIGZmID0gbG9hZChzcmMpCgktLWlmIChmZikgCglpZiAobm90IGZmKSBwcmludGgoImJhZCBm
ZiEgIi4uc3JjKQoJZmYoKQoJZ2VuX3QgPSB0KCkKCXR0ID0gMAoJCmVuZAoKZnVuY3Rpb24gbG9h
ZF9wYWdlX3N0cihzdHIpCgoJbG9jYWwgZGF0LG1ldGEgPSB1bnBvZChzdHIpCgkKCWlmICh0eXBl
KGRhdCkgfj0gInRhYmxlIiBvciBub3QgbWV0YSBvciBtZXRhLnBvZF90eXBlIH49ICJ4eXppbmUi
KSB0aGVuCgkJbm90aWZ5KCJub3QgYW4geHl6aW5lIHBhZ2UiKQoJCXJldHVybgoJZW5kCgkKCWlm
IHR5cGUoZGF0LnBhZ2UpIH49ICJudW1iZXIiIG9yCgkJdHlwZShkYXQucHgpIH49ICJudW1iZXIi
IG9yIHR5cGUoZGF0LnB5KSB_PSAibnVtYmVyIiBvcgoJCXR5cGUoZGF0LmNvbHMpIH49ICJ0YWJs
ZSIgb3IgdHlwZShkYXQuc3JjKSB_PSAic3RyaW5nIgoJdGhlbgoJCW5vdGlmeSgieHl6aW5lIHBh
Z2UgZm9ybWF0IG5vdCByZWNvZ25pc2VkIikKCQlyZXR1cm4KCWVuZAoJCglsb2NhbCB0ZXN0X2Yg
PSBsb2FkKGRhdC5zcmMpCglpZiAobm90IHRlc3RfZikgdGhlbgoJCW5vdGlmeSgic25pcHBldCBj
b3VsZCBub3QgY29tcGlsZSAoYmFkIGJicyBlbmNvZGluZz8pIikKCQlyZXR1cm4KCWVuZAoJCglw
YWdlLHB4LHB5LGNvbHMsc3JjID0gCgkJZGF0LnBhZ2UsZGF0LnB4LGRhdC5weSxkYXQuY29scyxk
YXQuc3JjCgkKCWluaXRfcGFnZSgpCgkKZW5kCgpmdW5jdGlvbiBsb2FkX3BhZ2UocGFnZV9wKQoK
CXBhZ2UgPSBwYWdlX3AKCXNyYW5kKHBhZ2UpCglvcCx2YWwsZXhwZixiZnJlcT17fSx7fSx7fSx7
fQoJCglzcmMgPSAiZnVuY3Rpb24gZih4LHkpcmV0dXJuIi4uZXhwKDApLi4iZW5kIgoJZ2VuX3Bh
bCgpCi0tCWlmIChybmQoMik8MSlnZW5fdGl0bGVfcGFsKCkKLS0JZ2VuX3RpdGxlX3BhbCgpCgoJ
cHgsIHB5ID0gMCwgMAoJCgllYXNlX3gwID0gcm5kKDIwMCktMTAwCgllYXNlX3kwID0gcm5kKDIw
MCktMTAwCgllYXNlX3gxID0gcm5kKDIwMCktMTAwCgllYXNlX3kxID0gcm5kKDIwMCktMTAwCgkK
CWluaXRfcGFnZSgpCgkKZW5kCgpmdW5jdGlvbiBnZW5fcGFsKCkKCgljb2xzID0ge30KCS0tIDIs
MyBtb3N0bHkgbGlrZWx5IHRvIHdvcmsgd2VsbAoJbnVtX2NvbHMgPSBybmR7MiwyLDIsMywzLDMs
NCw1LDYsN30KCQoJZm9yIGk9MCxudW1fY29scy0xIGRvCgkJY29sc1tpXSA9IHJuZCgzMilcMQoJ
ZW5kCgkKCS0tIGhhbGYgb2YgdGhlbSBoYXZlIGJsYWNrIGFzIGZpcnN0IGNvbG91cgoJaWYgKHJu
ZCgyKTwxKSBjb2xzWzBdID0gMAoJLS0gZXZlbiBwYWdlcyBoYXZlIGEgY3VyYXRlZCAic2FmZSIg
cGFsZXR0ZSAobW9zdGx5IHdhcm1lciBjb2xvdXJzKQoJaWYgKHBhZ2UgJSAyID09IDApIHRoZW4K
CQljb2xzWzBdID0gcm5kezAsMSw1LDE4fQoJCWZvciBpPTEsI2NvbHMgZG8KCQkJY29sc1tpXSA9
IHJuZHsKCQkJCTYsNyw4LDksMTIsMTMsMTQsMTUsCgkJCQkxNiwyMiwyMywyNCwyNSwyOSwzMCwz
MQoJCQl9CgkJZW5kCgllbmQKCQplbmQKCgpmdW5jdGlvbiBfZHJhdygpCgkKCWNscyhwYWdlX2Nv
bCkKCQoJaWYgKG1vZGUgPT0gInRpdGxlIikgdGhlbgoJCWRyYXdfdGl0bGUoKQoJCXR0Kz0xCgkJ
cmV0dXJuCgllbmQKCQoJYmxpdChicCxuaWwsMCwwLDI0MC0xMjgsMTM1LTEyOCkKCQoKCWlmKGlt
Z2kgfj0gbGFzdF9pbWdpKSBmbGlwKCkKCWxhc3RfaW1naT1pbWdpCgoJbG9jYWwgcSA9ICh0dCoy
KSU5CgkKCWxvY2FsIGNvbHMxID0gcmlzb2dyYXBoIGFuZCByaXNvZ3JhcGhfY29scyBvciBjb2xz
Cglsb2NhbCBudW1fY29scyA9ICNjb2xzMSsxCglmb3IgeD0tMTI4KyhxXDMpLDEyNywzIGRvCgkJ
Zm9yIHk9LTEyOCsocSUzKSwxMjcsMyBkbwoJCQlicDpzZXQoeCsxMjgseSsxMjgsY29sczFbZih4
LHkpJW51bV9jb2xzXSkKCQllbmQKCWVuZAoJCgkKCXR0Kz0xCgkKCWZvciBpPTEsI3Jpc29ncmFw
aF9yZ2IgZG8KCQlwYWwoMzEraSwgcmlzb2dyYXBoX3JnYltpXSwgMikKCWVuZAoJCgktLSByZW1h
cCBwYWxldHRlIChkb24ndCB1c2UgY3VzdG9tIGNvbG91cnMpCglpZiAocmlzb2dyYXBoX2Rpc3Bs
YXlfcGFsKSBwYWwocmlzb2dyYXBoX2Rpc3BsYXlfcGFsLDEpCgoKZW5kCgpmdW5jdGlvbiBzd2l0
Y2hfcGFnZShkcGFnZSkKCWlmIGJyb3dzZV9ib29rbWFya3MgdGhlbgoJCWJvb2ttYXJrX2luZGV4
ID0gbWlkKDEsIGJvb2ttYXJrX2luZGV4ICsgZHBhZ2UsICNib29rbWFya3MpCgkJbG9hZF9wYWdl
X3N0cihib29rbWFya3NbYm9va21hcmtfaW5kZXhdKQoJZWxzZQoJCWxvYWRfcGFnZShwYWdlICsg
ZHBhZ2UpCgllbmQKZW5kCgpmdW5jdGlvbiBkZWxldGVfYm9va21hcmsoKQoJaWYgKCNib29rbWFy
a3MgPT0gMSkgdGhlbgoJCWJvb2ttYXJrcyA9IHt9CgkJcm0oYm9va21hcmtzX2ZpbGUpCgkJaW5p
dF90aXRsZSgpCgkJbm90aWZ5KCJObyBNb3JlIEJvb2ttYXJrcyIpCgllbHNlCgkJZGVsaShib29r
bWFya3MsIGJvb2ttYXJrX2luZGV4KQoJCXN3aXRjaF9wYWdlKDApCgkJbm90aWZ5KCJSZW1vdmVk
IEJvb2ttYXJrICIuLmJvb2ttYXJrX2luZGV4Li4iIC8gIi4uKCNib29rbWFya3MgKyAxKSkKCWVu
ZAoJc3RvcmUoYm9va21hcmtzX2ZpbGUsIHRhYmxlLmNvbmNhdChib29rbWFya3MsIlxuIikpCmVu
ZAoKZnVuY3Rpb24gYWRkX2Jvb2ttYXJrKCkKCWFkZChib29rbWFya3MsIHBhZ2VfdG9fc3RyKCks
IDEpCglzdG9yZShib29rbWFya3NfZmlsZSwgdGFibGUuY29uY2F0KGJvb2ttYXJrcywiXG4iKSkK
CW5vdGlmeSgiQWRkZWQgQm9va21hcmsiKQplbmQKCi0tIGJpdHMgMHgxIChwaW5lKSAweDIgKGJs
dWUpCmZ1bmN0aW9uIHN0b3JlX3Jpc29ncmFwaF9sYXllcihiaXRzKQoJbG9jYWwgYmlnID0gdXNl
cmRhdGEoInU4IiwxMDI0LDEwMjQpCglmb3IgeD0wLDEwMjMgZG8KCQlibGl0KGJwLGJpZywgeFw0
LDAsIHgsMCwgMSwyNTYpCgllbmQKCWZvciB5PTEwMjMsMCwtMSBkbwoJCWJsaXQoYmlnLGJpZywg
MCx5XDQsIDAseSwgIDEwMjQsMSkKCWVuZAoJCgktLT4gYmxhY2sgYW5kIHdoaXRlICg3KQoJYmln
OmJhbmQoYml0cyx0cnVlKQoJaWYgKGJpdHMgPT0gMHgyKSBiaWc6c2hyKDEsIHRydWUpCgliaWc6
YWRkKDYyLHRydWUpIC0tIDYyIChubyBpbms6IHdoaXRlKSwgNjMgKGluazogYmxhY2spCglwYWwo
NjIsMHhmZmZmZmYsMikKCXBhbCg2MywweDAwMDAwMCwyKQoKCWxvY2FsIGZuID0gc2NyZWVuc2hv
dHNfcGF0aC4uIi94eXppbmVfIi4uZmxyKHBhZ2UpLi4iXyIuLnB4Li4iXyIuLnB5CgkKCWZuIC4u
PSAoYml0cyA9PSAweDEpIGFuZCAiX3BpbmsucG5nIiBvciAiX2JsdWUucG5nIgoJc3RvcmUoZm4s
IGJpZykKCXJldHVybiBmbgplbmQKCi0tW1sKCXN0b3JlX3Jpc29ncmFwaF9wcmV2aWV3CgkqKiBh
bHdheXMgdXNlcyBjdXN0b20gY29sb3VycwoJKGNvdWxkIHRvIGRvIGEgOnRha2UgYmFzZWQgb24g
cmlzb2dyYXBoX2Rpc3BsYXlfcGFsKQpdXQpmdW5jdGlvbiBzdG9yZV9yaXNvZ3JhcGhfcHJldmll
dygpCgoJbG9jYWwgYmlnID0gdXNlcmRhdGEoInU4IiwxMDI0LDEwMjQpCglmb3IgeD0wLDEwMjMg
ZG8KCQlibGl0KGJwLGJpZywgeFw0LDAsIHgsMCwgMSwyNTYpCgllbmQKCWZvciB5PTEwMjMsMCwt
MSBkbwoJCWJsaXQoYmlnLGJpZywgMCx5XDQsIDAseSwgIDEwMjQsMSkKCWVuZAoJCglsb2NhbCBm
biA9IHNjcmVlbnNob3RzX3BhdGguLiIveHl6aW5lXyIuLmZscihwYWdlKS4uIl8iLi5weC4uIl8i
Li5weS4uIi5wbmciIAoJc3RvcmUoZm4sIGJpZykKCW5vdGlmeSgic3RvcmVkIHByZXZpZXc6ICIu
LmZ1bGxwYXRoKGZuKSkKZW5kCgpmdW5jdGlvbiBzaG93X3Jpc29ncmFwaF9sYXllcihiaXRzKQoJ
bG9jYWwgYnAyID0gYnA6Y29weSgpCglicDI6YmFuZChiaXRzLHRydWUpCglpZiAoYml0cyA9PSAw
eDIpIGJwMjpzaHIoMSwgdHJ1ZSkKCWJwMjphZGQoNjIsdHJ1ZSkgLS0gNjIgKG5vIGluazogd2hp
dGUpLCA2MyAoaW5rOiBibGFjaykKCXBhbCg2MiwweGZmZmZmZiwyKQoJcGFsKDYzLDB4MDAwMDAw
LDIpCglibGl0KGJwMixuaWwsMCwwLDI0MC0xMjgsMTM1LTEyOCkKCWZsaXAoKQplbmQKCgpmdW5j
dGlvbiB0YWtlX3NjcmVlbnNob3QobmFtZSwgc2NhbGUsIHNpbGVudCkKCXNlbmRfbWVzc2FnZSgz
LHtldmVudCA9ICJjYXB0dXJlX3NjcmVlbnNob3QiLAoJCQl4ID0gMjQwLTEyOCwgeSA9IDEzNS0x
MjgsCgkJCXdpZHRoID0gMjU2LAoJCQloZWlnaHQgPSAyNTYsCgkJCXNjYWxlID0gc2NhbGUsCgkJ
CWRlbGF5ID0gMiwgICAgICAtLSBnaXZlIHRpbWUgdG8gZ2V0IG91dCB0aGUgd2F5CgkJCW5hbWUg
PSBuYW1lLAoJCQlzaWxlbnQgPSBzaWxlbnQKCQl9KQoJLS0gZ2l2ZSB3bSB0aW1lIHRvIHByb2Nl
c3MgaXQKCWZvciBpPTEsNSBkbwoJCWZsaXAoKQoJZW5kCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgp
CgoJaWYgKG1vZGUgPT0gInRpdGxlIikgdGhlbgoJCXVwZGF0ZV90aXRsZSgpCgkJcmV0dXJuCgll
bmQKCQoJbXgsbXksbWIgPSBtb3VzZSgpCgkKCWlmIGF1dG9wbGF5IGFuZCB0KCkgPiBnZW5fdCAr
IDYuMCB0aGVuCgkJbG9hZF9wYWdlKHBhZ2UrMSkKCWVuZAoKCS0tIHNhdmUgc2NyZWVuc2hvdCAo
dG8gZG86IGFsc28gZnJvbSBtZW51KQoJaWYga2V5cCgicyIpIHRoZW4KCQktLSBzaGlmdC1zIGZv
ciAxMDI0eDEwMjQgLS0gZ29vZCBmb3Igc29jaWFsIG1lZGlhIGJ1dCBtYXliZSBub3QgYmJzIHNo
YXJpbmcKCQktLSBkZWZhdWx0OiA1MTJ4NTEyIHNvIHRoYXQgY29uc2lzdGVudCBzaXplIGluIHRo
cmVhZAoJCXRha2Vfc2NyZWVuc2hvdCgieHl6aW5lXyIuLmZscihwYWdlKSwga2V5InNoaWZ0IiBh
bmQgNCBvciAyLCBmYWxzZSkKCWVuZAoJCglpZiAocmlzb2dyYXBoIGFuZCBrZXlwKCJsIikpIHRo
ZW4KCQlsb2NhbCBmbgoJCQoJCXNob3dfcmlzb2dyYXBoX2xheWVyKDB4MSkKCQl0YWtlX3NjcmVl
bnNob3QoInh5emluZV8iLi5mbHIocGFnZSkuLiJfcGluayIsIDQsIHRydWUpCgkJc2hvd19yaXNv
Z3JhcGhfbGF5ZXIoMHgyKQoJCXRha2Vfc2NyZWVuc2hvdCgieHl6aW5lXyIuLmZscihwYWdlKS4u
Il9ibHVlIiwgNCwgdHJ1ZSkKCgllbmQKCQoJaWYgKGtleXAoInIiKSkgdGhlbgoJCXJpc29ncmFw
aCA9IG5vdCByaXNvZ3JhcGgKCQlzdG9yZV9zZXR0aW5ncygpCgllbmQKCQoKCS0tIHJlY29yZCBn
aWYJCglpZiBrZXlwKCJnIikgdGhlbgoJCXNlbmRfbWVzc2FnZSgzLHtldmVudCA9ICJjYXB0dXJl
X3ZpZGVvIiwKCQkJeCA9IDI0MC0xMjgsIHkgPSAxMzUtMTI4LAoJCQl3aWR0aCA9IDI1NiwKCQkJ
aGVpZ2h0ID0gMjU2LAoJCQlzY2FsZSA9IDIsIAoJCQlmcmFtZXMgPSAzMCoxNiwgLS0gMTYgc2Vj
b25kcwoJCQlkZWxheSA9IDIsICAgICAgIC0tIGdpdmUgdGltZSB0byBnZXQgb3V0IHRoZSB3YXkK
CQkJbmFtZSA9ICJ4eXppbmVfIi4uZmxyKHBhZ2UpCgkJfSkKCWVuZAoKCQoJaWYgKG14IH49IGxh
c3RfbXggb3IgbXkgfj0gbGFzdF9teSkgdGhlbgoJCWxhc3RfbXggPSBteCAgbGFzdF9teSA9IG15
CgkJcHgxID0gbXggLSAyNDAKCQlweTEgPSBteSAtIDEzNQoJCWRweCwgZHB5ID0gMCwgMAoJZW5k
CgoKCWlmIChrZXkoImN0cmwiKSBhbmQga2V5cCgiYyIpKSB0aGVuCgkJc2V0X2NsaXBib2FyZChw
YWdlX3RvX3N0cigpKQoJCgkJbm90aWZ5KCJDb3BpZWQgcGFnZSBhcyB0ZXh0LiAoQ1RSTC1WIHRv
IHBhc3RlKSIpCgkJY2xlYXJfa2V5KCJjIikKCQktLSB0byBkbzogaG93IHRvIGNsZWFyIGJ1dHRv
bj8KCWVuZAoJCglpZiAoa2V5ImN0cmwiIGFuZCBrZXlwInYiKSB0aGVuCgkJbG9hZF9wYWdlX3N0
cihnZXRfY2xpcGJvYXJkKCkpCgkJY2xlYXJfa2V5KCJ2IikKCWVuZAoJCglpZiBrZXlwICJiIiBh
bmQgbm90IGJyb3dzZV9ib29rbWFya3MgdGhlbgoJCQlhZGRfYm9va21hcmsoKQoJZW5kCgkKCWlm
IGtleXAiZGVsIiBhbmQgYnJvd3NlX2Jvb2ttYXJrcyB0aGVuCgkJCWRlbGV0ZV9ib29rbWFyaygp
CgllbmQKCQoJLS0gb25seSBwcm9jZXNzIGJ1dHRvbnMgNCw1IHdoaWxlIGN0cmwgaXMgbm90IGhl
bGQgKGF2b2lkIGN0cmwteC9jL3YgY29uZmxpY3QpCglpZiAobm90IGtleSJjdHJsIikgdGhlbgoJ
CgkJaWYgKGJ0bnAoNCkgb3IgKG1iPT0xIGFuZCBsYXN0X21iPT0wKSkgc3dpdGNoX3BhZ2UoLTEp
CgkJaWYgKGJ0bnAoNSkgb3IgKG1iPT0yIGFuZCBsYXN0X21iPT0wKSkgc3dpdGNoX3BhZ2UoIDEp
CgllbmQKCglsb2NhbCBhY2NlbCA9IDAuMgoJaWYgKGJ0bigwKSkgZHB4IC09IGFjY2VsCglpZiAo
YnRuKDEpKSBkcHggKz0gYWNjZWwKCWlmIChidG4oMikpIGRweSAtPSBhY2NlbAoJaWYgKGJ0bigz
KSkgZHB5ICs9IGFjY2VsCgkKCQoJcHgxID0gbWlkKC0xMjgsIHB4MSArIGRweCwgMTI3KQoJcHkx
ID0gbWlkKC0xMjgsIHB5MSArIGRweSwgMTI3KQoKCWRweCAqPSAuOQoJZHB5ICo9IC45CgkKCWlm
IGF1dG9wbGF5IHRoZW4KCQktLSB1c2UgdCgpIC0tIHR0IG1pZ2h0IGJlIHJ1bm5pbmcgc2xvd2x5
IGlmIHByb2dyYW0gaGFwcGVucwoJCS0tIHRvIHJ1biBhdCBsZXNzIHRoYW4gMzBmcHMKCQkKCQls
b2NhbCBxID0gdCgpIC0gZ2VuX3QKCQkKCQlxID0gbWlkKDAsIChxLTIpLzIsIDEpIC0tIHN0YXJ0
IGF0IDEgc2VjIGFuZCB0YWtlIDIgc2Vjb25kcyB0byBlYXNlCgkJCgkJaWYgKHEgPCAwLjUpIHRo
ZW4KCQkJcSA9KChxKjIpXjMpLzIgLS0gMCAuLiAwLjUKCQllbHNlCgkJCXEgPSAxLXEKCQkJcSA9
KChxKjIpXjMpLzIKCQkJcSA9IDEtcSAgLS0_IDAuNSAuLiAxLjAKCQllbmQKCQkKCQkKCQlweCA9
IGVhc2VfeDAgKiAoMS1xKSArIGVhc2VfeDEgKiAocSkKCQlweSA9IGVhc2VfeTAgKiAoMS1xKSAr
IGVhc2VfeTEgKiAocSkKCQlweCA9IGZscihweCkKCQlweSA9IGZscihweSkKCQkKCWVsc2UJCgkJ
cHggPSBmbHIocHgxKQoJCXB5ID0gZmxyKHB5MSkKCWVuZAoJCglsYXN0X21iID0gbW91c2VfYgoJ
CmVuZAo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9InplcCIsYmJzX2lkPSJ4eXppbmUiLGNy
ZWF0ZWQ9IjIwMjUtMDEtMTggMDM6NDg6MjkiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMDEwNjA2MDEwZDBkMDEw
NjA2MDEwZDA3MDEwMTA3MGQwMTA2MDYwMTA2MDYwMTA2MDYwMTBkMDcwMTAxMDcwZDA2MDcwNzA2
MDYwNjA2MDcwNzA2MGQwNzAxMDEwNzBkMDEwMTAxMDEwZDBkMDEwMTAxMDEwZDA3MDEwMTA3MGQw
MTAxMDEwMTBkMGQwMTAxMDEwMTBkMDcwMTAxMDcwZDA3MDcwNjA2MDcwNzA2MDYwNzA3MGQwNzAx
MDEwNzBkMDEwNjAxMDEwNjA2MDEwMTA2MDEwZDA3MDEwMTA3MGQwMTA2MDEwMTA2MDYwMTAxMDYw
MTBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYw
NjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxs
b3djb2xfaWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixub3Rlcz0iQSBw
cm9jZWR1cmFsIHppbmUgZ2VuZXJhdG9yXG4iLHJ1bnRpbWU9MTMsc2FuZGJveD0iYmJzIix0aXRs
ZT0iWFlaSU5FIix2ZXJzaW9uPSIxLjAiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
MzciLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InRpdGxlLmx1YSMxMSIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIs
d29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDI1LTAxLTE4IDA1OjA2OjQ5Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBn
ZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFNElEQXpPalE0
T2pBMElpeHRiMlJwWm1sbFpEMGlNakF5TlMwdwpNaTB4T0NBd01qb3dPRG96TkNJc2NtVjJhWE5w
YjI0OU56RXpObDFkYkhvMEFBOEdBQURkV1FBQThpdDdXekJkUFh0aWJYQTljSGgxCkFFTWdFQkFF
OEZZSEVBZkFGOUFYd0FjUUItQldMR1pzWVdkelBUQXNjR0Z1WDNnOUxUTXVOVGN4TkRJNEJnQVJO
aGNBT1hrOU1CWUEKdWpVM0xIcHZiMjA5TjMwc1hBQXY5LUJQQURyLUVPRUgwUmZCSjdFM29VZVJW
NEZuY1hkaGgxR1hRYWN4dHlISEVkY0I5dzlzQURyLQpFUWZoRjlFbndUZXhSNkZYa1dlQmQzR0hZ
WmRScDBHM01jY2gxeEhuQWZjQWJRQTZILUFvQVRqLUJDQVlCUEF6SHhVVkh4WVdGNUFmCkh4OFBG
MUFPQUFBaDhBb0hBRVBRSEI4Y0VnQkpIdzhYa0E0QThRUHdHaHNmR2hmd0Noc2VGLUFXSHhVZkZC
UkFBSHh3SHc0ZkZ4ZFEKRVFBRUl3QlNHUmthY0JsbkFBZ1BBSER3R0JJZkdCOGVLd0JxY0I4ZEZo
ZHdEd0JnOEJZU0h4Z1lEd0I2RjNBWUh3NFhVQThBTC1Begpid0U3OFFZbFNaQVpQeGtKY0ZrZUNX
QUpEdzlKRGdsZ0NRMEdBSzhkV1hBSlBSbVFTZkJHY2dBODhRVklrQmctR0Fod1dCNElZQWdQCkRr
Z09DR0FJRFFZQWp4MVljQWc5R0pCSWNnQTUtd0VJQ0FTQUYxQTNNRmNRVnhBM01CZkF6QUE2SC1I
VkF6di1FZmNBQWVjUjF5SEgKTWJkQnAxR1hZWWR4ZDRGbmtWZWhSN0Uzd1NmUkZfRUhiUUE3LXc4
UEFkY1J4eUczTWFkQmwxR0hZWGR4WjRGWGtVZWhON0Vud1JmUgpCX0hWQTRxU1VoRWZFeDhRY05F
d0NBRHdDRThUQUJJQUh4SUFGZkFDRXdBZkVBQWZHQUFkQUI4V0hnQ2lFM0FmR3dBY0FCZ0FSZzRB
Cjh3OGJBQjhjQUI4T0FCOGE4QXNmRndBYUFCb3dFUjhTSGRBZkR3QVpBQmtNQVBFR0h3QWZHUUFl
OEFoRUFCUXdFUklmR05CUEZBQVgKQ2dDQWNOOFY4QlFWSHdVMkJBSUhBTzhxRlJjVUh4LXdDQlVY
RkJ6d2h1Y0FOM01vR0FUd1VOR3c2UUFEQ0FEaEh4SUFIeE1BVGdBUwo4QW9mRWdEc0FQTUZFd0Fm
R0xBUkhoTndIdzBBSHhFQUhBQWZHd0FSQVBBTUhRQlBIQUFiQUI4TzhBb1hBRWNBSHhvQUh4ZXdF
UjhTCkh3MXdFQUFrR2dBT0FQRUNGZ0FmRHdBZkZ3QVpBQjhQOEFvV0FCMGlBVkVaQUI4ZnNQVUFj
MDhXQUI4ZUFFUU5BQkFGYXdGeFR4VHcKQ3Q4VnNBUUJJbkRWQ0FBaDhEcm9CRE1mOEJBSUFCX3VS
UUpNa1RFdU5ETTRNRGsxTWdZQUV6TlBBRFV0TUM0VUFBRWFBQU5SQUJ3MgpVUUQtQVFmUko3Rkhr
V2R4aDFHbk1jY1I5NGRmQUR4SzhYREhJUUlBRDJFQVBBcjBCeF9QWGdBOENfWUhINEJmQUN3UHpn
Rk9QLThTCjhLTUFQUTlSQUk3LUFmZUhFY2N4cDFHSGNXZVJSN0VuMFFkZkFKd2FnTzhHRDE4QVBS
bVA0UVlQSFFJX0QxRUEtekR6RUNDUlFBR1gKQVNBQkJ3MEJmUWNCQUFFSERRWVJaZzBIRVFjTkJn
RUdBVllLQURJV0FVWUtBQ0pCTmdnQUpGRW1KQUJESVFZQkZnd0FVQllSRmdFRwpEQUQtQ3gyQkRR
Y1JCZ2VkQndZUkZwY1dBUUFCdGdFZ0FaWUJRSkVndmdCRkVwMjhBQktXaWdCVElRWU5CZzJXQUdJ
UkJ3WUhCZzJZCkFBQ3dBRk1OQmcwR0VRNEFBUUlBRXlFTkFBQW9BQll4R1FBU1FRc0FINWJLQUdT
UkFRWUhBUmNCQndZQmhnQWhBUllDQUFJTUFFQUgKQmdFWEh3QUJEZ0E1TmgwMkNBQUtIZ0FKT0FB
SFVnQVAwZ0JoRmpIUEFCVXhsUUFmTWNvQUNUSU5NUTBjQUZBZEZqMEdMUlFBWHhFSApNUWNSa2dG
eUlRY2RBZ0FPZEFFUGtnRU1JUVlkQWdBUGtnRmlKZkFqY2dBVFVNQUFGVkNlQUVGUU5oMDJCQUFH
RWdBRHJBQVZVRFlBCkwtQkRrZ0FfbFFZQkJ3WVhCZ2NCQnBJQUFBMEFFQmNYQUVGUU1SMHhCQUFH
RWdBaEFSMENBQlZRTmdBdjhFUDJBVXdGYWdBTjlnRUYKbGdBQkRnQTVNUjB4Q0FBS0hnQUR1QUFD
R2dBSFVnQVB5QUpoSFpHU0FEODJGemJFQUFJUmx3WUFZZ0VORVIwUkRTb0FYeFlkRmgwVwp1QUJw
ZngwWERSY05GeDIyQUJzR0RBQVB1QUJhY1FFV0FSMEJGZ0dfQUJJUkRBQUN6UVJBRFJZTkZzTUFY
eFlYTmhjV3d3QUE4UUlHCkZ4WVhGaGNHQnhFSEVRWVJGaEVHRVFvQU1CMFdIUW9BQURvQ0FCVUFI
d0dCQVY0ZkFjUUFBWDhOQmhjMkZ3WU54Z0FBRVEzR0FBUHAKQkFHeUFBTU1BQURKQUE2TkFRLUVB
RjRBREFBRmlBWVB4Z0FmQkF3QUQ3a0ZVaC13VVFELS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS1kVUcwOU5uMTkKOjogbGFiZWwucW9pCmI2NCRjVzlwWmdBQUFlQUFBQUVPQkFIOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mM3Ytdi14NlA0QUFBRHMKLWlt
dC16WE9QelhzQ2pYZEN2Ny1vd0Rfd3NQSENqODd3RDg3MXpYZENqWGRDdDgxM1FyZk5mMzkwai1f
WDFkUE5lb3VDalhPSWNBMQo2aTRLTmR3N1B5RTd3QW9oTzhBS085WTEzQXJBTmR3SzREWGNDdDgx
LWYzVFA4QXVOZWdLd0M0MXppNC1PelhvQ3NBdU5kc0tQenMtCndEdkFDanZZQ2pYYkNzRTEyd3Jo
TmRzSzN6WDktZFEtd0NFLU5lWUt3alhPUHlFLXdEWG1Dc0V1TmRvdVB5RTdDc0FoT3dyQU84QUsK
TzlVMTJnckNOZG9LNGpYYUN0ODEtZjNWUHlFLXdDRTE1QXJETmM0LUNqLUFMalhrQ3NNMTJRb2hQ
OEFLSVFyQVB3ckFQd3JCT3dvNwp5d283d0FyQ05ka0t3elhaQ3VNMTJRcmZOZjM5MWk0S1B5RS13
RFhpQ3NJdUNqWE9JUzQtd0NFLU5lSUt3aTRLTmRnLXdBby1DajhoCkNzRWhDc1E3elFvN0NzSTEy
QXJFTmRnSzVEWFlDdDgxLWYzWFA4QTdQOEF1UHpYZ0NzUWhOYzQtd0NIQVB3by1OZUFLeERzMTF3
bzcKUHdvdVB3by13QXJFT3dyQk84d0t3RHNLd1RYWENzVTExd3JsTmRjSzN6WDktZGctT3otQUxq
OHV3RFhlQ3NVN05jNC1JVC1DTGo4MQozZ3JGTGpYV1A4QTdQeTQtSVFyQklRckVPd3JBTzgwS084
QUt3RFhXQ3NZMTFncm1OZFlLM3pYOS1kay1Mc0EtTGotQUxqODEzQXJICk5jNGhPei1BSVQtQUxp
RTEzQXJITmRVS3dDN0FDaUUtd0M0aENzQS1Dc0EtQ3NFN0NzRTd6QXJBT3dvMTFRckhOZFVLNXpY
VkN0ODEKLWYzYUlUcy13Q0UtTGo4aExqWGFDc1k3Q2pYT0xqcy1Pei1BTGo4dXdEWGFDc1l1Q2pY
VUxqOEtMai1BQ2o4S1B5RUt3U0VLeERzSwp3VHZNQ3NBN05kUUt5RFhVQ3VnMTFBcmZOZjM5Mnk0
LUljQS13Q0UtT3lFLU5kZ0t5RDgxemk0LUxqLUFMajh1T3o4dU5kZ0t5QzQxCjB3bzdQeTRLT3o4
S0xqOEtQOEFLeERzS3dUdk5DanNLd1RYVENzazEwd3JwTmRNSzN6WDktZHdLSVQ4aFB5RS13U0hB
UHpYV0Nza3UKTmM0LUxpRS1MajhoTGo4dUlRbzExZ3JLTmRJLXdBbzdQOEE3UHk0LUlRckJJUXJF
T3dyQU85QUt3RFhTQ3NvMTBncnFOZElLM3pYOQotZDAtd3lFLXdDRUtQeUUtTmRRS3l6WE9QeUU3
UDhBaFB5NGhQeTQtTGpYVUNzczEwVC1BTGo4S3dDN0FDaUUtd0M0aE96LUFPOEEtCk84RUtPOEVL
MERYUkNzczEwUXJyTmRFSzN6WDktZDRoUHlFLUljQS13RHNLUDhBaENqWFNDc28tQ2pYT1B5NGhQ
eUUtTGo4aExnby0KSVQ4MTBncktMZ28xMEM0aHdDN0FQd291UDhBS1B6cy1JVHZBQ2lFN3dBbzd3
UW83d1FyUE5kQUt6RFhRQ3V3MTBBcmZOZjM5M3otQQpPeUUtd0NIQVB5SEFQeUVLUHpYUUNzdy1O
YzR1UDhBaFA4QWhQeTRoUDhFdVB6WFFDc3doTmM4LUNzQS1DanMtd0FvN1B3b3VQenNLClB6dkFD
anZCQ2p2QkN0STF6d3JOTmM4SzdUWFBDdDgxLWYzZ0NpRS1JVC1BT3dvLU95RUtQeUV1Q2pYT0Nz
MC1OYzRLUDhBaFB5RS0Kd1NIQVA4QWhDc0ExemdyTkxqWE9DaUhBQ2k0LUNqcy13RHMtTGo4aE93
ckFJVHNLd0R2QUNzQTd3QXJBTzhBS3pqWE9DczQxemdydQpOYzRLM3pYOS1lRS1Pei1BT3lFLU95
RXVQeUV1UHlFdVB6WE1DczgxemotRElULUFJUW91SVQtQkNqWE9DczQxN2dyT05jNEt6alhPCkNz
NDF6Z3JPTmM0S3pqWDktZk03SVRzLUlTNC1PeTRLT3lFLUNpRXVDalhLQ3M0LU5jOGhQeUUtSWNB
LXdRckFQeUUtQ2lFMXpnck8KTmU0S3pUWFBDczQxemdyT05jNEt6alhPQ3M0MS1mMzBPei1BT3lF
dU95RXVDaUV1Q3NBdUNzQTF5QXJQTmRBLXdEc2hQOEFod0Q4aApDajhoQ3NFMXpnck5JVFh1Q3N3
MTBBck9OYzRLempYT0NzNDF6Z3JPTmYzOTlTRXVQeUV1UHpzLXdEc2hQd29oTGlFS05jWUt4RHNL
CnlEWFJDaUhCUDhBN1A4RWhQOEFoTGdvMXpnck9OZTRLeXpYUkNzNDF6Z3JPTmM0S3pqWE9DczQx
LWYzMklULUFPei1BT3lFLUljQXUKUHdvdUNzQTF4QXJBT3dyTU5kSWhPei1BT3lFLXdDRXVQeUhB
UHlFS05jNEt6alh1Q3NvMTBnck9OYzRLempYT0NzNDF6Z3JPTmYzOQo5eUUtSWNBdVB5RUt3VDhL
d1Q4aENqWENDc2c3Q3NRMTB5NDdJY0EtSVM0aE93by1PeUVLd0NFMXpnck1Pd28xN2dySk5kTUt6
alhPCkNzNDF6Z3JPTmM0S3pqWDktZmctd0RzS1A4QWhDajhLTGo4S3d6WEFDc0E3Q3NBN0NzazEx
RHMtT3lFLU95RXVQeUV1UHlFdVB3bzEKemdyTk96WHVDc2cxMUFyT05jNEt6alhPQ3M0MXpnck9O
ZjM5X1FvLUlRby1JVDhLd1QtQUNzQS1Dc0EtQ3NBN0NzUTdDc0E3Q3NFMQoxUW83SWNBdVB6c3VQ
enNoUHpzaExnbzF6Z3JOT3pYdUNzYzExUXJPTmM0S3pqWE9DczQxemdyT05mMzlfZ29od0FyQVA4
QUtQd28tCndBckFQd3JFT3dyQU93ckFPd3JDTmRZLUlTNC1PeUUtT3lFdU95RXVQeUV1TmM0S3pq
WHVDc1kxMWdyT05jNEt6alhPQ3M0MXpncmIKTmYzOTdqLUFJVC1BQ3NBaENzRWhDc0EtQ3NBN0Nz
QTdDc1E3Q3NBMTF5RTdJUzRod0M0LUlTNC1PeUVLd0NFMXpnck1MZ28xN2dyRgpOZGNLempYT0Nz
NDF6Z3JPTmM0SzJ6WDktZThod0Q4S0lRby13QXJBUHdyQU93ckFPOEFLd0RzS3dEc0t3RHNLTmRn
N1B5RS13RHMtCndEc2hMajhoTGdyQU5jNEt6UzQxN2dyRU5kZ0t6alhPQ3M0MXpnck9OYzRLMnpY
OS1mQS1Majh1Q3NBaFB3ckFQd3JBUHdyQU93ckEKT3dyQk93ckFOZGstd1NFdVB5RXVQenMtd0Rz
aFB3bzF6Z3JOTGpYdUNzTTEyUXJPTmM0S3pqWE9DczQxemdyYk5mMzk4VHMtQ2k0LQpDc0EtQ3NB
LUNzQTdDc0E3d0FvN3dBckFPelhhSWNBdVB5RS13Q0Utd0RzaFA4QWhMalhPQ3M0MTdqLUNOZG8t
empYT1A4NDF6ai1PCk5jNC0yelg5LWZJLUNqOGhDc0Fod0FyQVB3ckFPd3JBT3dyQU93ckFOZHNo
T3lFLUljQXVQeUV1UHpzaFB3b2hOYzRLekRzS05lNC0Kd1RYYlA4NDF6ai1PTmM0LXpqWE9QOXMx
LWYzelB3ckFQd3JBUHdyRU93ckFPd3JBT3pYY096ODdJVDg3SVM0LUlTNC1JUW8tQ2pYTwpDczQx
N2otQU5kd2hQeUUtd0NFLUljRS1JY0EtSVQ4MXpqLUJJVC1CSVQtQUljTS1OYzQteVNFLXdTRTF6
aUhSUDhBaHdELUFJY0EtCndEWDktZlFLd0QtQUNzQWhDc0EtQ3NZMTNRb2hQeUUtd0RzS1A4QWhQ
OEFoTGdvMXpnck5Malh1UHpYZElUOGhQOFFoUDhBaFA4QWgKTmM0LXhTRS13Q0hBUHlIQVB6WE9Q
ODQxemo4aHdULUJJVC1UTmYzOTlDNC1DaTRLeURzS3dUWGRQenMtd1NFLXdDRUtQeUUtd1FvLQpD
aTRLMnpYZExqWHVQOEF1UDhBdVA4QXV3RDh1UDhBdVB6WE9QOEF1UHk3QVA4QXVQOEF1UHk3QVB6
WE9Mc0EtTGotQUxzTS1Mai1BCkxqWE9QeTdBUHk0LXdDNC1Mc0EtTGotQUxqWDktZjNDQ2lFLUNz
QXVDc0UtQ3NnMTNUOGh3RDhoUHlFLUxnby1JVDhLUDhBS3dDNEsKd1Q4SzFDNDEzVHNoTmU0LXdp
RTdMajg3UDhBN1A4QTdQelhPUDhBN1A4QXVQOEF1UHk3QVB6cy13RFhPUHpzLXdEcy1ManMtT3ot
QQpMajg3TGpYT1B6cy13RHMtTHNBLU96LUFMajh1d0RYOS1mM0JMajhLMGpYZFB5RS1MaUUtTGo4
dUNqOHVQd28tQ3RzMTNRby1JVFh1ClA4QXVJVDhoUDhBaFB5RXVQeUhBUHpYT1B5SEFQeUhBUHk0
aHdDNC13QzQtSVRYT0ljRXVJY0UtSWNFdXdDRXVQelhPUHk0LUlTNC0KTGlIQUxqOGh3UzRoTmYz
OS1jQS1JUzRLSWNBLUNzODEzVDh1UHk3QVB5RS1DaTQtTGdvLXdRby1DdFkxM1FvaExpRTE3aUV1
UHlFdQpJVDhoUDhFN1B5NGhQelhPSVQ4aFA4QWhQeTRoUHk0LXdEcy13RFhPSWNFN0lUODdQOEE3
UHp2QVB5NC1OYzRoUHlFLXdDRS1JY0EtCklUOGh3alg5LWYwaENzQWhDc0UtQ3NFLUNzdzEzU0hB
UHdvLUlRby13QW8td1FvLUNzRS1DdE0xM1FvdUNzQXVOZTRoUHpzLXlBby0Kd0RYT1B3by13QXJB
UHdyRFA4QUtQelhPUDhBS1A4QUtQOEFLd0Q4S3dEOEt3RFhPQ2o4S3dELUFDai1BQ2otQUNzQS1D
alg5LWZ3SwpJY0EtQ2lFS3dUOEt3VDhLekRYZFA4RUtQd291UDhBS0lUOEt3RC1BQ3NBLUN0RTEz
VDhLd0Q4dUNqWHVJVC1BSWNBLXdDRS13QW8tCndDN0FQelhPUHk3QVB5NEtMc0Utd0FvLXdqWE9Q
OEFLUDhBS0xqOEt3QzRLd0QtQUNqWE9Dai1BQ2otQUxqLUFDaTQtQ3NBLUxqWDkKLWZzLXdpNC1D
aTRLMURYZElUOHVDai1BTHNBLUNpNC1Dc0EtQ3RNMTNRckFQd3JCT3pYdVA4UWhDajhoQ2pzaE93
bzdOYzRoQ3NBNwpDc0EtSVFvLUlULUFJY0FLTmM0LXdBbzdQd3JBT3dyQU95RTd3Q0hBTmM0S0lj
QUtQOEFLd0Q4S3dEOEt3RC1BTmYzOV9qOHVJUW91ClA4QUtQeTRLd0M0LUN0QTEzVHMtTGlFLUxz
RUt3Q0UtQ2k0LUNzQS1DczQxM1FyRklUWHVQOEVoUDhFdVB3bzdDc0E3TGdvMXppRXUKQ3NBdUNz
QWhDai1BSVFvLUlTNDF6ai1CQ2otQUNzQS1DanNoTzhBaHdEWE9Dai1BQ2otQUNzQS1Dc0Etd0Fv
LXdEWDktZmt1UHk0SwpQeTQtd0M0LUNqOEt3VDhLMERYZE84QUt3Q0hBTGotQUNqLUFDc0EtQ3M4
MTNRckhOZTRoTHNBLUNzQS1Dc0F1Q3NBdXdqWE9Mc0FLCkxqLUFMai1BTGotQUxnby1MalhPQ3NB
dXdBb3VDc0F1UHdvdVB5N0FQelhPTGdvLUxnb3V3QW91d0FvdVA4QXV3RFg5LWZnLXdDRS0KQ2lI
QVB3by1MZ3JBUDhBS3dEWEFDczgxM1QtQUNqcy1Dc0EtQ3NBLXdBckFJUXJOTmQwS3hqc0tOZTRo
Q2k0aFB3b3VQeTRod0M3QQpQOEF1TmM0aHdEOHVQOEE3UDhBdUNqOHV3alhPT3k0aE95N0FQd291
UHpzdVB6c0tQelhPTGdvdVB3b3V3RHN1SVQ4dUlUOHV3RFg5Ci1mY0tQeUVLUDhNS3dEOEt3VDhL
TmNJS3p6WGRQOEFLUHlFS096OEt3RDhLenpYZENzZ2hOZTQ3UHpzdVB5N0FPeTQ3UHlFN1B5RXUK
TmM0dVB5RXVQeUhBQ2lIQUNqc2hDaTQ3TmM0aE84QS1POEEtTGpzLUxnby1MZ283TmM0aHdEdkFJ
VHZBSVR2QUlTNDdJY0FLTmYzOQo5ajhoQ2otQU96LUFDaUUtQ3NBLUNzQXVOY1FLenpYZFB5NEtJ
UXJBT3o4S0xpRUt3RDhLeWpYZENzazdOZTRLSVQ4aFA4QTdQOEE3ClA4QTdQOEFoTmM0aFB5RTdQ
OEFoQ2o4aExzQWhMc0E3TmM0aE95RS1MaUUtTGlFLUxnby1MZ3JBTmM0aHdEdkFJVHZBSVM0N1B6
c2gKUHpzdU5mMzk5VDg3SVQ4dVB5SEFDai1BQ2k0LUNpNC1OY1lLenpYZE96OEtMaUVLUDhBS3dE
OEt5elhkQ3NzMTdqOEtMajhLUDhBSwpQOFkxemdyT05jNC1Dai1BQ3NBLUNzYzF6ai1EQ2otQUNz
QS1Dc00xLWYzMExzQWhDanMtT3k0LUlRby1DaTdBQ3NBMXlBclBOZDAtCkNqOGhDc0UtQ3NBLUNz
azEzUXJLUHdvMTdpRS13Q0UteWpYT1B3ckFQd28td0FvLUNzQS13Z28xemotRENqOEt4RDhLUHpY
T1A4QUsKUDhFS1A4RUt3RDhLUHdvMS1mM3pQeUVLUHk3QU93ckFJVDhLTGlFS1A4QTF5Z3JQTmQw
LUNqLUFDczQxM1FyTUlUWHVPejhod0Q4aApQeUhBUHlFLUlUOGh3RFhPUDhBS1A4QUt3RDhLd0Q4
aENqOGhQelhPUHdyQVB3ckFQOEFLUDhBS1A4STF6ai1BQ2otQUNzQS1Dc0UtCkNzRS1OZjM5OGdv
aFB3by13RHMtd0FvN1B3ckFJUXJBTmN3S3p6WGRDaUUtSVFvdVB3ckpOZDBLelQ4MTdqOGh3RC1F
SVQtQUlUOGgKUHpYT1A4RUtQOEFLUDhBS1B5RUtQeUUtTmM0LUNqLUFDai1KTmM0LXdBby13QW8t
eURYOS1mSS1Pei1BQ3NBLUNzQS13QW8td0FvLQpOYzRLempYZVB3b3VDc3MxM2dyUExnckFMc0FL
THNFS0xzRUtMc0VLd1M0S3lEWE9QeTQtd0M3QVB5NC14alhPQ2k3QUNpN0FDaTQtCndDNC13QzQt
d0RYT0xzQUt3QzRLTHNBS0xzQUtMajhLTGpYT0NzQXVDaTdBQ3NBdUNzQXVDaTdBQ2k0LUNpNC1M
c0EtTGotQUxqOHUKd0Q4dU5mMzk0VC1BQ2lFLUxqOGhDaTQtd0FvLUNqWFFDczAxM2k0S3dDRS1D
c2sxM2dyTUxnckFMc0FLd0M3QUNqOHV3QW8tQ2k0SwpQd3JDUDhNS0xzSTF6eTdBTzhBaFA4VXVQ
enMxendvdXdBb3V3RDh1UDhBN1A4QXVQelhQUHk0LXdDNEtMc0FLTGo4S0xqOHVOZEEtCkxqcy1M
ajhLTGdvdXdBb3VQd291UHpzdVB6cy13RHMtTGpzLU93by1Pd28xLWYzZ096LUFPejh1Q2lFdUNq
LUFDaTQxMGdyTU5kNEsKd2o4S3lUWGVDczB1Q3NFdUNqOEtMc0EtQ3NBdVA4QUtMc0Etd0M3SU5k
QXVQOEFoUHlFdXdDRXVJVDh1d0RYUVB5N0FQeTQtSVM0LQpJY0EtSWNBMTBEOHVQeTdBUHk0LXdD
NC1JUzQtTmRJdUNqOHVQeTdBUHk0LUNpNC1Mc0EtTGotQUxqOHV3RDh1SVQ4dUNqOHVDaTQxCi1m
M2ZDaTRoQ2k0LXdDNC1MZ28tTGpYVUNzczEzaUUtQ3NBdVB3cklOZDRLelQ4S3dUOEt3QzQtQ2k3
QVB5RXV3RDhoTHNFaHdDN0EKUDhBaHdEODEwVC1BSVQtQkxzQS1PeUVLSVRYUlB5NGh3QzQtSVRz
LXdDRS13RFhSUHk0LUxzQS1Mai1BTGotQUxqWFVQOEF1UHk3QQpQeTQtQ2k0LUxzQS1Mai1BTGot
QklUOGh3RDhoUDhBaFB5RTEtZjNlUHk0S1B5NC13QzQtSWNBS05kWUt5alhlQ3NBdUNzRS1Dc2Mx
CjNnclBJUXJBSWNBS0ljRS1JY0UtSWNFLXdTRS14RFhTUHdvLXdBckFQd3JBUHdyQU5kSS13Q0Ut
eEFvLXdEWFNJY0FLSWNBLUljQS0Kd0NFLU5kWWh3QW9od0Q4aHdELUFJVC1EQ3NBLXdBckFQd3JJ
TmYzOTNTSEFDaUhBUDhFdVA4QTEyQXJKTmQ0dUNzQXVQd3JBUHdyRwpOZDRLekNFS3dDSEFDc0Fo
d0FvLUljQS13U0Utd1NFLXhqWFRMc0FLT3lFS1A4RUtQelhUUDhRS1A4QXV3RFhUSWNNLXdDRS13
VFhZCkljSS13Q0Utd1NFLXdBby13QzRLUHk3QVB3ckJQd3JCSVFyQUlUWDktZHdLUHlFS1B5RS1D
aUVLTmRvS3lEWGVDczQxM2dyTklRckEKUHlFS0lUOGhQeUUtd1NIQVA4RWh3RC1CSVQtQU5kUXVQ
d3JBUHdvLUxqOEtOZFEtd0NFS1B5RUtPeUU3TmRRaHdEOGh3RDhod0Q4aApOZG9oeHpzaHdEc0tJ
VHZBQ2p2QVB3ckFQd29oQ3NBaHdBb2h3RFg5LWRzS3dELUFDajhoTGdvMTNBckhOZDRLd3o4S3lE
WGVDczBoCkNzRWhDc0EtSVFvaFA4RWhQOEVoUDhJaFB3bzExUW8td2lFS0xqODExVC1BSVFvLXdD
NEtQelhWSWNFLUlULUFJY0ExM0NIR095SEEKTHNBLUxzQS1Mc0Etd0M0LUNpRUt3Q0hBQ2lIQVB6
WDktZG8tSVFyQU96OEtPelhlQ3NZMTNqOEt6VFhlQ3M4dUNzQXV3QW91d1FvdQp3UW91d1FyQkxn
ckFOZFktQ2otQUxqLUFMalhXTGdvdXdBb3VDc0ExMWotQU96LUFMai1BTmQ0LUxqcy1MZ28tTGdv
dXdBb3VDc0F1CkNpN0FDaTRoQ2k0aE95NGhPOEFoT3o4MS1mM1pDanNoQ3NBaExqWGdDc1UxM2dy
T05kNEt6RHNLd0R2QUNzQTd3QW91TzhBS0xqc3UKQ2k0S093ckFMZ28xMXk3QVB5NGhQd28xMXpz
dXdEc0tMc0ExMXotQU96LUFMZ28xNEM0S1B5N0JPeTRoQ2k0aENqOHVDaTdBQ2k0aAp3RDhod0Rz
dUlUcy1JVHMtTmYzOTJBckFPeUVLd0RYaUNzUTEzZ3JPTmQ0S3pTRUt3U0VLT3dvaExqc0t3QzQ3
d0FvdXdEdkFMc0ExCjJEcy1JY0EtSVRYWUNqc3VPOEF1TmRnLUljQUtJY0ExNGdvdXdBb3VPd291
Q2o4dUNpN0FDaTdBSVQ4dUlUc3VJVHNod0RzaExqc2gKd0RYOS1kY0t3U0VLTmVRS3d6WGVDczQx
M2dyTk93ckJPd3JBTGpzS095NDd3UzRLTzhBaExqczEyVC1CSVQ4MTJRckFJVHNLTmRrNwpQeUV1
UHpYa0xzQUtManNLTGpzLUNqcy1ManMtTGlFLUxpRTdMaUU3SWNBN1B6dkFQenN1TmYzOTFnckNO
ZVlLd2pYZUNzNDEzZ3JQCk93ckFPOEFLTzhzMTJpSEFQOEExMmotQ05kbzd3alhtUDlNN1A4QTd3
RDg3eERYOS1kVUt3VFhvQ3NFMTNnck9OZDRLekRzS3dEdkEKQ3NBN3dBbzd5VFhiSVRzaE5kcy13
VFhiTzhFMTZELVBPei1BTzhBLU84ZzEtZjNVQ3NBMTZnckFOZDRLempYZUNzMDdDc0E3d0FvNwp5
elhjT3o4MTNDRS1OZHc3d0RYcUlUOGh3VDhod0QtRE96LUFPOEEtTzh3MS1mM1RDalhzQ2pYZUNz
NDEzZ3JOT3dyQk93ckFPOEFLCk84WTEzUW8xM1Q4MTNUczE3RDhoUDhnN1A4QTd3RDg3d1Q4N3lU
WDktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mM1ZQOEUxMmotRE5jZy1O
Y3ctd0RYQlB6WE1Qelg5LWYzOS1mM1lQelhBClB6WFlQOEExUHpVLXdEWEhQelhMUHpYQVB6WEFQ
elhNUHpYOS1mMzktZjNZUHpYQVB6VS1OVC1BTmNBLXdEWEJQOEUxd0QtQk5jUS0Kd1RVLXdUWEdQ
OEkxd0QtQU5jVS1OY0ktd2pYQVA4QTF3RDgxUDhBMVA4STEtZjM5LWYzOTFqLUJOY0Etd0RYQlB6
WEFQelUtTmNJLQpOY2Mtd0RVLU5ULUFOY2MtTmNFLU5jQS1OY1Utd0RYQlB6WEVQelUtd0RYQ1B6
WDktZjM5LWYzWVB6WENQelhDUDhJMXdELUFOY0UtCndEWEdQOE0xeUQ4MXdUODF3RDgxeHo4MXdE
ODF3ai1CTlQ4MXd6ODEtZjM5LWYzOTJEODF3ajgxd2o4MXhUODF3ajgxeEQ4MXd6ODEKeHo4MXdU
ODF3RDgxeEQ4MXdEODF3RDgxd1Q4MXdEODFQelhEUHpYOS1mMzktZjNZUHpYQ1B6WERQOEUxUDhF
MXdELUJOY1ktd3pYSgpQOEExd0QtQU5jWS13RFhDUDhBMXdELUJOVDgxeEQtQU5mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkK
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5eGk3RE5jTXV3
elhITHNJMUxzQTF3UzQxeWk3Qk5lUXV3elhETHNNMXd5N0ROY011Cnd6WElMalhNTHNBMXd5NDF3
aTQxeWk0MXhpN0JOZHN1TmYzOS1mM09Mc0Exd1M3QU5jRXV3RFV1TlM3QU5jWXVOY011TmM0dU5j
QXUKTmRvdU5jVXV3VFhBTHNBMXdTN0FOY0F1d1RYQkxzRTFMc0Uxd1M3QU5jRXV3RFhITGpYTExq
WEFMalhDTGpYUExqWEdMalhBTGpYYQpMalg5LWYzOXppN0FOUzQxTHNBMXdTN0JOUzdCTmNZdU5j
TXVOY0F1d0RYQUxzRTF4UzQxd0M0MXdDN0FOY0V1d1RYQUxzQTF3UzdCCk5jWXVOY1V1d0RYQkxz
QTF3UzdBTmNFdXdEWEJMc0Exd1M3QU5jRXV3RFhCTHNBMXhpN0NOY0F1d0RYRkxqWEFMalhBTHNF
MXdTN0EKTlM0MXdDNDF3QzdCTlM3Q05jUXVOY0F1TmNBdXdEWEFMalV1d0RYQUxzQTF3QzdBTlM0
MXdTN0FOY0F1d2pYQUxzQTF3QzQxTHNBMQp3QzdCTmYzOS1mc3V3RFhCTHNBMXdTN0FOUzQxTHNB
MXhpN0JOY0V1TmNFdU5jQXVOY0F1TmNRdXdUWERMalV1TmNBdU5TNDF3QzQxCkxqWElMalhHTHNF
MXdDN0FOY0V1d0RYQUxzRTF3UzdBTmNFdXdEWEJMc0UxTHNFMXh5NDF3UzQxd0M0MXhDN0NOUzQx
d0M0MXdpNDEKTGpYQUxqVXVOY011TmNZdXdUWERMalV1d0RYRUxqVXVOUzQxTGpVdU5jQXVOY0F1
TmNFdU5jQXVOUzdBTmNFdU5mMzktZjNCTHNNMQp3eTdETmNjdU5jTXVOY0V1TmNBdU5jQXVOY1F1
TmNNdXdUVXVOY0F1TlM3Q05jQXV3RFhHTGpYSExzTTF3eTdETmNNdXd6WERMc00xCnlDNDF3UzQx
d0M0MXhDNDF3QzQxTGpYQUxqWENMalV1TmNBdU5jQXV3RFhCTGpYR0xqWERMc0UxTGpYRExzRTFM
alV1TlM0MUxzSTEKd0M0MXdTN0NOUzQxd3k3QU5mMzktZnd1TmNNdU5jRXVOY011TmNZdU5jTXVO
Y0V1TmNBdXdUWEZMalhDTGpYQUxqWEFMc0UxTGpYRgpMalhFTGpYSExqWERMalhCTGpYRExqWEJM
alhETGpYQkxqWERMalhITGpYQkxqWEFMalhFTGpYQUxqVXVOY0F1TmNJdU5TNDF3QzQxCndpNDF3
QzQxeGk0MXdpNDF3QzQxTGpYQ0xqWEFMalV1TmNFdU5TNDF3eTQxd1M0MXdpNDF4UzQxLWYzOS1D
N0ROY011d3pYSExqWEQKTHNBMUxzRTFMalhITGpYRExzRTF3aTQxd0M3Qk5TN0JOY1V1TmNndXd6
WERMc00xd3k3RE5jTXV3elhKTHNBMXdDN0FOY1V1TmNBdQpOY0F1d1RVdU5jQXVOY0F1d1RVdXdU
WENMc0ExeEM0MXd5N0JOUzQxd3k3Qk5TNDF3UzQxd0M3Qk5jRXV3RFhBTHNFMUxqWENMc0UxCi1m
MzktZVF1TmRJdXdEWDk0aTdBTmYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzkKLWYzOXhDN0JOY0V1d0RYQkxzRTF4aTdBTmZFdU5jZ3VOZEF1d1RY
QUxzRTF3UzdCTmNVdU5jc3VOY3d1TmRJdU5mMzktZjMxTGpYQwpMalhBTGpYQ0xqWEZMalh6TGpY
SUxqWElMalhGTGpYQ0xqWEFMalhDTGpYRkxqWExMalhNTGpYU0xqWDktZjM5OVM0MXdpNDF4UzQx
CnhTNDF3aTdBTmNBdU5TN0FOY1V1d1RYQUxzRTFMalV1d0RYQUxzQTF3UzdBTmNBdXdUWEJMc0Ux
THNFMXdTN0FOY0F1d2pYR0xqWEYKTGpYQ0xqWEFMalhDTGpYRUxzSTF3QzdBTmNVdXdUWEJMc0Ex
d1M3QU5jQXVOY0F1TlM3QU5TNDF3UzdBTmNBdU5TN0FOUzQxd0M0MQp4QzdCTmNFdXdEWEJMc0Ux
d0M3QU5mMzktZjNhTGpYRExzQTF3eTQxeEM3Q05TNDF3QzQxTHNBMXhpNDF3aTQxd2k3QU5jRXVO
Y0F1Ck5TNDF3QzQxTGpYQUxqVXVOY0l1TmNBdU5TNDF3QzQxd0M0MXh5NDF4aTQxd2k3Qk5jTXVO
Y1V1TmNFdU5jQXVOY1F1TmNBdU5TNDEKd0M0MUxqWEFMalV1TlM0MXdDNDFMalV1TmNJdU5TN0FO
Y0V1TlM0MXhTNDF3QzQxd2k0MUxqWEFMalV1TmNBdU5mMzktZjNaTGpYRgpMalhDTGpYRkxqWEJM
alhBTGpVdU5jZ3V3RFhBTGpYQ0xqWENMc0kxTHNJMUxqWEFMalhBTHNBMXdDNDF3QzQxTGpYQUxq
WEFMalhICkxqWEdMalhDTGpYQUxqWENMalhGTGpYQkxqWEFMalhFTGpYQUxqVXVOY0F1TlM0MXdD
NDFMc0Exd1M0MUxqVXVOY0F1d1RVdU5jSXUKd0RYR0xqWEFMalhBTHNFMUxqWEFMalV1d2pYOS1m
MzkyUzQxd2k0MXdDNDF3aTQxeFM0MXdTNDF3QzQxTGpYS0xqVXVOY0l1TmNJdQpOY0l1TmNJdU5j
QXVOY0l1TlM0MXdDNDFMalhBTGpYQUxqWEdMalhITGpYQ0xqWEFMalhDTGpYRkxqWEJMalhBTGpY
RUxqWEFMalV1Ck5jQXVOUzQxd0M0MUxqVXVOY0F1TmNFdU5TNDF3QzQxTGpYQ0xqVXVOY1V1d1RY
QUxqWEFMalhBTHNFMUxqWDktZjM5M0M0MXd5N0EKTmNNdU5jVXVOY0l1d0RYQUxqWEhMc0Uxd1M3
Qk5TNDF3eTdCTmNBdXdUVXVOY0F1TlM3Qk5jQXVOY0F1TmNBdXdEWENMc0ExeEM0MQp4eTQxd2k3
Qk5jTXVOY1l1d0RYQUxzQTF4UzdCTmNFdXdEWEJMc0Exd0M0MXdDNDFMalhCTGpYQUxzRTFMalhD
TGpYQUxqWEVMalhECkxzRTF3aTQxd0M3Qk5mMzktZjNaTHNFMXhpN0JOZjNiTHNFMXhpN0JOZjNE
TGpYSUxzQTEtZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZDB1d0RYQkxqWEdMc0ExeGk3QU5jc3V3RFhCTGpYR0xzQTF4UzQxd0M0MQp4UzQx
OUM0MS1mMzktZjNtTGpYQUxqWEFMalhITGpYRkxqWEFMalhKTGpYQUxqWEFMalhITGpYRkxqWEFM
alhGTGpYaExqWFFMalg5Ci1mMzktZVl1TmNJdXdqVXVOUzdBTmNBdU5jVXVOY3d1TmNJdXdqVXVO
UzdBTmNBdU5jVXVOY0F1TmNRdXdqWEFMc0ExeGk3Qk5jQXUKd0RYQUxzRTF3QzQxd0M0MXdTNDF3
QzdCTmNFdXdEWEJMc0UxTHNJMXdDN0FOY1l1d0RYRkxzRTF3UzdBTmNFdXdUWEFMc0ExLWYzOQot
ZnN1TmNNdU5jRXV3RFhDTGpYRkxqWE1MalhETGpYQkxzQTF3aTQxeFM0MXdDNDF4UzQxd1M0MXdD
NDF4QzQxd2k0MXdDNDFMalhBCkxqVXVOY0F1TmNBdU5jRXVOY0F1TmNJdU5TNDF3eTQxd1M0MXdD
NDF4eTQxeEM0MXdDNDF3aTQxTGpYQUxqVXVOY0F1TmYzOS1mMzYKTGpYRExqWEJMalhETGpYQUxz
STFMalhNTGpYRExqWEJMalhETGpYQUxzSTFMalhBTGpYRkxqWEJMalhBTGpYRUxqWENMalhBTGpV
dQpOY0F1TlM0MXdDNDF3QzQxd1M0MXdDNDF3QzdCTmNBdXdEWEJMalhCTHNJMXhTN0JOY1F1TmNB
dU5jQXV3VFV1TmNBdU5TN0NOZjM5Ci1mMzZMalhBTGpYQUxqWEJMalhETGpYRkxqWEFMalhKTGpY
QUxqWEFMalhCTGpYRExqWEZMalV1TmNZdU5jRXVOY0F1TmNRdU5jSXUKTmNBdU5TN0JOY0V1d1RV
dU5jSXV3VFhBTGpYQUxqWENMalhBTGpYQkxqWEhMalhBTGpYRUxzRTF3QzQxd0M0MXdDN0JOUzQx
LWYzOQotZjNBTHNBMXdpN0FOUzQxd3k3QU5jVXV3RFhDTGpYR0xzQTF3aTdBTlM0MXd5N0FOY1F1
d0RYSUxzQTF3QzdBTmNZdXdUWEFMc0ExCndDNDF4UzQxTGpYQ0xqWERMc0UxTHNFMXdpN0FOY0F1
d1RYRkxzRTF4QzQxd3k3Qk5jSXVOY0F1d1RYOS1mMzktZG91TmYzRExqWEQKTHNBMXhTNDE1UzQx
eUM3QU5mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWRvQUFBQUFBQUFBQVE9PQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAy
NS0wMS0xOCAwNTowNjo0OSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiXV0KOjogbWFw
LzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExURTRJREF6T2pRNE9q
QTBJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTWkweE9DQXdNam93T0Rvek5DSXNjbVYyYVhOcGIy
NDlOekV6T1YxZGJIbzBBSmtCQUFCZEVBQUE4QWg3ZTJKdGNEMTFjMlZ5WkdGMApZU2dpYVRFMklp
d3pNZ01BVUNJd01EQTVCQUFmWVFRQVpBX0FBQ2tmTUFRQUpCZGhCQUFmTUFRQWd4TXpDQUFmTWhB
QUJBQUlBQk14CkJBQVBHQUFOQUF3QUUySVFBQThFQUJVU1lUY0FCVGdBR3pFSUFBUUVBQTRnQUEw
SUFCUXhEQUFQQkFBWlNESXdNREg0QUJOaFZBQVgKWXRnQUZ6a0VBQjh4Q0FBSkR3UUFJQmRpZUFB
Zk9Vd0FBQnN4a0FBUENBQUZCTGdBQk1nQUR3UUEtLS0tLS0tLUdCOWhUQUE4Q0FRQQpIekFFQUJB
SEtBQVhNMndIQ0F3QUFOZ0hFak1NQUNjeE15QUFFekVVQUJjeUdBQW5PV0VFQUI4d0JBQWJGakZV
QUE4TUFBb09GQUFHCkRBQVBCQUFvRURFSUNSOWlWQUFBRnpJTUFBZ0lBQTRNQUFfQUFDc0lTQUVF
VEFnVE9RZ0FCR1FJQ0JRQUNIZ0pCQ0FBRHdRQUtRaFUKQUFmZ0FRa1lBQWdJQUF3VUFBOEVBQzBU
WXZnQUM0d0JKakZoWkFBbk1XRjBBQWNzQUFRZ0FBOEVBUC0tLXc3eENpSXBMR2hwWkdSbApiajFt
WVd4elpTeHdZVzVmZUQwdE5EVUtBUElCZVQwdE1UY3hMSFJwYkdWZmFEMHhOZ29BRUhjS0FJQjZi
Mjl0UFRGOWZRPT0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDEtMTgg
MDU6MDY6NDkiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IHNmeC8wLnNmeApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQXhMVEU0SURBek9qUTRPakExSWl4dGIy
UnBabWxsWkQwaU1qQXlOUzB3Ck1pMHhPQ0F3TWpvd09Eb3pOQ0lzY21WMmFYTnBiMjQ5TnpBeU5s
MWRiSG8wQUtBQUFBQUxDZ0FBLXpCd2VIVUFBeWdBQUFRQUJBOUEKRUFJT0FBR2dBU0FDb0E0QUR4
QUFEZkRLQVFJRFFBOFBrQVFGQmdkQURKQUlDUW9MUUF5UUR3d1BEUThPREVBTThQOEJBT3YtSjZv
QgpFQVlQSUJBQklBRWdBZkFBQWhBQ0RoQUJJQThoSUFFd0QwRHd3dzhvRC0td3hnLTRDZy0tRDRB
UDl3OE5BZkFKQVJBR0RqQUEtLS0tCi0tXzlILThCQUt6UHlBOUFBQThRUVAtLXNQRC1BUUQtNmxE
LS0tLS1LUT09Cjo6IHRpdGxlLmx1YQpiNjQkTFMxYlczQnZaRjltYjNKdFlYUTlJbkpoZHlJc1kz
SmxZWFJsWkQwaU1qQXlOUzB3TVMweU1TQXdOem8xTVRvMU1TSXNiVzlrCmFXWnBaV1E5SWpJd01q
VXRNREl0TVRnZ01ESTZNRGc2TXpRaUxISmxkbWx6YVc5dVBUUTFOek5kWFFvdExTQjBhWFJzWlM1
c2RXRUsKQ2kwdElITnBiWEJzWlN3Z2MyOXNhV1FnWTI5c2IzVnljeUJtYjNJZ2RHbDBiR1VLTFMw
Z0tHeHZiMnNnYTJsdVpHRWdibWxqWlNCMwphR1Z1SUhCaGNuUnpJRzltSUd4bGRIUmxjbk1nWVhK
bElHOWpZMkZ6YVc5dVlXeHNlU0J0YVhOemFXNW5LUXBtZFc1amRHbHZiaUJuClpXNWZkR2wwYkdW
ZmNHRnNLQ2tLQ1dOdmJITTllMzBLQ1dOdmJITmJNRjBnUFNCeWJtUjdOaXczTERFMExERTNMREl5
TERJekxETXgKZlNBdExTQmljbWxuYUhRS0NXTnZiSE5iTVYwZ1BTQnlibVI3TUN3eExEVjlJQzB0
SUdSaGNtc2dLR0Z1WkNCemIyMWxkR2x0WlhNZwpjMkZ0WlNCaGN5QmliR0ZqYXlCaVlXTnJaM0p2
ZFc1a0tRb0pZMjlzYzFzeVhTQTlJSEp1WkhzNExEa3NNVEFzTVRFc01USXNNVE1zCk1UUjlJQzB0
SUdOdmJHOTFjbVoxYkFwbGJtUUtDZ3BtZFc1amRHbHZiaUJwYm1sMFgzUnBkR3hsS0NrS0NXMXZa
R1VnUFNBaWRHbDAKYkdVaUNnbHNiMkZrWDNCaFoyVW9jbTVrS0RFd01EQXdNREFwWERFcENnbG5a
VzVmZEdsMGJHVmZjR0ZzS0NrS1pXNWtDZ29LWW5CMApJRDBnZFhObGNtUmhkR0VvSW5VNElpd3pO
akFzT0RBcENtWjFibU4wYVc5dUlHUnlZWGRmZEdsMGJHVW9LUW9LQ1dOc2N5aHdZV2RsClgyTnZi
Q2tLQ1d4dlkyRnNJSEVnUFNBb2RIUXFOU2tsTVRZS0NRb0pMUzBnWTI5dWMzUmhiblFnYlc5MlpX
MWxiblFnYVc0Z2RHbDAKYkdVZ0tIVnViR2xyWlNCaGRYUnZjR3hoZVNrS0NYQjRJRDBnWm14eUtH
TnZjeWgwZEM4ek1EQXBLalV3S1FvSmNIa2dQU0JtYkhJbwpjMmx1S0hSMEx6TXdNQ2txTlRBcENn
b0piRzlqWVd3Z2JuVnRYMk52YkhNZ1BTQWpZMjlzY3lzeENnbG1iM0lnZUQwdE1UZ3dLeWh4ClhE
UXBMREUzT1N3MElHUnZDZ2tKWm05eUlIazlMVFF3S3loeEpUUXBMRFF3TERRZ1pHOEtDUWtKWW5C
ME9uTmxkQ2g0S3pFNE1DeDUKS3pRd0xHTnZiSE5iWmloNExIa3BKVzUxYlY5amIyeHpYU2tLQ1Fs
bGJtUUtDV1Z1WkFvSkNnbGliR2wwS0dKd2RDeHVhV3dzTUN3dwpMREkwTUMweE9EQXNNakFyTVRZ
cENnbHBaaUFvZEhRZ1BpQXlNREFwSUhSb1pXNEtDUWxzYjJGa1gzQmhaMlVvY201a0tIQmhaMlZm
CmJXRjRLVnd4S1FvSlpXNWtDaTB0Q2kwdENRb0pjR0ZzZENnM0xIUnlkV1VwQ2dsd1lXd29NU3h3
WVdkbFgyTnZiQ2tLTFMwSlkyeHoKS0RJcENnbHRZWEFvTUN3d0xDMDRMREFzTXpJc09Da0tDUW9K
Y0dGc2RDZzNMQ0JtWVd4elpTa0tDWEJoYkNneExERXBjR0ZzS0RjcwpOeWtLQ1FvSmNISnBiblFv
SWxCeVpYTnpJRnd4TlRFZ2RHOGdVM1JoY25RaUxDQXlOREF0T0RVdk1pd2dNVGN3TERjcENnb0pZ
M1Z5CmMyOXlLRGswTERJeU1DdzFLUW9KY0hKcGJuUW9JaUFnSUNBZ0lJNWNNVFV4SUVac2FYQWdV
R0ZuWlhNZ0x5QmNNVE01WERFME5Wd3gKTkRoY01UTXhJSFJ2SUVGa2FuVnpkQ0JRWVhKaGJXVjBa
WEp6WEh4cElpa0tDWEJ5YVc1MEtDSWdJQ0FnSUNBZ0lDQmJVMTBnWm05eQpJSE5qY21WbGJuTm9i
M1FnTHlCYlFsMGdkRzhnWW05dmEyMWhjbXNnY0dGblpWeDhhU0lwQ2dsd2NtbHVkQ2dpSUNBZ0lD
QWdJQ0FnCklDQWdRM1J5YkMxRExDQkRkSEpzTFZZZ2RHOGdZMjl3ZVM5d1lYTjBaU0JoSUhCaFoy
VWlLUW9KQ21WdVpBb0tablZ1WTNScGIyNGcKZFhCa1lYUmxYM1JwZEd4bEtDa0tDZ2xwWmlBb1lu
UnVjQ2cwS1NCdmNpQmlkRzV3S0RVcElHOXlJR3RsZVhBaWMzQmhZMlVpS1NCMAphR1Z1Q2drSmJX
OWtaU0E5SUNKbllXeHNaWEo1SWdvSkNXSnliM2R6WlY5aWIyOXJiV0Z5YTNNZ1BTQm1ZV3h6WlFv
SkNXbG1JQ2h6CmRHRnlkRjl3WVdkbEtTQjBhR1Z1Q2drSkNXeHZZV1JmY0dGblpTaHpkR0Z5ZEY5
d1lXZGxLUW9KQ1Fsd2VDQTlJSE4wWVhKMFgzQjQKSUc5eUlIQjRDZ2tKQ1hCNUlEMGdjM1JoY25S
ZmNIa2diM0lnY0hrS0NRa0pjSGd4TEhCNU1TQTlJSEI0TEhCNUNna0paV3h6WlFvSgpDUWxzYjJG
a1gzQmhaMlVvY201a0tIQmhaMlZmYldGNEtWd3hLUW9KQ1dWdVpBb0pDUW9KWlc1a0Nna0taVzVr
Cjo6IFtlb2NdCg==
:: bios/themes/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: bios/themes/aqua.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTU5LTAxIDIzOjU5OjI1Iixtb2RpZmllZD0iMjAyMy01
OS0wMSAyMzo1OToyNSIscmV2aXNpb249MF1dbHo0AE0BAAAJAgAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgA1dG9wIwB0dG9wMT0xNgwA8ApfcGF0dGVybj1weHUAQyAMDARHEAcQBwA3
BgAwEDcABgARVxIAQQcQB5ACAAgIABWASAADcQDyATE5LGRvcl9ib3JkZXI9MjEOAHF1dHRvbj01
DQCBZnJhbWU9MTMNAHB0aXRsZT02DABKbWFudDgAAhIAAjwABxIAA0EAFTgRAAJFAJExLGljb24w
PTcIAAEKAQAJABAyKgAACQAQM0QAlHRvb2xiYXI9NwoAEDGKAAMMABcyDABWX2JhY2snABBfQgAI
HwBIaXRlbRAAgHNlbGVjdGVkdwA0d2luyQASMQ0AAsQAITEzDgACwAAhMjkNAAK8ABA3DAA0ZG93
NwAVMBAAAzoAFDgRAAM9ABQzEACQdGl0bGU9MzB9
:: bios/themes/biz.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTI2LTIyIDEwOjI2OjE2Iixtb2RpZmllZD0iMjAyMy0z
My0yMiAxMDozMzoyOCIscmV2aXNpb249NV1dbHo0ADsBAADmAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0xNgwARDE9MTMMAPUMX3BhdHRlcm49cHh1AEMgCAgEByAHQAcg
B-ABCQAFLAADVQDjMSxkb3JfYm9yZGVyPTIOAHF1dHRvbj01DQBRZnJhbWVlAKBvcl90aXRsZT02
DABEbWFudDgAFjARAAI7ABUxEQACPwAlMjIRAAJDAJExLGljb24wPTcIADExPTkIAEEyPTI1CQDU
Mz0xLHRvb2xiYXI9NwoAAesAAwwAFzIMAFZfYmFjaycAEF9BAAgfAEBpdGVtMgEEEAD0AHNlbGVj
dGVkPTEyLHdpbsUAEjENAAPBABEzDgADvgAROQ0AAroAEDcMADZkb3f8AAQQAAT7AAMQAAI8ABQ5
DwCQdGl0bGU9MjB9
:: bios/themes/candy.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTQxLTAxIDAzOjQxOjU4Iixtb2RpZmllZD0iMjAyMy01
OC0zMCAxODo1ODozMiIscmV2aXNpb249NV1dbHo0AFYBAAD5AQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yMwwABSYA9St0b3BfcGF0dGVybj1weHUAQyAMDAQAFwAXUAcQ
BxAHQAdAB1AHIAdwBwAHkAfwAQeAR3AngAcAB-AJPwADaADyADAsZG9yX2JvcmRlcj0yMQ4AcXV0
dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYMAERtYW50OAAWMBEAAjsAFTERAAI-ABYzEQACQwCh
MjAsaWNvbjA9NwgAMTE9OQgAMTI9OAgA1DM9Mix0b29sYmFyPTcKABAxhgADDAAXMgwAVl9iYWNr
JwAQX0EACB8AZWl0ZW09OA8A9ABzZWxlY3RlZD0xMix3aW7EABIxDQADwAARMw4AAr0AITI5DQAC
uQAQNwwANmRvd-sABBAAAzoAFDkRAAI9ACQxNRAAgHRpdGxlPTJ9
:: bios/themes/cga.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTM0LTIyIDEwOjM0OjQ1Iixtb2RpZmllZD0iMjAyMy01
My0zMCAxODo1Mzo1NSIscmV2aXNpb249NV1dbHo0ADgBAADnAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yOAwABSYA9Q90b3BfcGF0dGVybj1weHUAQyAICAQHIAdAByAH
8AEJAAUsAANVAOMxLGRvcl9ib3JkZXI9Mg4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYM
AERtYW50OAAWMBEAAjsAFTERAAI-ABYzIgACQwCRMSxpY29uMD03CAAyMT0xCQAQMioAAAkA1DM9
MSx0b29sYmFyPTcKABAxhwADDAAXMgwAVl9iYWNrJwAQX0EACB8AZml0ZW09MSAAgHNlbGVjdGVk
bQA0d2luxgASMQ0AA8IAETMOAAK-ACEyOQ0AArsAEDcMADZkb3f9AAQQAAT8AAMQAAI8ACQxNBAA
gHRpdGxlPTd9
:: bios/themes/classic.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTI4LTAxIDA0OjI4OjI4Iixtb2RpZmllZD0iMjAyNC0w
My0xMCAwMTozNjowOSIscmV2aXNpb249MTVdXWx6NAA1AQAA5QEAAKB7ZGVzazA9MTcsCQBBMT0x
NAkAkV9zaGFkb3c9NQ4ARHRvcDAaAHR0b3AxPTIzDADwCl9wYXR0ZXJuPXB4dQBDIAwMBPAKF5AX
8DAFABUKJgADTwDyATMwLGRvcl9ib3JkZXI9MjEOAHF1dHRvbj01DQCBZnJhbWU9MTMNAHB0aXRs
ZT02DABKbWFudDgAAhIAAjwABhEACEAAAREAAkQAoTE4LGljb24wPTcIAEExPTMxCQAUMhoA1DM9
MSx0b29sYmFyPTcKABAxSQADDAAXMgwAVl9iYWNrJwAQX0EACB8ASGl0ZW0QAIBzZWxlY3RlZEQB
NHdpbsgAEjENAAPDABEzDgACwAAhMjkNAAK8ABA3DAA0ZG93NwAVMBAABP0AAxAACDwAABAAkHRp
dGxlPTE4fQ==
:: bios/themes/concrete.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTA0IDE0OjA2OjM0Iixtb2RpZmllZD0iMjAyNS0w
My0yNSAyMzo1NzoyMiIscmV2aXNpb249NF1dbHo0AC4BAADjAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yMgwARDE9MjEMAPAKX3BhdHRlcm49cHh1AEMgDAwE8AoXkBfw
MAUAFQomAAZPAJFvcl9ib3JkZXJFAAAOAFN1dHRvbhsAgWZyYW1lPTEzDQBwdGl0bGU9NgwASm1h
bnQ4AAISAAI8AAYRAANAABU5EQACRAChMTgsaWNvbjA9NwgAMTE9NggAFDIZANQzPTEsdG9vbGJh
cj03CgAQMYgAAwwAFzIMAFZfYmFjaycAEF9BAAgfAEhpdGVtEACAc2VsZWN0ZWRcATR3aW7HABIx
DQADwgARMw4AAr8AITI5DQACuwAQNwwANGRvdzcAFTAQAAT8AAMQAAP7AAUwAJB0aXRsZT0xOH0=
:: bios/themes/moonlight.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTU4LTAxIDAyOjU4OjMxIixtb2RpZmllZD0iMjAyNC0w
My0wNyAwNTozODowMiIscmV2aXNpb249MjddXWx6NABDAQAA6QEAAKB7ZGVzazA9MTMsCQBBMT0x
NAkAkV9zaGFkb3c9NQ4AZHRvcDA9MAsANDE9MQsA9RZfcGF0dGVybj1weHUAQyAICAQgF0AHoAcA
B1AXUAcAB6AHQBcgLQADVADyADAsZG9yX2JvcmRlcj0yMQ4AcXV0dG9uPTUNAFFmcmFtZZMAoG9y
X3RpdGxlPTYMAERtYW50OAAWMBEAAjsAFTERAAg-AAERAAJDAKExOCxpY29uMD03CABBMT0yOQkA
QTI9MTYJANQzPTAsdG9vbGJhcj03CgAQMUkAAwwAFzIMAFBfYmFja0MABBAAAEIACCAAQGl0ZW10
AAQQAIBzZWxlY3RlZG4ANHdpbsgAEjENAAPEABEzDgACwQAhMjkNAAK9ABA3DAA2ZG93-wAEEAAD
OgAUOBEACD0AABAAgHRpdGxlPTF9
:: bios/themes/synthwave.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTMxLTAxIDAzOjMxOjQ0Iixtb2RpZmllZD0iMjAyMy0z
MS0wMSAwMzozMTo0NCIscmV2aXNpb249MF1dbHo0AEEBAADoAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0xOAwARDE9MzAMAPURX3BhdHRlcm49cHh1AEMgCAgEEAdQJzBH
8AEHUDcgN3AoAANRAPIBMTksZG9yX2JvcmRlcj0yMQ4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRp
dGxlPTYMAEptYW50OAACEgACPAAHEgADQQAVOBEAAkUAkTEsaWNvbjA9NwgAQTE9MjgJABAyzQAA
CQDUMz0xLHRvb2xiYXI9NwoAEDGJAAMMABcyDABQX2JhY2tDAAQQAABCAAggAHVpdGVtPTI5EACA
c2VsZWN0ZWRuADR3aW7JABIxDQACxAAhMTMOAALAACEyOQ0AArwAEDcMADRkb3c3ABUwEAADOgAU
OBEAAz0ABRAAgHRpdGxlPTJ9
:: bios/themes/tangerine.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTEzIDA1OjU5OjU2Iixtb2RpZmllZD0iMjAyNC0w
My0xMyAwNjowNDoyOSIscmV2aXNpb249MV1dbHo0ADgBAADgAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgBldG9wMD0xDAA1MT0yDADwCl9wYXR0ZXJuPXB4dQBDIAwMBPAKF5AX8DAF
ABUKJgADTwDzADMxLGRvcl9ib3JkZXI9Mg4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYM
AERtYW50OAAWMBEAAjsAFTERAAI-ABU0EAACQgCRMSxpY29uMD03CAAxMT05CABBMj0xOAkA1DM9
MSx0b29sYmFyPTcKABAxhQADDAAXMgwAVl9iYWNrJwAQX0EACB8AZWl0ZW09OQ8AgHNlbGVjdGVk
MwE0d2luwwASMQ0AA78AETMOAAK8ACEyOQ0AArkAEDcMADZkb3f6AAQQAAM6ABQ5EQACPQAFDwCQ
dGl0bGU9MTl9
:: bios/util/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-14 00:47:38"]]
:: bios/wallpapers/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: bios/wallpapers/biplane.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBib25lcy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3Jl
YXRlZD0iMjAyNC0zMi0wNSAwNzozMjozOCIsbW9kaWZpZWQ9IjIwMjQtMDMtMDYgMTE6MDk6MjYi
LHJldmlzaW9uPTI0M11dCi0tW1sKCgkKCl1dCgpmdW5jdGlvbiBib25lKHgseSxhKQogbG9jYWwg
bCA9NwogbG9jYWwgYj02NgogCiBhKz0xLzI4CiBhJT0xCiBsb2NhbCBxPSBmbHIoYSo0KSAtLSAw
Li4zIC0tIHdoaWNoIGdyb3VwIG9mIDcKIGxvY2FsIG9mcz17WzBdPQogIDEsNSwgNSw1LCA1LDEs
IDEsMQogfQogCiAtLWxpbmUoeCx5LHgrY29zKGEpKmwseStzaW4oYSkqbCwgMTQpCgogbG9jYWwg
aT1mbHIoKGElMC4yNSkqMjgpCiBiID0gZmxyKGEqMjgpCiB4LT1vZnNbcSoyKzBdCiB5LT1vZnNb
cSoyKzFdCgogc3ByKGIseCx5KQogCmVuZAoKCmZ1bmN0aW9uIGRyYXdfc2tlbGx5KHMpCgoJbG9j
YWwgYT1zLnBvc2UKCWxvY2FsIHN4PTAKCWxvY2FsIHN5PTAKCWxvY2FsIHgseQoJbG9jYWwgbD03
Cglsb2NhbCBsbD04IC0tIGxlZyBsZW5ndGgKCglwZGF0PXtbMF09CgkJezcsLTYsN30sCgkJey04
LC02LDd9LAoJCXszLDYsOH0sCgkJey00LDYsOH0KCX0KCgktLWNpcmNmaWxsKHMueCwgcy55LCAy
LDgpCgkKCS0tIGNhbGMgbG93ZXN0IGZvb3QKCglseCA9IDAKCWx5ID0gc3kgKyAxMCAtLSBoaXAg
Ym9uZQoJbGkgPSAwCglmb3IgaT0yLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQlsb2NhbCB4PXN4
K2RbMV0gCgkJbG9jYWwgeT1zeStkWzJdKzAgLS0gaGlwCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10g
CgkJeSs9c2luKGFbaSoyXSkqZFszXQoJCXgrPWNvcyhhW2kqMisxXSkqZFszXSAKCQl5Kz1zaW4o
YVtpKjIrMV0pKmRbM10KCgkJbHkgPSBtYXgobHkseSkKCQlpZiAoaT09MiBvciBseT09eSkgdGhl
bgoJCQlseD14CgkJCWxpPWkKCQllbmQKCWVuZAogCgktLSBhZGp1c3QKCXN5IC09IChseSAtIDIy
KQoKCglpZiAobm90IHMubGx4KSBzLmxseD0wCglpZiAocy5jaSAhPSBsaSkgdGhlbgoJCS0tIHBs
YW50IGFuY2hvciBmb290IAoJCS0tIC5jeCBtZWFucyBhbmNob3IgcmVsYXRpdmUgdG8gc3RhcnRp
bmcgcG9zaXRpb24gKG5vdCAnY2VudGVyJykKCQlzLmN4ID0gbHggKyAocy5jeCAtIHMubGx4KQoJ
CXMuY2kgPSBsaQoJZW5kCgkgCglzLmxseD1seCAtLSBsYXN0IGxvd2VzdCB4CglzeCAtPSAobHgg
LSBzLmN4KQoJc3ggKz0gcy54CglzeSArPSBzLnkKIAoKCS0tIGJvZHkKCXNwcig0MCxzeC04LCBz
eS04KQoKCS0tIHJlZ3VsYXIgaGVhZAoJc3ByKDMyLHN4LTMrcy5oeCxzeS0xNCtzLmh5KQoKCS0t
IGJ1bm55IGhlYWQgKGVhc3RlcikKCS0tc3ByKDQzLHN4LTMrcy5oeCxzeS0xNCtzLmh5LTgsMS4y
NSwyKQoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQl4PXN4K2RbMV0geT1zeStk
WzJdCgoJCWJvbmUoeCx5LGFbaSoyXSxpKjIrMCkKCgkJeCs9Y29zKGFbaSoyXSkqZFszXSAKCQl5
Kz1zaW4oYVtpKjJdKSpkWzNdCgoJCWJvbmUoeCx5LGFbaSoyKzFdLGkqMisxKQoKCWVuZAoKZW5k
Cgo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTAzLTA2IDEw
OjM5OjI5Iixtb2RpZmllZD0iMjAyNC0wMy0wNiAxMTowOTo0NiIscmV2aXNpb249MTldXQoKCmZ1
bmN0aW9uIF9kcmF3KCkKCXBhbCgpCgljbHModGhlbWUiZGVza3RvcDAiKQoJcGFsKDAsdGhlbWUi
ZGVza3RvcDAiKQoJcGFsKDcsdGhlbWUiZGVza3RvcDEiKQoJc3ByKDEpCmVuZAo6OiBwb3NlLmx1
YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTQ5LTA1IDA3OjQ5OjU3Iixtb2Rp
ZmllZD0iMjAyNC0wMy0wNiAxMTowOToyOSIscmV2aXNpb249MTc5XV0KCgpmdW5jdGlvbiBkZWZw
b3NlKCkKCXJldHVybiB7WzBdPQoJICAwLjcsMC45LAoJICAtMC4zLC0wLjQsCgkgIDAuODUsMC43
NSwKCSAgMC42NSwwLjc1LAoJICAwCgkgfQplbmQKCmZ1bmN0aW9uIG1ha2Vwb3NlKG4pCgogbj1m
bHIobikKIAoKCWxvY2FsIHBkYXQ9e1swXT0KCQoJIC0tIGRlZgoJIHtbMF09CgkJICAwLjg1LDAu
NzUsCgkJICAtMC4zLDAuNzUsCgkJICAwLjg1LDAuNywKCQkgIDAuNjUsMC43LAoJCSAgMAoJCSB9
LAoJCSAKCSAtLSAxLiBhcm1zIGRvd24KCQl7WzBdPQoJCSAgMC44MCwwLjkwLAoJCSAgMC43MCww
LjYwLAoJCSAgMC45NSwwLjk1LAoJCSAgMC41NSwwLjg1LAoJCSAgMAoJCSB9LCAKCQkgCgkJLS0g
MiBydXNzaWFuCgkJLS0gKGFybXMgd2F2ZSkKCQl7WzBdPQoJCSAgMC4yMCwwLjM1LAoJCSAgMC40
NSwwLjYwLAoJCSAgMC45NSwwLjk1LAoJCSAgMC41NSwwLjg1LAoJCSAgMAoJCSB9LCAKCQkKCQkt
LSAzIHN0b21weQoJCS0tIChhcm1zIG9wZW4gLS0gaGV5IGhvKQoJCXtbMF09CgkJICAwLjAsMC4x
NSwKCQkgIDAuMzUsMC4yNSwKCQkgIDAuNzUsMC43NSwKCQkgIDAuNDUsMC42NSwKCQkgIDAKCQkg
fSwKCQkgCgkJLS0gNCBhcm1zIHVwCgkJe1swXT0KCQkgIDAuMjUsMC4zNSwKCQkgIDAuMjUsMC4x
NSwKCQkgIDAuNzUsMC43NSwKCQkgIDAuNiwwLjYsCgkJICAwCgkJIH0sCgkJIAoJCQoJfQoJCglu
PW4lKCNwZGF0KzEpCgogbG9jYWwgcD17fQogZm9yIGk9MCw4IGRvCiAgcFtpXT1wZGF0W25dW2ld
CiBlbmQKCglyZXR1cm4gcAplbmQKCgoKLS0gY2hhc2UgcG9zZQpmdW5jdGlvbiBjaHBvc2UocDAs
cDEscSkKIGZvciBpPTAsNyBkbwogIGxvY2FsIGEwPXAwW2ldCiAgbG9jYWwgYTE9cDFbaV0KICBh
MCU9MSBhMSU9MQogIGlmIChhYnMoYTAtYTEpPjAuNSkgdGhlbgogICBhMCs9c2duKGExLWEwKQog
IGVuZAogIGEwPWEwKigxLXEpK2ExKnEKICBwMFtpXT1hMCUxCiBlbmQKIAogLS0gaGVhZAogcDBb
OF09cDBbOF0qKDEtcSkrcDFbOF0qcQplbmQKCgpmdW5jdGlvbiBmbGlwX3Bvc2UocCkKIGZvciBq
PTAsMSBkbwogIGZvciBpPTAsMSBkbwogICBwW2oqNCtpKzBdLHBbaio0K2krMl09CiAgIHBbaio0
K2krMl0scFtqKjQraSswXQogIGVuZAogZW5kCiBmb3IgaT0wLDcgZG8KICBwW2ldPSgwLjUtcFtp
XSklMQogZW5kCiAKLS0gcFs4XSo9LTEKIHBbOF09MHgwLmZmZmYtcFs4XQogCmVuZAoKOjogLmlu
Zm8ucG9kCi0tW1twb2QsYXV0aG9yPSJjYXN0cGl4ZWwiLGNyZWF0ZWQ9IjIwMjUtMTEtMTMgMjE6
MDc6NDMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBk
MGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEw
NzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzA3MDEwMTA3MDcwNjA2MDYwNjA2MDYwNjA2MDYwNzA3MDcwMTAxMDcwNzA2MDYwNjA2
MDYwNjA2MDYwNjA3MDcwNjAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMTA2MDYw
NjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKSxsb3djb2xfaWNvbj10cnVlLG1vZGlm
aWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixub3Rlcz0iIixzdG9yZWQ9IjIwMjQtMDMtMjMgMTk6
NDU6MzQiLHRpdGxlPSJCaXBsYW5lIix2ZXJzaW9uPSIxLjAiLHdvcmtzcGFjZXM9e3tsb2NhdGlv
bj0ibWFpbi5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29y
a3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwL21hcDAubWFwIix3b3Jrc3BhY2VfaW5kZXg9
M30se2xvY2F0aW9uPSJzZngvc2Z4MC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngv
LmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wMy0wNiAxMDozOToyOSIsbW9kaWZpZWQ9
IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyNC0wMy0wNiAxMDozOToyOSJdXQo6OiBn
ZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01
T2pJNUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB3TmlBeE1Ub3dPVG8wTmlJc2NtVjJhWE5w
YjI0OU1UVmRYV3g2TkFCRUZnQUFZMDRBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3
TEdac1lXZHpQVEFzY0dGdVgzZ0lBT1o1UFRBc2MyTmhiR1U5TVRKOUxETUF6eWpnQVFBQURnRUFB
QVR3LXdFQUhQTWcKMVlmdy04WW5ZQ2Z3LThJbjhQLUpWLUQteURmdy04d1g4UC1PRi1ELXlIZnct
OGNuOFAtTkYtRC16d2Z3LTg4WUFBUU1BQUFJQUJQUQpCQUFUemlnQUFDQUFGODBNQUFna0FBRUVB
QllYQkFBanp3Y01BUEVSTi1ELXpRZnctNzFub0Jmdy03c25RQmVRQi1ELXVpZHdCNUFYCjhQXzRG
NUFRQUVHM0Y3QUhDQURCQjdBWGdCZnctN1lYd0NkZ0VBQXc4QUFIQ1FEd0dMWW40QmRBRi1ELXRS
ZndBZ2RBQi1ELWUyY1EKTi1BZUItQURGeUFYOFA5NUp5QUhBRGNRQnhJQThDa0VSLUQtZVJkQUJ4
QUhNQWZ3SGhmdy01RUh3Q2Z3SGlmdy00NFh3QWNBQi1BZgpCLUQtalNmd0FCZndIUmZ3LTR3WEFB
ZndBUWZ3SFJZQU1nZndCQW9Ba0l3WDhBUVhNRWZ3RXd3QThCQUg4QVlIRUNjZ0YtQVFOLUQtCml3
ZndCamRRRi1BSU54QVg4UF9PQi1BRndnQWdCeGNjQUVDUEYtQUUyQUN5Qndmdy0zZG44QWtIOEE4
TkFFQnlWeUJIQ1FBUUVDb0EKOEI3dy0yMUhnRWVBUjJBWDhCQVg4QVVYOFA5cFY4QlhjQWNnUnlB
SDhCSUg4QVVIOFA5bFY2RFhZQ2RBSndBU0FDRGdKMnNBOENSaApSNkQzQkdBSGNDZndFZ2ZRRndB
MzhQOWRWNUQzQ2dBWEVCZGdGLUFVQjlBSElBZnctMXBYa1BjUEVEZHdCLUFWSjdBUUFLQkhvUGNV
CjhBY244QXNuWVFId0NWVlhrUGNaOEFjSEFCZndERWRRQi1ELVVGZVE5eDd3Qk0wQUlBOEhFUUNB
VEVlQTl5VGdWd0FfQVJFT2RBR0EKUjFkdzl5blFGeUFOQUJFTzZBQ2lRMWR3OXk3UUIwQUhNQlFC
OFVJeUJfQkhjSmNnOXlXd042QUhFQ2Z3LTFBbmdGZGcxekQzSWZBRApGNUEzQUFmdy0wOFhBQWN3
VjJEM0JCRDNIZkFaSi1ELVRCY1FWMkQzQ1JEM0dQQWdKLUQtU1Jjd0IwRDNEeEQzRTNBSDhCd3FB
ZkFYCi15Z25RQWNBOXhNUTl3M1FCLUFtaDFDSDhQOGpaMUJIRVBjT0VQY0k4QU1YOENCWFVJZWlB
RUlmVnpBWEdBQWhwd0IzQWZBY0hUZncKQ0Jmdy14dFhZQ2RRUnlEM0R3Q25BQmZ3Q1Zmd0d5ZndD
aGZ3LXhkWFlHZGdSeEQzRUFDSEFCSUM4QU1LQi1BZkYtQUpOLUQtRTFkZwpaeUFYVUZjY0FDQTNV
QndBOEFzSkYtQWZaLUFCTi1ELUVWZGdsekFYWUFjQUp4RDNFUUFIZ0I0QW9BZ1g4Q1FYY0tmdy13
LXdBTFFYCllCY2dCeERIQU5jd0J5QUFNUWZ3STRRRDl3RVVWMUQzQTBBSGNBY2dGeERIQUhlUUlR
QVJJU0VBWXhGWFVQY0hRRUlBTkJBbjRDRUEKNFFjWDhCOG5VRGZ3LXc1WFVMY1FaQUJCTUFjUUI5
SUFGQUVsQVBBS0FsZndIaWRBTi1ELURGZFE5d0VRMXlBWFlIY0FGeUEzSU4wQwpGQUltQUtBQkYt
QWZSeUJIOFA4S2JBRG9BUGNBQUFkZ055QUhFQmVRQnhBbkFBQkFBUUFuQVBBQ0RSZFFweERuRU1j
UUYxQVhRQmNBCko1QTNBZ2duQVBBRkdqY1FSLUQtRUJjUTF6RDNBQUNIUUJkUUYxQ2NBQ0FIZ0hn
QThCUURCd0FYY0FjQUI4Qkg4QnBuOFA4VEZ4RDMKQUJEM0FSQTNjQmRnQnhBM0FBY0FGeUVBRUJB
cUFDRVFCeW9BUUFmdy0wZ2pBbkFDQUJlQUYyQVhBQU1RSUJvQVZSZndBeGNBSXdDdwpTdmNDRVBj
RWtBZGdGeEF1QVVBSElBZGdjQUFtQlFjakFQb0dUZWNRdHdCWGtCZFFGekFYRUFjQUZ5QUhZQWNR
SXdEUVVMY1F0d0FICkVCZEFaMUFYVUVnQUlDZGdhUUFGSXdDUUotRC1Vb2NBZHlBSHFRQ1FNSGRR
RjNBWFlDY3dhUUFTQmlNQW9CZlFKLUQtVTFjQU4yQWoKQUJBSEl3QlVrQmRnWnhBaEFLQVFCLUFB
Si1ELVZDY1FNUUZ3SnlCM1VCZXdGN1FBSWdBWElnQUFUQUFRQWlJQUVRY2lBSUVYSUlkQQpGOUFI
Y0xFQUpQQUdhQUh5Q0FRSDhQOVVGd0FIZ0RjZ2QwQTN3QmR3QjBBbjhBRTNYQUZBc0Rjd0YwRUFn
QUFIa0NjUWR6QlhQd0F3ClVDZlFRd0FBendCQkI2QVhFQzhGQVNJQXdCY2daekIzd0FlQUYyQW5v
SWNBRUFkY0JRQ1hBekVBQnlCakJBTW1BTlIzRUlmQUY0QUgKZ0Nkd0Z4QW5KZ0F4SUJjd1lnSWdW
UWVjQWNFUUowQzMwQWVBQjZBblVBY2lBUVFtQUVBSDhQOW16d0FCMndHb0lHZlFCNEFYc0NjZwpG
eVFBQUdvQVFEVkg4QnpVQUFFckFJQWdWOUFIa0FmUUozUUVBU2NBRUJkNkF3QUNCQkExM2dVa0hB
Y3BBQURNQVFBckFGRHdBQ2N3Ckp5SUFBYUlEV1A4MkowQUhKZ0FpQnlBbUFDQUNOMndCdFFBSElE
Y0FaLUQtTGlkZ0pnQW1GM0FtQUJBRW5RQVFkN1lDQUVzRU5Dc24KZ0NZQUVDRDNBaEZISkFBZ0FS
ZHdBTEdBQndDSDhIVW44S0FYa0pZQUFPSUFVaWNnSjBCWGxBQVJOMU1CVUtjQWgtQjA0d0ZoblNl
UQpGLUFkMmdMd0FCQVhBRWRBZDlBSGNEZmdCeEFYTUNVQThnQjM4SE1uSUJjUUotQ1hCOEEzOEJy
ZUFuQVhFUGNCWUJkUU1nQXdKOEFICmt3THdCd0NuQUFmd0VKZndURWNBQnpBMzhCd1g4R0ozQUFl
OEJoQWFRZ0xCSnhDbkVFZmdCMkFYTUNlZ093RVJNSVFCRUVBWEFmRUEKQ1hkd0otQkVaLUFwRi1C
aUYxQW5zQU1CZGdLMUVMY2dOX0FIWUFkZ0Y1QTBBQ0VRRnpRQUlBSjNKUVRRUDBmd0xTZndZU2Z3
Q2lmdwpHYlVCb0JjUVp4QkhFQ2RRRjNBM0FFQW5nQWNnTlFBQklBWFFrSWZBbHhBSDhEMG5ZRWZ3
SkdvQXNQQU1Cd0FuOEJjSEFBZFFaQUpoClJ4QkhJQmVncEFZZ0VHY1dBaUV3QjBrQjhBSUhBSmZB
OXdid0VUZndFMGR3Ri1Bb0J6c0FRQkVYOEJadEF3RFlBNUVuRUpmd0FBZUEKbDVCMEEtQU1NSmZB
OXhEd0RpY1FGOEJIc0VlUUotQW9GLUJoRi1BVEotQVVBUVNRRnhBbklDY1FoLUFCaVFIeEF3ZW53
UGNaOEEwWApRQWVBUnlEWG9EZndLU3dBVUJZSDhCUVg2Z0FBcHdHUU1CY0FoOEFYRUVjQVlRTHhD
Z0dub1BjaDhBd1hVQWRnSi1CTkItQmlCLUFYCkItQVZCd0E1QkVBUUZ6Q1hqUVQyQlJDSGdJZXc5
eW53RFFkZ0Z5QTM4QThIOEM0WEt3QUI1QUx4Q21CSDhBTjNFQ2NRaDdEM01QQU4KRjNCSDhBMVg4
QzBYOEdOX0FEQUJkN0JSQU1FWE1CZndCeGN3UnhDWG9QZEhBUEVGRlFjQVItQXlCLUJsQi1BTUox
QVg4QUgzQWhCeApBNkJRQnlBWDhBZW5nUGM0WlFCd0V5ZndOeGZ3WTVZQmdBQjM4QUgzQ0NBbmNR
V1E4QUtYTVBjejhDTVhyQWdDSVFEd0h3d0g4QXYzCkJ5QzM4QWozTnZBbEoyQVg4QkVuOERjSDhH
UUg4QTRIOEJQWE1NY2dGLUFBSjFBblVQY2E4QzlrQldGSDhBNUg4RGlwQVBBRURpZncKSFJjZzl3
Q0FGMUIzSURjZzl4RHdPeUFBZ0JFWDhCdTM4QVFYUlFBUUVTUUo4QVlnRjJDWHNFY3dseEFISVBj
QThFY1g4QlUzOEJyegpBbEFDRi1Ca0Z5UUFNQndYRU0wQWtBTXdsd0JIQUFmd1ZlMEVNQUFuZ01Z
Q1VNQW44QUFISndBUUVtMERFU0RIQ1RIM0NRQVdCbER3ClZCZndDUG9Bb0NJbjhBQlhnQ2Z3SEZj
ZUFVQVNGLUFiVVFEd0NRTVhjUGNERUJjQUp4QUg4RkluOEFsSDhDRW44QWRYSU00SlVqQVgKOEM4
blZBQ3dFQmZ3QkNmUUZ3QlhFRWNGQkZId1VSZndBQXdEUUE1SDhCN3BDQ0V1RjF3SklQQWJIZ0JS
QmhmQUY5QXNCRER3VWdlcApDWkVvRi1CQ0IwQm44Q21mQVVGMzhCSUh1d2t3c0Jmd2R3VHdCQUFI
OEV4bjhBUTM4Q0NIOERSbkFFY0FGMEJtQlFBdEFCQW5rUVlnCjhCTENCUkFIRGdFUkFXY0ZZUEJH
Wi1BRVo2b0FvVGszUUNjZ0o2QW44Q2l0Q2xBUk5fQlhNUE1LSVFNSEtBQ2dRa2ZBMS1BbEotQTQK
TjRrQjhBRW1CLUFkRjBBbjhBa24wQ2VBRjNBWFJBRHdBRDAzd0Vmd01SZndPUmZ3RXhmd0pZc0JJ
VUFYcUFqeEFkQVhvRWN3Ri1BRQpoLUE1TjdCSDhEUWtBQkFWb1FnaDhCczdCVkR3R1FlZ0Y2NEFn
UEFFbC1BMVI0Qm5NQUlST3NJQ1lDVUg4Qm9YUUlvQjhBVVlGNUFuCkFHZndCS2Z3TWpjUXQtQThG
LUE2Sjc0Q0VDVnpCQ0FnSnlJQVFBZWdKeEItQWZBSUExY1FOLUF2bC1CR0YtQTJKd0FYOEJnSDhD
WW4KOEJoTkJIRVg4QmNIa0VjQXNRR3dSekFuOEk4SDhEa244QlczQ3BFbU4tQVZOMkFuOEJVaEFN
QUFOLUFCUjBBbjhJNFg4R0tFQnFNbgpCLUFvSi1BTUo1REhHQUJBQi1CcEJ4WUE4UU1tSndBWHdF
ZGdKN0JYUUFmd0FVY1FGeEFkQUJGb0pnRVJKQTRHSUxBWGp3VmcwRmNBCjl3c0FUQUR3QUk4WDhH
bEg4Q0lIOENJblVBZXdCX1VIOEF6d0FFY0E5d1VBUndBbkFDZndrQWZ3YlNmd0lBZndJQ2R3RjZC
RkNGQVgKOEFESDRMY0FBUjBBSUc4WExBekFIeGVnSjJBbmNDZndBcmZneXdCQmtCZndjRmtNZ3g0
WDBEY3dCLUFQRndCd0ItQnhGLUFaUnhvQQpNUUlYSUxZRk1RQlhFREFBRUhKWEFRQ0pBQkFFMkFJ
QXFBVEFoLUNSQi1CekItQVhGLUFqLWdJQVNRc1FaMzhGUVpJSDhITXVCQ0lnClZfb01JQk0zMGd4
UWxBZndkQWNYQURBYlZ6QlZBa1FRSi1EVUV3QjBHaGZ3RFRmdzFnOEFSQmMzOFBnTUFGTVZKLUQ2
Rnd3QW9STW4KOFBzWDhEa0g4Q3NQQUdFS055QW44UHdrQWhFcUp3SmtDUmNRUi1EOUVRQVJGdm9L
VXY4R0ItQTZNZ0FRRjFnTElmOEdJQUFnS3djeApBQ0VLQnlBQW9qZ244Q3dIOEJJMzhBc1FBQ0Ez
RnhrRklBMUhiQVR3QWY4RkYtQXROMEFYOERBSDhBd1g4QTAyQWxELUJCZndKMEVDCkFQd0JJREVY
TndBUURnSUZVZjhEQi1BaEVnSlFRQ2Z3TlFjWUFORU1KLUQtQ1Fmd0h5Y2dKLUJDS2dCUkRBZnct
d3RfQVZOS0ozQTMKMEJFQUVCY1pCeEJOVmdxUUY4QUg4QXNYOFA4TUJBUmc4RThYUUJjZ1h3WWdD
aGZPQ2dBcUFXQlFCMEFIY0pkTEFDRC1EeEVISVBCUgpmQUFYSFE4QUFKRUJVUDhQRi1BWkxRQUFX
QVVCR2dCaUYtQk9GLUFrSndBUkdRMEFFeVVOQUJBSEp3QWhKQmMwQUdBV0otQlBGLUE4CkN5QVJa
LXdORUZHOUFQQUo4UDhiSi1BTkItQlJaLUFWVndBWDhQOGNCLUFMSi1CUTJnTVFFVkVESWY4Zzdn
QWdXeGN6QUNILUVwc08KVUFzSDhGd0hIZ2FTLXhJWEFEY0F4LUFNSVFCQUItRC1FVGtBVUJnWDhG
c0hfQUZnLXc0bjhDQVg2Z0VSTkdRQlVmOFFGLUFod0FFUgpOa1lBTVA4UkJ4QUFJQmNIQWdZRUVB
QUF4UU1ORUFBaE5oYzdBUlFRRUFCRk16ZndEQ0FBWUFtSElEZndNZ0VPVWZEZ1YtQVpaQUFoCkJ4
Y3pBX0UyQi1BS1ItRGdGekFYSUdmd0RrQUJRQVEzZ0NkUUFKQUdSLURrQjFCSFFCY0FBUUhwQWhI
QU1BQmhBMGNRQi1EbGtnd1EKQWY0TUlDSUhOd2FBUmdmd0FTZnc0MmRtRERBWDRCY0hDaUh3SkNv
R0VVZHZEQkRpR2dJeUJBZlFSQWRoSmhmUUYtQkhEQWt3M1ZlQQppQTh3d0FkQVlBTVFKUmdDWUVn
WDRBZnczSEFDWUJJWGtEY3dSOEFFc0FBWDhFa1hBRWR3Qi1EYnJRUmdnQmR3Qi1BblJnMUE4RXNu
CklFVVB3TmtYOEJrM1VBZndMVWZ3QWdvR1FIQVg4TmdXQWhBUWNBQVFMSlFMb1BCU053Qkg4TmdY
OEI2cUJoRXRMQVlRVXhJT01RZncKMkxJR0VpM2lEeUJEQnkwQ0VTN2dEUUFOQUJKakNnQWdRaGNL
QUZFR04tRC1RQ1lIRUFLMEVGSC1RQWZ3Wm9jQThBUC1SUmZ3WmlmZwpGLUQtUlFmd1p3Y0FCX0FV
QUdJbjhHWUg0Q2NVQUNFWDRQSUtjVVVIOEV5SDhBQXJBSUpIRi1CS0YyQTNzRUlBVVVrSDhFa1hv
UW9RCkFrME5rQmZ3U1FmQXQtRC1XLXNBY3ZELWN4ZndTZ2NIQUFBT0FIQUg4RWczOFA5eWxnWUFq
aEZ3Y3lmd093Y1F0eElBRVFEb0FfTC0KZnhjd0ItQTNKLUQtZmlmd093Y0FFVHdYQU5Md1BSZnct
NEFIOEQ0SDhQX0FEZ0FpZnhjT0FFSUg4RDhIRGdBQUZRQUZEZ0JTUHhmdwotMzBIQUZKX0ItQkFC
eHdBQUE0QUVCY2pBQjlkRnhNTkR4WVRCUThCQUpZUU9YNFQ4QWhuOFAtS2gtRC15S2Z3LThVWEVB
Y1FSLUFPCk4tRC1vMUVMRUNjdENpRC1vbTBDWVNmd0RIZnctN3dOUUNmd0N4ZFFCQkNmSXdDU04t
QUtGMEJIOFBfZURRQ3dDUmRnUi1ELW5CY1EKRnpEd0VGQ0FSLUQtbS00TE1EZEFOd3dJTVBELW1p
Z0FFRWNmQ0VIQUY4QTNod0VrQ0JjVEFDQ3dGNXdURUh1R0JZQUhCeUFYTURkUQpGekFPQVJVQUlu
Y0FuQUlnUURlREQ2R1FGOUJIOFA5N3QtQUFQQXNRWU5vTElRZUFGUUJ5Zkxmd0FBY3dKeE1BUW5B
WDBGY1RBS0VuCklCZEFkd0FYRUFkZ0V3QkFmcGZ3QXU0TUFJMEp3QWRnQjlCbjhQX0FaLUFETi1J
U0F4TUFFRmRJQWdDX0NHRTNJQ2N3cDJCZEFCQi0KM3dxZ0F6Y3dGeENuQUJkQU4yOFBNWUFIY0Zr
UUVDZE1FREFIUUNjVUFER0JOMEJERUFEQUNSR24zUXZ3QTZkUUYtRC1nd2R3Ql9DbgpJSWN3QndC
bmNGc0FnUF9FRnlCSHdDZFFZZ0JnRnpBbklCZVFud2l3LTRZSFVBZFFWd0FYVURkMEN6U2dGekND
RHpELWh4Y29BREV3CkoxQklEZ0F0RFVBd0YyQTMxQTh3aVFjd1F3eUJCMEFIWUNjd056RFZESEF3
QjJCMzhQX0t2QXdCZFE4Z1VEZDlFQkJRR0FEd0E5ZncKLTRVM0lDY1FCekFYVUNkQVI1QVhNQlVG
Z0dmdy00b0hBRGN3UkFDQlozQVhRQWRRSjRDU0FES0lGeUJhQUdCM1FDZFFCMUEtRFhBSAo4UF9J
QnlBWEZnQWdRTmR1QVNHd0Y2SUFRZ2NRRjFBVUFEQjNRRWNZRXJEdy00YzNZS2RRdDRCbk1CVU5B
Qm9LWVBfSEI2Q1hZRTROCkVTREFBUUlWQUxCOVp5QUhrRGZ3QUZkZ2gwSVJBVWdSQVJrQWdYaFhR
SGRRbC1BSVZSRUEtd3lBRUFjZ04tRC1kRWRFRVJGQUtBSWgKOEFjdENSRVFUdzBBbmdJZ2NTZENB
TURRaDJBSDhBWVhZRWNnSndBTUJpRC1jSkVGVUFjZ1YwQlhDZ0lnOEFWYUFRQ1dFdUczOFA5cwpC
eEIzTURkUUp6QVhjTlFMOEFNWEVDZHdGeUFIVUNmdy0ybzNNQmZRbDREbkNIQ0FGeEEzVUJjZ0pB
RHhBLTlwdDdBSEFEY2dCNUFuCndDZVFGd0MzTUVJV1VXaFhRRmRnU2hLZ0VCZWdOMkEzc0FjUVo5
UVJBR0VFWUdzWFFCY3doeG9BUUJBSDBJY1ZFU0J3QjQwUVVmRC0KYWdkQThRNGdNQWZKQ2xBUUYt
QVNKMFVTRU5DNENVRC1hUmN3N3hJQjR3NXdFQWNnSi1BTk4tY1RBZjRDa1BELWFIZEFOekJYRUsw
VQpFRUJiRFNFQkJ4WUFBUEVCRVNmb0FEQTM4QXhFRUNFQ1J4WUFjUGNFSUFlUTl3NThFUUNQRlNC
b1p6NEFBSWdLOEFEM0JOQUhFTGVBCkItRC1ibWNBcHpEVUNtQlFkOUFIQU9mdkZ2RUZjQWRRZDFB
SDhBRTNFRGNRWjlBSEFDZFFaMUFYQUNQd0JCWUFVSWV3TjVCSDVRQWcKY0RmWUJqQUFWeENsRDJF
WG9DZkFOekFxQURBUUo5Q3pBSkVnSnpCSFVCZWdCX0Q0QUhCd0Z5Q1hNQmZnd1FGUm9BY0FKNkJf
Q0RCeQpGNkEzQnhBQXpoUnhnRmNBTjFBbkVBMEdBQ2dSQUZ3QUVBa01FU0JuVU9RR1VQOTJKMkEz
YUFZUkNoUUFBR1lMQUN3QWtIaVg4QU1ICjhBZEhjSDRFRUhjU0FIR1ZGLUFGSnlBSEVRQ1NwLUQt
bGlmd0FpZEFEd0FBNmdTRS01a0hBQ2ZRSjJBU0FCRVhyQVFoSjZEMkV5RVEKQjA0TnNQX1pGMEEz
WUJlZ0IzQkhZUU1BTkFCZ2dJZXdOMUNYREFCZ2xqZkFCeEFYRVFJQUhBQ2dFRmZ3LTVZWEFCZXdC
eDhDOEFFQQpSekJYOFBfZEp4QW5nQmNnRjJBbm9RTEFwemNnRjNBSFFHY0FCeUJuTEFsUS0zNlhB
SGRnRDBFQXQtQVQ5d0pBZmdjUVo1NFFJR0JYCjlCTWg4QkowQTVCOUp4QlhBR2RnUnlEcURCQVJE
Z01RWno0SEFLVUtVaUJuWURkQTRnd3hEeGNRaXdFUWN3c1RNU2RBVnhrQUFFQVgKSUE4SHZ3SUEz
aFVSYVpJVFkwQkhnRGNnVjBJT1VBeDNVQ2RRNFJjQ0hRQlJOeUJYZ01jYkFBQ3ZDakZRZDJCWkF4
QmxHd0FUeHhrQQpzU2Z3Q1FjUUIwQVhzQWNRdVFFeVpRY2dIUUFCWHhNZzhBaFJCZ0dEQUNCUVYx
TVhFR1VUQlRESGdNZmhBZ0FmQURBSFVBZVpBeEV3CkVRR2haemNRVnpBbmNDZGdSemdaRUFqNEV5
RUhNSVVPQUd3QUFITVVFT0I4QVBFRkJ3QTNnQmRRRjZBbk1EY2dGd0NISUdmZ0J6RC0KRVpEdy0w
OW5FQmNBNXdBT0E4QjNJRmN3OXhPUUZ4QjNVRWVnRlpFUk1IY0FkeEIzUUllRkZqQzNjUGUwQ1BB
Q1p4Q1hFSWN3UnpEMwpBUUNITURmd0RwZVhDSl9nRjBBbjBOZHc5d0RLQjVnZlBLd0lERjh3TGpW
OUxQY2JIZzh6QVAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tVUZBOU1USjlmUT09Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3Bv
ZCxjcmVhdGVkPSIyMDI0LTAzLTA2IDEwOjM5OjI5Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0
NzozOCIsc3RvcmVkPSIyMDI0LTAzLTA2IDEwOjM5OjI5Il1dCjo6IG1hcC8wLm1hcApiNjQkTFMx
YlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4dGIyUnBabWxs
WkQwaU1qQXlNeTAxCk9DMHdNeUF3TkRvMU9Eb3dNU0lzY21WMmFYTnBiMjQ5TXpWZFhXeDZOQUJw
QUFBQW93Z0FBUEFUZTJ4aGVXVnlQWHRiTUYwOWUySnQKY0QxMWMyVnlaR0YwWVNnaWFURTJJaXd4
TmdNQUx5SXdBUUQtLS0tdm9TSXBMSEJoYmw5NFBUQUlBUElHZVQwd0xITmpZV3hsUFRFcwpkR2xz
WlY5b1BURTJDZ0J2ZHoweE5uMHNTd1QtLS0tLU9GQXhObjE5ZlE9PQo6OiBtYXAvbWFwMC5tYXAK
YjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01T2pJNUlpeHRi
MlJwWm1sbFpEMGlNakF5TkMwdwpNeTB3TmlBeE1Ub3dPVG8wTmlJc2NtVjJhWE5wYjI0OU1UUmRY
V3g2TkFCZEFBQUFXQVFBQVBBVGUyeGhlV1Z5UFh0Yk1GMDllMkp0CmNEMTFjMlZ5WkdGMFlTZ2lh
VEUySWl3eE5nTUFMeUl3QVFELS0tLXZvU0lwTEhCaGJsOTRQVEFJQVBJR2VUMHdMSE5qWVd4bFBU
RXMKZEdsc1pWOW9QVEUyQ2dCd2R6MHhObjE5ZlE9PQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2Qs
Y3JlYXRlZD0iMjAyNC0wMy0wNiAxMDozOToyOSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6
MzgiLHN0b3JlZD0iMjAyNC0wMy0wNiAxMDozOToyOSJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJX
M0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVFUwTFRBeklEQTBPalUwT2pJM0lpeHRiMlJwWm1sbFpE
MGlNakF5TXkwMQpOeTB3TXlBd05EbzFOem8wTWlJc2NtVjJhWE5wYjI0OU16UmRYV3g2TkFCdkFB
QUE3UVlBQU45d2VIVUFBeWdBQUFNQUJQRC1BUURzCi15ZnhBUkFHRHlBUUFTQUJJQUh3QUFJUUFn
NFFBU0FQSVNBQk1BOUE4TU1QS0EtLThNWVBfQW9QLXdfQUQtY1BEUUh3Q1FFUUJnNHcKQVA4NUgt
OEJBTnpQX0E5QUFBOFFRUC0tc1BCd0N3RC0tNk1mLXdFQWwxRC0tLS0tSHc9PQo6OiBzZngvc2Z4
MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01T2pJ
NUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB3TmlBeE1Ub3dPVG8wTmlJc2NtVjJhWE5wYjI0
OU1USmRYV3g2TkFBUUFRQUFVUWNBQVBBbmNIaDFBQU1vQUFBREFBUVBRQkFDCkRnQUJvQUVnQXFB
T0FBOFFBQTN3eWdFQ0F3UUZCZ2NCRC1fUUNBa0tDdzhNRHcwUERnOFBFQUR3QUEwUEVROFNEeE1Q
RkE4VkR4WVAKRnhNQThRRVBHQThaRHhvUEd3OGNEeDBQSGc4ZkZBRHhBQ0FQSVE4aUR5TVBKQThs
RHlZUEp4UUE4UUFvRHlrUEtnOHJEeXdQTFE4dQpEeThVQVBFQU1BOHhEeklQTXc4MER6VVBOZzgz
RkFELUJUZ1BPUTg2RHpzUFBBODlEejRQUHdFUC0tRC1BUURyLXlkYUFSQUdEeUFRCkFTQUJJQUh3
QUFJUUFnd1FBU0FQSVNBQk1BOUE4TU1QS0EtLThNWVBfQW9QLXdfQUQtY1BEUUh3Q1FFUUJnd3dB
UDg1SC04QkFOeS0KX0E5QUFBMUEtLV93OEhBS0FQLS1aQi0tQVFDWFVQLS0tLThmCjo6IFtlb2Nd
Cg==
:: bios/wallpapers/hitomezashi.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTU0LTAzIDA0OjU0OjI3Iixtb2RpZmllZD0iMjAyMy0zNi0wMyAyMjozNjoxMyIs
cmV2aXNpb249ODldXQoKbG9jYWwgc2VlZCA9IHJuZCg2NTUzNikKCmZ1bmN0aW9uIF9pbml0KCkK
CWJhY2sgPSB1c2VyZGF0YSgidTgiLDQ4MCwyNzApCmVuZAoKZnVuY3Rpb24gZ2VuZXJhdGVfYmFj
aygpCgoJc2V0X2RyYXdfdGFyZ2V0KGJhY2spCglzcmFuZChzZWVkKQoJY2xzKHRoZW1lImRlc2t0
b3AwIikKCWNhbWVyYSgzLDMpCgljb2xvcih0aGVtZSJkZXNrdG9wMSIpCgluPXJuZCg2NTUzNilc
MQoJCglmb3IgeT0wLDY4IGRvCgkJZm9yIHg9KG48PCh5JTgpKSYxLDEyMCwyIGRvCgkJCWxpbmUo
eCo0KzEseSo0LHgqNCszLHkqNCkKCQllbmQgCgkJaWYgKHklMTA9PTApIG49cm5kKDY1NTM2KVwx
CgllbmQKCglmb3IgeD0wLDEyMCBkbwoJCWZvciB5PShuPj4oeCU4KSkmMSw2OCwyIGRvCgkJCWxp
bmUoeCo0LHkqNCsxLHgqNCx5KjQrMykKCQllbmQgCgkJaWYgKHglMTA9PTApIG49cm5kKDY1NTM2
KVwxCgllbmQKCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJCgktLSByZWdlbmVyYXRlIGlmIGRlc2t0
b3AgY29sb3VycyBjaGFuZ2UKCXRoZW1lX3N0YXRlID0gcG9ke3RoZW1lImRlc2t0b3AwIix0aGVt
ZSJkZXNrdG9wMSJ9CglpZiAodGhlbWVfc3RhdGUgfj0gbGFzdF90aGVtZV9zdGF0ZSkgZ2VuZXJh
dGVfYmFjaygpCglsYXN0X3RoZW1lX3N0YXRlID0gdGhlbWVfc3RhdGUKCQoJc2V0X2RyYXdfdGFy
Z2V0KCkKCWJsaXQoYmFjaywgbmlsKQplbmQKCgoKCgoKOjogLmluZm8ucG9kCi0tW1twb2QsY3Jl
YXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6Mzgi
LHN0b3JlZD0iMjAyMy0zNi0wMyAyMjozNjoxMyIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWlu
Lmx1YSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2Vf
aW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRp
b249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAzIDA0OjUzOjQ5Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAw
MDo0NzozOCIsc3RvcmVkPSIyMDIzLTUzLTAzIDA0OjUzOjQ5Il1dCjo6IGdmeC8wLmdmeApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4dGIyUnBa
bWxsWkQwaU1qQXlNeTB6Ck5pMHdNeUF5TWpvek5qb3hNeUlzY21WMmFYTnBiMjQ5TmpkZFhXeDZO
QUJ4QUFBQUJUTUFBUE1VZTFzd1hUMTdZbTF3UFhCNGRRQkQKSUJBUUJQRHdMR1pzWVdkelBUQXNj
R0Z1WDNnSUFPOTVQVEFzYzJOaGJHVTlNVEo5TERNQS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tblVEMHhNbjE5Cjo6IG1h
cC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAzIDA0OjUzOjQ5Iixtb2RpZmll
ZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTUzLTAzIDA0OjUzOjQ5Il1dCjo6
IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9q
VTBPakkzSWl4dGIyUnBabWxsWkQwaU1qQXlNeTB6Ck5pMHdNeUF5TWpvek5qb3hNeUlzY21WMmFY
TnBiMjQ5TmpkZFhXeDZOQUJkQUFBQVdBUUFBUEFUZTJ4aGVXVnlQWHRiTUYwOWUySnQKY0QxMWMy
VnlaR0YwWVNnaWFURTJJaXd4TmdNQUx5SXdBUUQtLS0tdm9TSXBMSEJoYmw5NFBUQUlBUElHZVQw
d0xITmpZV3hsUFRFcwpkR2xzWlY5b1BURTJDZ0J3ZHoweE5uMTlmUT09Cjo6IHNmeC8uaW5mby5w
b2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAzIDA0OjUzOjQ5Iixtb2RpZmllZD0iMjAyNS0x
Mi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTUzLTAzIDA0OjUzOjQ5Il1dCjo6IHNmeC8wLnNm
eApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4
dGIyUnBabWxsWkQwaU1qQXlNeTB5Ck5pMHdNeUF5TWpveU5qb3lNQ0lzY21WMmFYTnBiMjQ5TmpO
ZFhXeDZOQUJ2QUFBQTdRWUFBTjl3ZUhVQUF5Z0FBQU1BQlBELUFRRHMKLXlmeEFSQUdEeUFRQVNB
QklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVR
Qmc0dwpBUDg1SC04QkFOelBfQTlBQUE4UVFQLS1zUEJ3Q3dELS02TWYtd0VBbDFELS0tLS1Idz09
Cjo6IFtlb2NdCg==
:: bios/wallpapers/modern_monster.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTA2IDE0OjI0OjEwIixtb2RpZmllZD0iMjAyNC0wMy0xMiAxNzoyNTo0NCIs
cmV2aXNpb249Mzc0XV0KLS0gTW9kZXJuIE1vbnN0ZXIKLS0gYnkgb2Nvam8KCnJhcmU9ezM1LDQy
LDU2fQpoYWxsb3dlZW49ezQ2LDQ3LDQ4LDQ5LDUwfQp4bWFzPXs1OSw2MCw2MX0KZWFzdGVyPXs2
Miw2Myw2NH0KCmJ0ID0gMApmcmVxID0gMTAwCgpmdW5jdGlvbiBfaW5pdCgpCglsb2NhbCBnMCA9
IHt9Cglmb3IgaT0xLDY0IGRvIGFkZChnMCxpKSBlbmQKCWZvcmVhY2gocmFyZSwgZnVuY3Rpb24o
ZSkgZGVsKGcwLCBlKSBlbmQpCglmb3JlYWNoKGhhbGxvd2VlbiwgZnVuY3Rpb24oZSkgZGVsKGcw
LCBlKSBlbmQpCglmb3JlYWNoKHhtYXMsIGZ1bmN0aW9uKGUpIGRlbChnMCwgZSkgZW5kKQoJZm9y
ZWFjaChlYXN0ZXIsIGZ1bmN0aW9uKGUpIGRlbChnMCwgZSkgZW5kKQoJCgltb24gPSB7fQoJCgkt
LSBhZGQgZnJvbSByZWd1bGFyIGNvbGxlY3Rpb24KCWZvciBpPTEsMTEgZG8KCQlkZWwoZzAsIGFk
ZChtb24sIHJuZChnMCkpKQoJZW5kCgkKCS0tIHJhcmUKCWlmIChybmQoMjApPDEpIHRoZW4KCQls
b2NhbCBpbmRleCA9IDErcm5kKDExKVwxCgkJbW9uW2luZGV4XSA9IHJuZChyYXJlKQoJZW5kCgkK
CS0tIGhhbGxvd2VlbgoJaWYgKGRhdGUoKTpzdWIoNiwxMCk9PSIyMDI0LTEwLTMxIikgdGhlbgoJ
CWxvY2FsIGluZGV4ID0gMStybmQoMTEpXDEKCQltb25baW5kZXhdID0gZGVsKGhhbGxvd2Vlbiwg
cm5kKGhhbGxvd2VlbikpCgllbmQKCQoJLS0gZWFzdGVyCglpZiBkYXRlKCk6c3ViKDEsMTApPT0i
MjAyNC0wMy0wNiIgdGhlbgoJCWZvciBpPTEsMiBkbwoJCQlsb2NhbCBpbmRleCA9IDErcm5kKDEx
KVwxCgkJCW1vbltpbmRleF0gPSBkZWwoZWFzdGVyLCBybmQoZWFzdGVyKSkKCQllbmQKCWVuZAoJ
CgktLSB4bWFzCglpZiAoZGF0ZSgpOnN1Yig2LDEwKT09IjIwMjQtMTAtMzEiKSB0aGVuCgkJZm9y
IGk9MSwyIGRvCgkJCWxvY2FsIGluZGV4ID0gMStybmQoMTEpXDEKCQkJbW9uW2luZGV4XSA9IGRl
bCh4bWFzLCBybmQoeG1hcykpCgkJZW5kCgllbmQKCQoJZm9yIGk9MSwjbW9uIGRvCgkJbW9uW2ld
ID0gewoJCQlpbmRleCA9IG1vbltpXSwKCQkJYmxpbmsgPSBybmQoZnJlcSlcMQoJCX0KCWVuZAoJ
CmVuZAoKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyh0aGVtZSJkZXNrdG9wMCIpCgkKCQoJaSA9IDEK
CWZvciB5PTAsMiBkbwoJCWZvciB4PTAsIDMtKHklMikgZG8KCQoJCQlsb2NhbCBzeCA9IDIwK3gg
KiAxMjAgKyAoeSUyKSo2MAoJCQlsb2NhbCBzeSA9IDMwK3kqNzAKCQkJCgkJCXBhbCgxLHRoZW1l
ImRlc2t0b3AxIikKCQkJCgkJCQoJCQlidCArPSAxLzEyMAoJCQlpZiAoYnQ_PWZyZXEpIHRoZW4K
CQkJCWJ0ID0gMAoJCQkJZm9yIGk9MSwjbW9uIGRvCgkJCQkJbW9uW2ldLmJsaW5rID0gcm5kKGZy
ZXEpXDEKCQkJCWVuZAoJCQllbmQKCQkJcSA9IGZscihidCkKCQkJCgkJCWlmIG1vbltpXS5ibGlu
ayA9PSBxICB0aGVuCgkJCQlzcHIobW9uW2ldLmluZGV4KjIrMSxzeCxzeSkKCQkJZWxzZQoJCQkJ
c3ByKG1vbltpXS5pbmRleCoyKzAsc3gsc3kpCgkJCWVuZAoJCQkKCQkJaSs9MQoJCWVuZAoJZW5k
CmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgpCglpZiAocm5kKDEyMCk8MSkgYmxpbmt5ID0gKHJuZCgx
MilcMSkqMgplbmQKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0ib2Nvam8iLGNyZWF0ZWQ9
IjIwMjUtMTEtMTMgMjE6MDc6NDMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAx
MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQw
ZDA3MDEwMTA3MGQwZDBkMDEwMTAxMDEwMTAxMGQwZDBkMDcwMTAxMDcwZDBkMDEwZDBkMGQwZDBk
MGQwMTBkMGQwNzAxMDEwNzBkMDEwZDBkMDEwMTAxMDEwZDBkMDEwZDA3MDEwMTA3MGQwZDAxMGQw
ZDBkMGQwZDBkMDEwZDBkMDcwMTAxMDcwZDBkMGQwMTAxMDEwMTAxMDEwZDBkMGQwNzAxMDEwNzA3
MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNjA2MDYwNjA2MDYwNjA2MDYwNzA3MDcw
MTAxMDcwNzA2MDYwNjA2MDYwNjA2MDYwNjA3MDcwNjAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3
MDcwNjAxMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKSxsb3djb2xf
aWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Iixub3Rlcz0iaHR0cHM6Ly93
d3cub2Nvam8tZGVzaWduLmNvbSIsc3RvcmVkPSIyMDI0LTAzLTEyIDE3OjI1OjQ0Iix0aXRsZT0i
TW9kZXJuIE1vbnN0ZXIiLHZlcnNpb249IjEuMCIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWlu
Lmx1YSMzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFj
ZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHts
b2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogZ2Z4Ly5pbmZv
LnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTQ6MjQ6MDkiLG1vZGlmaWVkPSIyMDI1
LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMDMtMDYgMTQ6MjQ6MDkiXV0KOjogZ2Z4LzAu
Z2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTRJREEzT2pBek9qSTBJ
aXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweE1pQXhOem95TlRvME5DSXNjbVYyYVhOcGIyNDlN
amMwWFYxc2VqUUFWazBBQUE4NEFRRHpGSHRiTUYwOWUySnRjRDF3ZUhVQQpReUFRRUFUdzhDeG1i
R0ZuY3owd0xIQmhibDk0Q0FEUGVUMHdMSHB2YjIwOU9IMHNNUUFwOEJWR1JnVHc0R0h3TGdGZ0Fm
QXJFVEJSCjhDZ2hNQUZRQWZBbUFSQUJJQUZnRWZBbEFSQUxBSUZSQUJId0loRVFBUUlBOEFZUkFB
RWdBZkFoQVNBQklBRVFVU0FSOEI4UkVCRTMKQUpFd0FmQWZBU0FSUUdFSkFQQXZNQUdnQVRBUjhC
NEJNQkdBRVRBaDhCMFJNQkZnRVVBUkFBSHdIUUZBZ1VBaEVBSHdHeUZBQVZBQgpJRUVRQWZBYUFR
QVJRR0VnQVJBaElBSHdHUUZTQUJCQWV3Q3dFVEFCOEJnQklDRWdBVEJ5QUxNUk1CSHdGd0VnRVFB
QkVCRUFJVUFCCkVRQVpNQThBRUFFX0FBTVBBR1FXRVFBQkFBRlBBRUZRRWZBVkx3QVJRRUlBUUJB
UklBRVJBSUFCTUJGQUFRQUJVREVBWUJVQkVBRkEKQWFvQUlGQUJRQUFDRHdBcUFSQVBBRUVBQVdB
Qm5BQVRBQThBQVI0QUlCZ2hPZ0FCR2dBUkd4Z0FFSEF0QVJFZGZ3Q2djQUVBRWZBZgpBUUFoUURZ
Qjl3RWhBU0JoWUFId0pERkFjZkFsQWVBQkJRRFJKZ0hBQWZBbkFTQVJZQUh3S0pvQUlmQXBUUUFQ
QndBWkFlTUFRUEFxCkVTQUhBSkFyRVJBQlFCSHdLeEd0QUZBQUVmQXFJYklBRUFBZ0FBRUpBSEVS
OENvQlFCRVFCd0FpQVNBSEFLTVFJZkFwd2ZBcEFXQkIKQlFBUXNRZ0F3QUh3TEFFQU1TQUI4Q3NC
Z0FVQWYzQUI4QzF4OEoxMkFnc2ZNM1lDSVNad0FYWUNGV0Z5QWk5Z0FYSUMtLThtUU9HQgo4Q3hC
QURBcUFhRGtBQkFnVXdKd0p3RVFBV0FCRUFrQWNnQUJFRUVRQVFBTEFFRUFBUUFoQmdBTEdnQURM
Z0JRS0FFUVlSRDRBQUZLCkFEQUFBWUFlQUtFbElSQ0JFQ0h3SWdFQXFBSUJCUUVRSUFFQ1VqRUFN
U0FoQ3dCUUVVQVJFRUd6QWlFQkVDY0FBV2dBTVNId0hoRUEKQUJNQVlSQUJBQkVnRWI0QkVSQkZB
QUVnQUFZUEFEQVFRUURuQVJGUURBSUFQZ0FTRUE4QUVSQXVBZ0FrQUNMd0d6Z0FBU0VDSHlBUgpB
QUl3R2dFdzR3RUJ3UUlBX1FKUklVQVJJQkVlQXlBWkFWWURFaUJhQXpNYUFTQU5BQU5GQUFVTkFD
QWNNUWNBTUVCQjhOWUNFUkRXCkFqbndKUUVMQUFJX0FRRU5BQ0FnSVNjQWMtQW1BUUFSWUJGU0FR
RXlBV0FuSVlBaDhDaEZBUkFwWUFNQUdBTWVLWHdDRHdjQVowREIKOENqUkZRUC1DRkVnSWZBbFFR
QXhBQ0VBRWZBbDhRSHdKbUVBWWZDWWdRSV9JNEFCSGdFZ0FHRTlBUWdVQUE5NUF2LS1MQnJmZVFJ
QQo2Z1V3NGZBbkNBQVFKdndGWUNUeEEtQWtFZklCRUNDWEJSRW03Z0VCa3dJUU1JMEhvU2dCTUhI
d0tDR0FBUUNaQjVDaElBSHdJd0ZBCllWQ1JCeUR3QkdzQ0JnWUFFQl9JQVJCaEZ3Y2c4QjRWQWlL
QklBc0FrUUFSRUJGZ0VSQVJFQTBBQVFNSE1RQUJJTnNISVBBZHZnRlIKRVJCQkVCRkdBaDhjRHdB
QkVBQlJCeThSQUJNQUF3TXlBakFRRVlBZ0FCRVJEUUF4SUJGZzBnREI4QnRCTUlFd01mQWRNVUJo
Q1FnQQpmd0JQOEFFQkVBb0FJekFRQWVBSkFBQmFBQ0tnSVFrQUFSSUJNQUFCOERzSGpKQUI4Q0lC
Y0FHQUJ3QVJJd01EWUhBQjhDUUJVR0lIClR5VUJZQUVIQUVVQTRBZ0JxUUZSRVNBQk1DRVhBQkFn
NFFJd0pFRWdnZ0FnSTJGT0NkLXdJM0VBQVFDQjhDUHhBLUNYVHdKRkUyRk4KQWhfQVN3TC0td2ta
NEVzQ0FKMEtNQ2NCVUFzTUlDZFJXUVl5OENjaFFBWUZFQUFDSGdDZ0pvRkFJZkFrQVJBQm9FTUJV
Q0lCTUFHQQptQUJBSVFFQTBjd0JZUEFoRVNDaFFFTUNNVkNCVUFjQUF0RUFNUjBCY0JRTElQQWRm
Z3NnWVlBQUFnQk9CaG1RQ1FBUkVOWUdGR0QtCkFUUmdFWEFYQWlWd0FRc0FNR0FCZ0FzQUlCa1Jw
d3dRZ0RvSEVSZ3NBQktRb1FzUklDVUhGb0FOQUI2Z0N3QU1Jd0FFRFFDUlFXQUIKb0ZId0Z3RXdM
QUFDSFF3U01SOEFZU0F4OEJRQlFFa0xnVkF4VUFId0ZWRVFKd0FoTUZHQ0RBTU5BQ0VCSUZNQUVE
RU1CeUJBVWR3TQpBY3NNQUVnQklUQXg2Z0FDSndBbjhCOExBSkJCTUFGZ1VmQWVBWkNLQVFBSEFC
Q3dKd0VCQndBeEhBR2dnZ0JnOEJ2eEMtQWdoZ1lWCjRhY0JEd2NBTWhJbW53RVJKR0VCUVBBaUFZ
QVRBaEloQndCdklvRUFnZkNXV0FJM0lRRmdTQUlTWVZZQ0F3NEFEMVlDLS04V0VfSzAKRUNRc0Fi
UVFNU0h3STBrR01HQUJFSlVRRVRBc0UxQXdFZkFiRWU0QkVCQkZDd0JEQlJFWWxBOHdFRkZ3ekE4
UmdPc0tFSUNDQVVHQQpBVUJoQ1FBaE1DRjJBaUFoTUEwQVVHQWhvQ0ZnQ1FCUmtBR0FBWkFKQUND
aGtEb0FFbkNvQ3lJQkVBSUdFQmpmQVRBaElDR1NDeUh3CkdTRU1BSXdMQVEwQU1YQUJFTHNCRUhC
WkFoRndnQXNCTkFBekd3RndRd0FTY0o4Q0FrNEFFd0FJQUFFNUVBRHJDd0c5QUNKQkVBOEEKRkJB
U0NpSWRBU3NITWhBaEVETUhCaE1BRm1BUkFDLXdCd1lBRTdBZUFmQUZBZkFnOFFYd0loWUhBVUlH
UUNJQjhBTU1Cd0FhQURBZgpBWkQtQURBZUFhQV9BZ0EzQWprQUFaQUpBQktBWGdpQ0hhRWdvZkFl
QVZENEFSUWdDUUF5SHdGZ0NRQlFGM0ZnQVhBSkFEUVZNYkFKCkFER2dBWUFKQUNOQmtBa0FZeUVB
QVhBUmtBc0FJWUhBQ1FBQVpRZ1JCQW9BRWtFSUFDTVdNUWdBTUNId0JRZ0FFQzRGQUJVdkNnQkEK
TG5Id0xxa1F6eTVCSUJId0xLSHdMSkh3am1VQ1FpWndBV1VDRldGaEFpOWdBV0VDLS04VEZONWhB
aUJSTUNFSEFYSVBBR1lUQUFVUApNVkVnQVY4UU1SQXhFQWtBSVZFUUZ3QURKUUFqWVVCN0VJQXBB
YUFSOENrQmdKRUNJU2VoYkE5QUFBRVFJZVFHWVBBakFSQ0JZR2tGCkFDc1FFcUFsQVJBQThRVVVI
Z2tBSWgwQk9RWUJPd0VmSEEwQUF4SmdOQWNCRFFBUkVSb0FJQkFScVFzQkdnQVJHM29DRWlBYUFB
UU4KQUFDTEFURHdHeEZYQ3hKQVBRQUVDUUJDRWRBQk1IWUFEd2tBQkFBR0VSREFtZ2N5SGtIQUpS
RVF3UGNBSWg5QkJ3QkFBUkR4QkVVVgpFZkVPQUNEeEE0Y004d054QU5Id0hwRUFnZkFoWVVDQjhD
R1JBSkVGQUxDQkFJRUFBZkFpY1FCeEVIRUNFQUJHQVJDUnVoRVFnZjhDCjEtQW9ZVUFSOENkeDhD
NWg4QzRHQUIwdkF3QUI3d0V4TFFGZzdCUWZvX1FCT1FHaEF5RHdLYjBMQnhVQURfSUItNTRmbWpv
TkRRRjgKQ0E4OERRQVFKeXdBRUNpbUFRRUJFLUFHSnpHQU1mQWo4UVR3SUJFZzRSQVI4QndSWUtG
UTFBVVFvRGtHUUJnQjhBemVHQkZRVUFVUQpGb01CSWhIUUtnWWlNQ0VKQUVBUk1CSGdDUUF3VURF
Z0NRQmhGd0V3UVJBeHhRRVJHRWNFRWJBTEFFQkJJQUd3ekFGU0doRWdFYkNYCkFDQWNJU3dDSXdB
QjRnRVJzRjRHUXZBYk1jQUpBSDhhQWZBQUFTQmhDQUFEQVVFVU5ScnhBZ2dBRWxFWUFBQ0NHUXdL
QUVCUUlmQWIKQ0FDUjhDUUJVQ0ZnRWZBa2ZRSUF2QUVOQ1FCVUpBRXdBWEFKQUFFWkF3SUpBQ0VR
QWNrUVlHQWg4Q2doY0pzSEFMVUJCUVVBQ3c4QQpDQVVBR0ZBS0FDUXVjVEFBQkVRQVR5NWg4T2I1
QVRjTzJ3d1A5UUgtdHg3Z2N4TVB3Um9OUHhBeEFMOGFCUVU4QUhEQUFmQWxNYUF4CjJnNFF3UjBG
TVFHZ0VhME9VRkF4RUJFQUN3NVFHZ0hBRWJEdkNRTUhBQkVnd1JjZ01DRjNIQ0FCTUlVZE1SRWdR
UUFkVVRCUk1CRVEKUmhNUU1BOEFJU0J4a3hNU01RMEFFUkZlRXhJaEFRb1NNQzhBQUl3S0Fhc1ls
QmNCVUJFd0VWQWhVQXNBQVZFQ0g3QUhBQWdESlFCdwpHQUZnSVFBUlVJMEFNQm9CZ0pNR0VSekpB
UUY3Q2hFZTZ3QUE4UUFETEJnUUlJNGNBRWtMQUFzQVFCQXg4Q1IyQ3ZFTllmQWs4UUx3CkktRUM4
Q1JCQUxId0pGRWdnZkFqWVFDUjhDUnhBQW9BQWRvUzhRRnhFSEh3SkpFUVVmQWtzUkF4OENYQkZB
Y0FOZ2RRY1RBQjhDc00KRHhBdVdRc1FMUVVBUVM0aElCSDFBVFNCOEMwR0FBOEVBZ0lmbndRQ1F4
X0FSQm9PRC00Qi02UVU0ZElKQVFNQ0ptRkF0QWtEcEFzQgpLaFVmSUxRTENnVDVCVkVSQU9FQUVY
RVdNUUFCRUxZSUVBQUZDUUFIQUJMQURRQUFueFlDRFFBQ29nMUNJY0FoRUwwSkFoWUFBcGdiCkFT
a0pHQnNWQUZBYUFUQWh3QWtCQU5BYlJDQ2hJQUVMQUFGS0RRME5BQkZSQ3dBeFVmQWJDUW9BTXhJ
Q2J3QkVBVUJoUUFzQUwtQUIKQ2dBakVSN0tBQUMxQ2dERkFCZ0E1UUFFRVFBR0Z3QUF2UUlGS2dB
QVpnOERJQTRJQmdBd2NDR1EtQTAyZ0NGZ1J4SUNYQklTSkdvUwpIeVdMRjBza1lBR0xGeEV4Y2dB
QTJRSXg4Q01CS3hqLUJDRmhFQUVnY2ZBZ2dRQUJFSkh3SC1FSDhKUmhBamNDRlFjaEtXSGlBUVFP
CkFBOWZBdi0tSUEtQ0NCOEN3UXdQeEFnTEFzOEtJU0dnSkJNQW13VlVJQUZBb1VCV0FVQWVBZkFH
QmdBd2NIRlF2QUZTY0JFQU1RQnMKRG5KZ0lSQVJFQ0ZBQ3dBQlJRWVFHeDhBQUk4T0FiSUtJd0V3
VkJ3VkVBOEFNU0ZRSVZvRjhBSWFVU0JCRUVFUVFmQWFVVEF4RURFZwpRYVFDTVNFZ2NWNENVaHdC
VUFIUUNRQXlZQUhBQ1FBeWNBR3dDUUFRZ0lNVGNBSHdIUkZ3QVpBSkFDQWZFZkVYQVB3YkkwRWdD
UUFBCmNCd0NzQWRTSVFFZ01aQUpBQ0h3QVFnQWd2RUU4Q0x4QS1BanpCSXhBVkFSRHh3QVNoZ2k4
Q01xQWg4ak1RSUlQaVlCVUFjQU55Y0IKUUFjQUVTZ21BMEh3S1VGZ0dTRUFEQUFrS2pFUkFFSW9V
V0FCeVFZVExjc0JBbzhsbjZId0tySHdLcUh3bGhJQ1F4X0EwQWdWRHdvQwotNmtHMmdvQjNpUWZL
QklFS2dIWUNnRUZBRUVvd2ZBbXFRRWhJQUVmSlFIRkFSRWhCZ0FDWUFFQWdoWWhBQUhMQVJBZTJB
RUJZQUFCCmlBNEFCUXNqQUNFRkN4RmdMeW9CRUJjUWdPQUJBS3NBTVJjQmtFd0FBVGNYRWJCRUFC
Q2dTUmNSVUJVVEFDMENBZVFPRUJSeUFRQTYKS2dBNEFSRVRTUUlSWUVJbEFHa0ZnUEFUQVVBaFlC
RndkQUlSRTVzQkVJQlZBVE1VQVZBbEFBQUlGaU1CUUEwQUFuVUxCQ01jQkM0YwpBQ0lIRVVFaEFB
RjlBZ01zQUFNNEJ3TWhBR0FjTVdBQmdERzNGaEVoR2dJUlFCc0FjUEFqVVVCeDhDU3lJUU1IS2hC
UTVBQUtLd0lQCkJ3QnJFU1RDQUtEd0kwRWdBVkF4OENGeEVTTGY4Ql9SQUFFZ2dmQWU4UWp3bEdr
Q09SX0FPUTBhRDJFQy0tOEhEMXdaTHlJbklVa0wKTVNId0pPY0Y4UWNGOEIteENQQWUwUUFCQUhI
d0hjRkFjZkFjd1FBQm13N3dBUnZSSUtId0d1RUFvUUFCOEJuaEFKR2lIeUR4Q1ZVUApJZkVJVUE5
VUVQRURBQUVLQUFGNEFnRUtBQUhGSXdJVUFDSVJNQW9BQXQ0R0FRb0FFNUFJQUFFS0ZDQVE4YlFC
WUJrQkVQRUNRTG9nCk1CRHhCM0VYUWZFRDhDQUdBQkFmcHdzQTNRSWg4UU10S2hCUVB3QWlIMEZY
QVI4QkJ3QUNBY2NrQV9JS0VpR0JIQkVnaWh3NDhDQ3gKR2dDQVVCRUFvZkFoQVhBUkN6QWlBWkNn
QUZVakFZQWhRQWNBSUNReHRTQkE4Q2h4UUg0UEJBVUFKUzRSQlFBSU54c0Fxd1kta2ZDWAowUUU1
QVc4UURra1pEODhCLTRvZjM2QUREd0dlQXdfZ0F3Z0MxZ0VCNlE0UFFSY0gwREFoMERFZ0FSQ0I4
QXdCY0NIVERRQ2NGaEFBCldCY1FnSjBzS0VHQUVRQWdFRUhmRGtCQUVmQU5IZ0FoRVJDY0drTWdB
ZkFRV0I4UXdIMG5VQTd4R3ZBTFlnQWk4QW9HQUVEeEhQQU8KQVNnUUFGa3BIeElLQUFJUWNBb0FH
RkFLQUJBUktnb0JIZ0FZRUFvQUt2RUNDQUFPSkFBUENnQUVNRUFSZ0FzQU1BOFJrRDBMY1FGdwpF
ZkFPRVpDSUlBNExBRFJ3QVdBTEFDTXd3UWtBQUJnTEJRc0FBT29rTVBBT0VZMGZIVEFMQURLd0Fa
QUxBRkFORWNDeE1EVUFRUXdSCjhBVHBEd01NQUNVUkVBd0FFUVY4QnhPQURBQWpNQ0VLQUNNUlFC
UUFVd1lCUUJGd0NnQXBVQUVLQVBNQUN4SHdCM0dBRWZBS0VmQUcKRVZBQkNnQXRBV0FLQUc4SFla
QVI4SXFCQWprUFVBUVNEMzhDLS04dEhfRmRKQUVnUVNEZENSQWY1QkZBc2ZBYmdYOEM4dzRBRVJD
Qgo4QmlSSUFFUTRmQVdvVEFCVUtId0ZhRkE4UUh3RmFHZ29RVUFJSUVRUFFLd2dmQVZrUUNSRUpI
d0ZwR1hDZ0VFQUVHUjhCaUJPQ1JBCmdmQVpnYWdHVUJDQjhCbVJUd1ZTRUpId0drSElJeEVnQmdC
akFFSHdHekZBT1FCeFFESHdIQ0ZBRVE4SFVoRkFJZkFkN3cwU0VlNEsKQVA4Tkl2QWRTeE1qRVNB
SUFFLXdIZkVKQkFBT054N3hCd1lrRUNLSUIwTUI4QUlCRENRd0lRR1F0UUl3SVFHd1pnWkRJZ0hB
QVFjQQpBUUFURWNBUkhCRmhqUU1oSWhFT0FEUWhBZUFIQUJBd1lCZ0JNUUFBcGhRQjFRWUFQaTR4
TURHQUNRQUJ6UThBaVJBQ0lTb2hJVUVDCkN4VXNCUUFDUlE4UEJRQUJNb0h3TFNZQUJGNFBUeXlS
OEktdUFUd2ljR0h1QVJIaDZnRXZZSkhxQWZfcEd1Qk1FeEFBTHdZU0p4UTYKRVNjcEVRRzREZ0lW
SGhnZ0ZBQUNKQUF6S0hFd1dnWUFWVFl6SURFUVZ6WXhJVEFSMlE0QTBSSWhNQUduTVVFd0FSQlIt
QUFnUURFcwpEaUR3SC1VQkFNSXhVaDRCUUVGQUVDMEFBQTRCQ3dBUkhCQUJBUXNBR0JzTEFCRXd4
dzRCQkNBLW9BSEFCd0FBQUhBY01Cd1JnRG9GCkFBQW9NbEJSUVBvbkVTQ2lJMThkQVhCaGNBY0FD
MEVlZ1VDQm1TUUJjZ0FRSHc0QUZDRVFJQUFwQVRrbEFVQUhBQkF3QndBV0pnY0EKRUhBbEFRZ0hB
RFFvQVNBSEFBWVVFeFFwRlFBVU1EVVRHWEJERXhsd1dCTVRjRzBUQUZNeEE3d3hBTXdQQVhVdUVW
Q3dOekR3SkhHVgpISUJ4TUZId0l4RXdJUWNBQVBjeU1DSHdJeGdBSDVVV0Fqb0J1ZzhSSl80UUZp
QVFBQThRQXYtTDRPUkI4Q2d4SUlId0otRUE4Q2poCjNpSXd3ZkFrN1FtQmtmQWtRVkJoOENPWkh3
RDhNREFSTUNIVkJBQzNEUUlIRFRJaEFXQ0tDakFnQVhCSEFqSWZBWUQ3SnpFd0lSQlEKQm5FQllD
RkFFVUFSUFNzQkRBVkJIQUdnTVU4Z0lJQXhYU3NRRVVNVEFESUFJaEZBQ1FCQklTRVFNVklBTlNR
QkFBa0FBU2N4QXdzQQpBOThfVFNRQkFDRUpBQWNkQUFBeUFTRUJVQXNBSWlGQUZBQVZFQWtBQVIw
QUpqQVJDd0FBRmdBdElDRUpBQVVkQUFGdEJnSEhQaUltCmtkTV9GR0hZUGdPRUN5UkFFUndEQXdV
QVFwQUI4Q29GQUFUQ0JRV29QaUVBQVVRcENBY0FJWEFCckJnRkJ3QVhNS3NsRzJDNUpRQ1YKQUMt
d0pna0FGVkpoOENXQkFOTWdINU1hQWtBakFXQWFBaEpoR0FJdkFXQVlBdi1SR3Q1Q0JqSkFZUUFC
QlNCZ0VRNFhBVVlJQVFrQQpJQUFCSmpBSUZBQUFNQUlBQndBUmdlczU4UW1nRVFBeDhDQkJnQ0VB
UWZBZUVRRFJBR0h3SERFQU1XRDNFaEJCSHdvUVFFMEtrQnBoCkVDRWcwZkFac1FVQTh3SEJBQkVB
d2ZBWW9RQUJBUEVBOEJmUkJnRHdBQUVBMGZBWHNRQUJBT0h3R05FQTBTb1RJQUVBRHk4UUdrZ1QK
QUtFWFlodmhBS0h3R3hjQU53SHdHeGNBTUpId0hDRUtJV0VBOXdFaEFBRnFEd0lQQUJNZ0RRQWdB
UUJYRHpOaDBBRUZBQ0FCUUx3VwpFUl9lUTFCd0FmQWZZZndHQV9nR0FBc0FFWERxQmdFSkRocGdD
d0FpVVREckJUUWRBWUFKQUFDRURoUlFDUUFTWUJJY0FTOHdCd2tBCkFGY1RBd2tBUDVBQlFBa0FB
ejlRQWFBSkFDTWZZUmtBQlFCekFHSWJjYUJ4OEJ0bUV3S2FDaF9sTUFJOEVvQWpBZ0IwQ0FZUUFB
OHEKQXYta0lQOHBGeWRnY0JId0t3R1FHVDRRWUlJU0FiTTNNQkh3STQwS0FIQThRSUF4OENkS0Fo
Y3BJeUN6RUVGUUFmQWxFWEJCRUJIWApEVk1nOFFmd0k0TUVVU0FCOENZUjNRd0MzUVVSWUdFd0FC
OEFFZEgwS3dBTkRuRWhBVEFoVUJFd3ZRWWlVV0RMSXdCeVBoQWVZQkVoCjhCMEdBQ0FjTVRZZ0FH
UXdEd2dBQ1RBWW9hQktEakFhOFFUSENoQkJHQUlTME1na0Rnc0FJaDFoQndBUkFhVUFFZ0IzQUVN
Z0FiQkIKQ1FBMGNERXdGQUEwUUNGd0N3QTBJQkdnQ3dBUUFJVXRFQjRWT2hRQTFpQVBCZ0FJQWU0
Z0R3WUFKQlFIUVRVZ0hDRVNBQkFiVFFHdwpCQUh3R2pId0J4SHdHR0VhQUY4VzhSSHdqLVFCYnhO
aDhnRWZnUEFCLTRNZjM0QU9Cd0F6SGdHbkF3VC1EUkVBSEI4V0FCRUFCQjRBCklWRmcxUUdCWURI
d0VGRmdjVEFOQUNEd0RnOEtSQ0dnSVVBTkFJQVFFU0NoSUJFZ1VRMEFZU0ZRY1dBUkFBc0FNQUh3
Q1FVQUZ3MEsKQUNyd0VBZ0FJZUJobERkQURnSEFnV2tCNEE0Qm9MSGdBZkFQQVhBaE1ISFFDUUFR
VU1sS2NHSEFBZkFSVVRDbEFERVJJQkdWRGdJTApBQUNaRGhJQnZSSUFCQUFRTUM1TW9CMEJVRkZR
TWZBZkVWQTBJd0NZUnhCUUVnWXdJZ0VRbnhjRmtoSU1CZ0FoOFFRRUFCRWg0UUlFCkJnQVNZR0VT
QURRS0NBa0FBR2dMQVZNR0VSOHpDZ01KQUFGUEJqSWZrVERyRGdGU0R3SUpBQkpnRXkxaVVBRndj
ZkFWRmhjQnFnSXMKOEJRTkFCR0FhUXNIRFFBeUlBRWdEUUF4a0JFZ3hDQUJTeUF5d0hFd0NRQWs4
QVFnQUFNS0FEQ0I4QVEtQUFCbUFGLXdCU0h3RmU4UwpBQUgzVFJSd0h3cy1vZkNrV1FJOEZvQkdB
Z01pQkFJTkFCX0FVUUwtLXdnTEtoTVZ3T1lqQS1JakFGa0dFeEJERlFlUkpnRjBMeGtBCkdBQVJK
b0lqSVJBUkIwZndBU0poWUdId0lYRkFjZkFna1NDUjhCNUhQRUFkc1FDeDlCOHh3ZkFiQlFBd1lS
QXhCd0FoVVNBSEFKRGgKSUlId0dfRXdjZkFXUVVRYzhRcncxaGFJSC1FRzhDQ1JBS0VGQUQyQklK
RUZBQUFuQUhCeFFJSHdJR0ZRNHhKRHdHSHdJQk1DQUJRSwpBWThmQXc1QkR3Y0FFeEVqemdFdzhD
U0IyQklqUVhCTE5pOHRBUVVBRkFPZUFRY0pGejl4OEppZUFVZ0JUZzhCbkFFTHhpVVBtQUgtClFn
bGdHaEVxWXdVR0NoVUFDa01CQndBQ0JrTUJHUUFRRUJJQUFpY0FZVEVRWWZBb0VTd0FBS1FCRWlD
TEtnQTJCQkJRUXpBd01JRVEKVVNZQ2EwUUR3VHNnTUVGa0RRRlFGaEVRVnljUlVLd3JBU1VGRW1D
SFFBQlNBUUFNUVFEckJGSVlBY0FCMEFjQUFLa0VBREUwSWdIQQpvemdTVUFrQUVSblFQQUpPRFJN
aENRQVFIYXdKSUFCUkNBQVNBVzRBQUFRakFXb0FNR0FCa053UUVCdG1BQUZtQ2dERUZoS3dDd0F3
CkdnRlFDd0FSRVJRQUVRQTRIa1R3R3lFd0N3QXdIakVnUlQwd0lRSFFSUk1GeUNzZ0FURElBaFFp
QndBQVRnQUVCd0FSSVd3Tkl2QWkKZ3lNYkkzVWpDZ2NBRWxCN1FRQkxBZzhKQUFFQWl5Y0dDUUFB
Z1FVWFVBa0FBQ1FBREFrQUFMSUZEd2tBREJGeEJ3Q2ZJWUV3Y2ZBaApjVENCUUFKQkVuQUhBQ1lR
WVJVQUR6d0MtLWdFU1NNU0pjQVpBQUFRRURBSENnSWxXQU9URmpKQUFSQy1HQklnUng0RVlnd0FI
UUlBCkFnQUVIZ0FCcGdRVUVEWUFBUTBBSm1GQUdBQWZvQXNBQVRFUmdESElOQkFRTjBBajhCMEtB
QkVDTEE1QkVCRVFjWUk4QUJVQVF6QlIKY0JFTEFERkFNWkIySndNQ0FBQ0lBa053SWZBWkR3QUNF
UUJEZ0NId0dBMEFCZ0lBVG5BeDhCY1ZBQ0JSOERoWUZoQTdBRUpoOEJVQgo0d0FERVFBemNmQVVG
UmNBdmhaRllJSHdFdzhBY0JBUmNLSHdENEdDQ3ZBQmtQRUE4QXNoQUNFZ1FhRGg4QXdCQURoVVVR
R3d3ZkFPCk5nQmhVQUdRc2ZBU2IxbGhZQ0VRWWZBV0ZBQ2dNQ0ZBUWZBWlFWQUJBTDBPVVIwaEFJ
R2duUUlBWkFvaDhRVUVBQmdnb2c0djhRZGoKQ2dvR0NRQVBad29NQUl3Q0VrQWdDZ2tOQUFCYUNn
Y05BQ1ZBQVI4dE1wQWhFQTBBTEJPQlpRb1RnUWdBQWhJQUQyVUtDQVVGQUFsbgpDaF9tdFFKRkFV
NERBclVDQXNBTUJiRUNBeG9BRDdFQy0tOVhZdUNCOENnaEFBVWZJaUJ4RkJzQ2FBOGpJMEdoRVFD
Q0JnSUpEUUVQCkhDTkFBUmdBRVNBZkJ3RVFUakpnZ1VBWEFRRFNCZ0VKQUJJUUNRQUJXaUFBN3l6
QUhRRmdJZEFoOEJvQnNKRkFvQ3doOEF3R0FBQnkKS0JBUmNpaEFHeEh3Q0xVQklQQUM5UUFBRzFR
aUlBRnpBQk1BRVFBVEVUMGtGQkVSQUFFNEFoTVFDQUFBQWdBbDhDQU5BQk1nQ0FBQgpGUUF2OEFJ
SUFBVUFNbDBFQmdBTFd3OENHQUFnOFFRcUFDSHhCSElBQUp3QUFFWS1BVUFBRVJBT0NCQUNtaTB5
SGZFRTh6bENBREh3CklaZ1hFU1RfQVVMd0pRRndwaHNDQndBVkVlZ2JBSU1oQ1FjQUVpbmlEQjBx
QndBQlVGMEJCd0FrS1RHbE5ROEZBQUV1S3lFQURBS0oKRlFHNU5SX1lHUUk1QVdjUkFSY0NGV0VW
QWdFVUFBOFRBdi1QQUtZUFVRQWg4Q1p4MXhFQWVsRUI0QkVSSTJBYkVTQUxBQ0VSSURJMQpFREF4
QVFFV0FCRVIzQW9SY0FzTEFNNEdFSUVBQndIWEJnRF9DZ083QVNHZ0FVMUNFQndSSEFJb0FDQWFF
WDhGRWtBTkFFRVlFV0JoCk1pTUE3REJIOEFjQkFBb0FFUkFLQUJBSW1BQXdHQUhnVWxzQXlrNEJj
QUFBOFFZREN3QlJBZkFjUVNDTU9RR2dPVEFnUWFDb0FTRWMKQWM0c1F2QWRJVEFJQUFBVUl4SUFS
d3d2OEFFSUFBY0E2Q1F2OEFJSUFCY0JTeHNLQ0FBZzhRUUdBQUg4RnhBY29RQUNPazRTRzdBQwpF
UkVERURFYUFSQWpGQUVKRUJFYlpSTUJqVEVnR3pHTEF3UGxDeEtRblFzREJ3QVRFTkVMQVBRTUVT
VDhBQUVIQUFvWk5RZE1TQTk1CkFnRkFLQUZnWVJvQU0zSHdKZ1VBRDBJQ0JCX1pRZ0k1RTRCQUFo
VnhQZ0lmZ0R3Qy0tOEREOElWSFFNVURnckVGU0VsSVM0QVlDSHcKSVJFQThheGNFQjJqRndDS0cx
QVpFVkFSb05GbFVCWUJnQkdRV3drQXJ3cFFnQkZ3RVhBNUFCQVMxQ0F4RVdBUnBRc3hFUUVnWkFJ
ZwpFQkVRSUFGUk1SQkE2VGxCRVRBUkFHWUNFRUFOR0FBVEFCQWd6MXdSSVJFQUVBN2hDMEVoUUVF
QXR3WkJZQUh3RFRrQk4yQWhjQTBBCkloR0FEUUFSVUlvc0VvQXRDZ0lQQURpQUVaQVBBQkJ3Tmln
RUVRQlJRQUVnOFFWbUFBME1BSEVCSUJGd0lTQUJFUUFTRExBZ0FWZ0EKQUdzREVFQjFCd0FrQUJF
UVhBQUFrQU1GRXdBM0FCR2dFd0JDWVNBaHNBOEFFV0VnQUNFUUlWb3lKQUVRTVFBUUVGY0RBdzRB
QURVQQpJdkFIelFNQkRnQWw4UWtNQURGQThRV0pHU0FMVVFvQUVWRThBRFV3OFFXTUFBa01BRE9S
QUpFTkFDRXdFUTBBQUJZRW9Bd3hRSkVnCmtVQXg4QmJoRlFuQUN3d0pBQkpnZENFRkNRQXlIZ0Z3
blNrZkhRa0FBQkpnNndJT0NRQkJISkZna1ZJU0VtQlNBd0JGQXg5Z0NRQUwKTUlHQWdWQkFNRUdB
UWExRVg0R2dnZkNSOWdKSUg0QWFGd0VQN2dMLS01MTEzNkh3S3NId0tRTUFBUFVDSVNmeHl3SVNR
VFUzQUVKVQpBcmdIRlNrVUFBQmtBZ091U3h3b00yY0JCZ0lCVWkwaUlTRU1EQkFRRFFDeElERWdJ
U0FoSURId0gwRWNBMEZCOEI1UkNRQTdVZkFkCkNRQkFZZkFiY2JzQ1V3Qng4QnR4QWpNa0dvR21K
ZzRKQUFCZFBtRUJBS0h3R3BGdUFEQ2g4QnFpSmpPeDhCc0hBR0h4Q3ZBYThRc0UKQUZBYjhRQUFj
ZWdIUUJFQVlTQ1FKWUFnSVJCQllFSHdITUVXQUFJNEF5Z2VJQUVROWtRRkRRQlRFY0FSOEJ5alp4
QXdUd2NUSEJZcgpFNEFMQUJFUnFEWU1Dd0FSSWV0UUR3c0FFZ0FLTEJCUUhXZ0pDd0F3Y0JFUWRR
Z0F2U0lEbGdNYUh3c0FBRHNtQXdnakR3c0FCd0VtCkRRc0xBQzlBRVJZQUFSRlFyQVFDQ3dCaU1m
QWRJYUNoRGdBVGtZTUFJQkFCU2loZklaQ0I4SnRwQWpjQ296a1RjV01DSDNCaEF2LS0KSnhYZXVB
Y0FWQ29EUmpJU0FMSUhBTEJtQVFrQUE1MEtHQkVXQUFJb0FJRndNZkFiQVRCaEVDRUhSLUFhQWNB
SkFJRlI4QnZCY0ZIdwpHUWtGRVVCRkFBRC1GQ0h3Rm9vM0F0b0dBaVlGUVFBQjhCUV9ad01vQUFB
bkoxTUI4QklSUUNnQUVWQVZBR0VBRWZBUkFXQ1BBQkVnCnZ3SUI3aFFoRUFFaVp3RjdXUURUSWdJ
RUF4QUNEQUFBQlF3RURBQVNjSHdCRVFJeEFBSGtGQkJBNFNZeUVCRmdxUWNBaXhVU0VVVUgKQVVv
TkVsQzVRREVSQVFBUE1CSXdlUUF4VWZBU2lRQUE2R2NTc0JrQkFGWUFGQk1uSXg0eEZRQUJPd0VQ
RndBQkx3RWdGd0FDSXpIQQpGUUFRRU5nSUFERm9FQUMyRFFJU0FBbEFBQkx3RWdBZkFCWUFHZ1Bu
RmdDaExCQUNFZ0JEOEJrQkFQTUFBbjhCQVM5R0FJWU5BR0FCCkpmQWozVWtFWEJJRGhnMEJwQTBT
SXZzZkF3SWdBeEFnQUJVQUFDY0VEd2tBQUJFaHh4WVNZTzBqQUtneEFiOWZFRENJVndEYWNnSUwK
QUJJUTRWY1JVS2N4REFzQUlXQWhhaGdBQ3dBamdIRUpBQUNaVndBZkR4QmdxQUFES0FBQ0cwOEJG
QUJTQXlId0Y0RmJJQVgzTUFEcApHeF9vS3dNNUVvQWNBd0ZxYWdVUUFBOGpBLS0tNFZETUlmQUJn
WVViSUJIZ1NBQnhGZ0VRTWNBQm9GSUJJa0d3SGlreUZHR3dueGN6CkZVSEFvaG1DVUNId0RTSFFB
UUFLRWdIUkFtTVFFZkFRTVlBZ0FCQXdLRmNRRHJZNEFUb0FFRERDUFFBUEFBRGZBRkJBWWZBT1Vl
bzEKWlZCQjhBOVJjRHNSVVZBaDhBOXgxWEVBUUE0UkZsa0FFUURJU2dEbkFRUUJDVkJRTWZBTEFV
UlBDaGNBQVFVTk1nb0JVT1VCQUxKeQpDQlVBQVE4QUFOTUxBTEJ4Y0ZId0NnSFFFYURjZHdBTEFL
RHdGSEh3Q1FId0JCSFFTUTRCSHhnaEFqRmlZeEVLdlFjU1lBczJFQXRfClJpUVJjQTBBSVZBUnpW
TmpzQUh3REZFd0NnQVJGa1pQRXJEY1hBQXFhU2J3RndrQUFFdExBYVpMQU1VQkFKZ3BFQmtLQUJB
d2FnUWgKWUJGdkFnQXJBQVFIQUdFaUFYQVJnQkZWSEFCSENDRHdDRlVkQUpzQUVCcDlBQU5tWFJB
WWt3NGg4QmNHQUJBV0R3UWo4QlVHQUNDZwpNY0FURVJWRkJBQy1BeUR3RmFrX0lqR0FDUUFRWUww
WEFCbE1BVWtlTVJjQnNBeERBZ2tBQUJzQUVCbldDQ014VUFrQUVVSDZCRUdnCkFWQnhmRkFoY0RI
YkhDR0FRWEl5RUpEZGV3RHZBaUd3Y1o4ZEFLUUNFUkd2WkFCekl3Qi1DUUY5QlFFSEFER3g4Q3Qx
WkJfZ293Sk4KRjRDaEFobGhuUUlmZ0pzQy0tOC13dVFoOENfaDhDbmg4Q2J4QVdWMUdPRzBOaUVR
UVVFVEV5QXhCeWdBQVJZQUFTWUFBZFp5QWVZNQpjQ3JCOENkeEFIRURXUkZobFFnQmVTWUE0d0FR
SHVJOUFMZ0hFUjFGQWdGdkNCRWMtaElBMWdZU0lDa1JBQmdBQVEwQUFXWlVBX29DCkN0UllNeGdC
UUEwQUFmNUxEUTBBQWtNQUJROEFBbDhBQVE4QUFPWUZCQ0FBSVFBUmhBWTBNQkVnUmhrSlN3QUFC
MUFDRFFBRmZ3QUMKT0FBRkR3QUEtd0FCRHdBa0dnR25XVUV3OFFFd0NBQUNMVU1BbG1VaDRCRk1E
UU1KQUlBZUlmQUJJZkFnRWNNQkJSWk1Bd2NBRW5CMApKZzhKQUFsT2tRQ1I4RXdtQUlBOEF3a0FF
bEE5QXlNZ0FWTURFUl9yRWdGekFRQTJDUUVMQUJFYmN5NUJjSEh3R1R4ckFYTWRJeGdSCmwya2dG
eUhsSndHRmFURkFBZEFKQUJCQnNBUUFDUUF3WWZBQkNBQVFGOGtBRWdJMkFKQVFFZkFBa2ZBWFFm
RGtVUjRndUVNUGZBSXcKRGpBNUQzUUMtLTh5Q2pRWUlvRkExeElCY0Q0Q1l3RW04Q2ROT1FjVUFB
RWtBQ0Fsb2F3Z0FwaFVBRVJoRUhBaEM1QWlRUkNCSUJIdwpJR0VVQndEVkVnR2xIVkVnUWZBZWdR
a0FNVkh3SFkwU0l5QmhDUUJPRUlId0hBa0FJdkVLQkFDR0lTRHhCUEFjRVRBR0FCQWhsbEFRCkhU
aFJBaTBBSDJFSkFCdzFBVUF4Q3dBd01FRVFGU1lnSDRHUEJ5QUFZVFVlRm5IUElRQU9KZ2VGZUZJ
aEFYQXhjQllNQlM4ekVoQXYKTXdjSkFCQWdDUUFXSGdrQUVtQkFGeGdlYlJjQi1VTUNDUUFCWnd3
SENRQVNJSUlNQ1FrQUFYQUNEd2tBQWhPQklnQUJsd0J6WUFFdwpnZkFnZ1VRZEFCUUFFeXhGREJf
Z0Z3STRIb0FyUmc4UkF2LVJnT0ZSOEM0UlVCRUFuVDhCNXc0VUphb2tBYlFxRXlOV0tTSHdJdElC
CkFCQVFBY2dxQVBneEV5RFRLZ0FJU0FIOUJBQ3RBRkloQVRCeEFDNEZJYUFCQ1FBZ0hoSFNHeElB
SlFVaE1KSFlFQkVhU0VRUlVIOEsKTkFRUlVJMEtBb2NLQTQwS0VoRVNBQ0NBQVFoSUFUVlpRQUJC
VUVFN0FDSWhzRnd2QUxrNkVCeHhHd0RlQ2lFRUlXc2xBRDR2UUI4Qgp3Q0ZLRUFJdUN6WWljYUEt
RUE4R0FCWkE4UVR3SXgwd0VpWVdBUkltRHdNSHUwTUFGQmdZRVk4bEZTdVdKUURoSUFHOUNqY3FB
UkFICkFBWGdNQklnS2tnQkpRSVpKd2NBQU10REJ3Y0FGSEVGQUM4bllUNGhBQl9hN0FGSkpuQUI3
QUVpa1NBSkFDX0FBZW9CLTVjSjV3VUIKSWhVQjNnd0J1QUFqSndGcEdDQVdFWjFfQS1JTUFBQWdO
QUFCMEJ3QVZCUWhFQkd3TWdBU0ZDY0FJaEdnbmhVUUZkMG5JaEdBMmc4UgpFTXdVUUhDaDhCWmlJ
Q0FoSUhXREVCUXlHcUVoSUlFZ0lmQVNRZkFQV2c0UUR1UUlBTzhCVUJnUmtHR1FueVV3WUlHUUF6
TUJpRklCCmJnSUFxUjRRSWQ0VUFHd0FFaUJiQWd3UEFDS0JJRnNGQmdrQUF5RUFBTHdDRHc4QUFR
QmJBQVFOQUJHQkdrZ1JIN3RNQVFrQUFWRUsKSHlBSEFBUWlJUkFPQUNFUUFlMHBGZ0NmTXdZc0to
QkFpU0VBbkFBU3dKZ0ZFckFiQmdNSEFBRWtTUWt0V1FISFhRRlNCaldBRVlBWApBQkVoRndBQmxR
b1FnTWdQQmNzVUVJRGtBQUFnSnhsZ1BDb0dCd0FTSm40S0lDYUJFd0FRa1FVQUFwUURERWRaVHkx
eDhKZEZBajRWCmdFTUNGMkUtQWhfQVBRTC04MERaTWZBeDNBMVNnZkFpTVJBaUNSQWhlaDRDMXdC
UlVBRUFjVkM4RGdFLUJRTkdOeEVRemlFVE1BMEEKRUJISFVoQXdIQzRpSUhFWUFHRVFFZkFWWVdC
UlJCQWdaMWhRRUFHZzBXQ3VFaEF3QnhRaEJnRWVGQ0F3RWQwU0VBNlpDQUV5QWhFTwpsZzRoOEE4
S0FBRERHVkh3RHlFUUVWSUNFREVORXlBYkVWY0dJUjRSUlhvWUlXc1lEQVlBQlM0S0R4Z0FDU2NS
QUFJQUNXTUdBRnNBCkN3WUFCamNBQW14VUVDSnFKUW02R0NGZ0Fhb0NGQ0VKQUFBU0FCMFFDUUFL
SkFBUENRQUREb0VLSHpBdEFCNEtDUUFBZ3dvRkRnQVEKRUhzQ0VSNHpKZ1JkZTJfaDhCNmg4Snc1
QWxNQnBnd0JDd0FWY1RVQ0gzQXpBdi1XQzZrR0VCQW9raEVuRHdFQXdnNEJLVW9BdXdZVQpFZHdW
R0JBV0FBVW9BQUota2dFLWR3RTZqQkFtam9nUkViODNFU0FHR0JFQXJUY0JKd0FBM2pFQklCZ1NJ
T1VTTVJvUmNCNVlBQkFUCklDR1FRZ2tBdnhNUkVua2JFaUFVQnlJT0VRazhBR01XY2JBaDhBa2hz
QkZSQmhBQUJINFJFRGdMQVJBQVFRTVI4QU0yQmpGUUVSQXIKQ2dCWUZ5RVFJUkE4RUJBUEtBRVZB
RUZRSVdBQndBQUEwQUFBckhNUlFGY2VJUkFScndvekFWRndFUUFBNzR3UUlNZ0NFRUNIRnhBQgpo
bzBIRHdBUWNKQUdNUTBSUUNSWmdKQVI4QXdSUUJIUWhRQXdHWEhnWHhoZ0drSHdBREVnaElBUThN
aGlRUEVDOENSeUFBc0dBQ3BRCklTd3VJWEFSMjFSSllESHdJd2NBQUhGM0VuQUhBQ0pnUVFjQUVE
Rm1BUUFRSkJBb3NSZ2tMUUVGQUFGQmN4OHRCUUFhQWFvR0VTeXMKR0REd0xJRl9jdzlJQWowU2dE
a0NBQ0VSRmhBUUFBVWdBQTlBQXYtd1FPV1I4Q3VnQVRFaEFCSEdRQUp1QkNId0tMZ0JJZ0FCTndJ
TQpEUUFTRUlnQkFCY09BUmdDTUNjQlVFd3lNQkpoMEJjS0VCSHRhUkZoZVdrUUVmR1dBZFVHRWZC
ZUtBTlNmeEFQb3dZUkFIUTNFUEN2CkNrRHdBQUV3NG5kQkVHR3dVVmtGTWhkUlVDcEFJUnhSUnh3
QXJRVUJrZzhXSUFrQUVsQUtDaFFmQ1FBUkhvNEJHMEFKQUFNYkFCRlEKQ3dBQkNRQVNVQWtBQUVn
QUEtRVNCbG9BTjJId0lRY0FBRVFBUVNHQlVBRUlDeUJnc2JNUEVKR3pGeEVEU1FjQXFFMGdBZUIy
VFRBZApBZERRQmpBZEFhQ0NFeEVkZmh3UmdCQUFBT0lQUUI0QndERjhDeEVSSUhRd0lSR2cxWmN3
SkJGd0xvTWhKaEU1QVRBb0VTQU9BRFFyClVUQ3pkd0FZTkJzdTdnRVBCUUFWRVlFV0FtX1I4Q3VS
OEpnUEFpUUJsUUVUS2VvQkF3OENCZlVCQndBQ0R3c0MtOG9HZHhjbVFHRVEKRWxJd0FSQkJBQWtB
RUFCVGVnY1NBQU1pQUZGUWNmQWVJYXNCRUI1RkJqRVJjRkUtUkFESlB3Q0ZiZ0NrUHhJeFRBUUFQ
QVlCUGdJVApHSzlLQUJvUEFFYVJBYkVGRUJlX0lFRVJBQkZBNFE0RXNYc0JrQUlUb0JFQUlTRWdE
d0FBN2c0RElnQUFDUUFDSUFBQm5wb0FrdzBECkRRQUNIQUFTUU5CY0FCb0FBaWNBRW1CSWdESmdR
U0FMQURKUWNYQUpBQkZBQndNQmx3NEFwejhBRFFBMmtBRmdEUUFCTDJvZ0YwRUwKQUNGUUVhTUtR
UmdCSU1GQUFoUVkxQUlBVnlJY0lRb0FQeGNCSUFvQUFDVVFNUW9BSS1FRkVnQ2cwQ0V3SWZBWEFR
QkIwRWNpTWhvaApJUE1UQWZ5TkJJZzdEd2NBRVFINUFnNEhBQUZKR1E4SEFCY0FMd01QQndBU1Fl
SHdKaEY1RVZJbUFRREJBRDRlSDVkX0FqVVNjQWNBCkpnQnhEZ0FQZUFMLS16d2kzcEhDRmlBcDBl
cVlBZFFyQU5RZ0FXSVdBcGh6Qkpjb0NCWUFBeVlBTXpCaEFFNExBUVVBRUNaY0dBSXIKb0FDZmVn
QUJvQkFSSlFjU1VPVVBFUnFvQ2hGUXJRSUJKd0lBY1FzQlJDRmhGQUV3TVZBeHdqQlFFZ0Z3UVpD
b0NqRVJBY0JXTm5IdwpFUUhRVVVBUmZDc3cwR0V3ZEdJQUpnQWl3SEZhQUREd0VtR2tDeEVRMng4
QTFnb1NZUjhVQXc4QUVCck1BZ0RPVVFGdEFBQVBBQ0tCCklONEdFUmxSR1JKQTFpQTBRRUZRQ3dB
azhBQXJBQUFLQUFDM0pRME9Dd2NrQ3lBUWNkbGVFU0VCQWhBalB4VkFBZkFpRVJJTUFBSVEKQVNv
UUVPQmZEQkRRSldNd0l3SEFyeGtoSXdHN1ZnVVZFQkpnMWdJQTdDQUJDUUFTSXZrVUFJY0hGQ0Fa
QUFDam9CUUFGQUFBQWdBQgpDd0FBRkF3Ql95QUJydzhlSWM4UEVZRXJCQ0lkb1FjQUpaRmdLUWNH
WUFjQUxRY1FvVEFISDVNNkFqWVNnQ3NDQUlRTkJoQUFEeklDCi0tSlEzNkh3SmtFTEJoQUF1R0lC
V2dRQkVTb0JjUmNDbWdZQy1SRVNBQXlNRlNBaUFBREdQeUV4SU80QUFZNWxNUlpoSUZrN1VDQmgK
OEJHQkdXOVJJSUh3RHBFSkFHQ1I4QXp4QUtDWFNQQWY4UUpnOFFMd0MtRWI4QXZ4QUNCUklPSHdD
X0hRMGZBTXdmQUFzZkFPb2ZBQwprZkFTY2ZBQ1lmQVlRZkFDTWRnS0RrOUVEd1lBTXdiLVZRVy1J
QThHQUFFZ2NDRkpGU0FSY05vd0J5SVlEd2NBVXlJaFlBNEFFQkN6CkVBQU5SUVBYR0FFR0dqQWVZ
VEJqQVRBZGdTRElOZ0FMSWhfUy1RRXZHWUQ3QVJsaDl3RWZnUFVCLTdSQjB6R2dnYjkyQWVvbkVS
dDkKSTNGQVlmQWFjVkFCWWdRUkdjc0lBMUlORVJtRkJSUlFhZzBHRHdBREhnQlFVQUVnTVVCSkVo
RVhFZ0l3RUJGQS1RZ1NGX0lFQVRjXwpBUjVTQUJ4ckVtQU5BREZ3RVlCWEFnREZJQ01EQVJVQUlm
QUNQd0FBRkFBMUFnRndDZ0FYWUFvQUFSWUxJdkFCSGdBeEdESEFVQVV3CjhCc2hqd0FCQ3dBakhq
RUpBQVZTU1FsYlNRY0pBQUdnSVFrSkFCSUFDUUFWa0FrQUVSSFJLQUVnVWdFSEFCSWlBQkFHQndB
VXdRd0EKQUM4QUdiQUhBQktBNVFVRGpnQU9jd0FPQ1FBQTdBVURDUUFBMVJNQmNnTWJZQWtBUWg0
QllERUpBQkF4UmdZQkN3QXlJa0VRQ1FBRApaanNOVDBRUEJ3QUdET0VLQ3djQUVHSEtDZ0R2YUU4
bmdmQ2FZUUpGR1hCZkFoZHhEUUFmY0ZzQy0tOEhIX0Z5YVJZRFJCWUhGZ0FCCkpnQXdKaUV3ZENF
QWVqNFFrTTRLVUIwaFlKRkF6RU1RNE5PVk1oVVI0RVFQQVBNY1FQQUVBZERTZGlId0JnUUtFQWxT
VFFDWFhRQkkKSldFS0FWQVJzQkc0TmpIUUVZQU1QUURoQVFCeWxTQ1FJUnc5TXlBUmNCQUFBSmc5
RWFBSE14TlFFZ0FBOXowUXNBc0RJeUVnRWdBeApNQkZRRWdBaGtFRlRBQUE5QUFBUEFFTHdFV0dR
Q1FBZklnY0FHSEdBa2ZBaWtRQWhEQUFta0NFVEFCS1EweklYSWRNeUV4RTZUaEFZCjF3QUIwQVV3
Z0FFQXhaSUFUQ1pCTURGd0lRa0FRWEFoTUFHRnFCRndtSVVTSUFzQU03QVJNQWtBQUhjQUVSb2RB
QUVKQURCQU1hQzQKQmlBWFVlQW1Fb0RZTndjSkFCSndNemdRa0swX0FEOEFFS0FqRVFTS0tRS1BL
UVVLQUFnVUFDcGdBZHdsSDVjOEFqd09UakFQTkFMLQo4VUhnSWZBdzdrSlJLT0h3SmJHSWdCQWQy
Q2tSRWQ0QVVCc0JJT0VnOHdRVEdtWUVJaUFCQkFBQkRwSUdPem9SRU42TUx2QVpKZ0FSCk1GMEZF
akNvTVFBcVVnQVZGUEFDOEIxQmdLSHdIc0VBTVZBUjhCc2hBSUVfQUFBNEJ6QWhJRUU1Y0FES05s
QWhzQkV3VVhNN0FuS2kKRVNFcURoQVZRUThCbGhNQml4TVJGVll1RVJCZkFDRlFFVlk4SUJBQnUz
SVJNSVpySWZBVDgyOEFzb2tSTUdBSFEtQVRBVENzSEFEcQpEME1BRWZBU3NCd1FJQ0VNRlJNTkFB
RXhoUUJNV3lGd0FWczlBZ3NBQWZncUFnMEFFVkJSV2lEd0Vfc0NBbDZ0Z1FId0ZESGdJUUFCCkN3
QUF6RHd2OEFNTUFCTWxBU0FNQUFHT0ZERVE4UU12TnpBQThRTW1DQkFST1RrZUd3c2RBa1pZRFRB
cUVpZGRDQUhaQXd4dktnaUwKS2hBUnBTb1FNYmdxQkFVQVVySHdLZ0VBQWdBLUlmQXJDd0FBRUJH
SXNRTUNBQVI3QWdNZ0hRQUlBQkFzdlFnTzNwUVBpQUktRzRDRwpBZ0dYTUFlQ0FoX0FnQUwtLXlO
US0tLS0tLVpLQUVCd1FmQW5fRDhRSVFnVEFERW1FU0RVT2lId0hmeEJJWkF4WXdJQW9nRUJKNGtD
Cl9sb0F6d0VCT0NrekZERVFvUUFFRVFBakFTQVJBQWNUQUJBdzZ4TUdEd0FSUU1zSkFMZ0NBVk1D
UVRDUkVBRUNFekVUWVJBX0FBUVAKQUFCUkJ3SDFDZ0FCSWdEOUdBRW1Dd0FOQUJKeEl3QUJFQXd4
RVFGUWNSUUFIQUFGRHdBU3dQb0xBSFFIRkxBTEFES1FFYkJsQ3hFUAp1d3NTZ0NFTEVSQWZBQUN1
QmhJd25rSVJJT1VGQVNSOVFoQUJVSEdsQndIUVFoRkExQUFSa05RTU1QQVBZY2ExQUI0d0FFRVpJ
UEFOCkp3QVFzYVFBQWdzQUFMazdFQUFNQUFGWWZRSG1LaElPWmdFUUExZ0FFYkNMYkVJUkFaQWhD
QUFBMEFzQXhWc0JnQUFGVERNQk1UTVAKQ1FBUEJXSU5JU0J4cGdNQUtnd2lRSEVIQUFFUUFCUnhC
d0FBMDVJQTNHZ0JOazB3Z1RDUjN5RWZuRG9DWndnUEFBUDZBUmdRTmdJSgpEd0FSUUI0QUR6WUMt
NmNMckFzZlVQMGZCQUl6SkFVVUFBT3BsWUFrTVZDQjhDSlJvRk1HUUNCQkFLSHVJQ0V4SUljUUF3
a0FBUDRBCkVDSGJCUUJBS1JBeENRQVNvQUpXQU80QkdiQUxBQkVhU21VUXdGd0hCRFlDQVowLU1o
QXgwQWtBSlVBQkNRQUE0d1VGQ3dBQlRSZ0EKdVJnUjRBa0FHbEVIQUFRZ0FBQUpBQUFOSmpBYlVl
QWxIUUNaTHdFS0x5TWJFUk12RVJ2aUhRRlpEd0IwQVNCUU1kMFBRaUdBRVRCUQpFQUZzcEFuakZB
UUdBQW44a2dEeUFBQWNKZ09ZQmcwSEFCSW1IZ0VLekgwQUlSb05Cd0FBZEdZTHJRWVJBWVVHQndj
QUZDRkZXd1VCCklnQUlBRE1zQVhBRkFBNE9adzhTQWl3TmtSOFBDZ0wteW5ELS0tOVRNZkFCZ0U4
d01CSEFVZzRRR2dkVkFJY2JVaGtCZ0lHQWgyZ1IKRVBBRUFVMGdBZU1GSWxFQURRQVJZTWNGRW1C
YURoSkFxd2tTRldJRkZWRUxBQUlOWndNUEFBQW5ad01hQUFJQ0JnRVdBQ05nWVFrQQpFc0FTQUVG
UU1hQXhhd1pBSUNFd29lVUtJUEFXYlNvQVdSUUZzVGNSR0VCRUVSbEZCaUZBQVdFQVVCb0JVRUVn
d0hVVUd3a0FBTllBCkVRQU1JZ0pTTXk3d0hSRUFMLUFIQmdBQkdCNmhZdzBHQUZBZ0FmQURNU1FB
RVFGRUFDRHhBcWxVRVFGd1JsSWJBZEFCa0FjQXNxQUIKOEJyaHNBSHdGRkhRSmg0d0QwSEF5NkFB
ckFBUUQ3OEFFSUJsQmlGZ0lVd1ZBTDV4STJHUUd3QVJBSkZfRUdCNkJrSFFFU0F4TWdBQQp3d0ln
RUZFM0ExRHdFZ0d3RVZlVUVSQTlBeUR3RktrR29IRVFjZkFXUVZBQkVLRUJBZjhHOFFBZ2dmQWlZ
VENSOENGUlFLSHdJVEZnCmtmQ1FIUUoxRm5BTEFCUVFfZ0VISVFBUEdRTC1rRlBna2ZBcnNSZ2hV
Q2ZoOENYQkwxOGhzUkF2S2lRUk1NOUJFZ0R6YWdPX1B3SHAKaFRBbklaQk9qaEVGVlhrQl9HWUFv
cEpNOFFJZ0lRWUFJUkF4RjVVTUJBQVZIemdBRXdaTVp4SUVCQUFBYUpJUEJnQUFBS0VjQVowZwpL
ZkVDcFNBeVFBR1F1d1VEaW9VSXJRVVFRTE1LQTFZT0ZDZ0hBQUNzWGdfbUJSRVpMSjQ3RHdjQURC
TWhCUUF3b2ZBcHppRUVQR2NmCm01QUJNaUZCZ0g0QkhvRktRUV9NQWY5TUY2RWpYVEFtQVNEVlBn
Qmx4Z0ZzQ0FIYnJnRzJGQUFwSXdKMEN3R2xEQURxcmdFYUFBRUwKQUJJZzRSa3dJZ0ZBaVQwQ09t
b1JJR0FFSUIwUmhqNEZQRXNSRFprNkVnOGZFaUx3QTNPWkdEQUtBQkFDVmdFU0V4NEFFSUFoQkJn
dwpDZ0E0QWdHUUNnQVFFWFlBRUFLX0FBQjJFZ0lNVEJJUUhnQVFzR2NBR0VBS0FEOEJBY0FLQUFN
QnZIZ0dDZ0FBa1RzTENnQUFHaWtBCkN3QWtNU0FMQUpJUEFSQWhnQUZnVVlBWE54R0FkN1FBSkRj
aEVTQXVLUUZMTFRFUk1aQXFCZ0dWRGxLUUFZQkJZQWtBQUJrQkVCT1kKQUI4RUNBQUpFTUQ1QUNE
d0UzY1lCUW9BRUNDcEFBVkVBRDhVQWFBMEFBUVEwR3NZSVBBVElnRWg4QklHQUFVTUFBVURBR0VS
QVVCeApZSUV3VXdEcUdCSkFFVWx3RHdFZ0lXQ0JZQWNZQU9RQU1IQnhjREV1RUEzdkFDQmhnS3d6
RUF3RkZKNFJRQUZ3d2ZBUmNYRGxPZzl4CkFpOFZnRzhDRldGckFoX0FhUUwtLXlNQW16UUJUaFVD
dVVFU0lhd2JBc01FRVFBRk5pQUJBV0Y4Qk5VbUU5QnVEVEVBSVpDUUFqRVEKQWFDTkZCRFF0QkZC
QVJBaFlPNGtBS2tOQUJJRkFoWUFFU0FpVnhIQTVJMENGZ0FSRUVRTUFGWUlFY0JBeXhFZ0VBQXg0
Q0V3NHhJZwpFQkhScHdFV0FCRWg4bW9EUlFBQmxDMFNNQTRBQU9HVUV3QVpBQ0FRb1ZBQUFsRWFN
UEFLSWFjQUVTQk5BQUNuRENId0Q3d0lFYkExCkZ5RUFJU2RBTW9BaFVFTU9FRkJRTnhBaG9Wd0Ez
eWdRMEZNREVNQUpOaUdRSVY4REFKWlZBSjVJQU80a0lDUUJlMEFoOENUNk1pQlEKVVNjTEFBMHlJ
aEV3bUFvQUNsSUJPbEZCR2dHQUVaS0JNaGtCVU9vdUFBM01FSkJxTnhJWnRWSlFHQUhnRVdBZHZR
R1VBQUJDVVJDUQpqRmNTRVhBZ0VTRnhnZ0RfSUNCQndNOERBV1FsQUo4T0FLczhBVHdYRUZEaWpZ
SWdRWEFSOENRaE1LZ2hJQ01CV0NvQ0NRQUJVeGdBCnJ3QVJJWFFUQUYxSkFXVVRFU1JKS1FGNkxR
QnhvQkFRM0RZalFDRjVEZ0oyRGdFUEFBREtBQ0R3TFhRQ0Joc0FFaTBiQUJBQVV3ODUKTFJGUUd3
QUFDak1RTFN4U0E3WU9Ba0lYSDV5S0FpY1ZnSWdDSEdHRUFoX0FnZ0wtLTBzWDM0Z0FBbWNPSlBB
ckNRQVJLZzBDQWU0agpBd2tBRVNqMHdBSXhaeEFtaGdZUkpBN1FRdkFpRVZBU0FRRFNDZ0kwQlNE
d0hiVEdCbFVGTXh3aGtCb0FZWEJSOEE0aG9EQUFBZHNICklCQkIxd1VBMkNCQjhCUkIwRHdXUVBB
TFVZQzZBZ0RnQUFEdlpRQTREd0hhTFNBTUVXQVBBdzBBSVEwQkRRQUJIeVl3OEF3eEJ3QkIKRUtF
UUVjUVBFUTROSVVNQXdRQkJEUUJpRUZFQWdRQmhEUUFWZ1FzQU1tRHhDUWdBRUdGcEN4QUFUd3lq
RHdGd01RQWhZQ0VBVVEwQQpFT0NjU3dEZk1rRXdnVEJCZ0J3UmNBMXRFREROQWhVVURRQWhrQ0dy
VmpGZ0VVQ2VBQktBWFIxeENoRWdNVkJCVUZzUUFjc09NZ3NoCklGWW1FaUFRQUNFUUFSMFBBTGtE
QkE0QUFNc0lBWE1BSWZBRF93Y0FPQWNTQTVjVUFRb0FJaUFSQ2dBd0JER0FqZ0FnOEFSMUlVRVUK
QVlBaHVac1JGbHdBSVdDQkNDY0Jfd2NDSFFrRlNEZ2ljSEhoTXdFb0FBTVFkUWtOQUJGdzF4Y0hE
UUFCLUFFQURRQUFhVE1VTUU1MQpNckJ4TUFrQUpQQURJQUFEQ2dBUmdUVTlBV1lBQU9RaUZSWmtB
Z254RXc0WWVBXzVBbXdWZ0xjQ0ZXR3pBaF9Bc1FMLS16aEwzZUh3Ckp3TUFBSTRDVUNYeEEtQVM5
VFlTRUlrQ0VBQU1BRGtnRWRCOUNoSFFSUWNab0tjS0FnRUlFY0RzQUFDZ2VRUXdBQkZ3ZVFjUklC
b0EKQURXSEJGb0FBREZjRVJBWUFBQUdBR0p3VVNCaElGRkVBWERRSVJBQnNER2c4R0FSSVQ0Y0lN
RHhQcklBZjU4Q1h3QUJUd0JTRWZBSgpJWkRFQmdBYUdWRWg4QTRoWUhNelFXQWg4QkhNdGdPTkIy
SlI4QkV4RUNFZ0FoRUFCZ0JoRUNFUU1mQVJLd2NURUpzVUFBb0FGekFWCkFBTmVBZ1lWQUNNUkFC
VUFKUUFSRlFBQjBRQUJ2d0FFRVFBREt0VUZFUUFUTUFNRUh6QVJBQWNCd0FnbEFCRVJBQk5BcHdB
VlFCRUEKQUdFQkZTRVBBQkZnYmdFVllBOEFGVUVMQUNUd0F3b0FFWENmRlFvWEFBRHh5eUFoY01K
VEFBc0FJRUFoSXBVQ0RRQXhVWUJSQ1FBQgpwbHdTTUFvQUFJb1pBd3NBQUgxY0F3c0FMbkFCQ3dB
UlFQNENIMEFMQUJJd0lDRmdIU2dBQ3dBQVJ3RUFHQUJCRUJFQVFVYUpFbUN2CnlBZ0xBQWM3QUFH
ZEZSQmczRjBnRVJGeURnRkpRaDBidkhJUEJ3QU5FZkVCQ1JBQmUxY0FxQThPUThnUE9RTkNIb0Ez
QXg5aE13TUQKSDRBeEEtLS13NERvUWZBd2NmQXRvZkFTSUFMQjhCSmdBWUVBVWZBVUNBQUFFZ0ZB
RWZBQW9hVW1kQUN4OEJnUjRNRUZBRkhRNGZBWApFUjFEUUJjUndQRktWTENnOFFYd0ZCR1E4UWZ3
RTFnREVqRjNBZ0FmQUFIeFNRRVVZaEd3TGdNQU5nSkM4QlVSc0VTU1FCVVJrQkVICkVsSVVFWEFS
VUVpU0lCUVJUYzBBWFNNQWNna2dZYUFKQUtKQWdRQlJzQUh3RXZFQUNBQUFibmdSUVFrQUpCREJD
UUE1MFFBeENRQWgKOFFNSUFCQVJ0UWdXVVFzQU5HRWdBUXNBUTNFZ0FhQUxBQkd4Q1FBMVVBRXdD
UUFwd1pBSkFBQ2lEU1dnQVFzQUVRQkVBd0FHQUFKTwphQURCRGdBZUFBSEpSeHpSQ1FCUkFQRUFn
QUdFcHhrQkNBQVJrREdzQVFnQUFQOGFFREgwSXdNTEhEWVBFYUFOQUZJT01hQVJVUGNCClF3OFJ3
QUVMQUNBT01RWmlBZ29UQWhZQUpTRkFGZ0FsUVNBTEFDVmhBQXNBQUVncE1RMVJvQXNBSlBBVkNR
QWdGSEh6Z1E4R0FBWUEKVlFRQXN3QWo4QlB6QUg4QUFYRHhBUENVYlFKMUZXRnJBaF9BYVFMLTlC
LWZqTjQzQk94M1VCR2dFZkFsZEEwUUVkSEJBMVlIQWRnRQpFUjRFQnhNUURnY0NBMklCSGdBQl9Z
b1NzUHdqTUJrQnNFc09BUEtLRU9DMUh3Q3RFeGZBQ1FBUUZoNEFBSzhDQndnQUFkSVhCd2tBCkFM
b1hBUUlvRHdzQUJ3QVFxd093R0FBT2R3SUN6UkFIdWhJQWttY0FkWDJSRWZBWUlmQUhJZkFhN0Jn
UUhIOTlEQVlBRUFteEh3a0cKQUJnS202d1RBU0laQU1ZeEFGY3hJUEFPZ2VFRERBQVJDdDR4QU9v
eE1DSHdCRFFsUVlCUjhDWDNWUVRrUkFQU0hBQnZEd1lIQUNRcQpNUVVBS2lzaFVBMEpXZzBSRVM4
VVR5NWg4SmtTQWo0VWdBRUNBMVVWQnhRQUR3b0MtN3dmNEJKS0RnQVJCQmdSRkFBR25FY3lKaEhB
CjZNUUJFaWhoSHlFd29VQVI0b2tnUUpIN0FRQ2xKd0VMQUFNOE1RTUxBQUI5WlNGQWtmZ1FGaGNM
QUFBbVJ3QUxBQUduQVFVTEFBQV8KdUFBTEFBR2pNQXdMQUNzUk1CWUFNVUR4QVFvQUVCVFpPUk9C
VEFCQmdCRVFjUXNBRUJZSU5oTnhlQUFCQ3dBQUJRSXdHQkZRQ3dDUgpNZkFiOFFKQU1mQWRUZ0FC
aTNVRHJ3QUpDUUFoSUNIZGRRQ2JJQUVYQVRBZkFVQS1NaUlCOEFZcEFPOENFUERNT2hKd1Z5Z0Fr
bEFpCjhDR3hud0FuQUNvQUFRc0FGQ0ZDV1NPQUFUdFpBRndEQXdrQUFRRUNBZ2tBQVRJc0J3a0FB
U29DRHdrQUZRQ01xQmFCRlJJS0RnQUEKeFFaUEh3RlFFUklBQ1FCMkFBQlNUU0ZRZ2E5N0FJSXNI
NkQ4U1VRUFlBTC0teklQNUFnMUFlUEJZU2p4QVBBa0VaSU9DemxDSkFHUQpCd0FSY01aREtBR2dD
UUFTTUowQ0duQUxBQUZoUnc4TEFBVVJZUHNQQ1EwQUlRQVIyZ0lSRURVV0FhUUxCUTBBSkFGQURR
QUFHZ0lCClpBQU5EUUFSTUE4QUFnMEFBcDJVRVJzWUFCSkFrUWN4R3pGd2h3RUNGZ0FpY1FDX0FE
QVFBWEI1eFFDWVJDRndrU1FCQUY1cUkzQ2gKMVhvUmNDaFJFTEdBUndFRkFET2g4Q0lGQURfUjhD
TUZBQUpCUU1Id0l3V1FJQ01SSzZWLUl3RVE4UUR3SmdRQUVRSWxDd1FIQUVEeApBUEFsUVFnUlVh
a0FBRDRtSDVZbEFqNGZnUGNJQVE4ZEF2LVZkZjhxWWZBclFWQjdDUU9RQ1JBbnJTNHhKLUVFNzVZ
U29KNW1JUUNoCmF4SUI5RlFSSl9zdUJMY0dFaWdoQmxBcHdmQW5JVHdKRURBaHhqQUFVU0JiY2hB
Z096a0FBVjRBTFFGaE1CR2dFVEFCZE44Q0N3QUIKelFFZ1FPRi1BUVlKQUFCRXZZRURNRUh3Ri1F
R01GZ0dVU0V3OFFFUUNnQXdBVkN4SXdBU0lPZFBFZ1lLQURVaDBCRVZBRER3QWVGLQpDaUFCMFM4
UUVVSGlBVUVhRVhDQkNRQWdIUEU0RkJFZTBXNFJJTGdwQTBFVEFPaDREd1FBQUJJbGlnSURCbEFS
Si00RkM2ZENFaWtnCkF4MHFCd0FHWXlrUktyZ0NJdkFyQndBS3R5a0RkUUVMQndBVVFRVUFJQ3F4
OHpZUkFiOERBTFMwSDVyZUFWQWJZWk1JRDl3Qi00Z24KSjRGSnpoSW9LUVVDcDRVUk1DcGRBZTRI
R0RBVUFBTWtBQkZ4YTFJVXdOQUZNZUh3SmVZWEFhRUpFQ0loVHhBaEtVOHc4Q0F4eXhZeApBQkVR
UTRNUWdVR0R3MkVRWVJCaDhCMXhFRUVRY2FHR0FlaUNNUTN3R1FRQThRZ084QmZ4RC1BWDhSRHdG
dkVROEJYeEVmQVZVUUR4CkNnWUFFQVBtRXhOaENBQVFVV2pCTkdId0V3Z0FBcHdZUWZFREVGSEFQ
UU1LQUNGQklBZ0FFaHZTZXdHdEJRQnRSZ01MQUJGd3J6MFUKSUFzQVR5QkI4QndqRndFSVV5MEgx
Z0lYTUFjQUNxUUJBZFVCTUJId0t4RklFaEh4QVRjeDhDZ0hBQkFoR3dJYVFVVHhJU29CYnlNUQpV
RUU5STBBeFNFOVBMWEh3bk5jQk5BRTFCeEFuWDJNR0RnQVB6d0gtazBJbTBmQW5Bd0JpNGZBbklX
QkItV0pqTWJBaDhCZ1Jrd3NRCk1iZzhBUllBOEF0d1lmQVlJV0JCVUhId0dlRXdvZkFad1NDQjhC
M0JBSEh3SVVjd29ERkFVZkFtVVNCeDhDVUZBRUVrY1FDUnl3UVQKSXNzd1lSNmhBTUh3SFFVQWNK
RWdzZkFkZ1RBRkFDZEFvUVVBRUI1TE94QWdFSjRUSXlBRkZTVTh5QVFxQlFCUEFBTFdNQWdpTVE4
RQpBQWNYSURBQUV5SkVBQklrWjNjaEtNRmJJd0ctQlI4ckNRQWFNRUVBUVE3VEVHRnIydzdnRVE5
MkFTSVRnSFFCRTJGd0FSX0FiZ0gtCk55bmhnV3pEQUtHSkFBSUFBZGdERDVFR0lFQXFvZkFvRFlr
RkF4RVNJSGI0QUdVSUtFREJKTEVSR3I1ckFSeGFFV0JfaENUd0Z3a0EKQVBrUUFPTklFZ0NJNlRC
UUVlQ0NEd0RESXlQZ0FiOWFFdUE2QURKQUFlQVREQVhpZUJJZ2s3NFhIUWtBR1BFSUFBTHllQUJu
M1FKaQpBRkFBSWZBV0lYcWxJVUJSSFFzUUVka0RNbEVBSVdNUEFKNExZUUFSOEE1QklBeC1BaWds
RUFEZ0JCQVNxc3dnTVhBbUFHRWg4Qm94CkVCSGlIaEFqNFNzdkxBRUZBQUVnVUNFRkFEY3g4Q3NG
QUNCQVVmWUJZbkh3S2pFUVVXZ1NNQ2toSU1fakVCQnBkVUFwSVJDQnExY3cKRVFCeEhnVUFNSDhC
RGdBQTgwUTdLQ0VRRUFBUklBY0FBTEVGQXdjQUVVRzk4d0VIQUJBUTd2bWZLa0V3RWZBc0lmQ2dJ
d0l1QThJRwpGd0FxQWc3ZEJnOGJBdi1USF9BX0JBY1JJR1NtQVN3RUFBUUFKZkFmUkFRU0VBdGpC
UndBTVNId0hURUNFaENWS0VFZGNWQUJmbUlSCkhDQkRFRUNoQVJLZ0xDZ3hHX0ZBelY0Uk1lUHlB
aVNURUJSS0dBUUE2U0FCQUVBeUFOeWdCaE1BQVVNQUFYZ2RBTnVDQW1ZSUVRNGsKRVNJQWdTQUFB
VF9URVpBekFDVkFFUk1BRVF5V0VBQmxvZ0FYSkNId0RGa01BRmNBRVNBa0FCQWc2QWt4REFGd2lR
VVRFTjBBQUFJUgpBU2pJRVNEWDNSQWd1R3NURDE4cEFPY2hBRnNBQUtkU0FSRUFBQWNrRWdCYmZn
QVJBQUFZZmdCTkNRR3RTQlVBX1NOQjhCNWhJQWtBCkFUd0FBRzRWQW5Na0FBMEFBUWNBRWhCUkFR
QXJVeU1BQVdNQUVTUGpQQUY0QVFHLTNSQUI0WDBSSXVOb0VTRFhBQ0Z3RWNBVUVDQzEKVGpBY0FY
Q1lMd0RBSWpJZ01TQkNFUUFhSXdPZmtqSkFJWUFKQUFCU1NRTUxBQkVRa1U0QnNnTVJJTXdxQWNs
a0VTRFRUZ0ZpQUFGMApKQkVpQ1FBU0lQRUpFakNNRWdjSkFDRkFFYUVPSy1BdkJRQVlZUTBBREFV
QVJ6QUI4REFGQUVBZ0FmQXhCUUJQTWlId3ByMENMaFZ3CnR3SUZ4Z0lCUXdFUkg5NEVBN2NDSDND
MUF2LS1iUlRaZ3lOQUs4RVFJVFFtQUFBdU1DS0JNRGN5SVNHaHl4bHlJYkZBSWZBaHdhbkEKR09D
NUNnRV9nd1hiSlJFblNCZ0JHeFlSWUFFREFMNzNBR0s4SVNBUlJMTWdZREZPa2xBaEVHRXdJY1Vh
RUNISEJnQi1VVEJCWUpIdwpZOERCUURGd0FmQVcwVUJCY0RFdFNmQUEwYkFoOEE1eE1OSFFFZkFN
Y1REUi1sSkFDb0VRNGNwYk1BZnhDME1lc0FYeEMtQUdFZkFECmtSRGhvQjVBQVpFdzBaWWVGQUFJ
QUpDaEVOSHdDd0hRQVVEUmx3Rk5BZ0VPWlFEc0J3SGVLVFh4QWxCa0FnUUNBRUJBQWRCUkdRQUIK
eWdJYUFCa0FBUzBBRWdENEFRQXREZ0N5RFJBUnB3NEFUUWdDWWdBQUFnTTFVQUZRVXdBUklFY0RN
OEJCRURZQUFPZ3VKQVR4QndBVApVRklBQWk4Z0dGQVVBQUM2WlFJOEVpRUY4V3dDQkZJQUVRRGZG
aUx3QlNvQUVqQVVBQUlHQkRFRzRXQVRBQklnRlFBQVVRQWdCdUd3Ck9oQUlPV1FURGdnQVFBMEI4
QXBRNHhBTUNBQWdNQkVxQVRBTWtWQ0FLa0h3RGFGZ3U0TXdFTEZnajVSZ0VnRlFVWkNCQlFrWFVa
MlYKTWJId0ttWHJBR3ZqUDJId3FIRUNZQmhoemo4UGJRTC0td3daMVVpTEFnWUFJZ0FCQ3l3aUFR
QU9BQk1ReUFZVElBd0FOZkFXUVJFQQpBTUtxQVozOHNVSHdIa0VnUVNCQjhDTWhJQWN3SWZBbWlE
Z1NJallUQWNHWEFUa0JJZ0JCQTZJRFV4MEFqUXdTUVRVQkFRWUFOVUh3Ckl4d0FEMUliQXdITGZo
RXBNWElRRUZja0VqQmFCaUVpSVFrQUFMb1RBUWtBOEFNeDhCOHhRRUZBTWZBZVVVQWhRRkh3SFdG
Q3dBRDAKbTBBYlFRRGg0R2hRVVJEQkVGR1U0LWdBb1NCUjhCaHg0SEh3RjRIQWdmQVd1Uk9TSVFC
QkFFRUFJUUJSRmxFVEVhZ0FBQVFBRWhITApFd1FpQUFIUUUxWlJBRUVBVWRNVEUwRXJBQUY0Q3dM
Y0V3RWlBQWpmRXlIeEF4MEFCQWdBRVJ3OERRRWtEUUI5UHlFd1FlOGVGVEJPCnVoRW9qd2NtOENr
SEFCVVFZQmNVSzdvVEFQYzZBdzRrS1NzeFNCY3BLRkVGQUNBcHdWY1hEcTFYRHo4Q2tCZUFQUUlB
aVIwQ09RSWYKZ0RjQy01UlEteXdCOERSOEFCQXlqd0JDTFRGQU1UdU1BbWs3QXNNSkFHUUZJLUF1
dWpzakFRQUNBUElBOEN3aEFDRUFJZkF2SWZBeQpRZkF3dVBJUWdlRW1RQ3loOENwcVBCSXBlRUFV
S0hFQk1DSHdKMEVRTUNId0prcWNFeVhtR2hJb01RQVFVYWdQTWxFZ1Vjd1RCUFNNCkFDRUFFQ0py
aXdHTnVTQWZvZXg1UlBFSjhCenZGd0M4eFlBWTBTRFI4QmJ4QUpNZUZCMDBBQVB1RkFCN0ZOVWVN
VUJoUURId0hFRXcKZ1RCQkpoZ1JHQ0lZRVE4dUF2RUdGUEVUOEJMeEZmQVE4UmZ3RC1FWDhBN3hH
ZkFaUndZQTMzNEZDUUFBUzQwUUpDd0RFREZYTXc2NApIZzl3QVc4UmdHNEJFV0ZxQVJfQWFBSHFF
TnlfN2hFaVZ5b0RlUTBDaWdRU0lQX3RBUTBBQUpNaEVSNG1maEZBSjBBQURoTVFNZEVJCkVnRE9E
aEV3dHdJUklBWUFBaVJhRVFFM0JCRkJSd1FpQVNBVEFDRVFBU2NGQWx3QUVSdXhDQUNPT1FCM0lT
RVJJUGNFRUNEbkNRSi0KQUFBVENnWlVCeU1BQVJvREJBOEFEMjRIQmhBdzVrUWhLaEZNQUdFcEVS
QWhBQ0U3QlJEZ053VVE0RE1GRU9BdkJmQU40REh3SGtGUQpJVkJCOEIxQlFFRkFRZkFjVVVCQlFG
SHdHMUV3WVJMekltRXd6QUJBWWZBWllSME9jaEFSSUdId0dIRWdEMmdBRVNCeDhCY05BQ0FXCmdZ
RWJzQUFSSUlId0ZZRXdZVENCVVFVeEVVQkJ2NVFBQ3dBaTRCRk5Hd0FKQURWaDhCTUpBQ01CTUdX
UEFEVUZFVkVMQUJkUkNRQUoKSHdBRFp4c0NEQUFBRmdvRFB3VmhFMEV3QVlBUlFRVUEyTWdCSVFJ
RkJ3QUdBaDhIMW5BUEJ3QUpFVUNrS0M4QlVBY0FFdy1JY0FJUApnZ0s1SDRBNkpRRVBlZ0wtLXp3
MURSSEFmQUlpd0JHMU9nWEJPaURnRVVZQ0ZhRHhCQkNnV0FJQ0Jwa0JXRVFCQ0FJREdBVUE3RVVB
CjlRMFE4S3NDQUIyTUJEVUFFRkN5RGlCaDhCdEFBTFU1QWwwQUFNVTVRREJ4OEFRMUh4TUJnQUFB
WWc4d0VmQUxsVG9CemdJQm1UcEEKRFFFUU1aSndBS0FBUVRBQklERlhXZ0QxQUJNZzVBSVNJUGtB
Z1ExUlFCSGdFVUJSSGdBQTdRSVNJQllBTUFCUjRFb0hvQTNCNE1IdwpEY0ZRSVZBSEFEZEFRVUFI
QURFd1lUQUhBQUpFQVdQQjhBNXhFQkg4QW9VUkVISHdFRUV3RWZNQ0VCRXlCd2NQQUFBTnN3SUNB
d0FMCkFEQXdZVEFIQUNGQVFhbjBIX0FGQUE0QVhCMENpQkFBeUFJdjhDWEdBdjlPSDRERUFnTWZZ
Y0FDQkJfQXZnTC0wVkQtS2tId0w5M1cKRUNxSkN3SXdCd2V1VHlBZUFadFdBcVkwQW9nME1CZ0Jv
TVU1QU56ckFhNmlNUllCa09rRUVKQzdEekdRQVFDSUFSQUFEd0FBalU0QQpHZ0FTb0pCT0FRS01V
UklCMEdIUWZFUVJFMFFUQ2dnUUFPTVNGeGR5VnhFWDVSSVNHZWcwQWFscE1Ca1I4TzQwQVU0MVFC
c1I4QWFfClNnRDVFaWtkRVFZQUlBUWhWcmtlQXdZQUFIV0xDd0lBUVFBeDhBTXRFQThFQUFvZlFU
d0FCWElFTWZBWk1mQUZqaWtCWTg4QlRDbFEKSUFId0JqRlNpUmNMM3dBQjdtUWg4QklBQVJFVWdt
b1JGOVlBSUJvaHZtbEJHd0VRSVZxTkVCc2JHUkVoR1I4eWNLRndXVXNoZ0FFSgpBQUJLU3hKZzZo
a0E5QzBtOEJjSkFBU0hIeEJCVmhvaUlFRmtFRkFYVVFBUndJUUlBbklRRVdFT0FJOWg4QldCNElI
d2ppd0NZaENBCkNRQUJLZ0lWWVNZQ0FkOHVEeVFDLTdCZkVCQUU4UEF4QUFzZk9ERUEtLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tdVVHMDkKT0gxOQo6OiBtYXAvLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyNC0wMy0wNiAxNDoyNDowOSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6
NDc6MzgiLHN0b3JlZD0iMjAyNC0wMy0wNiAxNDoyNDowOSJdXQo6OiBtYXAvbWFwMC5tYXAKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERTBPakkwT2pFd0lpeHRiMlJw
Wm1sbFpEMGlNakF5TkMwdwpNeTB4TWlBeE56b3lOVG8wTkNJc2NtVjJhWE5wYjI0OU16QXdYVjFz
ZWpRQVZBQUFBRVFRQUFEd0NIdDdZbTF3UFhWelpYSmtZWFJoCktDSnBNVFlpTERNeUF3QXZJakFC
QVAtLS0tLS0tLS0tLS0tLS0tLS0tLXVoSWlrc2NHRnVYM2c5TUFnQTBuazlNQ3gwYVd4bFgyZzkK
TVRZS0FHQjNQVEUyZlgwPQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0w
My0wNiAxNDoyNDowOSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAy
NC0wMy0wNiAxNDoyNDowOSJdXQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhk
R1ZrUFNJeU1ESTBMVEF6TFRBMklERTBPakkwT2pFd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpN
eTB4TWlBeE56b3lOVG8wTkNJc2NtVjJhWE5wYjI0OU1qazNYVjFzZWpRQUVBRUFBRkVIQUFEd0oz
QjRkUUFES0FBQUF3QUVEMEFRCkFnNEFBYUFCSUFLZ0RnQVBFQUFOOE1vQkFnTUVCUVlIQVEtLWtB
Z0pDZ3NQREE4TkR3NFBEeEFBOEFBTkR4RVBFZzhURHhRUEZROFcKRHhjVEFQRUJEeGdQR1E4YUR4
c1BIQThkRHg0UEh4UUE4UUFnRHlFUElnOGpEeVFQSlE4bUR5Y1VBUEVBS0E4cER5b1BLdzhzRHkw
UApMZzh2RkFEeEFEQVBNUTh5RHpNUE5BODFEellQTnhRQS13VTREemtQT2c4N0R6d1BQUThfRHo4
QkQtLXctd0VBNi04bldnRVFCZzhnCkVBRWdBU0FCOEFBQ0VBSU1FQUVnRHlFZ0FUQVBRUERERHln
UC0tREdELWdLRC04UGdBLTNEdzBCOEFrQkVBWU1NQUQtT1ItLUFRRGMKdi1nUFFBQU5RUC0tc1BC
d0NnRC0tMlFmLXdFQWwxRC0tLS0tSHc9PQo6OiBbZW9jXQo=
:: bios/wallpapers/patchwork.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTE2LTA2IDAxOjE2OjIwIixtb2RpZmllZD0iMjAyMy0zNC0wNiAyMjozNDo1MCIs
cmV2aXNpb249MjM1XV0KCnAgPSB7CjIzMTMwLDIwNzY3LDMyMTI1LC0xODQwMywtMTYzMywyMDky
NywtMTkwMDksLTIwMTkzLC0yNDM1MiwKMjU3OTMsMSwtMjAwMzMsMjU2MSwtMjAxMjksNjk0Mywt
MjYyNSwzMTQ1NSwzODU1LDIxODQ1Cn0KCmZ1bmN0aW9uIGRyYXdfYmFjaygpCgliYWNrID0gdXNl
cmRhdGEoInU4IiwgNDgwLCAyNzApCglzZXRfZHJhd190YXJnZXQoYmFjaykKCWNscyh0aGVtZSJk
ZXNrdG9wMCIpCglmb3IgaT0wLCAxMiBkbwoJCWxvY2FsIHggPSAtMjQwICsgaSAqIDgwICsgcm5k
KDUwKQoJCWxvY2FsIGR4ID0gMStybmQoMS41KQoJCQoJCWNvbG9yKHRoZW1lImRlc2t0b3AwIiAr
IHRoZW1lImRlc2t0b3AxIioyNTYpCgkJCgkJZmlsbHAocm5kKHApKQoJCWZvciB5PTAsMjY5IGRv
CgkJCWxpbmUoeCx5LDQ4MCx5KQoJCQl4ICs9IGR4CgkJZW5kCgkJCgkJbG9jYWwgeCA9IC0yNDAg
KyBpICogODAgKyBybmQoNTApCgkJbG9jYWwgZHggPSAxK3JuZCgxLjUpCgkJCgkJZmlsbHAocm5k
KHApKQoJCWZvciB5PTI2OSwwLC0xIGRvCgkJCWxpbmUoeCx5LDQ4MCx5KQoJCQl4ICs9IGR4CgkJ
ZW5kCgkJCgllbmQKCQplbmQKZnVuY3Rpb24gX2luaXQoKQoJZHJhd19iYWNrKCkKCmVuZAoKZnVu
Y3Rpb24gX2RyYXcoKQoKCWhhc2hfcG9kID0gcG9kewoJCXRoZW1lImRlc2t0b3AwIiwKCQl0aGVt
ZSJkZXNrdG9wMSIsCgkJdGhlbWUiZGVza3RvcF9wYXR0ZXJuIiwJCQoJCXRoZW1lImRlc2t0b3Bf
cGF0dGVybl9zcGFjaW5nIgoJfQoJCgktLSByZWdlbmVyYXRlIHdoZW4gc2V0dGluZ3MgY2hhbmdl
CglpZiAoaGFzaF9wb2Qgfj0gbGFzdF9oYXNoX3BvZCkgdGhlbgoJCWRyYXdfYmFjaygpCgllbmQK
CQoJbGFzdF9oYXNoX3BvZCA9IGhhc2hfcG9kCgkKCglibGl0KGJhY2spCmVuZAoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0x
MyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyMy0z
NC0wNiAyMjozNDo1MCIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIs
d29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDIzLTEyLTA2IDAxOjEyOjM2Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVk
PSIyMDIzLTEyLTA2IDAxOjEyOjM2Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxURTJMVEEySURBeE9qRTJPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlNeTB6
Ck5DMHdOaUF5TWpvek5EbzFNQ0lzY21WMmFYTnBiMjQ5TVRneFhWMXNlalFBY1FBQUFBVXpBQUR6
Rkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NENBRHZlVDB3
TEhOallXeGxQVEV5ZlN3ekFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTUxQTlNVEo5ZlE9PQo6OiBtYXAvLmluZm8ucG9k
Ci0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMi0wNiAwMToxMjozNiIsbW9kaWZpZWQ9IjIwMjUtMTIt
MTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyMy0xMi0wNiAwMToxMjozNiJdXQo6OiBtYXAvMC5tYXAK
YjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEUyTFRBMklEQXhPakUyT2pJd0lpeHRi
MlJwWm1sbFpEMGlNakF5TXkwegpOQzB3TmlBeU1qb3pORG8xTUNJc2NtVjJhWE5wYjI0OU1UZ3hY
VjFzZWpRQVhRQUFBRmdFQUFEd0UzdHNZWGxsY2oxN1d6QmRQWHRpCmJYQTlkWE5sY21SaGRHRW9J
bWt4TmlJc01UWURBQzhpTUFFQS0tLS03NkVpS1N4d1lXNWZlRDB3Q0FEeUJuazlNQ3h6WTJGc1pU
MHgKTEhScGJHVmZhRDB4TmdvQWNIYzlNVFo5ZlgwPQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2Qs
Y3JlYXRlZD0iMjAyMy0xMi0wNiAwMToxMjozNiIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6
MzgiLHN0b3JlZD0iMjAyMy0xMi0wNiAwMToxMjozNiJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJX
M0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEUyTFRBMklEQXhPakUyT2pJd0lpeHRiMlJwWm1sbFpE
MGlNakF5TXkwegpOQzB3TmlBeU1qb3pORG8wT1NJc2NtVjJhWE5wYjI0OU1UY3pYVjFzZWpRQWJ3
QUFBTzBHQUFEZmNIaDFBQU1vQUFBREFBVHctd0VBCjdQOG44UUVRQmc4Z0VBRWdBU0FCOEFBQ0VB
SU9FQUVnRHlFZ0FUQVBRUERERHlnUC0tREdELWdLRC04UGdBLTNEdzBCOEFrQkVBWU8KTUFELU9S
LS1BUURjei1nUFFBQVBFRUQtLTdEd2NBc0EtLV9qSC04QkFKZFEtLS0tLXg4PQo6OiBbZW9jXQo=
:: bios/wallpapers/pattern.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
My0yMy0xOSAxNjoyMzowNCIsbW9kaWZpZWQ9IjIwMjMtNDMtMDMgMjI6NDM6MDAiLHJldmlzaW9u
PTM2OSxzdG9yZWQ9IjIwMjMtMDMtMjggMDA6MDM6MjQiXV0KLS1bWwoJZGVza3RvcC5wNjQKCQoJ
ZGVmYXVsdCBkZXNrdG9wOiBkaXNwbGF5IHBhdHRlcm4KCShqdXN0IHVzZSB0aGVtZSBkYXRhIC0t
IG5vIHNldHRpbmdzIG9mIG93bikKCQpdXQoKCmZ1bmN0aW9uIF9pbml0KCkKCQoJYmFjayA9IHVz
ZXJkYXRhKCJ1OCIsNDgwLDI3MCkKCQoJZHJhd19iYWNrKCkKCQplbmQKZnVuY3Rpb24gZHJhd19i
YWNrKCkKCWxvY2FsIGJtcCA9IHRoZW1lImRlc2t0b3BfcGF0dGVybiIKCQoJaWYgKHR5cGUoYm1w
KSAhPSAidXNlcmRhdGEiKSBibXAgPSB1c2VyZGF0YSJbZ2Z4XTAyMDI3Nzc3Wy9nZnhdIgoJCglz
ZXRfZHJhd190YXJnZXQoYmFjaykKCS0tbG9jYWwgY2MgPSBzZXR0aW5ncy5jaGVja2VyIGFuZCAw
eDEgb3IgMHgxMDAwMAoJCglsb2NhbCBjYyA9IHRoZW1lImRlc2t0b3BfcGF0dGVybl9jaGVja2Vy
IiBhbmQgMHgxIG9yIDB4MTAwMDAKCQoJaWYgKGVudigpLndpbmRvd19hdHRyaWJzLndvcmtzcGFj
ZSA9PSAidG9vbHRyYXkiKSB0aGVuCgkJLS0gdG8gZG86IHNlcGFyYXRlIHNldHRpbmdzIGZvciB0
b29sdHJheT8KCQlyZWN0ZmlsbCgwLDAsNDc5LDI2OSwxKQoJCXBhbCg3LDIpCgllbHNlCgkJcmVj
dGZpbGwoMCwwLDQ3OSwyNjksdGhlbWUiZGVza3RvcDAiKQoJCXBhbCg3LHRoZW1lImRlc2t0b3Ax
IikKCWVuZAoJCglsb2NhbCB3dyA9IHRoZW1lImRlc2t0b3BfcGF0dGVybl9zcGFjaW5nIiBvciAw
Cglsb2NhbCBoaCA9IHRoZW1lImRlc2t0b3BfcGF0dGVybl9zcGFjaW5nIiBvciAwCgkKCXd3ICs9
IGJtcDp3aWR0aCgpCgloaCArPSBibXA6aGVpZ2h0KCkKCQoJd3cgPSBtYXgoOCwgd3cpCgloaCA9
IG1heCg4LCBoaCkKCQoJCglmb3IgeT0tMSwyNzAvaGggZG8KCQlmb3IgeD0tMSw0ODAvd3cgZG8K
CQkJaWYgKCgweDEwMDAwK3greSkmY2MgPiAwKSB0aGVuCgkJCQlzcHIoYm1wLCB4Knd3LCB5Kmho
KQoJCQllbmQKCQllbmQKCWVuZAkKCQoJY2FtZXJhKCkKZW5kCgpmdW5jdGlvbiBfZHJhdygpCgkK
CWhhc2hfcG9kID0gcG9kewoJCXRoZW1lImRlc2t0b3AwIiwKCQl0aGVtZSJkZXNrdG9wMSIsCgkJ
dGhlbWUiZGVza3RvcF9wYXR0ZXJuIiwJCQoJCXRoZW1lImRlc2t0b3BfcGF0dGVybl9zcGFjaW5n
IgoJfQoJCgktLSByZWdlbmVyYXRlIHdoZW4gc2V0dGluZ3MgY2hhbmdlCglpZiAoaGFzaF9wb2Qg
fj0gbGFzdF9oYXNoX3BvZCkgdGhlbgoJCWRyYXdfYmFjaygpCgllbmQKCQoJbGFzdF9oYXNoX3Bv
ZCA9IGhhc2hfcG9kCgkKCS0tIG1vc3Qgb2YgdGhlIHRpbWUgb25seSBuZWVkIHRvIGJsaXQKCS0t
IGxhdGVyOiBjb3VsZCBpbXBsZW1lbnQgOHg4IGZpbGwgcGF0dGVybiB3aXRoIGZpbGxwIChmYXN0
ZXIpCgkKCWJsaXQoYmFjaykKCQplbmQKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKOjogLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0xNyAwNjoyMDowMCIsbW9kaWZpZWQ9IjIw
MjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyMy00My0wMyAyMjo0MzowMCIsd29ya3NwYWNl
cz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNlX2luZGV4PTF9fV1dCjo6IGdmeC8uaW5m
by5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTE3IDA2OjIwOjAwIixtb2RpZmllZD0iMjAy
NS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTIwLTE3IDA2OjIwOjAwIl1dCjo6IGdmeC8w
LmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTNMVEF6SURJek9qVTNPak16
SWl4dGIyUnBabWxsWkQwaU1qQXlNeTAxCk55MHdNeUF5TXpvMU56b3pNeUlzY21WMmFYTnBiMjQ5
TUYxZGJIbzBBSEVBQUFBRk13QUE4eFI3V3pCZFBYdGliWEE5Y0hoMUFFTWcKRUJBRThQQXNabXho
WjNNOU1DeHdZVzVmZUFnQTczazlNQ3h6WTJGc1pUMHhNbjBzTXdELS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUVBURXlm
WDA9Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTE3IDA2OjIwOjAw
Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDIzLTIwLTE3IDA2OjIw
OjAwIl1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUSXpM
VEU1SURFMk9qSXpPakEwSWl4dGIyUnBabWxsWkQwaU1qQXlNeTAxCk5TMHpNQ0F3TkRvMU5Ub3hP
Q0lzY21WMmFYTnBiMjQ5TVRFeExITjBiM0psWkQwaU1qQXlNeTAwT0MweU55QXlNem8wT0Rvek55
SmQKWFh0c1lYbGxjajE3V3pCZFBYdGliWEE5ZFhObGNtUmhkR0VvSW1reE5pSXNNVFlzTVRZc0lq
QXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBaUtTeHdZVzVmZUQwd0xIQmhibDk1UFRBcwpjMk5oYkdVOU1TeDBhV3hs
WDJnOU1UWXNkR2xzWlY5M1BURTJmWDE5Cjo6IFtlb2NdCg==
:: bios/wallpapers/robot.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTA2IDEwOjM5OjI5Iixtb2RpZmllZD0iMjAyNC0wMy0wNiAxMDo1MzoxMCIs
cmV2aXNpb249MjJdXQpmdW5jdGlvbiBfZHJhdygpCglwYWwoKQoJY2xzKHRoZW1lImRlc2t0b3Aw
IikKCXBhbCgwLHRoZW1lImRlc2t0b3AwIikKCXBhbCg3LHRoZW1lImRlc2t0b3AxIikKCXNwcigy
KQplbmQKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIs
bW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHN0b3JlZD0iMjAyNC0wMy0wNiAxMDo1Mzox
MCIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNlX2luZGV4PTF9LHts
b2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvbWFw
MC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC9zZngwLnNmeCIsd29ya3Nw
YWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAz
LTA2IDEwOjM5OjI5Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0
LTAzLTA2IDEwOjM5OjI5Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQ
U0l5TURJMExUQXpMVEEySURFd09qTTVPakk1SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHdO
aUF4TURvMU16b3hNQ0lzY21WMmFYTnBiMjQ5TVRsZFhXeDZOQUJFRmdBQVkwNEFBUE1VZTFzd1hU
MTdZbTF3UFhCNGRRQkQKSUJBUUJQRHdMR1pzWVdkelBUQXNjR0Z1WDNnSUFPWjVQVEFzYzJOaGJH
VTlNVEo5TERNQXp5amdBUUFBRGdFQUFBVHctd0VBSFBNZwoxWWZ3LThZbllDZnctOEluOFAtSlYt
RC15RGZ3LTh3WDhQLU9GLUQteUhmdy04Y244UC1ORi1ELXp3ZnctODhZQUFRTUFBQUlBQlBRCkJB
QVR6aWdBQUNBQUY4ME1BQWdrQUFFRUFCWVhCQUFqendjTUFQRVJOLUQtelFmdy03MW5vQmZ3LTdz
blFCZVFCLUQtdWlkd0I1QVgKOFBfNEY1QVFBRUczRjdBSENBREJCN0FYZ0Jmdy03WVh3Q2RnRUFB
dzhBQUhDUUR3R0xZbjRCZEFGLUQtdFJmd0FnZEFCLUQtZTJjUQpOLUFlQi1BREZ5QVg4UDk1SnlB
SEFEY1FCeElBOENrRVItRC1lUmRBQnhBSE1BZndIaGZ3LTVFSHdDZndIaWZ3LTQ0WHdBY0FCLUFm
CkItRC1qU2Z3QUJmd0hSZnctNHdYQUFmd0FRZndIUllBTWdmd0JBb0FrSXdYOEFRWE1FZndFd3dB
OEJBSDhBWUhFQ2NnRi1BUU4tRC0KaXdmd0JqZFFGLUFJTnhBWDhQX09CLUFGd2dBZ0J4Y2NBRUNQ
Ri1BRTJBQ3lCd2Z3LTNkbjhBa0g4QThOQUVCeVZ5QkhDUUFRRUNvQQo4Qjd3LTIxSGdFZUFSMkFY
OEJBWDhBVVg4UDlwVjhCWGNBY2dSeUFIOEJJSDhBVUg4UDlsVjZEWFlDZEFKd0FTQUNEZ0oyc0E4
Q1JoClI2RDNCR0FIY0Nmd0VnZlFGd0EzOFA5ZFY1RDNDZ0FYRUJkZ0YtQVVCOUFISUFmdy0xcFhr
UGNQRURkd0ItQVZKN0FRQUtCSG9QY1UKOEFjbjhBc25ZUUh3Q1ZWWGtQY1o4QWNIQUJmd0RFZFFC
LUQtVUZlUTl4N3dCTTBBSUE4SEVRQ0FURWVBOXlUZ1Z3QV9BUkVPZEFHQQpSMWR3OXluUUZ5QU5B
QkVPNkFDaVExZHc5eTdRQjBBSE1CUUI4VUl5Ql9CSGNKY2c5eVd3TjZBSEVDZnctMUFuZ0ZkZzF6
RDNJZkFECkY1QTNBQWZ3LTA4WEFBY3dWMkQzQkJEM0hmQVpKLUQtVEJjUVYyRDNDUkQzR1BBZ0ot
RC1TUmN3QjBEM0R4RDNFM0FIOEJ3cUFmQVgKLXlnblFBY0E5eE1ROXczUUItQW1oMUNIOFA4alox
QkhFUGNPRVBjSThBTVg4Q0JYVUllaUFFSWZWekFYR0FBaHB3QjNBZkFjSFRmdwpDQmZ3LXh0WFlD
ZFFSeUQzRHdDbkFCZndDVmZ3R3lmd0NoZncteGRYWUdkZ1J4RDNFQUNIQUJJQzhBTUtCLUFmRi1B
Sk4tRC1FMWRnClp5QVhVRmNjQUNBM1VCd0E4QXNKRi1BZlotQUJOLUQtRVZkZ2x6QVhZQWNBSnhE
M0VRQUhnQjRBb0FnWDhDUVhjS2Z3LXctd0FMUVgKWUJjZ0J4REhBTmN3QnlBQU1RZndJNFFEOXdF
VVYxRDNBMEFIY0FjZ0Z4REhBSGVRSVFBUklTRUFZeEZYVVBjSFFFSUFOQkFuNENFQQo0UWNYOEI4
blVEZnctdzVYVUxjUVpBQkJNQWNRQjlJQUZBRWxBUEFLQWxmd0hpZEFOLUQtREZkUTl3RVExeUFY
WUhjQUZ5QTNJTjBDCkZBSW1BS0FCRi1BZlJ5Qkg4UDhLYkFEb0FQY0FBQWRnTnlBSEVCZVFCeEFu
QUFCQUFRQW5BUEFDRFJkUXB4RG5FTWNRRjFBWFFCY0EKSjVBM0FnZ25BUEFGR2pjUVItRC1FQmNR
MXpEM0FBQ0hRQmRRRjFDY0FDQUhnSGdBOEJRREJ3QVhjQWNBQjhCSDhCcG44UDhURnhEMwpBQkQz
QVJBM2NCZGdCeEEzQUFjQUZ5RUFFQkFxQUNFUUJ5b0FRQWZ3LTBnakFuQUNBQmVBRjJBWEFBTVFJ
Qm9BVlJmd0F4Y0FJd0N3ClN2Y0NFUGNFa0FkZ0Z4QXVBVUFISUFkZ2NBQW1CUWNqQVBvR1RlY1F0
d0JYa0JkUUZ6QVhFQWNBRnlBSFlBY1FJd0RRVUxjUXR3QUgKRUJkQVoxQVhVRWdBSUNkZ2FRQUZJ
d0NRSi1ELVVvY0FkeUFIcVFDUU1IZFFGM0FYWUNjd2FRQVNCaU1Bb0JmUUotRC1VMWNBTjJBagpB
QkFISXdCVWtCZGdaeEFoQUtBUUItQUFKLUQtVkNjUU1RRndKeUIzVUJld0Y3UUFJZ0FYSWdBQVRB
QVFBaUlBRVFjaUFJRVhJSWRBCkY5QUhjTEVBSlBBR2FBSHlDQVFIOFA5VUZ3QUhnRGNnZDBBM3dC
ZHdCMEFuOEFFM1hBRkFzRGN3RjBFQWdBQUhrQ2NRZHpCWFB3QXcKVUNmUVF3QUF6d0JCQjZBWEVD
OEZBU0lBd0JjZ1p6QjN3QWVBRjJBbm9JY0FFQWRjQlFDWEF6RUFCeUJqQkFNbUFOUjNFSWZBRjRB
SApnQ2R3RnhBbkpnQXhJQmN3WWdJZ1ZRZWNBY0VRSjBDMzBBZUFCNkFuVUFjaUFRUW1BRUFIOFA5
bXp3QUIyd0dvSUdmUUI0QVhzQ2NnCkZ5UUFBR29BUURWSDhCelVBQUVyQUlBZ1Y5QUhrQWZRSjNR
RUFTY0FFQmQ2QXdBQ0JCQTEzZ1VrSEFjcEFBRE1BUUFyQUZEd0FDY3cKSnlJQUFhSURXUDgySjBB
SEpnQWlCeUFtQUNBQ04yd0J0UUFISURjQVotRC1MaWRnSmdBbUYzQW1BQkFFblFBUWQ3WUNBRXNF
TkNzbgpnQ1lBRUNEM0FoRkhKQUFnQVJkd0FMR0FCd0NIOEhVbjhLQVhrSllBQU9JQVVpY2dKMEJY
bEFBUk4xTUJVS2NBaC1CMDR3RmhuU2VRCkYtQWQyZ0x3QUJBWEFFZEFkOUFIY0RmZ0J4QVhNQ1VB
OGdCMzhITW5JQmNRSi1DWEI4QTM4QnJlQW5BWEVQY0JZQmRRTWdBd0o4QUgKa3dMd0J3Q25BQWZ3
RUpmd1RFY0FCekEzOEJ3WDhHSjNBQWU4QmhBYVFnTEJKeENuRUVmZ0IyQVhNQ2VnT3dFUk1JUUJF
RUFYQWZFQQpDWGR3Si1CRVotQXBGLUJpRjFBbnNBTUJkZ0sxRUxjZ05fQUhZQWRnRjVBMEFDRVFG
elFBSUFKM0pRVFFQMGZ3TFNmd1lTZndDaWZ3CkdiVUJvQmNRWnhCSEVDZFFGM0EzQUVBbmdBY2dO
UUFCSUFYUWtJZkFseEFIOEQwbllFZndKR29Bc1BBTUJ3QW44QmNIQUFkUVpBSmgKUnhCSElCZWdw
QVlnRUdjV0FpRXdCMGtCOEFJSEFKZkE5d2J3RVRmd0UwZHdGLUFvQnpzQVFCRVg4Qlp0QXdEWUE1
RW5FSmZ3QUFlQQpsNUIwQS1BTU1KZkE5eER3RGljUUY4QkhzRWVRSi1Bb0YtQmhGLUFUSi1BVUFR
U1FGeEFuSUNjUWgtQUJpUUh4QXdlbndQY1o4QTBYClFBZUFSeURYb0Rmd0tTd0FVQllIOEJRWDZn
QUFwd0dRTUJjQWg4QVhFRWNBWVFMeENnR25vUGNoOEF3WFVBZGdKLUJOQi1CaUItQVgKQi1BVkJ3
QTVCRUFRRnpDWGpRVDJCUkNIZ0lldzl5bndEUWRnRnlBMzhBOEg4QzRYS3dBQjVBTHhDbUJIOEFO
M0VDY1FoN0QzTVBBTgpGM0JIOEExWDhDMFg4R05fQURBQmQ3QlJBTUVYTUJmd0J4Y3dSeENYb1Bk
SEFQRUZGUWNBUi1BeUItQmxCLUFNSjFBWDhBSDNBaEJ4CkE2QlFCeUFYOEFlbmdQYzRaUUJ3RXlm
d054ZndZNVlCZ0FCMzhBSDNDQ0FuY1FXUThBS1hNUGN6OENNWHJBZ0NJUUR3SHd3SDhBdjMKQnlD
MzhBajNOdkFsSjJBWDhCRW44RGNIOEdRSDhBNEg4QlBYTU1jZ0YtQUFKMUFuVVBjYThDOWtCV0ZI
OEE1SDhEaXBBUEFFRGlmdwpIUmNnOXdDQUYxQjNJRGNnOXhEd095QUFnQkVYOEJ1MzhBUVhSUUFR
RVNRSjhBWWdGMkNYc0Vjd2x4QUhJUGNBOEVjWDhCVTM4QnJ6CkFsQUNGLUJrRnlRQU1Cd1hFTTBB
a0FNd2x3QkhBQWZ3VmUwRU1BQW5nTVlDVU1BbjhBQUhKd0FRRW0wREVTREhDVEgzQ1FBV0JsRHcK
VkJmd0NQb0FvQ0luOEFCWGdDZndIRmNlQVVBU0YtQWJVUUR3Q1FNWGNQY0RFQmNBSnhBSDhGSW44
QWxIOENFbjhBZFhJTTRKVWpBWAo4QzhuVkFDd0VCZndCQ2ZRRndCWEVFY0ZCRkh3VVJmd0FBd0RR
QTVIOEI3cENDRXVGMXdKSVBBYkhnQlJCaGZBRjlBc0JERHdVZ2VwCkNaRW9GLUJDQjBCbjhDbWZB
VUYzOEJJSHV3a3dzQmZ3ZHdUd0JBQUg4RXhuOEFRMzhDQ0g4RFJuQUVjQUYwQm1CUUF0QUJBbmtR
WWcKOEJMQ0JSQUhEZ0VSQVdjRllQQkdaLUFFWjZvQW9UazNRQ2NnSjZBbjhDaXRDbEFSTl9CWE1Q
TUtJUU1IS0FDZ1FrZkExLUFsSi1BNApONGtCOEFFbUItQWRGMEFuOEFrbjBDZUFGM0FYUkFEd0FE
MDN3RWZ3TVJmd09SZndFeGZ3SllzQklVQVhxQWp4QWRBWG9FY3dGLUFFCmgtQTVON0JIOERRa0FC
QVZvUWdoOEJzN0JWRHdHUWVnRjY0QWdQQUVsLUExUjRCbk1BSVJPc0lDWUNVSDhCb1hRSW9COEFV
WUY1QW4KQUdmd0JLZndNamNRdC1BOEYtQTZKNzRDRUNWekJDQWdKeUlBUUFlZ0p4Qi1BZkFJQTFj
UU4tQXZsLUJHRi1BMkp3QVg4QmdIOENZbgo4QmhOQkhFWDhCY0hrRWNBc1FHd1J6QW44SThIOERr
bjhCVzNDcEVtTi1BVk4yQW44QlVoQU1BQU4tQUJSMEFuOEk0WDhHS0VCcU1uCkItQW9KLUFNSjVE
SEdBQkFCLUJwQnhZQThRTW1Kd0FYd0VkZ0o3QlhRQWZ3QVVjUUZ4QWRBQkZvSmdFUkpBNEdJTEFY
andWZzBGY0EKOXdzQVRBRHdBSThYOEdsSDhDSUg4Q0luVUFld0JfVUg4QXp3QUVjQTl3VUFSd0Fu
QUNmd2tBZndiU2Z3SUFmd0lDZHdGNkJGQ0ZBWAo4QURINExjQUFSMEFJRzhYTEF6QUh4ZWdKMkFu
Y0Nmd0FyZmd5d0JCa0Jmd2NGa01neDRYMERjd0ItQVBGd0J3Qi1CeEYtQVpSeG9BCk1RSVhJTFlG
TVFCWEVEQUFFSEpYQVFDSkFCQUUyQUlBcUFUQWgtQ1JCLUJ6Qi1BWEYtQWotZ0lBU1FzUVozOEZR
WklIOEhNdUJDSWcKVl9vTUlCTTMwZ3hRbEFmd2RBY1hBREFiVnpCVkFrUVFKLURVRXdCMEdoZndE
VGZ3MWc4QVJCYzM4UGdNQUZNVkotRDZGd3dBb1JNbgo4UHNYOERrSDhDc1BBR0VLTnlBbjhQd2tB
aEVxSndKa0NSY1FSLUQ5RVFBUkZ2b0tVdjhHQi1BNk1nQVFGMWdMSWY4R0lBQWdLd2N4CkFDRUtC
eUFBb2pnbjhDd0g4QkkzOEFzUUFDQTNGeGtGSUExSGJBVHdBZjhGRi1BdE4wQVg4REFIOEF3WDhB
MDJBbEQtQkJmd0owRUMKQVB3QklERVhOd0FRRGdJRlVmOERCLUFoRWdKUVFDZndOUWNZQU5FTUot
RC1DUWZ3SHljZ0otQkNLZ0JSREFmdy13dF9BVk5LSjNBMwowQkVBRUJjWkJ4Qk5WZ3FRRjhBSDhB
c1g4UDhNQkFSZzhFOFhRQmNnWHdZZ0NoZk9DZ0FxQVdCUUIwQUhjSmRMQUNELUR4RUhJUEJSCmZB
QVhIUThBQUpFQlVQOFBGLUFaTFFBQVdBVUJHZ0JpRi1CT0YtQWtKd0FSR1EwQUV5VU5BQkFISndB
aEpCYzBBR0FXSi1CUEYtQTgKQ3lBUlotd05FRkc5QVBBSjhQOGJKLUFOQi1CUlotQVZWd0FYOFA4
Y0ItQUxKLUJRMmdNUUVWRURJZjhnN2dBZ1d4Y3pBQ0gtRXBzTwpVQXNIOEZ3SEhnYVMteElYQURj
QXgtQU1JUUJBQi1ELUVUa0FVQmdYOEZzSF9BRmctdzRuOENBWDZnRVJOR1FCVWY4UUYtQWh3QUVS
Ck5rWUFNUDhSQnhBQUlCY0hBZ1lFRUFBQXhRTU5FQUFoTmhjN0FSUVFFQUJGTXpmd0RDQUFZQW1I
SURmd01nRU9VZkRnVi1BWlpBQWgKQnhjekFfRTJCLUFLUi1EZ0Z6QVhJR2Z3RGtBQlFBUTNnQ2RR
QUpBR1ItRGtCMUJIUUJjQUFRSHBBaEhBTUFCaEEwY1FCLURsa2d3UQpBZjRNSUNJSE53YUFSZ2Z3
QVNmdzQyZG1EREFYNEJjSENpSHdKQ29HRVVkdkRCRGlHZ0l5QkFmUVJBZGhKaGZRRi1CSERBa3cz
VmVBCmlBOHd3QWRBWUFNUUpSZ0NZRWdYNEFmdzNIQUNZQklYa0Rjd1I4QUVzQUFYOEVrWEFFZHdC
LURiclFSZ2dCZHdCLUFuUmcxQThFc24KSUVVUHdOa1g4QmszVUFmd0xVZndBZ29HUUhBWDhOZ1dB
aEFRY0FBUUxKUUxvUEJTTndCSDhOZ1g4QjZxQmhFdExBWVFVeElPTVFmdwoyTElHRWkzaUR5QkRC
eTBDRVM3Z0RRQU5BQkpqQ2dBZ1FoY0tBRkVHTi1ELVFDWUhFQUswRUZILVFBZndab2NBOEFQLVJS
ZndaaWZnCkYtRC1SUWZ3WndjQUJfQVVBR0luOEdZSDRDY1VBQ0VYNFBJS2NVVUg4RXlIOEFBckFJ
SkhGLUJLRjJBM3NFSUFVVWtIOEVrWG9Rb1EKQWswTmtCZndTUWZBdC1ELVctc0FjdkQtY3hmd1Nn
Y0hBQUFPQUhBSDhFZzM4UDl5bGdZQWpoRndjeWZ3T3djUXR4SUFFUURvQV9MLQpmeGN3Qi1BM0ot
RC1maWZ3T3djQUVUd1hBTkx3UFJmdy00QUg4RDRIOFBfQURnQWlmeGNPQUVJSDhEOEhEZ0FBRlFB
RkRnQlNQeGZ3Ci0zMEhBRkpfQi1CQUJ4d0FBQTRBRUJjakFCOWRGeE1ORHhZVEJROEJBSllRT1g0
VDhBaG44UC1LaC1ELXlLZnctOFVYRUFjUVItQU8KTi1ELW8xRUxFQ2N0Q2lELW9tMENZU2Z3REhm
dy03d05RQ2Z3Q3hkUUJCQ2ZJd0NTTi1BS0YwQkg4UF9lRFFDd0NSZGdSLUQtbkJjUQpGekR3RUZD
QVItRC1tLTRMTURkQU53d0lNUEQtbWlnQUVFY2ZDRUhBRjhBM2h3RWtDQmNUQUNDd0Y1d1RFSHVH
QllBSEJ5QVhNRGRRCkZ6QU9BUlVBSW5jQW5BSWdRRGVERDZHUUY5Qkg4UDk3dC1BQVBBc1FZTm9M
SVFlQUZRQnlmTGZ3QUFjd0p4TUFRbkFYMEZjVEFLRW4KSUJkQWR3QVhFQWRnRXdCQWZwZndBdTRN
QUkwSndBZGdCOUJuOFBfQVotQUROLUlTQXhNQUVGZElBZ0NfQ0dFM0lDY3dwMkJkQUJCLQozd3Fn
QXpjd0Z4Q25BQmRBTjI4UE1ZQUhjRmtRRUNkTUVEQUhRQ2NVQURHQk4wQkRFQURBQ1JHbjNRdndB
NmRRRi1ELWd3ZHdCX0NuCklJY3dCd0JuY0ZzQWdQX0VGeUJId0NkUVlnQmdGekFuSUJlUW53aXct
NFlIVUFkUVZ3QVhVRGQwQ3pTZ0Z6Q0NEekQtaHhjb0FERXcKSjFCSURnQXREVUF3RjJBMzFBOHdp
UWN3UXd5QkIwQUhZQ2N3TnpEVkRIQXdCMkIzOFBfS3ZBd0JkUThnVURkOUVCQlFHQUR3QTlmdwot
NFUzSUNjUUJ6QVhVQ2RBUjVBWE1CVUZnR2Z3LTRvSEFEY3dSQUNCWjNBWFFBZFFKNENTQURLSUZ5
QmFBR0IzUUNkUUIxQS1EWEFICjhQX0lCeUFYRmdBZ1FOZHVBU0d3RjZJQVFnY1FGMUFVQURCM1FF
Y1lFckR3LTRjM1lLZFF0NEJuTUJVTkFCb0tZUF9IQjZDWFlFNE4KRVNEQUFRSVZBTEI5WnlBSGtE
ZndBRmRnaDBJUkFVZ1JBUmtBZ1hoWFFIZFFsLUFJVlJFQS13eUFFQWNnTi1ELWRFZEVFUkZBS0FJ
aAo4QWN0Q1JFUVR3MEFuZ0lnY1NkQ0FNRFFoMkFIOEFZWFlFY2dKd0FNQmlELWNKRUZVQWNnVjBC
WENnSWc4QVZhQVFDV0V1RzM4UDlzCkJ4QjNNRGRRSnpBWGNOUUw4QU1YRUNkd0Z5QUhVQ2Z3LTJv
M01CZlFsNERuQ0hDQUZ4QTNVQmNnSkFEeEEtOXB0N0FIQURjZ0I1QW4Kd0NlUUZ3QzNNRUlXVVdo
WFFGZGdTaEtnRUJlZ04yQTNzQWNRWjlRUkFHRUVZR3NYUUJjd2h4b0FRQkFIMEljVkVTQndCNDBR
VWZELQphZ2RBOFE0Z01BZkpDbEFRRi1BU0owVVNFTkM0Q1VELWFSY3c3eElCNHc1d0VBY2dKLUFO
Ti1jVEFmNENrUEQtYUhkQU56QlhFSzBVCkVFQmJEU0VCQnhZQUFQRUJFU2ZvQURBMzhBeEVFQ0VD
UnhZQWNQY0VJQWVROXc1OEVRQ1BGU0JvWno0QUFJZ0s4QUQzQk5BSEVMZUEKQi1ELWJtY0FwekRV
Q21CUWQ5QUhBT2Z2RnZFRmNBZFFkMUFIOEFFM0VEY1FaOUFIQUNkUVoxQVhBQ1B3QkJZQVVJZXdO
NUJINVFBZwpjRGZZQmpBQVZ4Q2xEMkVYb0NmQU56QXFBREFRSjlDekFKRWdKekJIVUJlZ0JfRDRB
SEJ3RnlDWE1CZmd3UUZSb0FjQUo2Ql9DREJ5CkY2QTNCeEFBemhSeGdGY0FOMUFuRUEwR0FDZ1JB
RndBRUFrTUVTQm5VT1FHVVA5MkoyQTNhQVlSQ2hRQUFHWUxBQ3dBa0hpWDhBTUgKOEFkSGNINEVF
SGNTQUhHVkYtQUZKeUFIRVFDU3AtRC1saWZ3QWlkQUR3QUE2Z1NFLTVrSEFDZlFKMkFTQUJFWHJB
UWhKNkQyRXlFUQpCMDROc1BfWkYwQTNZQmVnQjNCSFlRTUFOQUJnZ0lld04xQ1hEQUJnbGpmQUJ4
QVhFUUlBSEFDZ0VGZnctNVlYQUJld0J4OEM4QUVBClJ6Qlg4UF9kSnhBbmdCY2dGMkFub1FMQXB6
Y2dGM0FIUUdjQUJ5Qm5MQWxRLTM2WEFIZGdEMEVBdC1BVDl3SkFmZ2NRWjU0UUlHQlgKOUJNaDhC
SjBBNUI5SnhCWEFHZGdSeURxREJBUkRnTVFaejRIQUtVS1VpQm5ZRGRBNGd3eER4Y1Fpd0VRY3dz
VE1TZEFWeGtBQUVBWApJQThIdndJQTNoVVJhWklUWTBCSGdEY2dWMElPVUF4M1VDZFE0UmNDSFFC
Uk55QlhnTWNiQUFDdkNqRlFkMkJaQXhCbEd3QVR4eGtBCnNTZndDUWNRQjBBWHNBY1F1UUV5WlFj
Z0hRQUJYeE1nOEFoUkJnR0RBQ0JRVjFNWEVHVVRCVERIZ01maEFnQWZBREFIVUFlWkF4RXcKRVFH
aFp6Y1FWekFuY0NkZ1J6Z1pFQWo0RXlFSE1JVU9BR3dBQUhNVUVPQjhBUEVGQndBM2dCZFFGNkFu
TURjZ0Z3Q0hJR2ZnQnpELQpFWkR3LTA5bkVCY0E1d0FPQThCM0lGY3c5eE9RRnhCM1VFZWdGWkVS
TUhjQWR4QjNRSWVGRmpDM2NQZTBDUEFDWnhDWEVJY3dSekQzCkFRQ0hNRGZ3RHBlWENKX2dGMEFu
ME5kdzl3REtCNWdmUEt3SURGOHdMalY5TFBjYkhnOHpBUC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1VRkE5TVRKOWZRPT0K
OjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiLG1v
ZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6Mjki
XV0KOjogbWFwL21hcDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxU
QTJJREV3T2pNNU9qSTVJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXhNRG8xTXpveE1D
SXNjbVYyYVhOcGIyNDlNVFpkWFd4Nk5BQmRBQUFBV0FRQUFQQVRlMnhoZVdWeVBYdGJNRjA5ZTJK
dApjRDExYzJWeVpHRjBZU2dpYVRFMklpd3hOZ01BTHlJd0FRRC0tLS12b1NJcExIQmhibDk0UFRB
SUFQSUdlVDB3TEhOallXeGxQVEVzCmRHbHNaVjlvUFRFMkNnQndkejB4Tm4xOWZRPT0KOjogc2Z4
Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiLG1vZGlmaWVk
PSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiXV0KOjog
c2Z4L3NmeDAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREV3
T2pNNU9qSTVJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXhNRG8xTXpveE1DSXNjbVYy
YVhOcGIyNDlNVFJkWFd4Nk5BQVFBUUFBVVFjQUFQQW5jSGgxQUFNb0FBQURBQVFQUUJBQwpEZ0FC
b0FFZ0FxQU9BQThRQUEzd3lnRUNBd1FGQmdjQkQtX1FDQWtLQ3c4TUR3MFBEZzhQRUFEd0FBMFBF
UThTRHhNUEZBOFZEeFlQCkZ4TUE4UUVQR0E4WkR4b1BHdzhjRHgwUEhnOGZGQUR4QUNBUElROGlE
eU1QSkE4bER5WVBKeFFBOFFBb0R5a1BLZzhyRHl3UExROHUKRHk4VUFQRUFNQTh4RHpJUE13ODBE
elVQTmc4M0ZBRC1CVGdQT1E4NkR6c1BQQTg5RHo0UFB3RVAtLUQtQVFEci15ZGFBUkFHRHlBUQpB
U0FCSUFId0FBSVFBZ3dRQVNBUElTQUJNQTlBOE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NR
RVFCZ3d3QVA4NUgtOEJBTnktCl9BOUFBQTFBLS1fdzhIQUtBUC0tWkItLUFRQ1hVUC0tLS04Zgo6
OiBbZW9jXQo=
:: bios/wallpapers/skellytown.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBib25lcy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3Jl
YXRlZD0iMjAyNC0zMi0wNSAwNzozMjozOCIsbW9kaWZpZWQ9IjIwMjQtMDMtMDYgMDM6NDE6MzMi
LHJldmlzaW9uPTQxN11dCi0tW1sKCgkKCl1dCgpmdW5jdGlvbiBib25lKHgseSxhKQogbG9jYWwg
bCA9NwogbG9jYWwgYj02NgogCiBhKz0xLzI4CiBhJT0xCiBsb2NhbCBxPSBmbHIoYSo0KSAtLSAw
Li4zIC0tIHdoaWNoIGdyb3VwIG9mIDcKIGxvY2FsIG9mcz17WzBdPQogIDEsNSwgNSw1LCA1LDEs
IDEsMQogfQogCiAtLWxpbmUoeCx5LHgrY29zKGEpKmwseStzaW4oYSkqbCwgMTQpCgogbG9jYWwg
aT1mbHIoKGElMC4yNSkqMjgpCiBiID0gZmxyKGEqMjgpCiB4LT1vZnNbcSoyKzBdCiB5LT1vZnNb
cSoyKzFdCgogc3ByKGIseCx5KQogCmVuZAoKCmZ1bmN0aW9uIGRyYXdfc2tlbGx5KHMpCgoJbG9j
YWwgYT1zLnBvc2UKCWxvY2FsIHN4PTAKCWxvY2FsIHN5PTAKCWxvY2FsIHgseQoJbG9jYWwgbD03
Cglsb2NhbCBsbD04IC0tIGxlZyBsZW5ndGgKCglwZGF0PXtbMF09CgkJezcsLTYsN30sCgkJey04
LC02LDd9LAoJCXszLDYsOH0sCgkJey00LDYsOH0KCX0KCgktLWNpcmNmaWxsKHMueCwgcy55LCAy
LDgpCgkKCS0tIGNhbGMgbG93ZXN0IGZvb3QKCglseCA9IDAKCWx5ID0gc3kgKyAxMCAtLSBoaXAg
Ym9uZQoJbGkgPSAwCglmb3IgaT0yLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQlsb2NhbCB4PXN4
K2RbMV0gCgkJbG9jYWwgeT1zeStkWzJdKzAgLS0gaGlwCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10g
CgkJeSs9c2luKGFbaSoyXSkqZFszXQoJCXgrPWNvcyhhW2kqMisxXSkqZFszXSAKCQl5Kz1zaW4o
YVtpKjIrMV0pKmRbM10KCgkJbHkgPSBtYXgobHkseSkKCQlpZiAoaT09MiBvciBseT09eSkgdGhl
bgoJCQlseD14CgkJCWxpPWkKCQllbmQKCWVuZAogCgktLSBhZGp1c3QKCXN5IC09IChseSAtIDIy
KQoKCglpZiAobm90IHMubGx4KSBzLmxseD0wCglpZiAocy5jaSAhPSBsaSkgdGhlbgoJCS0tIHBs
YW50IGFuY2hvciBmb290IAoJCS0tIC5jeCBtZWFucyBhbmNob3IgcmVsYXRpdmUgdG8gc3RhcnRp
bmcgcG9zaXRpb24gKG5vdCAnY2VudGVyJykKCQlzLmN4ID0gbHggKyAocy5jeCAtIHMubGx4KQoJ
CXMuY2kgPSBsaQoJZW5kCgkgCglzLmxseD1seCAtLSBsYXN0IGxvd2VzdCB4CglzeCAtPSAobHgg
LSBzLmN4KQoJc3ggKz0gcy54CglzeSArPSBzLnkKIAoKCS0tIGJvZHkKCXNwcig0MCxzeC04LCBz
eS04KQoKCS0tIGhlYWQKCXNwcihzLmhlYWQsc3gtNytzLmh4LHN5LTIxK3MuaHkpCgoJLS0gYnVu
bnkgaGVhZCAoZWFzdGVyKQoJLS1zcHIoNDMsc3gtMytzLmh4LHN5LTE0K3MuaHktOCwxLjI1LDIp
CgkKCWZvciBpPTAsMyBkbwoJCWxvY2FsIGQ9cGRhdFtpXQoJCXg9c3grZFsxXSB5PXN5K2RbMl0K
CgkJYm9uZSh4LHksYVtpKjJdLGkqMiswKQoKCQl4Kz1jb3MoYVtpKjJdKSpkWzNdIAoJCXkrPXNp
bihhW2kqMl0pKmRbM10KCgkJaWYgKGkgfj0gcy5taXNzaW5nX2JvbmUpIHRoZW4KCQkJYm9uZSh4
LHksYVtpKjIrMV0saSoyKzEpCgkJZW5kCgoJZW5kCgplbmQKCgoKCjo6IG1haW4ubHVhCi0tW1tw
b2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtMjgtMDUgMDc6Mjg6MjAiLG1vZGlmaWVkPSIy
MDI0LTAzLTA2IDAzOjQxOjMzIixyZXZpc2lvbj00ODBdXQoKaW5jbHVkZSJib25lcy5sdWEiCmlu
Y2x1ZGUicG9zZS5sdWEiCgoJCgkKZnVuY3Rpb24gX2luaXQoKQoKCXNrZWw9e30KCQoJZm9yIHk9
MCw0IGRvCglmb3IgeD0wLDUtKHklMikgZG8KCQoJbG9jYWwgcyA9IGFkZChza2VsLHsKCQljaT0t
MSxjeD0wLAoJCXg9MzYgKyB4ICogODAgKyAoeSUyKSo0MCwgCgkJeT0zNiArIHkgKiA1MCwKCQlo
eD0wLCBoeT0wLAoJCWIgPSBkZWZwb3NlKCksCgkJbmV4dF90PTAsCgkJdHA9e1swXT0wLDAsMCww
LCAwLDAsMCwwLCAwfSwKCQloZWFkID0gMzIKCX0pCgkKCWlmIChybmQoMjApPDEpIHMuaGVhZCA9
IDMzIC0tIHJhcmUgaGF0CglpZiAocm5kKDIwKTwxKSBzLmhlYWQgPSAzNiAtLSBjaGlwcGVkIHNr
dWxsCglpZiAocm5kKDEwKTwxKSBzLm1pc3NpbmdfYm9uZSA9IHJuZHswLDF9IC0tIG1pc3Npbmcg
bG93ZXIgYXJtCgkKCWlmIChybmQoMTApPDEgYW5kIGRhdGUoKTpzdWIoMSwxMCk9PSIyMDI0LTAz
LTA2Iikgcy5oZWFkID0gMzQKCQoJcy5wb3NlID0gZGVmcG9zZSgxKQoJcy50cCAgID0gbWFrZXBv
c2Uocm5kKDUpXDEpIC0tIHRhcmdldCBwb3NlCgoJZW5kIAoJZW5kCgkKZW5kCgoKZnVuY3Rpb24g
X2RyYXcoKQoJY2xzKHRoZW1lImRlc2t0b3AwIikKCQoJcGFsKDcsdGhlbWUiZGVza3RvcDEiKQoJ
Zm9yIGk9MSwjc2tlbCBkbwoJCWRyYXdfc2tlbGx5KHNrZWxbaV0pCgllbmQKCQplbmQKCmZ1bmN0
aW9uIF91cGRhdGUoKQoKCQoJbG9jYWwgbXgsIG15LCBtYiA9IG1vdXNlKCkKCQoJZm9yIGk9MSwj
c2tlbCBkbwoJCWxvY2FsIHMgPSBza2VsW2ldCgkJY2hwb3NlKHMucG9zZSxzLnRwLCAwLjMpCgkJ
CgkJbG9jYWwgZHggPSBteCAtIHMueAoJCWxvY2FsIGR5ID0gbXkgLSBzLnkKCQkKCQlpZiAoZHgq
ZHgrZHkqZHkgPCA0MDApIHRoZW4KCQkJaWYgbm90IHMuaG92ZXIgb3IgKGxhc3RfbWIgPT0gMCBh
bmQgbWIgPiAwKSB0aGVuCgkJCQktLSBjaG9vc2UgbmV3IHJhbmRvbSBwb3NlCgkJCQlpZiAocm5k
KDQpID4gMSkgdGhlbgoJCQkJCXMudHAgICA9IG1ha2Vwb3NlKHJuZCg1KVwxKQoJCQkJCWlmIChy
bmQoMik8MSkgZmxpcF9wb3NlKHMudHApIC0tIHZhcmlhdGlvbgoJCQkJZWxzZQoJCQkJCS0tIGZs
aXAKCQkJCQlmbGlwX3Bvc2Uocy50cCkKCQkJCWVuZAoJCQllbmQKCQkJcy5ob3ZlciA9IHRydWUK
CQllbHNlCgkJCXMuaG92ZXIgPSBmYWxzZQoJCWVuZAoJZW5kCgkKCWxhc3RfbWIgPSBtYgplbmQK
CgoKCjo6IHBvc2UubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtNDktMDUg
MDc6NDk6NTciLG1vZGlmaWVkPSIyMDI0LTAzLTA2IDAzOjQxOjMzIixyZXZpc2lvbj0zMzJdXQoK
CmZ1bmN0aW9uIGRlZnBvc2UoKQoJcmV0dXJuIHtbMF09CgkgIDAuNywwLjksCgkgIC0wLjMsLTAu
NCwKCSAgMC44NSwwLjc1LAoJICAwLjY1LDAuNzUsCgkgIDAKCSB9CmVuZAoKZnVuY3Rpb24gbWFr
ZXBvc2UobikKCiBuPWZscihuKQogCgoJbG9jYWwgcGRhdD17WzBdPQoJCgkgLS0gZGVmCgkge1sw
XT0KCQkgIDAuODUsMC43NSwKCQkgIC0wLjMsMC43NSwKCQkgIDAuODUsMC43LAoJCSAgMC42NSww
LjcsCgkJICAwCgkJIH0sCgkJIAoJIC0tIDEuIGFybXMgZG93bgoJCXtbMF09CgkJICAwLjgwLDAu
OTAsCgkJICAwLjcwLDAuNjAsCgkJICAwLjk1LDAuOTUsCgkJICAwLjU1LDAuODUsCgkJICAwCgkJ
IH0sIAoJCSAKCQktLSAyIHJ1c3NpYW4KCQktLSAoYXJtcyB3YXZlKQoJCXtbMF09CgkJICAwLjIw
LDAuMzUsCgkJICAwLjQ1LDAuNjAsCgkJICAwLjk1LDAuOTUsCgkJICAwLjU1LDAuODUsCgkJICAw
CgkJIH0sIAoJCQoJCS0tIDMgc3RvbXB5CgkJLS0gKGFybXMgb3BlbiAtLSBoZXkgaG8pCgkJe1sw
XT0KCQkgIDAuMCwwLjE1LAoJCSAgMC4zNSwwLjI1LAoJCSAgMC43NSwwLjc1LAoJCSAgMC40NSww
LjY1LAoJCSAgMAoJCSB9LAoJCSAKCQktLSA0IGFybXMgdXAKCQl7WzBdPQoJCSAgMC4yNSwwLjM1
LAoJCSAgMC4yNSwwLjE1LAoJCSAgMC43NSwwLjc1LAoJCSAgMC42LDAuNiwKCQkgIDAKCQkgfSwK
CQkgCgkJCgl9CgkKCW49biUoI3BkYXQrMSkKCiBsb2NhbCBwPXt9CiBmb3IgaT0wLDggZG8KICBw
W2ldPXBkYXRbbl1baV0KIGVuZAoKCXJldHVybiBwCmVuZAoKCgotLSBjaGFzZSBwb3NlCmZ1bmN0
aW9uIGNocG9zZShwMCxwMSxxKQogZm9yIGk9MCw3IGRvCiAgbG9jYWwgYTA9cDBbaV0KICBsb2Nh
bCBhMT1wMVtpXQogIGEwJT0xIGExJT0xCiAgaWYgKGFicyhhMC1hMSk_MC41KSB0aGVuCiAgIGEw
Kz1zZ24oYTEtYTApCiAgZW5kCiAgYTA9YTAqKDEtcSkrYTEqcQogIHAwW2ldPWEwJTEKIGVuZAog
CiAtLSBoZWFkCiBwMFs4XT1wMFs4XSooMS1xKStwMVs4XSpxCmVuZAoKCmZ1bmN0aW9uIGZsaXBf
cG9zZShwKQogZm9yIGo9MCwxIGRvCiAgZm9yIGk9MCwxIGRvCiAgIHBbaio0K2krMF0scFtqKjQr
aSsyXT0KICAgcFtqKjQraSsyXSxwW2oqNCtpKzBdCiAgZW5kCiBlbmQKIGZvciBpPTAsNyBkbwog
IHBbaV09KDAuNS1wW2ldKSUxCiBlbmQKIAotLSBwWzhdKj0tMQogcFs4XT0weDAuZmZmZi1wWzhd
CiAKZW5kCgoKCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3
OjQzIixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCIsc3RvcmVkPSIyMDI0LTAzLTA2IDAz
OjQxOjMzIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzUxIix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJib25lcy5sdWEjNzIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249InBvc2UubHVhIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdv
cmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIsd29ya3NwYWNlX2luZGV4
PTN9LHtsb2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogZ2Z4
Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDUgMDc6Mjg6MjAiLG1vZGlmaWVk
PSIyMDI1LTEyLTE0IDAwOjQ3OjM4IixzdG9yZWQ9IjIwMjQtMjgtMDUgMDc6Mjg6MjAiXV0KOjog
Z2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRJNExUQTFJREEzT2pJ
NE9qSXdJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXdNem8wTVRvek15SXNjbVYyYVhO
cGIyNDlNemsxWFYxc2VqUUFVZ0lBQUJnMUFBRHpISHRiTUYwOWUySnRjRDF3ZUhVQQpReUFJQ0FU
d0dSY2dCeEJIY0FjQUxHWnNZV2R6UFRBc2NHRnVYM2dJQU90NVBUQXNjMk5oYkdVOU1USjlMRHNB
bnhZSEVFY2dGeUFICmdEc0FINThOQjBBM0VCZFFGOEE3QUI5LUJRZGdGekFYTUQwQUkzOEVCMkFY
UUFkQVBRQWlmNkFIWUJkUUIyQV9BQ1JBa0FjQUJ6NEEKRDBBQUpSWEFRQUJQVUJkUUYzTUJIeFd3
UUFBZllFQUFKQ0JRRno0QUgzQV9BQ0pmb0FkUUYzQV9BQ1loOEFNLUFBODlBQ1JQQ2dkUQpOenNB
Skg4SkIzQW5NQWNnUFFBaXJ3QUhjRWNRQnlBWDhCazdBQjZ2Z0FjZ0Z5QkhFQWZ3RmpzQUhxLUFG
MUFYRURkQUItQU5Pd0FpCkFGa0RUMkFIOEFVOUFDSUFXUU5QWUFmd0JEMEFKQkZnWWdJZm9ENEFK
bjlnQjFBSEFBZVFRQUFlVllBWFVCZFFRQUFmd0VBQUloVmcKUUFBZnNFQUFJaEp3bUFNUFBnQW9Y
M0FYVUFlZ1BnQWtBRHdBTC1BRFBRQWpYemRRQi1BS093QWlqeUFITUNkd0ItQUpQUUFiWHhBUQpC
UER3TXdDNG8yVkhrR2VBQndBbkFBY0dBSzRuQUNlUVI2QUhBQWNBQUFRUFVBQVEtd01WRndBWG9F
ZWdSM0FIRUVjUUIxQ0g4QWhmCkFEbHhBQmR3RnpBWGNEQUQ3M0FIVUFkd0Z5QVhnQmNnRi1BS3h3
QThoQk1YUUJkZ0YwQVhZUUJma0FjZ0I2QmtBRHdEZXdHd041QUgKQUNlZ0p3QUhzRGNsQnktd0dD
c0NoUTh6QUNCd0UwY0FSMEFYSU1NRy14UTNBRGRnQnlBSElBZUFGd0FYa0FjUUJ4QUhvQ2ZRQjlB
bgprQmNRQnhBWFlJZndJNU1BSUE4ekFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tCi05ZFFQVEV5ZlgwPQo6OiBtYXAvLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyNC0xMC0wNSAwNzoyODoyMCIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6
NDc6MzgiLHN0b3JlZD0iMjAyNC0yOC0wNSAwNzoyODoyMCJdXQo6OiBtYXAvMC5tYXAKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVFUwTFRBeklEQTBPalUwT2pJM0lpeHRiMlJwWm1s
bFpEMGlNakF5TXkwMQpPQzB3TXlBd05EbzFPRG93TVNJc2NtVjJhWE5wYjI0OU16VmRYV3g2TkFC
cEFBQUFvd2dBQVBBVGUyeGhlV1Z5UFh0Yk1GMDllMkp0CmNEMTFjMlZ5WkdGMFlTZ2lhVEUySWl3
eE5nTUFMeUl3QVFELS0tLXZvU0lwTEhCaGJsOTRQVEFJQVBJR2VUMHdMSE5qWVd4bFBURXMKZEds
c1pWOW9QVEUyQ2dCdmR6MHhObjBzU3dULS0tLS1PRkF4Tm4xOWZRPT0KOjogbWFwL21hcDAubWFw
CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRJNExUQTFJREEzT2pJNE9qSXdJaXh0
YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXdNem8wTVRvek15SXNjbVYyYVhOcGIyNDlNelkz
WFYxc2VqUUFYUUFBQUZnRUFBRHdFM3RzWVhsbGNqMTdXekJkUFh0aQpiWEE5ZFhObGNtUmhkR0Vv
SW1reE5pSXNNVFlEQUM4aU1BRUEtLS0tNzZFaUtTeHdZVzVmZUQwd0NBRHlCbms5TUN4elkyRnNa
VDB4CkxIUnBiR1ZmYUQweE5nb0FjSGM5TVRaOWZYMD0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9k
LGNyZWF0ZWQ9IjIwMjQtMTAtMDUgMDc6Mjg6MjAiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3
OjM4IixzdG9yZWQ9IjIwMjQtMjgtMDUgMDc6Mjg6MjAiXV0KOjogc2Z4LzAuc2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRVMExUQXpJREEwT2pVME9qSTNJaXh0YjJScFptbGxa
RDBpTWpBeU15MDEKTnkwd015QXdORG8xTnpvME1pSXNjbVYyYVhOcGIyNDlNelJkWFd4Nk5BQnZB
QUFBN1FZQUFOOXdlSFVBQXlnQUFBTUFCUEQtQVFEcwoteWZ4QVJBR0R5QVFBU0FCSUFId0FBSVFB
ZzRRQVNBUElTQUJNQTlBOE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NRRVFCZzR3CkFQODVI
LThCQU56UF9BOUFBQThRUVAtLXNQQndDd0QtLTZNZi13RUFsMUQtLS0tLUh3PT0KOjogc2Z4L3Nm
eDAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRJNExUQTFJREEzT2pJNE9q
SXdJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXdNem8wTVRvek15SXNjbVYyYVhOcGIy
NDlNell5WFYxc2VqUUFFQUVBQUZFSEFBRHdKM0I0ZFFBREtBQUFBd0FFRDBBUQpBZzRBQWFBQklB
S2dEZ0FQRUFBTjhNb0JBZ01FQlFZSEFRLS1rQWdKQ2dzUERBOE5EdzRQRHhBQThBQU5EeEVQRWc4
VER4UVBGUThXCkR4Y1RBUEVCRHhnUEdROGFEeHNQSEE4ZER4NFBIeFFBOFFBZ0R5RVBJZzhqRHlR
UEpROG1EeWNVQVBFQUtBOHBEeW9QS3c4c0R5MFAKTGc4dkZBRHhBREFQTVE4eUR6TVBOQTgxRHpZ
UE54UUEtd1U0RHprUE9nODdEendQUFE4X0R6OEJELS13LXdFQTYtOG5XZ0VRQmc4ZwpFQUVnQVNB
QjhBQUNFQUlNRUFFZ0R5RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JFQVlN
TUFELU9SLS1BUURjCnYtZ1BRQUFOUVAtLXNQQndDZ0QtLTJRZi13RUFsMUQtLS0tLUh3PT0KOjog
W2VvY10K
:: bios/wallpapers/trinkets.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTEwLTI5IDA0OjE4OjQ3Iixtb2RpZmllZD0iMjAyNS0xMS0wMyAxMTo0NTo1NCIs
cmV2aXNpb249MjU2XV0KLS0gdHJpbmtldHMgd2FsbHBhcGVyCi0tIGJ5IHplcAoKLS0gZXhwZXJp
bWVudDogdmFyaWFibGUgYmFnIHNpemUgKHVuY29tbWVudCBsaW5lIGluIGdyYWIoKSB0byB1c2Ug
YmFnMCkKbG9jYWwgbnVtX3NoYXBlcyA9IDEyOApiYWcwPXt9Cm49cm5kezIsNCw4LDEyOCwyNTZ9
CmZvciBpPTEsbiBkbwoJYWRkKGJhZzAscm5kKDI1NilcMSkKZW5kCgpmdW5jdGlvbiBncmFiKCkK
CWlmIG5vdCBiYWcgb3IgI2JhZyA9PSAwIHRoZW4KCQliYWcgPSB7fQoJCWZvciBpPTAsbnVtX3No
YXBlcy0xIGRvCgkJCWFkZChiYWcsaSkKCQllbmQKCQktLSByYXJlIGl0ZW1zCgkJZm9yIGk9MTI4
K3JuZCg4KSwxMjgsNCtybmQoOCkgZG8KCQkJYWRkKGJhZyxpKQoJCWVuZAotLQkJYmFnID0gdW5w
b2QocG9kKGJhZzApKSAtLSBleHBlcmltZW50OiB1c2UgYSBzbWFsbCBiYWcgc29tZXRpbWVzCgll
bmQKCQoJcmV0dXJuIGRlbChiYWcscm5kKGJhZykpCmVuZAoKbG9jYWwgc2VlZCA9IHJuZCgxMDAw
MDAwKQpmdW5jdGlvbiBnZW5lcmF0ZSgpCgoJc3JhbmQoc2VlZCkKCWJhZz17fQoKCWZnY29sPXRo
ZW1lImRlc2t0b3AxIgoJYmdjb2w9dGhlbWUiZGVza3RvcDAiCgkKCS0tIGNvbG91cmZ1bCB2ZXJz
aW9uIAotLQljb2xzID0gezgsOSwxMCwxMSwxMiwxMywxNCwxNiwxNywxOCwyMywyNSwyNiwyNywy
OCwyOSwzMH0KLS0JYmdjb2wgPSAxCgoJY2xzKGJnY29sKQoJCglsb2NhbCByciA9IDAgLS0gcG9z
aXRpb24gdmFyaWF0aW9uCglsb2NhbCBpdyA9IDMwIC0tIGl0ZW0gd2lkdGgKCWxvY2FsIGloID0g
MjAgLS0gaXRlbSBoZWlnaHQKCQoJcGFsKDcsZmdjb2wpCgkKCWZvciB5PTAsMjAgZG8KCQlmb3Ig
eD0wLDMwIGRvCgkJCWxvY2FsIHN4ID0gMCsoeSAlIDIpICogaXcvMiArIHggKiBpdwoJCQlsb2Nh
bCBzeSA9IDEyICsgeSAqIGloCgkJCXN4Kz1ybmQocnIpLXJuZChycikKCQkJc3krPXJuZChycikt
cm5kKHJyKQoJCQkKCQkJaWYgKGNvbHMpIHBhbCg3LHJuZChjb2xzKSkKCQkJCgkJCXNwcihncmFi
KCksIHN4LCBzeSkKCQllbmQKCWVuZAoJc2V0X2RyYXdfdGFyZ2V0KCkKCXBhbCgpCmVuZAoKZnVu
Y3Rpb24gX2luaXQoKQoJd2luZG93KCkgLS0gc29tZXRoaW5nIHRvIGRyYXcgdG8KCWdlbmVyYXRl
KCkKCWJsaXQoYnApCmVuZAoKLS0gb25seSByZWRyYXcgd2hlbiB0aGVtZSBjb2xvdXJzIGNoYW5n
ZQpmdW5jdGlvbiBfZHJhdygpCglpZiBmZ2NvbCB_PSB0aGVtZSJkZXNrdG9wMSIgb3IgYmdjb2wg
fj0gdGhlbWUiZGVza3RvcDAiIHRoZW4KCQlnZW5lcmF0ZSgpCgkJYmxpdChicCkKCWVuZAplbmQK
Cgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTI5IDA0OjE0OjA0IixpY29u
PXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3
MDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDAxMGQwMTBkMDEw
ZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwMTBk
MDEwZDAxMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQw
ZDBkMDEwZDAxMGQwMTBkMGQwZDBkMDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDEwNzA3MWQxZDFkMWQxZDFkMWQxZDFkMDcwNzA3MDEwMTA3MDcxZDFkMWQxZDFkMWQxZDFkMWQw
NzA3MWQwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MWQwMTAwMDExZDFkMWQxZDFkMWQxZDFk
MWQxZDFkMWQwMTAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwIiksbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiLHJ1
bnRpbWU9MjMsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxNyIsd29ya3NwYWNlX2lu
ZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9u
PSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29y
a3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1
LTEwLTI5IDA0OjE0OjA0Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBnZngv
MC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lERXdPak0xT2pR
NElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNUzB3TXlBeE1UbzBNam95TkNJc2NtVjJhWE5wYjI0
OU16YzRYVjFzZWpRQUFoSUFBSEpLQUFEeklYdGJNRjA5ZTJKdGNEMXdlSFVBClF5QVFFQVR3Undm
QVI0Q0hjR2VBWjVCSDhFWXNabXhoWjNNOU1DeHdZVzVmZUFnQXpIazlNQ3g2YjI5dFBUZDlMRDRB
M3hmQU42QlgKa0ZlZ044QVg4RWNfQUIwd0dRZlFBZ0FwTl9BSUFDLXdLRWdBSGZFSktnZndBQWVR
SnlBSGNBY2dCeUFIVUFkQUJ4QUhVQWNRQWdELQpBMUFISUJjZ0IyQUhVQWVBQnpBSG9EZndKVjhB
SFdWR1I2QUhJQWNFQUQ5SDhGVkNBQjU1QndBSEFBZndDd2NBRDBZQUh2OERPQWZRCkJ3QUhzQWNn
QjVBSFFBZHdoLUJqUWdBZG9UWTNvQmNRRjVBSE1BY0VBSDhYRUJlZ04tQldSZ0FkOEFBMEZ6QVhn
RmVRVjVBSEFCY0EKQjVELUFUQUhFQWRhQUMtd05Vd0FIUk5Ha2dBQlNnQUNCZ0FDbGdBUGl3SWZ2
d2ZRRjhCWHdCZlFCLUJYUEFBZE1VVUhJTUFBZ1pBbgpBQ2RnSndBbmhBQS1CeUFIaGdBZkVFVkdB
QVFFQUFVaUFTLXdSYW9CSDQtd0NuZndDSGZ3Q2dzQklCQXFDd0VCS3dJUkVMTUNBTzBCCjc0QUhR
QWVRRnlBSHNCY0FCOUFYQlFNZmoxWVhBQmVnUjdBblh3RWhVVVlYQUJlUWpRTUJoZ0JnQnlBSHNB
Y0E2Z01QTWdRZUVUY0QKQTlPUUp5QW5ZQWRnQjNBSFFBZUFXQUFSQUFJQVA0QVhJSVVDSUw5SEI5
QW5vR2VRUjZBWEFQY0JKQk0zZlFJQkFnQUNoUUlmSjBRQQpIUkVtLWdRaUlDZkZCRjlnQnhBSFFN
VUVCeDhtWGdBZGMxSUhFQmNRRjNBb0FYRUFCM0FYRUJjUU1RVVBBUVFmRURXLUJEc05Cd0FICkFD
LXdSRWtBSGhGWGlBUUktZ01BRUFBZlZ4d0ZIeVJEbHhFQ0FFSUFBSkFFRXNCakFoODJTZ0Fkc1NV
WDBBY0FGN0FISUJlUVh3SVIKTUxFQ0FGSUFBTFVDQWRzQkh5cFVBQjBiS0pFREZMQ2dBRjhYNEFm
d04wNEFIVHBqaDNCSEF4ODRRZ0Fkb1RZSDRDZkFSNkEzc0NmUQpBQjlKUUFBZGNGVm5rRWV3TjhD
X0FCOUdmQUJkejBZSDRCZkFON0JIa0dmd1ZhY0RJak1uc0hkOEFCOUh5QUVmRU9BZUFvZ0h3QWNR
CkIyQ1hZTVlCRDRRQkhoZ25GQUlabDJBQ0R4SUNIbFZVRnpBWFlDc0VDZ2dBSDVDWkNTQVRWNjhG
RGs0QVQyQVhNQmZvQXlJUVpfd0EKUUlBbkFDZXJCVS1BWjVCWFJnQWZkaVFINEFmZ05fQUdBQjhI
NndVZmNUa0g0QWZBSjhBRUFFLWdCLUJLUUFBZE1rUUhBUEVFSFFrSgpBQS1RQ1I0Zk5SWUtBUU1I
QUFfQ0JpQUZQUUFJbFFBZkMwMEFJaEVxMkFJUm9FTUFCVnNIQ3dnQUFoNEFBQ2dBRDRnQklSRldQ
Z0JJCjhBb0hBQWtBRHlnSkh6RTFaNENtQlM0QUo2SUFBQWdBRUNBR0FCOUhzZ0lnSVRlZ05Ra0NK
UWRUQUFjd0IzQk9BRElRSnhCb0JoOUgKWEFZZkdUZFdBQkV3cEFCWUlBY0FCMkJXQUE5TUFSNDFS
U2NBTlFnRUZRa0RCQUEtWi1BMHdnb2xVN0FYMEJld0RBQVBtQUVmRVVicQpCaUV3QjBZQUE1SUhE
OVVDSU9FWDBCZlFGNkFuRUNkd0p4QW5vQTRBRHg0RkgxQTNGLUFPRjY4Q0VCRDRDQU1JQUJDZ0ZR
QVBUQUFmCklDY1gtQVVHeGdFTWRnVVJZQllBRTREeUFDLUFGd2NLSHlWa1o4QUNEX0lHSURCRUZ6
RGxDUkEzNlFBVlVPMEFBQXdBSDRDR0RDQVEKUnQ4UG4wY0FGMkNYVUpmd1V6NEFIVzlZSjRBWEFF
YzhBQ1BBTmhmQU53QVhjSWRnaC1BSTdRNEJYUUZQb0Fmd09XY0hIeEd3UEFBQgpMd21TSjVBWEFD
Y0FGNUFuUlE4UkVIVUhEN3NISHlJNE4xWU5BTEVLQW5zRUZIQ0JCQUhEQ2hBZ29nc1BWZ0FlTVRR
M3NHa0tBa1FBCkp3QW5CZ0FpRndBM0NoODN6d01nSVNmQTVnQURkUW9mSl80TEh6RklKN0I4QVFN
RkN4OG5BQTRmSUVjbkp3WVp3QVlBRHowRkh4VlgKLXhBRDl3b2ZTRUlBSUNJbnNNUU9IMGdrRGlB
RGZnQWZrSDBMTEFCdURoQ3dFZ19mRnlBWGtCY0FGN0FuUmdBaFlFWTNvRmZ3Q2dNQQpMNkEzVEFF
ZkZFVnNBZ0VhQXdFUUJZOEhFQmV3Ti1BQUIyTUNIMEE3QjZBM1B3QUNTUUFUa0ZVQUFRVUREM29L
SG9zMEItQUFON0FYCkVKd0FBZndDRDc4RUhoTkhxQU1IbHdBaEZ4Q3RBQy13TzB3QUhZOUlCX0FY
b0ZlUVZ6a01Jd0lvRlJLd3dRWWZSeklDSUNBWHdHY1QKTHhmZ3VnSWhBWFlBSDdDa0ZTUVJOVDRF
WFJBSGtIZVFDZ0FQUHdjZkVUUjBCU253R1FjQUgwVkdBQ01Ta0Q0QUh3Z05BQVFQeVFJZwpFRVVB
RWxRWEFCZndDd2tBRHkwRkhoTTA0Z3dUQU80TUxQQUpFUUFQN2dBZUdFUkNBSjluY0lkZ0YwQVhj
R2RJQUI5Uk15Y2dKMUJ2CkNqRWdCMEFPQXdBWUF4QlFNd29BaWdRQllBQUFBUlVQUkJNakVXY1NB
aUlRQjBnQUg2REdEQ1FDWmdVZjBFd0FNaEVsT0FBUnNQSUYKRTdDdERMLWdCd0FYZ0JjQUo2QW40
R2dZSUNBbEYwSUFFQ0NSQ2hBSHJCZ1h3QkFBTC1BalRnQWRNU3dIMEpJVkFNSVVBcnNZQURrSwpC
RTBLTWlBWFlFRUtIenBZQUIwZ0l3Y3JDekVnQl9DZ0FEZlFCX0FRQUEtNEZSOFJPdkVLTldBWElP
VUtDckFBQURvQ1Q5QUg4Q3hZCkFCMDJTZ2ZRLWdZZldENEFIV0JGUjZCbmdFY1FBMl9BUjdBbjhF
ZEFBQ0F5QnlBbmZRMFRnQW9BRDBnQUlXRXBCX0FYc0FjdEJCQW4KM2dPZmNEY0FKLUFJZDRCWFFR
TWZFRWZ4QWhCSDh3a0RJd2t2QndCcEJpQVFSVFVDWmtld0p3QUhvRVlBRDRjRElDTEFSMzBLRUtD
cgpDQzhINElvQUlCZElSQUFSd0ZJVkwtQklJaEVnRUJmT0VDQVhBSTBGRWdnSEFCSUpGUUFQS3hB
ZUlGTVg1UmtBLUFNQjVoYy1GLUJVClBSSWZFZERpRnpIZ0ZfQUlBRS1RQi1BcFpBWWhBSTRFSXJC
SDJBUlBvRWZ3VnI0Q0lBSEdDai1nQjlDMEFpQVZOc29LRVJER0F4RUEKQmdZUlFCWUdUNEFIOEZL
T0J4OFJBQUlBSXBBSHpBUUFXZ1lWY0pNUUVxQ3BFeDg0dFE4ZkU4QnBEeFNRQkFBdlY3RC1EeVFB
QUFsUwpBQmR3RndBR0FEOUhjRWRKRUNNV051d2VIdzVMQ1NCUlJSY0FCN0JhQ0YtUVI2QkhvRzhm
SURkR1Y1QVJBU0J3SndRQVR4QW53Q2ZyCkNCOGdKUmZTRWhFUVl3WWZvQXdBQkMtd05wa0pLUkdB
QmdBWGNBWUFGNEFlQUFfakNTVVhOSUlYQXNNTVBqQUhrQTBKRDM4R0VoSEEKQndNaUVBY2xEQkF3
Y0JFUHRnVWVNVVZua093UkdpRFVHUS1ZQUI0dk5XZHFHZ0FQb0JZZ0ZEZmJFQUdiRUFJR0FBT3ZE
aDhuY0FJZgpjMVZuY0JkQUYyQUVBQzl3WjBnVkh4QWxteUVBMGdrd3dGZUFteElIQkFBUEpRY2hF
MlEwRHdCNENROVBCaUVRMEc0SVFCUUgwQ2NTCkFTX1FKOEVGSVRJMUJ6QkhBRkVLQjlBblFFSUZB
UThBRDVJZEhsQkZGOUFYRUlnRUVBc0ZBQS1OQUI0UkdpOGVVX0FIc0ZlUTRRNEMKQmdBQ2VoUWVz
QlVRRDl3VUZCU3dDQVFOVWhvUC1Ca2pGU2hXQUZXQUZ4QVhnR0lBRnhCdUFDLXdKbDRJTEFINkFC
RWdZZ0F2OERaNgpDU2tUc0pRQU1RQUhjTm9ETC1BbVpCd2dBbk1NVDBlUVo3RDdCaUlRSlp3Q0lS
Y2dzeFlSb0hvQkluQ0hRZ1VCRWdBQnJRMGVJTm9lCkR4RU5GaEdRbVFjQ1VnQkRjRGNBTndvQUFS
WUFBQnNWQUNZQUwtQTIwQndnQmZnQWY1QkhrR2R3aDZCakRTQVRKb0FBQU9FSUFTVVQKRUdkWEN4
Q1E1UXNmTjVJQUh4RHdqd1ZnMEFmd0RrZWdLZ0l2UjZCR0FDQVZSb1lCZ0dBSEVFY1FCMUNIT0FR
UDJBRWhFak9jRndGZQpBZ0hSRHhBWGh3NEJjaVFRRjMwSklTQVhEQUFmQjVzT0lSRTNZUkpQOEFz
M3NPWVJJak1YQjlDNUFSR2dmd0VRa0lVWUV5ZW5BQUVCCkFSOEE3aEVnRlRiaEF4R3d0QXNBT2dr
aXdEZmlGZy04QlI4UU5Ca05NQ2Z3QUM0RkFTVU5ELWNJSUJFNU9BQVJvRlVhQVVJQUh6bUcKQUI4
Q2pSb0VrUm9Yb0JBQUwtQTBld1FvRWpjVEhCNlE5UWNQUmdBWlgxZVFCLUFBQVFJZ0VVVGlBZ0Jv
QXlMQUoxZ0pELTRtSXdBbApKaUNnUjNRZEFFSUZEOEFhSHlCVlI4Z3BFSUFFQUJfSE5ob2pBR3ND
UXJCbmdEY0VEdzlmRkNIU1JVZVFCeEFuZ0JjUUo0Q25RUFFECkFUY2FBQVFKTC1BelRnQWlCZjRL
SDNCU0FETWdaNEN4S3dLYkF5OUhvQTRHSWpsR0o3Q2FBQUpvQlJfZy1nVWtJRFZIc2dZRFNnQUQK
T3dRQlZnQUFyZ1lQNmd3Z0VUaldCXzl3QnpBM2NGZWdSNkEzd0FmZ0YzSUZIeEFrRFFNQW1SZ0Ft
d0FSQUFZT0FKRUFJb0FYREFBdgowQmV5QXg4QWhTc1V3SUVCQUk4UUQ5c0FIaEJFZHdFZ04zQUdC
WU0zRUFjd0J6QlhRQXdBYjBBSEVEZVFSMmdGSUFITEFRRjFBU1ZuCmtMQUZBQk1KRHpZZEpTTTBk
ejhlQVVrZUFyTUdCQTRBVDFBSGNIY0hDaDhmTktraEN3RVdBQjlBZ3cwaUFWQWJGRWU2RmdCR0FD
LXcKUmVRY0lBRUNBQkhRQWdBUGhBQWZNVVVIUU9zQ0JLMElEeVFhSVJNMWZnQUNpZ0F2OEVoNUNp
QUFaQWVBSndBWDBDZHdKOURxRWdEMApBZ180QnlBUlJmSUJBQ1VsSVFBSFZnWUJidzhQZEJNaEVD
eUxKQkFnQVFoQk53QUhnQ1ljRXFEeUN4ODV6Z2tnVVE4SDRBZWdXd1lBClZoSXY4QV9FQ1NBZ09S
ZkRFMkNBUi1BQVI0RENFd19KQUNCQVFnY2dKMlV3QUlnQUUyRENBZ0VLQUFIekJnRFNBd0hoQlM4
bklCQUkKSUJBbjN4REFGOUFIc0JjZ04xQTNJQmV3d0FvdkZfQk9MQ0FDT3hVQWRBOFNrRzhSQVhN
a0loQVhleEVRa0lBUEQ0Z0pKQUJyQ2pDdwpON0J2Q2g4TWFnZ2dFbFhHRlJrSEJ3QVB6UlVnQVRn
QUdRa0hBQjlEUmdBZEV6S05JQnNBQ0FBUFNnQWZNem9ud09FYkY0QUlBRS1BCkotQkwtZzBpQUVj
RUFVOFZBSlFOVVZBbkFDY0F1eHNDRWdBRUhnQVA5QWNmRVNtckVBOVdBQUVCd3hBZk9yTXVJRTBu
MEFmQVVBQVMKd0ZBQUQxc0NIaEVuVnhjZ0VCZklEd0t6QWhPUURnQUFHQUFQeVFRZk15Y0gwQVFa
QVBrZk1SQVhVTHNhQUg0SkFBNEFFNUFjQUE5LQpJU0VCRng4QXd4Y1JGLVFPTHpmd1p4a2hNRGNI
c0k0a1FRY0FONUJJR3hnd29qRVB4eEFlRVRkdkpiX0FOd0FuY0dkd0Z3QlhvT3dqCklCYzFQZ2dU
b0M4UUFPME9BZ0lBTC1Bb0xna2dJUmZBYWcwajBCZEVBQS1LQkI0UlJqVXBBUjRCSDFldk5DRUE2
UW9CVHhBUDVCc2sKTVNWSGtJSW1BR01FQWVnRkF3Z0FBQUlBQ2hRQUR4Y3FKUVJpQUFCU0FCRVFm
QWNiWUF3QUQxb0FLQ0ZuY08wQ0VtQUdBQ2VIWUE0QQpMM0JuVkFBaEdqVTNEQ2RuZ0E0QURfc0xJ
UlZHOHhFRWNnSVBZaVlmUHlSbmdKUUFCaFNBS2g0LVotQWxWQWtnQWRrRkFiY1pBbVFLCkgyY05L
eVFSUjVrT0FSSVJIX0QzTUNBaVJ3ZEFBeFBBTEFFZndMVUVJQkFWZkJFeU41QTN0VGNTa0FnZFB3
Zndac3dMSHhKdzRRWi0KVjNCbmdIZUFSN0FCSHhBalV4Z0JpaUlFLVN3QTVnSUdFZ0FpWUFlVkZB
TzVHQS03RXg0aU56ZHFBUVFNQWhLd0V4Y2ZTQWN1SHhTdwpQZ0FtWjdCSUFBLV9EQjRSSTBZQ0lN
Qm5jQUVGQkFBVFoyMElEeVlLSGhFcFRnQUEyZ0FHVGdBamdHZHhDQjg2R0NRaEYyQzRIUUd6CkpC
UndmUVFBeHdvUDd3QWVNVlZYZ0Zra0lCQTNQaGdBUGk4UkFBZ0FBQ1VGTHdBSFhna2ZFRlkwREJB
bkJBZ2ZBSzgySUNGV0YwNGIKQWR3WER6NEFJQ0FIQUg0SUx5ZkFQZ0FrQURNckFXd2NEMDRtSUJF
MUpCa2c4QUlEQ1FFS0Jnd05BQjg0WWdrZ0EtOExCTjRaSDVBUwpBQVF2OENhcEppRWg4QWpaRWlE
d0NBd0FIMVZ2QlI4aThBNHVIQVpnS3g5SUd4b2ZCT0FnRWNBS0FDLXdEZ01QSUFKcE9oT3dneUJX
CmdCY3dCNkNiQ1E4ZEp4NUJPQ2VnRnd3VEJvNGRBUVlQRDBZWUlUTTBGOUNnT0VTZ0J6QVhhakFE
TFFFZk9NSUxIeEhnN2dFQ05oNFIKUU5FbEFEZ2VMNkFuaHhZZklqUm5feEFFZndFUG1COGhOVFJu
a1BzQkFwTVlEMFFBSHhJMl9UUVFRSHdRRTBBRE5RX09FUjRRTk00UgpzQmNRSjVBWDRDZmdGNUFu
aHd3ZklLa09JQlpGendBREZ3RXY4Rll6RHlBRHd3d1JvSmNGTC1CbHJ3d2hBV2dURlFkRUFCRUpi
UWNpCmdDY1JBQS03SmlFT2RVRVBzRHc0Smljbmt3SUljQ2dQWGdBekV5YUpOUUNsQmdCTUFBYTRB
QkZBV3dVQTBnQXhjQ2NndGdFUFhnQTEKQ3NnQUJaVWhIeWNqSFNGZzRBZndBQ2Z3S3h3VnNBNEFI
eWRqQVI4TFFnQUNEZ0F2OENiZlBDQUFpeUFwTjlBSUFDLXdHYkVkSW0zdwpBQWV3TjhBS0FDLXdG
azRBSFRBVUItQlRGd0JWRENEd0FxOGhFU0Q2RUNEd0NoZ0FMLUFhS2dVZkFKVUdJUEFNQlFBUUN6
SURVQXNICk1BY2doeVVQN3lNZ2dTWW5zRWZ3Q1llUUV3UUIzUU1CQVE0QWR3SVBiZ2tmZEROWGtB
ZmdCd0FHQUQ5WGtGZGlDUjhSSkJBN0FUTVcKQW1NTUFjQVNBUkFBQVFRQUFNTVBEejhOSHpRbEJf
QlFBQU5QRUFLRkJBNElBQUo0QUFfOUNoXy1OaWZ3REVmd0NtZndDSWM1QVI4egpOd2ZBRlFJQ0Jn
QUdDZ0Fmd0hnSUlEUTJKOERMQURFbmNCZjNBQkkzdGhBUEZBOGZRVVVYNEFkU0xBRWhBUUFVRFNH
QVI1NERMemV3CmhoRWdFU2M0QUZMZ0J3QkhnUFVGSXdjQVhnQWY0TUFhSURKR0I5RHRNeUlYd0tF
VEx3ZlFQd1lnRWpqREp4QVhCQUFRc0h3MEx3Y1EKZGdFaUJHazZGSUFPQmc2bkN3OUdBQmdCc0FF
UFJnQW1FemI0QlNRUUY5Y0NBUWdBRUVlVUh3OTVFaUFDdVNvUTBHMHFEelkwSVFCWQpFUVAyTHg4
T1dRRWdBZnNRSlNld25nTXBBQWYzRVM4bkFDY2JERkJ0UFRkOWZRPT0KOjogbWFwLy5pbmZvLnBv
ZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMTAtMjkgMDQ6MTQ6MDQiLG1vZGlmaWVkPSIyMDI1LTEy
LTE0IDAwOjQ3OjM4Il1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJMUxUQXhMVEUzSURFd09qTTFPalE0SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1DMHlPU0F3
TkRveE5Eb3dOU0lzY21WMmFYTnBiMjQ5TWwxZGJIbzBBRXdBQUFCUUFBQUE4Ung3ZTJKdGNEMXdl
SFVBVElBZ0lBRC0KQUFELS0tOERMR2hwWkdSbGJqMW1ZV3h6WlN4d1lXNWZlRDB3Q0FEU2VUMHdM
SFJwYkdWZmFEMHhOZ29BRUhjS0FJQjZiMjl0UFRGOQpmUT09Cjo6IHNmeC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDI1LTEwLTI5IDA0OjE0OjA0Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAw
MDo0NzozOCJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFM
VEEzTFRNeElEQTRPak13T2pJNElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNQzB6TVNBd016bzFP
RG95T1NJc2NtVjJhWE5wYjI0OU1WMWRiSG8wQUtBQUFBQUxDZ0FBLXpCd2VIVUFBeWdBQUFRQUJB
OUFFQUlPCkFBR2dBU0FDb0E0QUR4QUFEZkRLQVFJRFFBOFBrQVFGQmdkQURKQUlDUW9MUUF5UUR3
d1BEUThPREVBTThQOEJBT3YtSjZvQkVBWVAKTUJBQklBRWdBZkFBQWhBQ0RoQUJJQThoSUFFd0Qw
RHd3dzhvRC0td3hnLTRDZy0tRDRBUDl3OE5BZkFKQVJBR0RqQUEtLS0tLS1fOQpILThCQUt6UHlB
OUFBQThRUVAtLXNQRC1BUUQtNmxELS0tLS1LUT09Cjo6IFtlb2NdCg==
:: bios/widgets/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: bios/widgets/clock.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTAxLTA1IDAzOjAxOjU5Iixtb2RpZmllZD0iMjAyNS0wMS0wNiAwMjowOTo0NSIs
cmV2aXNpb249NzBdXQoKc2hvd19kYXRlID0gZmFsc2UKc2hvd19sb2NhbCA9IHRydWUKCmZ1bmN0
aW9uIF9pbml0KCkKCQoJd2luZG93ewoJCXdpZHRoPTcyLAoJCWhlaWdodD04LAoJCWhhc19mcmFt
ZT1mYWxzZSwKCQlyZXNpemVhYmxlPWZhbHNlCgl9CgkKCS0tIHdoZW4gY2xpY2sgYW55d2hlcmUg
aW4gd2luZG93LCB0ZWxsIHdtIGNhbiBncmFiIGl0IGFuZCBtb3ZlIGFyb3VuZAoJLS0gYWxzbzog
c2V0IGN1cnNvciB0byBncmFiIHdoZW4gaG92ZXJpbmcgb3ZlciB3aW5kb3cKCWd1aSA9IGNyZWF0
ZV9ndWl7CgkJY2xpY2sgPSBmdW5jdGlvbigpIHNlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9ImdyYWIi
fSkgZW5kLAoJCWN1cnNvcj0iZ3JhYiIsCgkJCgkJLS0gdG9nZ2xlIHRpbWV6b25lLCBkYXRlIC8g
dGltZQoJCXRhcCA9IGZ1bmN0aW9uKHNlbGYsbXNnKQoJCQlpZiAobXNnLm14ID4gNDgpIHRoZW4K
CQkJCXNob3dfbG9jYWwgPSBub3Qgc2hvd19sb2NhbAoJCQllbHNlCgkJCQlzaG93X2RhdGUgPSBu
b3Qgc2hvd19kYXRlCgkJCWVuZAoJCWVuZAoJfQplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJZ3Vp
OnVwZGF0ZV9hbGwoKQplbmQKCgpmdW5jdGlvbiBfZHJhdygpCgoJY2xzKDApCglsb2NhbCBmb3Jt
YXQgPSBzaG93X2xvY2FsIGFuZCAiJVktJW0tJWQgJUg6JU06JVMiIG9yIG5pbAoKCWlmIHNob3df
ZGF0ZSB0aGVuCgkJcHJpbnQoZGF0ZShmb3JtYXQpOnN1YigxLDEwKSwwLDAsMTMpCgllbHNlCgkJ
cHJpbnQoZGF0ZShmb3JtYXQpOnN1YigxMiksNCwwLDEzKQoJZW5kCgoJcHJpbnQoIlwwMTQiLi4o
c2hvd19sb2NhbCBhbmQgImxvY2FsIiBvciAiIGdtdCIpLDUyLDEsMTYpCgoJLS0gd20gZHJhdyBt
YXNrOyBjb2xvdXIgMCBpcyB0cmFuc3BhcmVudAoJLS0gY2FuIHN0aWxsIGludGVyYWN0IHdpdGgg
YW55IHBpeGVsIHRob3VnaAoJcG9rZSgweDU0N2QsMHhmZikgCgplbmQKCjo6IC5pbmZvLnBvZAot
LVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDEtMDUgMDM6MDI6MjUiLG1vZGlmaWVkPSIyMDI1LTEyLTE0
IDAwOjQ3OjM4IixydW50aW1lPTEzLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjNTIi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4
PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJz
ZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8ucG9kCi0tW1twb2Qs
Y3JlYXRlZD0iMjAyNS0wMS0wNSAwMzowNDowOSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6
MzgiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExU
QTFJREF6T2pBeE9qVTVJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTVMwd05pQXdNam93T1RvME5T
SXNjbVYyYVhOcGIyNDlORGxkWFd4Nk5BQl9BQUFBRWpFQUFQTWhlMXN3WFQxN1ltMXdQWEI0ZFFC
RApJQkFRQlBCV0J4QUh3QmZRRjhBSEVBZndWaXhtYkdGbmN6MHdMSEJoYmw5NENBRExlVDB3TEhw
dmIyMDlPSDBzUGdBZjhERUEtLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTExQnRQVGg5ZlE9PQo6OiBtYXAvLmluZm8ucG9kCi0t
W1twb2QsY3JlYXRlZD0iMjAyNS0wMS0wNSAwMzowNDowOSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQg
MDA6NDc6MzgiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkx
TFRBeExUQTFJREF6T2pBeE9qVTVJaXh0YjJScFptbGxaRDBpTWpBeU5TMHcKTVMwd05pQXdNam93
T1RvME5TSXNjbVYyYVhOcGIyNDlOVEJkWFd4Nk5BQm9BQUFBV0JBQUFQQUllM3RpYlhBOWRYTmxj
bVJoZEdFbwpJbWt4TmlJc016SURBQzhpTUFFQS0tLS0tLS0tLS0tLS0tLS0tLS0tXy1FSUlpa3Nh
R2xrWkdWdVBXWmhiSE5sTEhCaGJsOTRQVEFJCkFOSjVQVEFzZEdsc1pWOW9QVEUyQ2dBUWR3b0Fn
SHB2YjIwOU1YMTkKOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDEtMDUg
MDM6MDQ6MDkiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAwOjQ3OjM4Il1dCjo6IHNmeC8wLnNmeApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQXhMVEExSURBek9qQXhPalU1SWl4dGIy
UnBabWxsWkQwaU1qQXlOUzB3Ck1TMHdOaUF3TWpvd09UbzBOU0lzY21WMmFYTnBiMjQ5TlRCZFhX
eDZOQUNnQUFBQUN3b0FBUDh3Y0hoMUFBTW9BQUFFQUFRUFFCQUMKRGdBQm9BRWdBcUFPQUE4UUFB
M3d5Z0VDQTBBUEQ1QUVCUVlIUUF5UUNBa0tDMEFNa0E4TUR3MFBEZ3hBRFBELUFRRHIteWVxQVJB
RwpEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1j
UERRSHdDUUVRQmc0d0FQLS0tLS0tCnZSLS1BUUNzejhnUFFBQVBFRUQtLTdEdy13RUEtX3BRLS0t
LS15az0KOjogW2VvY10K
:: bios/widgets/owl.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTAxLTA0IDAyOjIwOjUwIixtb2RpZmllZD0iMjAyNS0wMS0wNyAyMjozNDo1OSIs
cmV2aXNpb249NTIwXV0KYmxpbmtfdCA9IDAKCmZ1bmN0aW9uIF9pbml0KCkKCQoJd2luZG93ewoJ
CXdpZHRoPTIyLAoJCWhlaWdodD0yMCwKCQloYXNfZnJhbWU9ZmFsc2UsCgkJcmVzaXplYWJsZT1m
YWxzZSwKCQl6ID0gMTAgLS0gc3RheSBvbiB0b3A7IGNhbiBkcmFnIGludG8gdG9vbCB3aW5kb3dz
Cgl9CgkKCS0tIHdoZW4gY2xpY2sgYW55d2hlcmUgaW4gd2luZG93LCB0ZWxsIHdtIGNhbiBncmFi
IGl0IGFuZCBtb3ZlIGFyb3VuZAoJLS0gYWxzbzogc2V0IGN1cnNvciB0byBncmFiIHdoZW4gaG92
ZXJpbmcgb3ZlciB3aW5kb3cKCWd1aSA9IGNyZWF0ZV9ndWl7CgkJY2xpY2sgPSBmdW5jdGlvbigp
IHNlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9ImdyYWIifSkgZW5kLAoJCWN1cnNvcj0iZ3JhYiIKCX0K
ZW5kCgoKLS0gdmVjdG9yIG93bApmdW5jdGlvbiBkcmF3X293bCgpCgoJbG9jYWwgYiA9IDEKCW14
LG15LG1iID0gbW91c2UoKQoJaWYgKG14PD0wKSBiID0gMAoJaWYgKG14Pj0yMykgYiA9IDIKCQoJ
aWYgKGJsaW5rX3QgPiAxMCBvciBtYiA_IDApIGIgKz0gOAoJc3ByKGIsMCwwKQplbmQKCmZ1bmN0
aW9uIF9kcmF3KCkKCgl3LCBoID0gZ2V0X2Rpc3BsYXkoKTphdHRyaWJzKCkKCXIgPSBtaW4ody8y
LGgpCgoJY2xzKDApCglkcmF3X293bCgpCglwb2tlKDB4NTQ3ZCwweGZmKSAtLSB3bSBkcmF3IG1h
c2s7IGNvbG91ciAwIGlzIHRyYW5zcGFyZW50CgplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJYmxp
bmtfdCA9IG1heCgwLCBibGlua190LTEpCglmcmVxID0gMTIwCgkKCW14LG15PW1vdXNlKCkKCWlm
KG14PjAgYW5kIG14PDI0IGFuZCBteT4wIGFuZCBteTwyMCkgZnJlcSA9IDQwIC0tIGJsaW5rIG1v
cmUgd2hlbiBob3ZlcgoJaWYgKGJsaW5rX3QgPT0gMCBhbmQgcm5kKGZyZXEpPDEpIGJsaW5rX3Qg
PSAyMAoJCglndWk6dXBkYXRlX2FsbCgpCgkKZW5kCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRo
b3I9InplcCIsY3JlYXRlZD0iMjAyNS0wMS0wNCAwMjoyMTo0OCIsaWNvbj11c2VyZGF0YSgidTgi
LDE2LDE2LCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxMDEwMTAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MGQwZDBk
MGQwZDA3MDcwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDcwNzBkMGQwZDBkMDcwNzBkMGQwNzAxMDEw
NzBkMDcwNzA3MDcwZDBkMDcwNzA3MDcwZDA3MDEwMTA3MGQwNzAxMDcwNzBkMGQwNzAxMDcwNzBk
MDcwMTAxMDcwZDBkMDcwNzBkMGQwZDBkMDcwNzBkMGQwNzAxMDEwNzBkMGQwZDBkMDYwNjA2MDYw
ZDBkMGQwZDA3MDEwMTA3MDcwNzA3MDcwNzA2MDYwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwNzAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDEwMTA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAw
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6Mzgi
LG5vdGVzPSIiLHJ1bnRpbWU9MTMsdGl0bGU9Ik93bCBXaWRnZXQiLHZlcnNpb249IiIsd29ya3Nw
YWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlv
bj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdv
cmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9
fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTA0IDAyOjQ3OjA1
Iixtb2RpZmllZD0iMjAyNS0xMi0xNCAwMDo0NzozOCJdXQo6OiBnZngvMC5nZngKYjY0JExTMWJX
M0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRBMElEQXlPakl3T2pVd0lpeHRiMlJwWm1sbFpE
MGlNakF5TlMwdwpNUzB3TnlBeU1qb3pORG8xT1NJc2NtVjJhWE5wYjI0OU5EVTNYVjFzZWpRQUJB
VUFBTVU3QUFEd0wzdGJNRjA5ZTJKdGNEMXdlSFVBClF5QVdGQVJBQkhBRW9MU0ExR0FVSHc4a1Rq
UlFCQmNlQkI0bkhpUlFCeDhWQnk0SExRY2VGRkFkQmcwSERnY3RCZ0IwRkZBOUJ3NEgKVFFrQU1B
MERMUXNBSkFjZEt3QkFCQmRQSHo0QTh5NFVIaXhPRkM4VU1BdEVESFE3SUFzSmhDa0VPeUFMRkNr
RUtSUUpGRHNnQ3lRSgpKQWxVT3pEa0cxRFVnTFR3REN4bWJHRm5jejB3TEhCaGJsOTRDQURLZVQw
d0xIcHZiMjA5Tkgwc3RRRHdCREFFb0FTUXBKREVjQlEtCkR5UV9GRkFVRGllMkFISU9GRUFFRGdj
dnVBQmxEZ1JBQkFjdHVnQUFEZ0FSVGJzQUFBb0FBYmdBQWI0QUVBUXpBQlF0TWdEeUZSUU8KSjA4
Zkp3NFVNQThVSkQ0dkh6NGtEeFFnREhRUEgzUU1JQndwaENrY0lCd0VDY1VBLXdVRUhDQWNSQWtr
Q1VRY01BemtERkRrY01UdwpDOFlBSEJSUWV3R1FORThQSkI0VVVDUWV4Z0JTRndSUUZCN0ZBRU1k
QjFBVWVBRWdCejBMQUJSTkNRQUV3QUFRSFN3QUVpMHJBUElVCkpCNG5UeDhYQkVBdkZCUk9MeDhl
RkRBLUZIUVBIMFFQRkNBOEJDbUVDUXdnUEJTOEFOQU1JRHhVQ1NRSkpBd3dIT1JnZndFUHVRQWEK
WHhBUUJQRHdNUURkRHlrREFmRU1QZ1J1SkZEZUZGQU9IeFJPTFM0VVVBMGVEUzROTGcwZUZGRGVB
d0JUQkI1UEgwNEtBNUF0TUExRQpESFE5SUEwSkF6STlJQTFFQWtFVVBTQU5DUU5QUFREa0hRa0RN
LUFCWGdSZUZFQUU3Z1JBQkI0dkZFNHRIdDhDQVpjQVFpNE5EZ1FaCkFQVVE3Z1JBRkQ1UEh6NFVN
QTBrUGl3X0pBMGdEWFFNZEEwZ0hTbUVLUjBnSGVFQ01SMGdIZUVDWHgwd0RlUU40UUl6OHdKdUJE
NEUKVUJUZVVCUXVMeFJPSFE1UUZETUJFUTBWQVBBSTNsQWtUazhmSGdSQUxSUk9MQjRVTUQxMERF
UU5JRDI5QWpNTklEMjlBakVOSUQyOQpBajhOTUIyOUF2OHY4QXNPSnk1SEhoUlFCeFlYRGhjbUZ3
NFVVQVlYQmdjT0J3WW5CdFVGVkVjT1p3NFVKQUFGelFJUkxkY0ZjQXhFCkRYUThJQXpPQWpJOElB
d3hBa0VVUENBTXpnSlBQRERrSE00Q09VQU9SeTVIdlFJaEZ5YW9BQURBQlNRR0o2a0FkUVJBQkdj
T1p3UW0KQUFQYkFnZkFCUkFOd0FVUDN3SlljUjVITGljT1VCUlRBU0VYRnNNRkE2OEFoQmNHVUJR
T1p3NUhKQUFEN3dJT3NRVVA5QUpkSHpneApBQ3RwRmhRRThBeVVqd2NmVG8wSGpBLUJBQlZnTHhV
WExpMFh2d0JRTFFZTkZ3NEZBSEFFUUFSTkZ3NU5DQUJRRFFNdEZ3NEZBQUM1CkFCTXRLZ0FQdHdC
eEF6SURpd2N2RlNjT0J5MG52d0FJdHdCQlRRY2VUVzBCYnkwSFB4OHRCN2NBUkE2UkFnOHhBUC0t
LS1fRUFFOEYKSnd1a0pRbGh2aVJRQkI4VjNRdGdIUVlOTGkwRzNRc3hQUzVOQmdBd0RRTXRHQWtS
SFI4QUFCOEpJRjRVN0FzdlhnVDJEalVQN0FVRgprQzhQUkM0VVVCVE9GT1FMRXhYa0N4SXRvQUFB
OVFWQkRrMHVUUWdBTUEwRExhWUFBQXdBSVI0dEtBQU9IUWtQbVFaSE5ndWtrQm9KCklMNEU5QXN3
RlU0ZElBa0FyQUJSUFZBVUhrMEdBQUttQUZFZFVCUXVMUjhBRTE0VUNTOEVYc1VPT2c4Y0FnQVBh
d2M2QW9VS0NBWUEKQXhvQURnOElENU1LTndfSENjWVA1QUlyRkJia0FoUVdyUUFRRnEwQWdPUWNJ
QndVcng4VUJ3RGVxeFFjTUF3VXF4UU1VQ1NMSktnQQpENHdEWXZBSExBUVBGajRQSHo0UEZnUXNJ
RHlyUENBY0JBeXJERlVCSVJTdXJ3QVFycThBSG82dkFBLVlCQjB2RjA3aEV5d2ZMdXNFCkhnLUlB
dDRKLXdRLUhpZE8xeE1tSkJRdTF4TVBFZ1ZQRHpFQS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0KLS0tLS0tLS0tN0pRYlQwNGZYMD0KOjogbWFwLy5pbmZvLnBvZAotLVtb
cG9kLGNyZWF0ZWQ9IjIwMjUtMDEtMDQgMDI6NDc6MDUiLG1vZGlmaWVkPSIyMDI1LTEyLTE0IDAw
OjQ3OjM4Il1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxU
QXhMVEEwSURBeU9qSXdPalV3SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB3Ck1TMHdOeUF5TWpvek5E
bzFPU0lzY21WMmFYTnBiMjQ5TkRJeVhWMXNlalFBYUFBQUFGZ1FBQUR3Q0h0N1ltMXdQWFZ6WlhK
a1lYUmgKS0NKcE1UWWlMRE15QXdBdklqQUJBUC0tLS0tLS0tLS0tLS0tLS0tLS0tdnhDQ0lwTEdo
cFpHUmxiajFtWVd4elpTeHdZVzVmZUQwdwpDQURTZVQwd0xIUnBiR1ZmYUQweE5nb0FFSGNLQUlC
NmIyOXRQVEY5ZlE9PQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0wMS0w
NCAwMjo0NzowNSIsbW9kaWZpZWQ9IjIwMjUtMTItMTQgMDA6NDc6MzgiXV0KOjogc2Z4LzAuc2Z4
CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExUQTBJREF5T2pJd09qVXdJaXh0
YjJScFptbGxaRDBpTWpBeU5TMHcKTVMwd055QXlNam96TkRvMU9TSXNjbVYyYVhOcGIyNDlOREl5
WFYxc2VqUUFvQUFBQUFzS0FBRC1NSEI0ZFFBREtBQUFCQUFFRDBBUQpBZzRBQWFBQklBS2dEZ0FQ
RUFBTjhNb0JBZ05BRHdfUUJBVUdCMEFNa0FnSkNndEFESkFQREE4TkR3NE1RQXp3LXdFQTYtOG5x
Z0VRCkJnOGdFQUVnQVNBQjhBQUNFQUlPRUFFZ0R5RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBn
QS0zRHcwQjhBa0JFQVlPTUFELS0tLS0KLTcwZi13RUFyTS1JRDBBQUR4QkEtLV93OFA4QkFQLXFV
UC0tLS04cAo6OiBbZW9jXQo=
:: bios/wm/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-14 00:47:38"]]
:: gfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0x
Mi0xNCAwMDozMjoxMCIscmV2aXNpb249MTFdXWx6NADoAAAAcjIAAPNse1swXT17Ym1wPXB4dQBD
IBAQBCBPIJBucB4WDhYeYA4GDiYOBg5gDhYvGRYOYB4GLQYecFcOgGdwHgYcBw8OBw5QHicMJx5A
DgYHCwcsFg5ADgZnBg5ADh1XDQ5ADj0GPQ5QPQ49cB0OAA4dYCxmbGFncz0wLHBhbl94CADaeT0w
LHpvb209MTR9LIoA-whXkGegHAcOB4AnDCeABw4HLJBnkFfwiUcAHS-w8DIA----------------
-------------------------------------------------6VQPTE0fX0=
:: map/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0w
MS0xNyAxMDozNzo0NCIscmV2aXNpb249MV1dbHo0AFQAAABEEAAA8Ah7e2JtcD11c2VyZGF0YSgi
aTE2IiwzMgMALyIwAQD--------------------7oSIpLHBhbl94PTAIANJ5PTAsdGlsZV9oPTE2
CgBgdz0xNn19
:: sfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-14 00:47:38"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODozMDoyOCIscmV2aXNpb249MF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oBEAYP
MBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA------_9
H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: [eoc]
